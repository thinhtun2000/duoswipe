with Ada.Containers.Vectors;
with Ada.Unchecked_Deallocation;

with Langkit_Support.Diagnostics; use Langkit_Support.Diagnostics;
with Langkit_Support.Packrat;
with Langkit_Support.Text;        use Langkit_Support.Text;

with Libadalang.Common; use Libadalang.Common;
use Libadalang.Common.Symbols;
with Libadalang.Implementation;     use Libadalang.Implementation;
with Libadalang.Private_Converters; use Libadalang.Private_Converters;

package body Libadalang.Parsers is
   use all type Symbols.Symbol_Type;

   --  Prepare packrat instantiations: one per enum type and onefor each kind
   --  of node (including lists). Likewise for bump ptr. allocators, except we
   --  need them only for non-abstract AST nodes.
   --
   --  In the Alloc instanciations, there are unchecked conversions to wrap
   --  System.Address values from a low-level allocator. All read/writes for
   --  the pointed values are made through values of the same access types
   --  (i.e. AST node access). Thus, strict aliasing issues should not arise
   --  for these.
   --
   --  See <https://gcc.gnu.org/onlinedocs/gnat_ugn/
   --       Optimization-and-Strict-Aliasing.html>.

   pragma Warnings (Off, "is not referenced");
   pragma Warnings (Off, "possible aliasing problem for type");
   package Bare_Ada_Node_Memos is new Langkit_Support.Packrat
     (Bare_Ada_Node, Token_Index);

   package Bare_Abort_Node_Memos is new Langkit_Support.Packrat
     (Bare_Abort_Node, Token_Index);

   package Bare_Abort_Absent_Memos is new Langkit_Support.Packrat
     (Bare_Abort_Absent, Token_Index);

   subtype Subtype_For_Abort_Absent is Root_Node_Record (Ada_Abort_Absent);
   type Access_To_Subtype_For_Abort_Absent is
     access all Subtype_For_Abort_Absent;
   package Bare_Abort_Absent_Alloc is new Alloc
     (Subtype_For_Abort_Absent, Access_To_Subtype_For_Abort_Absent);

   function Allocate_Abort_Absent
     (Pool : Bump_Ptr_Pool) return Bare_Abort_Absent;

   function Allocate_Abort_Absent
     (Pool : Bump_Ptr_Pool) return Bare_Abort_Absent
   is
      Result : constant Access_To_Subtype_For_Abort_Absent :=
        Bare_Abort_Absent_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Abort_Absent;
      return Bare_Abort_Absent (Result);
   end Allocate_Abort_Absent;

   package Bare_Abort_Present_Memos is new Langkit_Support.Packrat
     (Bare_Abort_Present, Token_Index);

   subtype Subtype_For_Abort_Present is Root_Node_Record (Ada_Abort_Present);
   type Access_To_Subtype_For_Abort_Present is
     access all Subtype_For_Abort_Present;
   package Bare_Abort_Present_Alloc is new Alloc
     (Subtype_For_Abort_Present, Access_To_Subtype_For_Abort_Present);

   function Allocate_Abort_Present
     (Pool : Bump_Ptr_Pool) return Bare_Abort_Present;

   function Allocate_Abort_Present
     (Pool : Bump_Ptr_Pool) return Bare_Abort_Present
   is
      Result : constant Access_To_Subtype_For_Abort_Present :=
        Bare_Abort_Present_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Abort_Present;
      return Bare_Abort_Present (Result);
   end Allocate_Abort_Present;

   package Bare_Abstract_Node_Memos is new Langkit_Support.Packrat
     (Bare_Abstract_Node, Token_Index);

   package Bare_Abstract_Absent_Memos is new Langkit_Support.Packrat
     (Bare_Abstract_Absent, Token_Index);

   subtype Subtype_For_Abstract_Absent is
     Root_Node_Record (Ada_Abstract_Absent);
   type Access_To_Subtype_For_Abstract_Absent is
     access all Subtype_For_Abstract_Absent;
   package Bare_Abstract_Absent_Alloc is new Alloc
     (Subtype_For_Abstract_Absent, Access_To_Subtype_For_Abstract_Absent);

   function Allocate_Abstract_Absent
     (Pool : Bump_Ptr_Pool) return Bare_Abstract_Absent;

   function Allocate_Abstract_Absent
     (Pool : Bump_Ptr_Pool) return Bare_Abstract_Absent
   is
      Result : constant Access_To_Subtype_For_Abstract_Absent :=
        Bare_Abstract_Absent_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Abstract_Absent;
      return Bare_Abstract_Absent (Result);
   end Allocate_Abstract_Absent;

   package Bare_Abstract_Present_Memos is new Langkit_Support.Packrat
     (Bare_Abstract_Present, Token_Index);

   subtype Subtype_For_Abstract_Present is
     Root_Node_Record (Ada_Abstract_Present);
   type Access_To_Subtype_For_Abstract_Present is
     access all Subtype_For_Abstract_Present;
   package Bare_Abstract_Present_Alloc is new Alloc
     (Subtype_For_Abstract_Present, Access_To_Subtype_For_Abstract_Present);

   function Allocate_Abstract_Present
     (Pool : Bump_Ptr_Pool) return Bare_Abstract_Present;

   function Allocate_Abstract_Present
     (Pool : Bump_Ptr_Pool) return Bare_Abstract_Present
   is
      Result : constant Access_To_Subtype_For_Abstract_Present :=
        Bare_Abstract_Present_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Abstract_Present;
      return Bare_Abstract_Present (Result);
   end Allocate_Abstract_Present;

   package Bare_Ada_List_Memos is new Langkit_Support.Packrat
     (Bare_Ada_List, Token_Index);

   package Bare_Ada_Node_List_Memos is new Langkit_Support.Packrat
     (Bare_Ada_Node_List, Token_Index);

   subtype Subtype_For_Ada_Node_List is Root_Node_Record (Ada_Ada_Node_List);
   type Access_To_Subtype_For_Ada_Node_List is
     access all Subtype_For_Ada_Node_List;
   package Bare_Ada_Node_List_Alloc is new Alloc
     (Subtype_For_Ada_Node_List, Access_To_Subtype_For_Ada_Node_List);

   function Allocate_Ada_Node_List
     (Pool : Bump_Ptr_Pool) return Bare_Ada_Node_List;

   function Allocate_Ada_Node_List
     (Pool : Bump_Ptr_Pool) return Bare_Ada_Node_List
   is
      Result : constant Access_To_Subtype_For_Ada_Node_List :=
        Bare_Ada_Node_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Ada_Node_List;
      return Bare_Ada_Node_List (Result);
   end Allocate_Ada_Node_List;

   package Bare_Alternatives_List_Memos is new Langkit_Support.Packrat
     (Bare_Alternatives_List, Token_Index);

   subtype Subtype_For_Alternatives_List is
     Root_Node_Record (Ada_Alternatives_List);
   type Access_To_Subtype_For_Alternatives_List is
     access all Subtype_For_Alternatives_List;
   package Bare_Alternatives_List_Alloc is new Alloc
     (Subtype_For_Alternatives_List, Access_To_Subtype_For_Alternatives_List);

   function Allocate_Alternatives_List
     (Pool : Bump_Ptr_Pool) return Bare_Alternatives_List;

   function Allocate_Alternatives_List
     (Pool : Bump_Ptr_Pool) return Bare_Alternatives_List
   is
      Result : constant Access_To_Subtype_For_Alternatives_List :=
        Bare_Alternatives_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Alternatives_List;
      return Bare_Alternatives_List (Result);
   end Allocate_Alternatives_List;

   package Bare_Constraint_List_Memos is new Langkit_Support.Packrat
     (Bare_Constraint_List, Token_Index);

   subtype Subtype_For_Constraint_List is
     Root_Node_Record (Ada_Constraint_List);
   type Access_To_Subtype_For_Constraint_List is
     access all Subtype_For_Constraint_List;
   package Bare_Constraint_List_Alloc is new Alloc
     (Subtype_For_Constraint_List, Access_To_Subtype_For_Constraint_List);

   function Allocate_Constraint_List
     (Pool : Bump_Ptr_Pool) return Bare_Constraint_List;

   function Allocate_Constraint_List
     (Pool : Bump_Ptr_Pool) return Bare_Constraint_List
   is
      Result : constant Access_To_Subtype_For_Constraint_List :=
        Bare_Constraint_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Constraint_List;
      return Bare_Constraint_List (Result);
   end Allocate_Constraint_List;

   package Bare_Decl_List_Memos is new Langkit_Support.Packrat
     (Bare_Decl_List, Token_Index);

   subtype Subtype_For_Decl_List is Root_Node_Record (Ada_Decl_List);
   type Access_To_Subtype_For_Decl_List is access all Subtype_For_Decl_List;
   package Bare_Decl_List_Alloc is new Alloc
     (Subtype_For_Decl_List, Access_To_Subtype_For_Decl_List);

   function Allocate_Decl_List (Pool : Bump_Ptr_Pool) return Bare_Decl_List;

   function Allocate_Decl_List (Pool : Bump_Ptr_Pool) return Bare_Decl_List is
      Result : constant Access_To_Subtype_For_Decl_List :=
        Bare_Decl_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Decl_List;
      return Bare_Decl_List (Result);
   end Allocate_Decl_List;

   package Bare_Stmt_List_Memos is new Langkit_Support.Packrat
     (Bare_Stmt_List, Token_Index);

   subtype Subtype_For_Stmt_List is Root_Node_Record (Ada_Stmt_List);
   type Access_To_Subtype_For_Stmt_List is access all Subtype_For_Stmt_List;
   package Bare_Stmt_List_Alloc is new Alloc
     (Subtype_For_Stmt_List, Access_To_Subtype_For_Stmt_List);

   function Allocate_Stmt_List (Pool : Bump_Ptr_Pool) return Bare_Stmt_List;

   function Allocate_Stmt_List (Pool : Bump_Ptr_Pool) return Bare_Stmt_List is
      Result : constant Access_To_Subtype_For_Stmt_List :=
        Bare_Stmt_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Stmt_List;
      return Bare_Stmt_List (Result);
   end Allocate_Stmt_List;

   package Bare_Aspect_Assoc_List_Memos is new Langkit_Support.Packrat
     (Bare_Aspect_Assoc_List, Token_Index);

   subtype Subtype_For_Aspect_Assoc_List is
     Root_Node_Record (Ada_Aspect_Assoc_List);
   type Access_To_Subtype_For_Aspect_Assoc_List is
     access all Subtype_For_Aspect_Assoc_List;
   package Bare_Aspect_Assoc_List_Alloc is new Alloc
     (Subtype_For_Aspect_Assoc_List, Access_To_Subtype_For_Aspect_Assoc_List);

   function Allocate_Aspect_Assoc_List
     (Pool : Bump_Ptr_Pool) return Bare_Aspect_Assoc_List;

   function Allocate_Aspect_Assoc_List
     (Pool : Bump_Ptr_Pool) return Bare_Aspect_Assoc_List
   is
      Result : constant Access_To_Subtype_For_Aspect_Assoc_List :=
        Bare_Aspect_Assoc_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Aspect_Assoc_List;
      return Bare_Aspect_Assoc_List (Result);
   end Allocate_Aspect_Assoc_List;

   package Bare_Base_Assoc_List_Memos is new Langkit_Support.Packrat
     (Bare_Base_Assoc_List, Token_Index);

   subtype Subtype_For_Base_Assoc_List is
     Root_Node_Record (Ada_Base_Assoc_List);
   type Access_To_Subtype_For_Base_Assoc_List is
     access all Subtype_For_Base_Assoc_List;
   package Bare_Base_Assoc_List_Alloc is new Alloc
     (Subtype_For_Base_Assoc_List, Access_To_Subtype_For_Base_Assoc_List);

   function Allocate_Base_Assoc_List
     (Pool : Bump_Ptr_Pool) return Bare_Base_Assoc_List;

   function Allocate_Base_Assoc_List
     (Pool : Bump_Ptr_Pool) return Bare_Base_Assoc_List
   is
      Result : constant Access_To_Subtype_For_Base_Assoc_List :=
        Bare_Base_Assoc_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Base_Assoc_List;
      return Bare_Base_Assoc_List (Result);
   end Allocate_Base_Assoc_List;

   package Bare_Basic_Assoc_List_Memos is new Langkit_Support.Packrat
     (Bare_Basic_Assoc_List, Token_Index);

   package Bare_Assoc_List_Memos is new Langkit_Support.Packrat
     (Bare_Assoc_List, Token_Index);

   subtype Subtype_For_Assoc_List is Root_Node_Record (Ada_Assoc_List);
   type Access_To_Subtype_For_Assoc_List is access all Subtype_For_Assoc_List;
   package Bare_Assoc_List_Alloc is new Alloc
     (Subtype_For_Assoc_List, Access_To_Subtype_For_Assoc_List);

   function Allocate_Assoc_List (Pool : Bump_Ptr_Pool) return Bare_Assoc_List;

   function Allocate_Assoc_List (Pool : Bump_Ptr_Pool) return Bare_Assoc_List
   is
      Result : constant Access_To_Subtype_For_Assoc_List :=
        Bare_Assoc_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Assoc_List;
      return Bare_Assoc_List (Result);
   end Allocate_Assoc_List;

   package Bare_Case_Expr_Alternative_List_Memos is new Langkit_Support.Packrat
     (Bare_Case_Expr_Alternative_List, Token_Index);

   subtype Subtype_For_Case_Expr_Alternative_List is
     Root_Node_Record (Ada_Case_Expr_Alternative_List);
   type Access_To_Subtype_For_Case_Expr_Alternative_List is
     access all Subtype_For_Case_Expr_Alternative_List;
   package Bare_Case_Expr_Alternative_List_Alloc is new Alloc
     (Subtype_For_Case_Expr_Alternative_List,
      Access_To_Subtype_For_Case_Expr_Alternative_List);

   function Allocate_Case_Expr_Alternative_List
     (Pool : Bump_Ptr_Pool) return Bare_Case_Expr_Alternative_List;

   function Allocate_Case_Expr_Alternative_List
     (Pool : Bump_Ptr_Pool) return Bare_Case_Expr_Alternative_List
   is
      Result : constant Access_To_Subtype_For_Case_Expr_Alternative_List :=
        Bare_Case_Expr_Alternative_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Case_Expr_Alternative_List;
      return Bare_Case_Expr_Alternative_List (Result);
   end Allocate_Case_Expr_Alternative_List;

   package Bare_Case_Stmt_Alternative_List_Memos is new Langkit_Support.Packrat
     (Bare_Case_Stmt_Alternative_List, Token_Index);

   subtype Subtype_For_Case_Stmt_Alternative_List is
     Root_Node_Record (Ada_Case_Stmt_Alternative_List);
   type Access_To_Subtype_For_Case_Stmt_Alternative_List is
     access all Subtype_For_Case_Stmt_Alternative_List;
   package Bare_Case_Stmt_Alternative_List_Alloc is new Alloc
     (Subtype_For_Case_Stmt_Alternative_List,
      Access_To_Subtype_For_Case_Stmt_Alternative_List);

   function Allocate_Case_Stmt_Alternative_List
     (Pool : Bump_Ptr_Pool) return Bare_Case_Stmt_Alternative_List;

   function Allocate_Case_Stmt_Alternative_List
     (Pool : Bump_Ptr_Pool) return Bare_Case_Stmt_Alternative_List
   is
      Result : constant Access_To_Subtype_For_Case_Stmt_Alternative_List :=
        Bare_Case_Stmt_Alternative_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Case_Stmt_Alternative_List;
      return Bare_Case_Stmt_Alternative_List (Result);
   end Allocate_Case_Stmt_Alternative_List;

   package Bare_Compilation_Unit_List_Memos is new Langkit_Support.Packrat
     (Bare_Compilation_Unit_List, Token_Index);

   subtype Subtype_For_Compilation_Unit_List is
     Root_Node_Record (Ada_Compilation_Unit_List);
   type Access_To_Subtype_For_Compilation_Unit_List is
     access all Subtype_For_Compilation_Unit_List;
   package Bare_Compilation_Unit_List_Alloc is new Alloc
     (Subtype_For_Compilation_Unit_List,
      Access_To_Subtype_For_Compilation_Unit_List);

   function Allocate_Compilation_Unit_List
     (Pool : Bump_Ptr_Pool) return Bare_Compilation_Unit_List;

   function Allocate_Compilation_Unit_List
     (Pool : Bump_Ptr_Pool) return Bare_Compilation_Unit_List
   is
      Result : constant Access_To_Subtype_For_Compilation_Unit_List :=
        Bare_Compilation_Unit_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Compilation_Unit_List;
      return Bare_Compilation_Unit_List (Result);
   end Allocate_Compilation_Unit_List;

   package Bare_Contract_Case_Assoc_List_Memos is new Langkit_Support.Packrat
     (Bare_Contract_Case_Assoc_List, Token_Index);

   subtype Subtype_For_Contract_Case_Assoc_List is
     Root_Node_Record (Ada_Contract_Case_Assoc_List);
   type Access_To_Subtype_For_Contract_Case_Assoc_List is
     access all Subtype_For_Contract_Case_Assoc_List;
   package Bare_Contract_Case_Assoc_List_Alloc is new Alloc
     (Subtype_For_Contract_Case_Assoc_List,
      Access_To_Subtype_For_Contract_Case_Assoc_List);

   function Allocate_Contract_Case_Assoc_List
     (Pool : Bump_Ptr_Pool) return Bare_Contract_Case_Assoc_List;

   function Allocate_Contract_Case_Assoc_List
     (Pool : Bump_Ptr_Pool) return Bare_Contract_Case_Assoc_List
   is
      Result : constant Access_To_Subtype_For_Contract_Case_Assoc_List :=
        Bare_Contract_Case_Assoc_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Contract_Case_Assoc_List;
      return Bare_Contract_Case_Assoc_List (Result);
   end Allocate_Contract_Case_Assoc_List;

   package Bare_Defining_Name_List_Memos is new Langkit_Support.Packrat
     (Bare_Defining_Name_List, Token_Index);

   subtype Subtype_For_Defining_Name_List is
     Root_Node_Record (Ada_Defining_Name_List);
   type Access_To_Subtype_For_Defining_Name_List is
     access all Subtype_For_Defining_Name_List;
   package Bare_Defining_Name_List_Alloc is new Alloc
     (Subtype_For_Defining_Name_List,
      Access_To_Subtype_For_Defining_Name_List);

   function Allocate_Defining_Name_List
     (Pool : Bump_Ptr_Pool) return Bare_Defining_Name_List;

   function Allocate_Defining_Name_List
     (Pool : Bump_Ptr_Pool) return Bare_Defining_Name_List
   is
      Result : constant Access_To_Subtype_For_Defining_Name_List :=
        Bare_Defining_Name_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Defining_Name_List;
      return Bare_Defining_Name_List (Result);
   end Allocate_Defining_Name_List;

   package Bare_Discriminant_Spec_List_Memos is new Langkit_Support.Packrat
     (Bare_Discriminant_Spec_List, Token_Index);

   subtype Subtype_For_Discriminant_Spec_List is
     Root_Node_Record (Ada_Discriminant_Spec_List);
   type Access_To_Subtype_For_Discriminant_Spec_List is
     access all Subtype_For_Discriminant_Spec_List;
   package Bare_Discriminant_Spec_List_Alloc is new Alloc
     (Subtype_For_Discriminant_Spec_List,
      Access_To_Subtype_For_Discriminant_Spec_List);

   function Allocate_Discriminant_Spec_List
     (Pool : Bump_Ptr_Pool) return Bare_Discriminant_Spec_List;

   function Allocate_Discriminant_Spec_List
     (Pool : Bump_Ptr_Pool) return Bare_Discriminant_Spec_List
   is
      Result : constant Access_To_Subtype_For_Discriminant_Spec_List :=
        Bare_Discriminant_Spec_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Discriminant_Spec_List;
      return Bare_Discriminant_Spec_List (Result);
   end Allocate_Discriminant_Spec_List;

   package Bare_Elsif_Expr_Part_List_Memos is new Langkit_Support.Packrat
     (Bare_Elsif_Expr_Part_List, Token_Index);

   subtype Subtype_For_Elsif_Expr_Part_List is
     Root_Node_Record (Ada_Elsif_Expr_Part_List);
   type Access_To_Subtype_For_Elsif_Expr_Part_List is
     access all Subtype_For_Elsif_Expr_Part_List;
   package Bare_Elsif_Expr_Part_List_Alloc is new Alloc
     (Subtype_For_Elsif_Expr_Part_List,
      Access_To_Subtype_For_Elsif_Expr_Part_List);

   function Allocate_Elsif_Expr_Part_List
     (Pool : Bump_Ptr_Pool) return Bare_Elsif_Expr_Part_List;

   function Allocate_Elsif_Expr_Part_List
     (Pool : Bump_Ptr_Pool) return Bare_Elsif_Expr_Part_List
   is
      Result : constant Access_To_Subtype_For_Elsif_Expr_Part_List :=
        Bare_Elsif_Expr_Part_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Elsif_Expr_Part_List;
      return Bare_Elsif_Expr_Part_List (Result);
   end Allocate_Elsif_Expr_Part_List;

   package Bare_Elsif_Stmt_Part_List_Memos is new Langkit_Support.Packrat
     (Bare_Elsif_Stmt_Part_List, Token_Index);

   subtype Subtype_For_Elsif_Stmt_Part_List is
     Root_Node_Record (Ada_Elsif_Stmt_Part_List);
   type Access_To_Subtype_For_Elsif_Stmt_Part_List is
     access all Subtype_For_Elsif_Stmt_Part_List;
   package Bare_Elsif_Stmt_Part_List_Alloc is new Alloc
     (Subtype_For_Elsif_Stmt_Part_List,
      Access_To_Subtype_For_Elsif_Stmt_Part_List);

   function Allocate_Elsif_Stmt_Part_List
     (Pool : Bump_Ptr_Pool) return Bare_Elsif_Stmt_Part_List;

   function Allocate_Elsif_Stmt_Part_List
     (Pool : Bump_Ptr_Pool) return Bare_Elsif_Stmt_Part_List
   is
      Result : constant Access_To_Subtype_For_Elsif_Stmt_Part_List :=
        Bare_Elsif_Stmt_Part_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Elsif_Stmt_Part_List;
      return Bare_Elsif_Stmt_Part_List (Result);
   end Allocate_Elsif_Stmt_Part_List;

   package Bare_Enum_Literal_Decl_List_Memos is new Langkit_Support.Packrat
     (Bare_Enum_Literal_Decl_List, Token_Index);

   subtype Subtype_For_Enum_Literal_Decl_List is
     Root_Node_Record (Ada_Enum_Literal_Decl_List);
   type Access_To_Subtype_For_Enum_Literal_Decl_List is
     access all Subtype_For_Enum_Literal_Decl_List;
   package Bare_Enum_Literal_Decl_List_Alloc is new Alloc
     (Subtype_For_Enum_Literal_Decl_List,
      Access_To_Subtype_For_Enum_Literal_Decl_List);

   function Allocate_Enum_Literal_Decl_List
     (Pool : Bump_Ptr_Pool) return Bare_Enum_Literal_Decl_List;

   function Allocate_Enum_Literal_Decl_List
     (Pool : Bump_Ptr_Pool) return Bare_Enum_Literal_Decl_List
   is
      Result : constant Access_To_Subtype_For_Enum_Literal_Decl_List :=
        Bare_Enum_Literal_Decl_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Enum_Literal_Decl_List;
      return Bare_Enum_Literal_Decl_List (Result);
   end Allocate_Enum_Literal_Decl_List;

   package Bare_Expr_List_Memos is new Langkit_Support.Packrat
     (Bare_Expr_List, Token_Index);

   package Bare_Expr_Alternatives_List_Memos is new Langkit_Support.Packrat
     (Bare_Expr_Alternatives_List, Token_Index);

   subtype Subtype_For_Expr_Alternatives_List is
     Root_Node_Record (Ada_Expr_Alternatives_List);
   type Access_To_Subtype_For_Expr_Alternatives_List is
     access all Subtype_For_Expr_Alternatives_List;
   package Bare_Expr_Alternatives_List_Alloc is new Alloc
     (Subtype_For_Expr_Alternatives_List,
      Access_To_Subtype_For_Expr_Alternatives_List);

   function Allocate_Expr_Alternatives_List
     (Pool : Bump_Ptr_Pool) return Bare_Expr_Alternatives_List;

   function Allocate_Expr_Alternatives_List
     (Pool : Bump_Ptr_Pool) return Bare_Expr_Alternatives_List
   is
      Result : constant Access_To_Subtype_For_Expr_Alternatives_List :=
        Bare_Expr_Alternatives_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Expr_Alternatives_List;
      return Bare_Expr_Alternatives_List (Result);
   end Allocate_Expr_Alternatives_List;

   package Bare_Identifier_List_Memos is new Langkit_Support.Packrat
     (Bare_Identifier_List, Token_Index);

   package Bare_Discriminant_Choice_List_Memos is new Langkit_Support.Packrat
     (Bare_Discriminant_Choice_List, Token_Index);

   subtype Subtype_For_Discriminant_Choice_List is
     Root_Node_Record (Ada_Discriminant_Choice_List);
   type Access_To_Subtype_For_Discriminant_Choice_List is
     access all Subtype_For_Discriminant_Choice_List;
   package Bare_Discriminant_Choice_List_Alloc is new Alloc
     (Subtype_For_Discriminant_Choice_List,
      Access_To_Subtype_For_Discriminant_Choice_List);

   function Allocate_Discriminant_Choice_List
     (Pool : Bump_Ptr_Pool) return Bare_Discriminant_Choice_List;

   function Allocate_Discriminant_Choice_List
     (Pool : Bump_Ptr_Pool) return Bare_Discriminant_Choice_List
   is
      Result : constant Access_To_Subtype_For_Discriminant_Choice_List :=
        Bare_Discriminant_Choice_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Discriminant_Choice_List;
      return Bare_Discriminant_Choice_List (Result);
   end Allocate_Discriminant_Choice_List;

   package Bare_Name_List_Memos is new Langkit_Support.Packrat
     (Bare_Name_List, Token_Index);

   subtype Subtype_For_Name_List is Root_Node_Record (Ada_Name_List);
   type Access_To_Subtype_For_Name_List is access all Subtype_For_Name_List;
   package Bare_Name_List_Alloc is new Alloc
     (Subtype_For_Name_List, Access_To_Subtype_For_Name_List);

   function Allocate_Name_List (Pool : Bump_Ptr_Pool) return Bare_Name_List;

   function Allocate_Name_List (Pool : Bump_Ptr_Pool) return Bare_Name_List is
      Result : constant Access_To_Subtype_For_Name_List :=
        Bare_Name_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Name_List;
      return Bare_Name_List (Result);
   end Allocate_Name_List;

   package Bare_Parent_List_Memos is new Langkit_Support.Packrat
     (Bare_Parent_List, Token_Index);

   subtype Subtype_For_Parent_List is Root_Node_Record (Ada_Parent_List);
   type Access_To_Subtype_For_Parent_List is
     access all Subtype_For_Parent_List;
   package Bare_Parent_List_Alloc is new Alloc
     (Subtype_For_Parent_List, Access_To_Subtype_For_Parent_List);

   function Allocate_Parent_List
     (Pool : Bump_Ptr_Pool) return Bare_Parent_List;

   function Allocate_Parent_List (Pool : Bump_Ptr_Pool) return Bare_Parent_List
   is
      Result : constant Access_To_Subtype_For_Parent_List :=
        Bare_Parent_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Parent_List;
      return Bare_Parent_List (Result);
   end Allocate_Parent_List;

   package Bare_Param_Spec_List_Memos is new Langkit_Support.Packrat
     (Bare_Param_Spec_List, Token_Index);

   subtype Subtype_For_Param_Spec_List is
     Root_Node_Record (Ada_Param_Spec_List);
   type Access_To_Subtype_For_Param_Spec_List is
     access all Subtype_For_Param_Spec_List;
   package Bare_Param_Spec_List_Alloc is new Alloc
     (Subtype_For_Param_Spec_List, Access_To_Subtype_For_Param_Spec_List);

   function Allocate_Param_Spec_List
     (Pool : Bump_Ptr_Pool) return Bare_Param_Spec_List;

   function Allocate_Param_Spec_List
     (Pool : Bump_Ptr_Pool) return Bare_Param_Spec_List
   is
      Result : constant Access_To_Subtype_For_Param_Spec_List :=
        Bare_Param_Spec_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Param_Spec_List;
      return Bare_Param_Spec_List (Result);
   end Allocate_Param_Spec_List;

   package Bare_Pragma_Node_List_Memos is new Langkit_Support.Packrat
     (Bare_Pragma_Node_List, Token_Index);

   subtype Subtype_For_Pragma_Node_List is
     Root_Node_Record (Ada_Pragma_Node_List);
   type Access_To_Subtype_For_Pragma_Node_List is
     access all Subtype_For_Pragma_Node_List;
   package Bare_Pragma_Node_List_Alloc is new Alloc
     (Subtype_For_Pragma_Node_List, Access_To_Subtype_For_Pragma_Node_List);

   function Allocate_Pragma_Node_List
     (Pool : Bump_Ptr_Pool) return Bare_Pragma_Node_List;

   function Allocate_Pragma_Node_List
     (Pool : Bump_Ptr_Pool) return Bare_Pragma_Node_List
   is
      Result : constant Access_To_Subtype_For_Pragma_Node_List :=
        Bare_Pragma_Node_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Pragma_Node_List;
      return Bare_Pragma_Node_List (Result);
   end Allocate_Pragma_Node_List;

   package Bare_Select_When_Part_List_Memos is new Langkit_Support.Packrat
     (Bare_Select_When_Part_List, Token_Index);

   subtype Subtype_For_Select_When_Part_List is
     Root_Node_Record (Ada_Select_When_Part_List);
   type Access_To_Subtype_For_Select_When_Part_List is
     access all Subtype_For_Select_When_Part_List;
   package Bare_Select_When_Part_List_Alloc is new Alloc
     (Subtype_For_Select_When_Part_List,
      Access_To_Subtype_For_Select_When_Part_List);

   function Allocate_Select_When_Part_List
     (Pool : Bump_Ptr_Pool) return Bare_Select_When_Part_List;

   function Allocate_Select_When_Part_List
     (Pool : Bump_Ptr_Pool) return Bare_Select_When_Part_List
   is
      Result : constant Access_To_Subtype_For_Select_When_Part_List :=
        Bare_Select_When_Part_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Select_When_Part_List;
      return Bare_Select_When_Part_List (Result);
   end Allocate_Select_When_Part_List;

   package Bare_Unconstrained_Array_Index_List_Memos is new Langkit_Support
     .Packrat
     (Bare_Unconstrained_Array_Index_List, Token_Index);

   subtype Subtype_For_Unconstrained_Array_Index_List is
     Root_Node_Record (Ada_Unconstrained_Array_Index_List);
   type Access_To_Subtype_For_Unconstrained_Array_Index_List is
     access all Subtype_For_Unconstrained_Array_Index_List;
   package Bare_Unconstrained_Array_Index_List_Alloc is new Alloc
     (Subtype_For_Unconstrained_Array_Index_List,
      Access_To_Subtype_For_Unconstrained_Array_Index_List);

   function Allocate_Unconstrained_Array_Index_List
     (Pool : Bump_Ptr_Pool) return Bare_Unconstrained_Array_Index_List;

   function Allocate_Unconstrained_Array_Index_List
     (Pool : Bump_Ptr_Pool) return Bare_Unconstrained_Array_Index_List
   is
      Result : constant Access_To_Subtype_For_Unconstrained_Array_Index_List :=
        Bare_Unconstrained_Array_Index_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Unconstrained_Array_Index_List;
      return Bare_Unconstrained_Array_Index_List (Result);
   end Allocate_Unconstrained_Array_Index_List;

   package Bare_Variant_List_Memos is new Langkit_Support.Packrat
     (Bare_Variant_List, Token_Index);

   subtype Subtype_For_Variant_List is Root_Node_Record (Ada_Variant_List);
   type Access_To_Subtype_For_Variant_List is
     access all Subtype_For_Variant_List;
   package Bare_Variant_List_Alloc is new Alloc
     (Subtype_For_Variant_List, Access_To_Subtype_For_Variant_List);

   function Allocate_Variant_List
     (Pool : Bump_Ptr_Pool) return Bare_Variant_List;

   function Allocate_Variant_List
     (Pool : Bump_Ptr_Pool) return Bare_Variant_List
   is
      Result : constant Access_To_Subtype_For_Variant_List :=
        Bare_Variant_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Variant_List;
      return Bare_Variant_List (Result);
   end Allocate_Variant_List;

   package Bare_Aliased_Node_Memos is new Langkit_Support.Packrat
     (Bare_Aliased_Node, Token_Index);

   package Bare_Aliased_Absent_Memos is new Langkit_Support.Packrat
     (Bare_Aliased_Absent, Token_Index);

   subtype Subtype_For_Aliased_Absent is Root_Node_Record (Ada_Aliased_Absent);
   type Access_To_Subtype_For_Aliased_Absent is
     access all Subtype_For_Aliased_Absent;
   package Bare_Aliased_Absent_Alloc is new Alloc
     (Subtype_For_Aliased_Absent, Access_To_Subtype_For_Aliased_Absent);

   function Allocate_Aliased_Absent
     (Pool : Bump_Ptr_Pool) return Bare_Aliased_Absent;

   function Allocate_Aliased_Absent
     (Pool : Bump_Ptr_Pool) return Bare_Aliased_Absent
   is
      Result : constant Access_To_Subtype_For_Aliased_Absent :=
        Bare_Aliased_Absent_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Aliased_Absent;
      return Bare_Aliased_Absent (Result);
   end Allocate_Aliased_Absent;

   package Bare_Aliased_Present_Memos is new Langkit_Support.Packrat
     (Bare_Aliased_Present, Token_Index);

   subtype Subtype_For_Aliased_Present is
     Root_Node_Record (Ada_Aliased_Present);
   type Access_To_Subtype_For_Aliased_Present is
     access all Subtype_For_Aliased_Present;
   package Bare_Aliased_Present_Alloc is new Alloc
     (Subtype_For_Aliased_Present, Access_To_Subtype_For_Aliased_Present);

   function Allocate_Aliased_Present
     (Pool : Bump_Ptr_Pool) return Bare_Aliased_Present;

   function Allocate_Aliased_Present
     (Pool : Bump_Ptr_Pool) return Bare_Aliased_Present
   is
      Result : constant Access_To_Subtype_For_Aliased_Present :=
        Bare_Aliased_Present_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Aliased_Present;
      return Bare_Aliased_Present (Result);
   end Allocate_Aliased_Present;

   package Bare_All_Node_Memos is new Langkit_Support.Packrat
     (Bare_All_Node, Token_Index);

   package Bare_All_Absent_Memos is new Langkit_Support.Packrat
     (Bare_All_Absent, Token_Index);

   subtype Subtype_For_All_Absent is Root_Node_Record (Ada_All_Absent);
   type Access_To_Subtype_For_All_Absent is access all Subtype_For_All_Absent;
   package Bare_All_Absent_Alloc is new Alloc
     (Subtype_For_All_Absent, Access_To_Subtype_For_All_Absent);

   function Allocate_All_Absent (Pool : Bump_Ptr_Pool) return Bare_All_Absent;

   function Allocate_All_Absent (Pool : Bump_Ptr_Pool) return Bare_All_Absent
   is
      Result : constant Access_To_Subtype_For_All_Absent :=
        Bare_All_Absent_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_All_Absent;
      return Bare_All_Absent (Result);
   end Allocate_All_Absent;

   package Bare_All_Present_Memos is new Langkit_Support.Packrat
     (Bare_All_Present, Token_Index);

   subtype Subtype_For_All_Present is Root_Node_Record (Ada_All_Present);
   type Access_To_Subtype_For_All_Present is
     access all Subtype_For_All_Present;
   package Bare_All_Present_Alloc is new Alloc
     (Subtype_For_All_Present, Access_To_Subtype_For_All_Present);

   function Allocate_All_Present
     (Pool : Bump_Ptr_Pool) return Bare_All_Present;

   function Allocate_All_Present (Pool : Bump_Ptr_Pool) return Bare_All_Present
   is
      Result : constant Access_To_Subtype_For_All_Present :=
        Bare_All_Present_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_All_Present;
      return Bare_All_Present (Result);
   end Allocate_All_Present;

   package Bare_Array_Indices_Memos is new Langkit_Support.Packrat
     (Bare_Array_Indices, Token_Index);

   package Bare_Constrained_Array_Indices_Memos is new Langkit_Support.Packrat
     (Bare_Constrained_Array_Indices, Token_Index);

   subtype Subtype_For_Constrained_Array_Indices is
     Root_Node_Record (Ada_Constrained_Array_Indices);
   type Access_To_Subtype_For_Constrained_Array_Indices is
     access all Subtype_For_Constrained_Array_Indices;
   package Bare_Constrained_Array_Indices_Alloc is new Alloc
     (Subtype_For_Constrained_Array_Indices,
      Access_To_Subtype_For_Constrained_Array_Indices);

   function Allocate_Constrained_Array_Indices
     (Pool : Bump_Ptr_Pool) return Bare_Constrained_Array_Indices;

   function Allocate_Constrained_Array_Indices
     (Pool : Bump_Ptr_Pool) return Bare_Constrained_Array_Indices
   is
      Result : constant Access_To_Subtype_For_Constrained_Array_Indices :=
        Bare_Constrained_Array_Indices_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Constrained_Array_Indices;
      return Bare_Constrained_Array_Indices (Result);
   end Allocate_Constrained_Array_Indices;

   package Bare_Unconstrained_Array_Indices_Memos is new Langkit_Support
     .Packrat
     (Bare_Unconstrained_Array_Indices, Token_Index);

   subtype Subtype_For_Unconstrained_Array_Indices is
     Root_Node_Record (Ada_Unconstrained_Array_Indices);
   type Access_To_Subtype_For_Unconstrained_Array_Indices is
     access all Subtype_For_Unconstrained_Array_Indices;
   package Bare_Unconstrained_Array_Indices_Alloc is new Alloc
     (Subtype_For_Unconstrained_Array_Indices,
      Access_To_Subtype_For_Unconstrained_Array_Indices);

   function Allocate_Unconstrained_Array_Indices
     (Pool : Bump_Ptr_Pool) return Bare_Unconstrained_Array_Indices;

   function Allocate_Unconstrained_Array_Indices
     (Pool : Bump_Ptr_Pool) return Bare_Unconstrained_Array_Indices
   is
      Result : constant Access_To_Subtype_For_Unconstrained_Array_Indices :=
        Bare_Unconstrained_Array_Indices_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Unconstrained_Array_Indices;
      return Bare_Unconstrained_Array_Indices (Result);
   end Allocate_Unconstrained_Array_Indices;

   package Bare_Aspect_Assoc_Memos is new Langkit_Support.Packrat
     (Bare_Aspect_Assoc, Token_Index);

   subtype Subtype_For_Aspect_Assoc is Root_Node_Record (Ada_Aspect_Assoc);
   type Access_To_Subtype_For_Aspect_Assoc is
     access all Subtype_For_Aspect_Assoc;
   package Bare_Aspect_Assoc_Alloc is new Alloc
     (Subtype_For_Aspect_Assoc, Access_To_Subtype_For_Aspect_Assoc);

   function Allocate_Aspect_Assoc
     (Pool : Bump_Ptr_Pool) return Bare_Aspect_Assoc;

   function Allocate_Aspect_Assoc
     (Pool : Bump_Ptr_Pool) return Bare_Aspect_Assoc
   is
      Result : constant Access_To_Subtype_For_Aspect_Assoc :=
        Bare_Aspect_Assoc_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Aspect_Assoc;
      return Bare_Aspect_Assoc (Result);
   end Allocate_Aspect_Assoc;

   package Bare_Aspect_Clause_Memos is new Langkit_Support.Packrat
     (Bare_Aspect_Clause, Token_Index);

   package Bare_At_Clause_Memos is new Langkit_Support.Packrat
     (Bare_At_Clause, Token_Index);

   subtype Subtype_For_At_Clause is Root_Node_Record (Ada_At_Clause);
   type Access_To_Subtype_For_At_Clause is access all Subtype_For_At_Clause;
   package Bare_At_Clause_Alloc is new Alloc
     (Subtype_For_At_Clause, Access_To_Subtype_For_At_Clause);

   function Allocate_At_Clause (Pool : Bump_Ptr_Pool) return Bare_At_Clause;

   function Allocate_At_Clause (Pool : Bump_Ptr_Pool) return Bare_At_Clause is
      Result : constant Access_To_Subtype_For_At_Clause :=
        Bare_At_Clause_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_At_Clause;
      return Bare_At_Clause (Result);
   end Allocate_At_Clause;

   package Bare_Attribute_Def_Clause_Memos is new Langkit_Support.Packrat
     (Bare_Attribute_Def_Clause, Token_Index);

   subtype Subtype_For_Attribute_Def_Clause is
     Root_Node_Record (Ada_Attribute_Def_Clause);
   type Access_To_Subtype_For_Attribute_Def_Clause is
     access all Subtype_For_Attribute_Def_Clause;
   package Bare_Attribute_Def_Clause_Alloc is new Alloc
     (Subtype_For_Attribute_Def_Clause,
      Access_To_Subtype_For_Attribute_Def_Clause);

   function Allocate_Attribute_Def_Clause
     (Pool : Bump_Ptr_Pool) return Bare_Attribute_Def_Clause;

   function Allocate_Attribute_Def_Clause
     (Pool : Bump_Ptr_Pool) return Bare_Attribute_Def_Clause
   is
      Result : constant Access_To_Subtype_For_Attribute_Def_Clause :=
        Bare_Attribute_Def_Clause_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Attribute_Def_Clause;
      return Bare_Attribute_Def_Clause (Result);
   end Allocate_Attribute_Def_Clause;

   package Bare_Enum_Rep_Clause_Memos is new Langkit_Support.Packrat
     (Bare_Enum_Rep_Clause, Token_Index);

   subtype Subtype_For_Enum_Rep_Clause is
     Root_Node_Record (Ada_Enum_Rep_Clause);
   type Access_To_Subtype_For_Enum_Rep_Clause is
     access all Subtype_For_Enum_Rep_Clause;
   package Bare_Enum_Rep_Clause_Alloc is new Alloc
     (Subtype_For_Enum_Rep_Clause, Access_To_Subtype_For_Enum_Rep_Clause);

   function Allocate_Enum_Rep_Clause
     (Pool : Bump_Ptr_Pool) return Bare_Enum_Rep_Clause;

   function Allocate_Enum_Rep_Clause
     (Pool : Bump_Ptr_Pool) return Bare_Enum_Rep_Clause
   is
      Result : constant Access_To_Subtype_For_Enum_Rep_Clause :=
        Bare_Enum_Rep_Clause_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Enum_Rep_Clause;
      return Bare_Enum_Rep_Clause (Result);
   end Allocate_Enum_Rep_Clause;

   package Bare_Record_Rep_Clause_Memos is new Langkit_Support.Packrat
     (Bare_Record_Rep_Clause, Token_Index);

   subtype Subtype_For_Record_Rep_Clause is
     Root_Node_Record (Ada_Record_Rep_Clause);
   type Access_To_Subtype_For_Record_Rep_Clause is
     access all Subtype_For_Record_Rep_Clause;
   package Bare_Record_Rep_Clause_Alloc is new Alloc
     (Subtype_For_Record_Rep_Clause, Access_To_Subtype_For_Record_Rep_Clause);

   function Allocate_Record_Rep_Clause
     (Pool : Bump_Ptr_Pool) return Bare_Record_Rep_Clause;

   function Allocate_Record_Rep_Clause
     (Pool : Bump_Ptr_Pool) return Bare_Record_Rep_Clause
   is
      Result : constant Access_To_Subtype_For_Record_Rep_Clause :=
        Bare_Record_Rep_Clause_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Record_Rep_Clause;
      return Bare_Record_Rep_Clause (Result);
   end Allocate_Record_Rep_Clause;

   package Bare_Aspect_Spec_Memos is new Langkit_Support.Packrat
     (Bare_Aspect_Spec, Token_Index);

   subtype Subtype_For_Aspect_Spec is Root_Node_Record (Ada_Aspect_Spec);
   type Access_To_Subtype_For_Aspect_Spec is
     access all Subtype_For_Aspect_Spec;
   package Bare_Aspect_Spec_Alloc is new Alloc
     (Subtype_For_Aspect_Spec, Access_To_Subtype_For_Aspect_Spec);

   function Allocate_Aspect_Spec
     (Pool : Bump_Ptr_Pool) return Bare_Aspect_Spec;

   function Allocate_Aspect_Spec (Pool : Bump_Ptr_Pool) return Bare_Aspect_Spec
   is
      Result : constant Access_To_Subtype_For_Aspect_Spec :=
        Bare_Aspect_Spec_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Aspect_Spec;
      return Bare_Aspect_Spec (Result);
   end Allocate_Aspect_Spec;

   package Bare_Base_Assoc_Memos is new Langkit_Support.Packrat
     (Bare_Base_Assoc, Token_Index);

   package Bare_Contract_Case_Assoc_Memos is new Langkit_Support.Packrat
     (Bare_Contract_Case_Assoc, Token_Index);

   subtype Subtype_For_Contract_Case_Assoc is
     Root_Node_Record (Ada_Contract_Case_Assoc);
   type Access_To_Subtype_For_Contract_Case_Assoc is
     access all Subtype_For_Contract_Case_Assoc;
   package Bare_Contract_Case_Assoc_Alloc is new Alloc
     (Subtype_For_Contract_Case_Assoc,
      Access_To_Subtype_For_Contract_Case_Assoc);

   function Allocate_Contract_Case_Assoc
     (Pool : Bump_Ptr_Pool) return Bare_Contract_Case_Assoc;

   function Allocate_Contract_Case_Assoc
     (Pool : Bump_Ptr_Pool) return Bare_Contract_Case_Assoc
   is
      Result : constant Access_To_Subtype_For_Contract_Case_Assoc :=
        Bare_Contract_Case_Assoc_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Contract_Case_Assoc;
      return Bare_Contract_Case_Assoc (Result);
   end Allocate_Contract_Case_Assoc;

   package Bare_Pragma_Argument_Assoc_Memos is new Langkit_Support.Packrat
     (Bare_Pragma_Argument_Assoc, Token_Index);

   subtype Subtype_For_Pragma_Argument_Assoc is
     Root_Node_Record (Ada_Pragma_Argument_Assoc);
   type Access_To_Subtype_For_Pragma_Argument_Assoc is
     access all Subtype_For_Pragma_Argument_Assoc;
   package Bare_Pragma_Argument_Assoc_Alloc is new Alloc
     (Subtype_For_Pragma_Argument_Assoc,
      Access_To_Subtype_For_Pragma_Argument_Assoc);

   function Allocate_Pragma_Argument_Assoc
     (Pool : Bump_Ptr_Pool) return Bare_Pragma_Argument_Assoc;

   function Allocate_Pragma_Argument_Assoc
     (Pool : Bump_Ptr_Pool) return Bare_Pragma_Argument_Assoc
   is
      Result : constant Access_To_Subtype_For_Pragma_Argument_Assoc :=
        Bare_Pragma_Argument_Assoc_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Pragma_Argument_Assoc;
      return Bare_Pragma_Argument_Assoc (Result);
   end Allocate_Pragma_Argument_Assoc;

   package Bare_Base_Formal_Param_Holder_Memos is new Langkit_Support.Packrat
     (Bare_Base_Formal_Param_Holder, Token_Index);

   package Bare_Base_Subp_Spec_Memos is new Langkit_Support.Packrat
     (Bare_Base_Subp_Spec, Token_Index);

   package Bare_Entry_Spec_Memos is new Langkit_Support.Packrat
     (Bare_Entry_Spec, Token_Index);

   subtype Subtype_For_Entry_Spec is Root_Node_Record (Ada_Entry_Spec);
   type Access_To_Subtype_For_Entry_Spec is access all Subtype_For_Entry_Spec;
   package Bare_Entry_Spec_Alloc is new Alloc
     (Subtype_For_Entry_Spec, Access_To_Subtype_For_Entry_Spec);

   function Allocate_Entry_Spec (Pool : Bump_Ptr_Pool) return Bare_Entry_Spec;

   function Allocate_Entry_Spec (Pool : Bump_Ptr_Pool) return Bare_Entry_Spec
   is
      Result : constant Access_To_Subtype_For_Entry_Spec :=
        Bare_Entry_Spec_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Entry_Spec;
      return Bare_Entry_Spec (Result);
   end Allocate_Entry_Spec;

   package Bare_Enum_Subp_Spec_Memos is new Langkit_Support.Packrat
     (Bare_Enum_Subp_Spec, Token_Index);

   subtype Subtype_For_Enum_Subp_Spec is Root_Node_Record (Ada_Enum_Subp_Spec);
   type Access_To_Subtype_For_Enum_Subp_Spec is
     access all Subtype_For_Enum_Subp_Spec;
   package Bare_Enum_Subp_Spec_Alloc is new Alloc
     (Subtype_For_Enum_Subp_Spec, Access_To_Subtype_For_Enum_Subp_Spec);

   function Allocate_Enum_Subp_Spec
     (Pool : Bump_Ptr_Pool) return Bare_Enum_Subp_Spec;

   function Allocate_Enum_Subp_Spec
     (Pool : Bump_Ptr_Pool) return Bare_Enum_Subp_Spec
   is
      Result : constant Access_To_Subtype_For_Enum_Subp_Spec :=
        Bare_Enum_Subp_Spec_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Enum_Subp_Spec;
      return Bare_Enum_Subp_Spec (Result);
   end Allocate_Enum_Subp_Spec;

   package Bare_Subp_Spec_Memos is new Langkit_Support.Packrat
     (Bare_Subp_Spec, Token_Index);

   subtype Subtype_For_Subp_Spec is Root_Node_Record (Ada_Subp_Spec);
   type Access_To_Subtype_For_Subp_Spec is access all Subtype_For_Subp_Spec;
   package Bare_Subp_Spec_Alloc is new Alloc
     (Subtype_For_Subp_Spec, Access_To_Subtype_For_Subp_Spec);

   function Allocate_Subp_Spec (Pool : Bump_Ptr_Pool) return Bare_Subp_Spec;

   function Allocate_Subp_Spec (Pool : Bump_Ptr_Pool) return Bare_Subp_Spec is
      Result : constant Access_To_Subtype_For_Subp_Spec :=
        Bare_Subp_Spec_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Subp_Spec;
      return Bare_Subp_Spec (Result);
   end Allocate_Subp_Spec;

   package Bare_Component_List_Memos is new Langkit_Support.Packrat
     (Bare_Component_List, Token_Index);

   subtype Subtype_For_Component_List is Root_Node_Record (Ada_Component_List);
   type Access_To_Subtype_For_Component_List is
     access all Subtype_For_Component_List;
   package Bare_Component_List_Alloc is new Alloc
     (Subtype_For_Component_List, Access_To_Subtype_For_Component_List);

   function Allocate_Component_List
     (Pool : Bump_Ptr_Pool) return Bare_Component_List;

   function Allocate_Component_List
     (Pool : Bump_Ptr_Pool) return Bare_Component_List
   is
      Result : constant Access_To_Subtype_For_Component_List :=
        Bare_Component_List_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Component_List;
      return Bare_Component_List (Result);
   end Allocate_Component_List;

   package Bare_Discriminant_Part_Memos is new Langkit_Support.Packrat
     (Bare_Discriminant_Part, Token_Index);

   package Bare_Known_Discriminant_Part_Memos is new Langkit_Support.Packrat
     (Bare_Known_Discriminant_Part, Token_Index);

   subtype Subtype_For_Known_Discriminant_Part is
     Root_Node_Record (Ada_Known_Discriminant_Part);
   type Access_To_Subtype_For_Known_Discriminant_Part is
     access all Subtype_For_Known_Discriminant_Part;
   package Bare_Known_Discriminant_Part_Alloc is new Alloc
     (Subtype_For_Known_Discriminant_Part,
      Access_To_Subtype_For_Known_Discriminant_Part);

   function Allocate_Known_Discriminant_Part
     (Pool : Bump_Ptr_Pool) return Bare_Known_Discriminant_Part;

   function Allocate_Known_Discriminant_Part
     (Pool : Bump_Ptr_Pool) return Bare_Known_Discriminant_Part
   is
      Result : constant Access_To_Subtype_For_Known_Discriminant_Part :=
        Bare_Known_Discriminant_Part_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Known_Discriminant_Part;
      return Bare_Known_Discriminant_Part (Result);
   end Allocate_Known_Discriminant_Part;

   package Bare_Unknown_Discriminant_Part_Memos is new Langkit_Support.Packrat
     (Bare_Unknown_Discriminant_Part, Token_Index);

   subtype Subtype_For_Unknown_Discriminant_Part is
     Root_Node_Record (Ada_Unknown_Discriminant_Part);
   type Access_To_Subtype_For_Unknown_Discriminant_Part is
     access all Subtype_For_Unknown_Discriminant_Part;
   package Bare_Unknown_Discriminant_Part_Alloc is new Alloc
     (Subtype_For_Unknown_Discriminant_Part,
      Access_To_Subtype_For_Unknown_Discriminant_Part);

   function Allocate_Unknown_Discriminant_Part
     (Pool : Bump_Ptr_Pool) return Bare_Unknown_Discriminant_Part;

   function Allocate_Unknown_Discriminant_Part
     (Pool : Bump_Ptr_Pool) return Bare_Unknown_Discriminant_Part
   is
      Result : constant Access_To_Subtype_For_Unknown_Discriminant_Part :=
        Bare_Unknown_Discriminant_Part_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Unknown_Discriminant_Part;
      return Bare_Unknown_Discriminant_Part (Result);
   end Allocate_Unknown_Discriminant_Part;

   package Bare_Entry_Completion_Formal_Params_Memos is new Langkit_Support
     .Packrat
     (Bare_Entry_Completion_Formal_Params, Token_Index);

   subtype Subtype_For_Entry_Completion_Formal_Params is
     Root_Node_Record (Ada_Entry_Completion_Formal_Params);
   type Access_To_Subtype_For_Entry_Completion_Formal_Params is
     access all Subtype_For_Entry_Completion_Formal_Params;
   package Bare_Entry_Completion_Formal_Params_Alloc is new Alloc
     (Subtype_For_Entry_Completion_Formal_Params,
      Access_To_Subtype_For_Entry_Completion_Formal_Params);

   function Allocate_Entry_Completion_Formal_Params
     (Pool : Bump_Ptr_Pool) return Bare_Entry_Completion_Formal_Params;

   function Allocate_Entry_Completion_Formal_Params
     (Pool : Bump_Ptr_Pool) return Bare_Entry_Completion_Formal_Params
   is
      Result : constant Access_To_Subtype_For_Entry_Completion_Formal_Params :=
        Bare_Entry_Completion_Formal_Params_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Entry_Completion_Formal_Params;
      return Bare_Entry_Completion_Formal_Params (Result);
   end Allocate_Entry_Completion_Formal_Params;

   package Bare_Generic_Formal_Part_Memos is new Langkit_Support.Packrat
     (Bare_Generic_Formal_Part, Token_Index);

   subtype Subtype_For_Generic_Formal_Part is
     Root_Node_Record (Ada_Generic_Formal_Part);
   type Access_To_Subtype_For_Generic_Formal_Part is
     access all Subtype_For_Generic_Formal_Part;
   package Bare_Generic_Formal_Part_Alloc is new Alloc
     (Subtype_For_Generic_Formal_Part,
      Access_To_Subtype_For_Generic_Formal_Part);

   function Allocate_Generic_Formal_Part
     (Pool : Bump_Ptr_Pool) return Bare_Generic_Formal_Part;

   function Allocate_Generic_Formal_Part
     (Pool : Bump_Ptr_Pool) return Bare_Generic_Formal_Part
   is
      Result : constant Access_To_Subtype_For_Generic_Formal_Part :=
        Bare_Generic_Formal_Part_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Generic_Formal_Part;
      return Bare_Generic_Formal_Part (Result);
   end Allocate_Generic_Formal_Part;

   package Bare_Base_Record_Def_Memos is new Langkit_Support.Packrat
     (Bare_Base_Record_Def, Token_Index);

   package Bare_Null_Record_Def_Memos is new Langkit_Support.Packrat
     (Bare_Null_Record_Def, Token_Index);

   subtype Subtype_For_Null_Record_Def is
     Root_Node_Record (Ada_Null_Record_Def);
   type Access_To_Subtype_For_Null_Record_Def is
     access all Subtype_For_Null_Record_Def;
   package Bare_Null_Record_Def_Alloc is new Alloc
     (Subtype_For_Null_Record_Def, Access_To_Subtype_For_Null_Record_Def);

   function Allocate_Null_Record_Def
     (Pool : Bump_Ptr_Pool) return Bare_Null_Record_Def;

   function Allocate_Null_Record_Def
     (Pool : Bump_Ptr_Pool) return Bare_Null_Record_Def
   is
      Result : constant Access_To_Subtype_For_Null_Record_Def :=
        Bare_Null_Record_Def_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Null_Record_Def;
      return Bare_Null_Record_Def (Result);
   end Allocate_Null_Record_Def;

   package Bare_Record_Def_Memos is new Langkit_Support.Packrat
     (Bare_Record_Def, Token_Index);

   subtype Subtype_For_Record_Def is Root_Node_Record (Ada_Record_Def);
   type Access_To_Subtype_For_Record_Def is access all Subtype_For_Record_Def;
   package Bare_Record_Def_Alloc is new Alloc
     (Subtype_For_Record_Def, Access_To_Subtype_For_Record_Def);

   function Allocate_Record_Def (Pool : Bump_Ptr_Pool) return Bare_Record_Def;

   function Allocate_Record_Def (Pool : Bump_Ptr_Pool) return Bare_Record_Def
   is
      Result : constant Access_To_Subtype_For_Record_Def :=
        Bare_Record_Def_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Record_Def;
      return Bare_Record_Def (Result);
   end Allocate_Record_Def;

   package Bare_Basic_Assoc_Memos is new Langkit_Support.Packrat
     (Bare_Basic_Assoc, Token_Index);

   package Bare_Aggregate_Assoc_Memos is new Langkit_Support.Packrat
     (Bare_Aggregate_Assoc, Token_Index);

   subtype Subtype_For_Aggregate_Assoc is
     Root_Node_Record (Ada_Aggregate_Assoc);
   type Access_To_Subtype_For_Aggregate_Assoc is
     access all Subtype_For_Aggregate_Assoc;
   package Bare_Aggregate_Assoc_Alloc is new Alloc
     (Subtype_For_Aggregate_Assoc, Access_To_Subtype_For_Aggregate_Assoc);

   function Allocate_Aggregate_Assoc
     (Pool : Bump_Ptr_Pool) return Bare_Aggregate_Assoc;

   function Allocate_Aggregate_Assoc
     (Pool : Bump_Ptr_Pool) return Bare_Aggregate_Assoc
   is
      Result : constant Access_To_Subtype_For_Aggregate_Assoc :=
        Bare_Aggregate_Assoc_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Aggregate_Assoc;
      return Bare_Aggregate_Assoc (Result);
   end Allocate_Aggregate_Assoc;

   package Bare_Multi_Dim_Array_Assoc_Memos is new Langkit_Support.Packrat
     (Bare_Multi_Dim_Array_Assoc, Token_Index);

   subtype Subtype_For_Multi_Dim_Array_Assoc is
     Root_Node_Record (Ada_Multi_Dim_Array_Assoc);
   type Access_To_Subtype_For_Multi_Dim_Array_Assoc is
     access all Subtype_For_Multi_Dim_Array_Assoc;
   package Bare_Multi_Dim_Array_Assoc_Alloc is new Alloc
     (Subtype_For_Multi_Dim_Array_Assoc,
      Access_To_Subtype_For_Multi_Dim_Array_Assoc);

   function Allocate_Multi_Dim_Array_Assoc
     (Pool : Bump_Ptr_Pool) return Bare_Multi_Dim_Array_Assoc;

   function Allocate_Multi_Dim_Array_Assoc
     (Pool : Bump_Ptr_Pool) return Bare_Multi_Dim_Array_Assoc
   is
      Result : constant Access_To_Subtype_For_Multi_Dim_Array_Assoc :=
        Bare_Multi_Dim_Array_Assoc_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Multi_Dim_Array_Assoc;
      return Bare_Multi_Dim_Array_Assoc (Result);
   end Allocate_Multi_Dim_Array_Assoc;

   package Bare_Discriminant_Assoc_Memos is new Langkit_Support.Packrat
     (Bare_Discriminant_Assoc, Token_Index);

   subtype Subtype_For_Discriminant_Assoc is
     Root_Node_Record (Ada_Discriminant_Assoc);
   type Access_To_Subtype_For_Discriminant_Assoc is
     access all Subtype_For_Discriminant_Assoc;
   package Bare_Discriminant_Assoc_Alloc is new Alloc
     (Subtype_For_Discriminant_Assoc,
      Access_To_Subtype_For_Discriminant_Assoc);

   function Allocate_Discriminant_Assoc
     (Pool : Bump_Ptr_Pool) return Bare_Discriminant_Assoc;

   function Allocate_Discriminant_Assoc
     (Pool : Bump_Ptr_Pool) return Bare_Discriminant_Assoc
   is
      Result : constant Access_To_Subtype_For_Discriminant_Assoc :=
        Bare_Discriminant_Assoc_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Discriminant_Assoc;
      return Bare_Discriminant_Assoc (Result);
   end Allocate_Discriminant_Assoc;

   package Bare_Param_Assoc_Memos is new Langkit_Support.Packrat
     (Bare_Param_Assoc, Token_Index);

   subtype Subtype_For_Param_Assoc is Root_Node_Record (Ada_Param_Assoc);
   type Access_To_Subtype_For_Param_Assoc is
     access all Subtype_For_Param_Assoc;
   package Bare_Param_Assoc_Alloc is new Alloc
     (Subtype_For_Param_Assoc, Access_To_Subtype_For_Param_Assoc);

   function Allocate_Param_Assoc
     (Pool : Bump_Ptr_Pool) return Bare_Param_Assoc;

   function Allocate_Param_Assoc (Pool : Bump_Ptr_Pool) return Bare_Param_Assoc
   is
      Result : constant Access_To_Subtype_For_Param_Assoc :=
        Bare_Param_Assoc_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Param_Assoc;
      return Bare_Param_Assoc (Result);
   end Allocate_Param_Assoc;

   package Bare_Basic_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Basic_Decl, Token_Index);

   package Bare_Base_Formal_Param_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Base_Formal_Param_Decl, Token_Index);

   package Bare_Component_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Component_Decl, Token_Index);

   subtype Subtype_For_Component_Decl is Root_Node_Record (Ada_Component_Decl);
   type Access_To_Subtype_For_Component_Decl is
     access all Subtype_For_Component_Decl;
   package Bare_Component_Decl_Alloc is new Alloc
     (Subtype_For_Component_Decl, Access_To_Subtype_For_Component_Decl);

   function Allocate_Component_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Component_Decl;

   function Allocate_Component_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Component_Decl
   is
      Result : constant Access_To_Subtype_For_Component_Decl :=
        Bare_Component_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Component_Decl;
      return Bare_Component_Decl (Result);
   end Allocate_Component_Decl;

   package Bare_Discriminant_Spec_Memos is new Langkit_Support.Packrat
     (Bare_Discriminant_Spec, Token_Index);

   subtype Subtype_For_Discriminant_Spec is
     Root_Node_Record (Ada_Discriminant_Spec);
   type Access_To_Subtype_For_Discriminant_Spec is
     access all Subtype_For_Discriminant_Spec;
   package Bare_Discriminant_Spec_Alloc is new Alloc
     (Subtype_For_Discriminant_Spec, Access_To_Subtype_For_Discriminant_Spec);

   function Allocate_Discriminant_Spec
     (Pool : Bump_Ptr_Pool) return Bare_Discriminant_Spec;

   function Allocate_Discriminant_Spec
     (Pool : Bump_Ptr_Pool) return Bare_Discriminant_Spec
   is
      Result : constant Access_To_Subtype_For_Discriminant_Spec :=
        Bare_Discriminant_Spec_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Discriminant_Spec;
      return Bare_Discriminant_Spec (Result);
   end Allocate_Discriminant_Spec;

   package Bare_Generic_Formal_Memos is new Langkit_Support.Packrat
     (Bare_Generic_Formal, Token_Index);

   package Bare_Generic_Formal_Obj_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Generic_Formal_Obj_Decl, Token_Index);

   subtype Subtype_For_Generic_Formal_Obj_Decl is
     Root_Node_Record (Ada_Generic_Formal_Obj_Decl);
   type Access_To_Subtype_For_Generic_Formal_Obj_Decl is
     access all Subtype_For_Generic_Formal_Obj_Decl;
   package Bare_Generic_Formal_Obj_Decl_Alloc is new Alloc
     (Subtype_For_Generic_Formal_Obj_Decl,
      Access_To_Subtype_For_Generic_Formal_Obj_Decl);

   function Allocate_Generic_Formal_Obj_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Generic_Formal_Obj_Decl;

   function Allocate_Generic_Formal_Obj_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Generic_Formal_Obj_Decl
   is
      Result : constant Access_To_Subtype_For_Generic_Formal_Obj_Decl :=
        Bare_Generic_Formal_Obj_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Generic_Formal_Obj_Decl;
      return Bare_Generic_Formal_Obj_Decl (Result);
   end Allocate_Generic_Formal_Obj_Decl;

   package Bare_Generic_Formal_Package_Memos is new Langkit_Support.Packrat
     (Bare_Generic_Formal_Package, Token_Index);

   subtype Subtype_For_Generic_Formal_Package is
     Root_Node_Record (Ada_Generic_Formal_Package);
   type Access_To_Subtype_For_Generic_Formal_Package is
     access all Subtype_For_Generic_Formal_Package;
   package Bare_Generic_Formal_Package_Alloc is new Alloc
     (Subtype_For_Generic_Formal_Package,
      Access_To_Subtype_For_Generic_Formal_Package);

   function Allocate_Generic_Formal_Package
     (Pool : Bump_Ptr_Pool) return Bare_Generic_Formal_Package;

   function Allocate_Generic_Formal_Package
     (Pool : Bump_Ptr_Pool) return Bare_Generic_Formal_Package
   is
      Result : constant Access_To_Subtype_For_Generic_Formal_Package :=
        Bare_Generic_Formal_Package_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Generic_Formal_Package;
      return Bare_Generic_Formal_Package (Result);
   end Allocate_Generic_Formal_Package;

   package Bare_Generic_Formal_Subp_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Generic_Formal_Subp_Decl, Token_Index);

   subtype Subtype_For_Generic_Formal_Subp_Decl is
     Root_Node_Record (Ada_Generic_Formal_Subp_Decl);
   type Access_To_Subtype_For_Generic_Formal_Subp_Decl is
     access all Subtype_For_Generic_Formal_Subp_Decl;
   package Bare_Generic_Formal_Subp_Decl_Alloc is new Alloc
     (Subtype_For_Generic_Formal_Subp_Decl,
      Access_To_Subtype_For_Generic_Formal_Subp_Decl);

   function Allocate_Generic_Formal_Subp_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Generic_Formal_Subp_Decl;

   function Allocate_Generic_Formal_Subp_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Generic_Formal_Subp_Decl
   is
      Result : constant Access_To_Subtype_For_Generic_Formal_Subp_Decl :=
        Bare_Generic_Formal_Subp_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Generic_Formal_Subp_Decl;
      return Bare_Generic_Formal_Subp_Decl (Result);
   end Allocate_Generic_Formal_Subp_Decl;

   package Bare_Generic_Formal_Type_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Generic_Formal_Type_Decl, Token_Index);

   subtype Subtype_For_Generic_Formal_Type_Decl is
     Root_Node_Record (Ada_Generic_Formal_Type_Decl);
   type Access_To_Subtype_For_Generic_Formal_Type_Decl is
     access all Subtype_For_Generic_Formal_Type_Decl;
   package Bare_Generic_Formal_Type_Decl_Alloc is new Alloc
     (Subtype_For_Generic_Formal_Type_Decl,
      Access_To_Subtype_For_Generic_Formal_Type_Decl);

   function Allocate_Generic_Formal_Type_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Generic_Formal_Type_Decl;

   function Allocate_Generic_Formal_Type_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Generic_Formal_Type_Decl
   is
      Result : constant Access_To_Subtype_For_Generic_Formal_Type_Decl :=
        Bare_Generic_Formal_Type_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Generic_Formal_Type_Decl;
      return Bare_Generic_Formal_Type_Decl (Result);
   end Allocate_Generic_Formal_Type_Decl;

   package Bare_Param_Spec_Memos is new Langkit_Support.Packrat
     (Bare_Param_Spec, Token_Index);

   subtype Subtype_For_Param_Spec is Root_Node_Record (Ada_Param_Spec);
   type Access_To_Subtype_For_Param_Spec is access all Subtype_For_Param_Spec;
   package Bare_Param_Spec_Alloc is new Alloc
     (Subtype_For_Param_Spec, Access_To_Subtype_For_Param_Spec);

   function Allocate_Param_Spec (Pool : Bump_Ptr_Pool) return Bare_Param_Spec;

   function Allocate_Param_Spec (Pool : Bump_Ptr_Pool) return Bare_Param_Spec
   is
      Result : constant Access_To_Subtype_For_Param_Spec :=
        Bare_Param_Spec_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Param_Spec;
      return Bare_Param_Spec (Result);
   end Allocate_Param_Spec;

   package Bare_Base_Package_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Base_Package_Decl, Token_Index);

   package Bare_Generic_Package_Internal_Memos is new Langkit_Support.Packrat
     (Bare_Generic_Package_Internal, Token_Index);

   subtype Subtype_For_Generic_Package_Internal is
     Root_Node_Record (Ada_Generic_Package_Internal);
   type Access_To_Subtype_For_Generic_Package_Internal is
     access all Subtype_For_Generic_Package_Internal;
   package Bare_Generic_Package_Internal_Alloc is new Alloc
     (Subtype_For_Generic_Package_Internal,
      Access_To_Subtype_For_Generic_Package_Internal);

   function Allocate_Generic_Package_Internal
     (Pool : Bump_Ptr_Pool) return Bare_Generic_Package_Internal;

   function Allocate_Generic_Package_Internal
     (Pool : Bump_Ptr_Pool) return Bare_Generic_Package_Internal
   is
      Result : constant Access_To_Subtype_For_Generic_Package_Internal :=
        Bare_Generic_Package_Internal_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Generic_Package_Internal;
      return Bare_Generic_Package_Internal (Result);
   end Allocate_Generic_Package_Internal;

   package Bare_Package_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Package_Decl, Token_Index);

   subtype Subtype_For_Package_Decl is Root_Node_Record (Ada_Package_Decl);
   type Access_To_Subtype_For_Package_Decl is
     access all Subtype_For_Package_Decl;
   package Bare_Package_Decl_Alloc is new Alloc
     (Subtype_For_Package_Decl, Access_To_Subtype_For_Package_Decl);

   function Allocate_Package_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Package_Decl;

   function Allocate_Package_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Package_Decl
   is
      Result : constant Access_To_Subtype_For_Package_Decl :=
        Bare_Package_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Package_Decl;
      return Bare_Package_Decl (Result);
   end Allocate_Package_Decl;

   package Bare_Base_Type_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Base_Type_Decl, Token_Index);

   package Bare_Base_Subtype_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Base_Subtype_Decl, Token_Index);

   package Bare_Discrete_Base_Subtype_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Discrete_Base_Subtype_Decl, Token_Index);

   subtype Subtype_For_Discrete_Base_Subtype_Decl is
     Root_Node_Record (Ada_Discrete_Base_Subtype_Decl);
   type Access_To_Subtype_For_Discrete_Base_Subtype_Decl is
     access all Subtype_For_Discrete_Base_Subtype_Decl;
   package Bare_Discrete_Base_Subtype_Decl_Alloc is new Alloc
     (Subtype_For_Discrete_Base_Subtype_Decl,
      Access_To_Subtype_For_Discrete_Base_Subtype_Decl);

   function Allocate_Discrete_Base_Subtype_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Discrete_Base_Subtype_Decl;

   function Allocate_Discrete_Base_Subtype_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Discrete_Base_Subtype_Decl
   is
      Result : constant Access_To_Subtype_For_Discrete_Base_Subtype_Decl :=
        Bare_Discrete_Base_Subtype_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Discrete_Base_Subtype_Decl;
      return Bare_Discrete_Base_Subtype_Decl (Result);
   end Allocate_Discrete_Base_Subtype_Decl;

   package Bare_Subtype_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Subtype_Decl, Token_Index);

   subtype Subtype_For_Subtype_Decl is Root_Node_Record (Ada_Subtype_Decl);
   type Access_To_Subtype_For_Subtype_Decl is
     access all Subtype_For_Subtype_Decl;
   package Bare_Subtype_Decl_Alloc is new Alloc
     (Subtype_For_Subtype_Decl, Access_To_Subtype_For_Subtype_Decl);

   function Allocate_Subtype_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Subtype_Decl;

   function Allocate_Subtype_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Subtype_Decl
   is
      Result : constant Access_To_Subtype_For_Subtype_Decl :=
        Bare_Subtype_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Subtype_Decl;
      return Bare_Subtype_Decl (Result);
   end Allocate_Subtype_Decl;

   package Bare_Classwide_Type_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Classwide_Type_Decl, Token_Index);

   subtype Subtype_For_Classwide_Type_Decl is
     Root_Node_Record (Ada_Classwide_Type_Decl);
   type Access_To_Subtype_For_Classwide_Type_Decl is
     access all Subtype_For_Classwide_Type_Decl;
   package Bare_Classwide_Type_Decl_Alloc is new Alloc
     (Subtype_For_Classwide_Type_Decl,
      Access_To_Subtype_For_Classwide_Type_Decl);

   function Allocate_Classwide_Type_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Classwide_Type_Decl;

   function Allocate_Classwide_Type_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Classwide_Type_Decl
   is
      Result : constant Access_To_Subtype_For_Classwide_Type_Decl :=
        Bare_Classwide_Type_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Classwide_Type_Decl;
      return Bare_Classwide_Type_Decl (Result);
   end Allocate_Classwide_Type_Decl;

   package Bare_Incomplete_Type_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Incomplete_Type_Decl, Token_Index);

   subtype Subtype_For_Incomplete_Type_Decl is
     Root_Node_Record (Ada_Incomplete_Type_Decl);
   type Access_To_Subtype_For_Incomplete_Type_Decl is
     access all Subtype_For_Incomplete_Type_Decl;
   package Bare_Incomplete_Type_Decl_Alloc is new Alloc
     (Subtype_For_Incomplete_Type_Decl,
      Access_To_Subtype_For_Incomplete_Type_Decl);

   function Allocate_Incomplete_Type_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Incomplete_Type_Decl;

   function Allocate_Incomplete_Type_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Incomplete_Type_Decl
   is
      Result : constant Access_To_Subtype_For_Incomplete_Type_Decl :=
        Bare_Incomplete_Type_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Incomplete_Type_Decl;
      return Bare_Incomplete_Type_Decl (Result);
   end Allocate_Incomplete_Type_Decl;

   package Bare_Incomplete_Tagged_Type_Decl_Memos is new Langkit_Support
     .Packrat
     (Bare_Incomplete_Tagged_Type_Decl, Token_Index);

   subtype Subtype_For_Incomplete_Tagged_Type_Decl is
     Root_Node_Record (Ada_Incomplete_Tagged_Type_Decl);
   type Access_To_Subtype_For_Incomplete_Tagged_Type_Decl is
     access all Subtype_For_Incomplete_Tagged_Type_Decl;
   package Bare_Incomplete_Tagged_Type_Decl_Alloc is new Alloc
     (Subtype_For_Incomplete_Tagged_Type_Decl,
      Access_To_Subtype_For_Incomplete_Tagged_Type_Decl);

   function Allocate_Incomplete_Tagged_Type_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Incomplete_Tagged_Type_Decl;

   function Allocate_Incomplete_Tagged_Type_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Incomplete_Tagged_Type_Decl
   is
      Result : constant Access_To_Subtype_For_Incomplete_Tagged_Type_Decl :=
        Bare_Incomplete_Tagged_Type_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Incomplete_Tagged_Type_Decl;
      return Bare_Incomplete_Tagged_Type_Decl (Result);
   end Allocate_Incomplete_Tagged_Type_Decl;

   package Bare_Protected_Type_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Protected_Type_Decl, Token_Index);

   subtype Subtype_For_Protected_Type_Decl is
     Root_Node_Record (Ada_Protected_Type_Decl);
   type Access_To_Subtype_For_Protected_Type_Decl is
     access all Subtype_For_Protected_Type_Decl;
   package Bare_Protected_Type_Decl_Alloc is new Alloc
     (Subtype_For_Protected_Type_Decl,
      Access_To_Subtype_For_Protected_Type_Decl);

   function Allocate_Protected_Type_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Protected_Type_Decl;

   function Allocate_Protected_Type_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Protected_Type_Decl
   is
      Result : constant Access_To_Subtype_For_Protected_Type_Decl :=
        Bare_Protected_Type_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Protected_Type_Decl;
      return Bare_Protected_Type_Decl (Result);
   end Allocate_Protected_Type_Decl;

   package Bare_Task_Type_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Task_Type_Decl, Token_Index);

   subtype Subtype_For_Task_Type_Decl is Root_Node_Record (Ada_Task_Type_Decl);
   type Access_To_Subtype_For_Task_Type_Decl is
     access all Subtype_For_Task_Type_Decl;
   package Bare_Task_Type_Decl_Alloc is new Alloc
     (Subtype_For_Task_Type_Decl, Access_To_Subtype_For_Task_Type_Decl);

   function Allocate_Task_Type_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Task_Type_Decl;

   function Allocate_Task_Type_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Task_Type_Decl
   is
      Result : constant Access_To_Subtype_For_Task_Type_Decl :=
        Bare_Task_Type_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Task_Type_Decl;
      return Bare_Task_Type_Decl (Result);
   end Allocate_Task_Type_Decl;

   package Bare_Single_Task_Type_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Single_Task_Type_Decl, Token_Index);

   subtype Subtype_For_Single_Task_Type_Decl is
     Root_Node_Record (Ada_Single_Task_Type_Decl);
   type Access_To_Subtype_For_Single_Task_Type_Decl is
     access all Subtype_For_Single_Task_Type_Decl;
   package Bare_Single_Task_Type_Decl_Alloc is new Alloc
     (Subtype_For_Single_Task_Type_Decl,
      Access_To_Subtype_For_Single_Task_Type_Decl);

   function Allocate_Single_Task_Type_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Single_Task_Type_Decl;

   function Allocate_Single_Task_Type_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Single_Task_Type_Decl
   is
      Result : constant Access_To_Subtype_For_Single_Task_Type_Decl :=
        Bare_Single_Task_Type_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Single_Task_Type_Decl;
      return Bare_Single_Task_Type_Decl (Result);
   end Allocate_Single_Task_Type_Decl;

   package Bare_Type_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Type_Decl, Token_Index);

   subtype Subtype_For_Type_Decl is Root_Node_Record (Ada_Type_Decl);
   type Access_To_Subtype_For_Type_Decl is access all Subtype_For_Type_Decl;
   package Bare_Type_Decl_Alloc is new Alloc
     (Subtype_For_Type_Decl, Access_To_Subtype_For_Type_Decl);

   function Allocate_Type_Decl (Pool : Bump_Ptr_Pool) return Bare_Type_Decl;

   function Allocate_Type_Decl (Pool : Bump_Ptr_Pool) return Bare_Type_Decl is
      Result : constant Access_To_Subtype_For_Type_Decl :=
        Bare_Type_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Type_Decl;
      return Bare_Type_Decl (Result);
   end Allocate_Type_Decl;

   package Bare_Anonymous_Type_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Anonymous_Type_Decl, Token_Index);

   subtype Subtype_For_Anonymous_Type_Decl is
     Root_Node_Record (Ada_Anonymous_Type_Decl);
   type Access_To_Subtype_For_Anonymous_Type_Decl is
     access all Subtype_For_Anonymous_Type_Decl;
   package Bare_Anonymous_Type_Decl_Alloc is new Alloc
     (Subtype_For_Anonymous_Type_Decl,
      Access_To_Subtype_For_Anonymous_Type_Decl);

   function Allocate_Anonymous_Type_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Anonymous_Type_Decl;

   function Allocate_Anonymous_Type_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Anonymous_Type_Decl
   is
      Result : constant Access_To_Subtype_For_Anonymous_Type_Decl :=
        Bare_Anonymous_Type_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Anonymous_Type_Decl;
      return Bare_Anonymous_Type_Decl (Result);
   end Allocate_Anonymous_Type_Decl;

   package Bare_Synth_Anonymous_Type_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Synth_Anonymous_Type_Decl, Token_Index);

   subtype Subtype_For_Synth_Anonymous_Type_Decl is
     Root_Node_Record (Ada_Synth_Anonymous_Type_Decl);
   type Access_To_Subtype_For_Synth_Anonymous_Type_Decl is
     access all Subtype_For_Synth_Anonymous_Type_Decl;
   package Bare_Synth_Anonymous_Type_Decl_Alloc is new Alloc
     (Subtype_For_Synth_Anonymous_Type_Decl,
      Access_To_Subtype_For_Synth_Anonymous_Type_Decl);

   function Allocate_Synth_Anonymous_Type_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Synth_Anonymous_Type_Decl;

   function Allocate_Synth_Anonymous_Type_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Synth_Anonymous_Type_Decl
   is
      Result : constant Access_To_Subtype_For_Synth_Anonymous_Type_Decl :=
        Bare_Synth_Anonymous_Type_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Synth_Anonymous_Type_Decl;
      return Bare_Synth_Anonymous_Type_Decl (Result);
   end Allocate_Synth_Anonymous_Type_Decl;

   package Bare_Basic_Subp_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Basic_Subp_Decl, Token_Index);

   package Bare_Classic_Subp_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Classic_Subp_Decl, Token_Index);

   package Bare_Abstract_Subp_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Abstract_Subp_Decl, Token_Index);

   subtype Subtype_For_Abstract_Subp_Decl is
     Root_Node_Record (Ada_Abstract_Subp_Decl);
   type Access_To_Subtype_For_Abstract_Subp_Decl is
     access all Subtype_For_Abstract_Subp_Decl;
   package Bare_Abstract_Subp_Decl_Alloc is new Alloc
     (Subtype_For_Abstract_Subp_Decl,
      Access_To_Subtype_For_Abstract_Subp_Decl);

   function Allocate_Abstract_Subp_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Abstract_Subp_Decl;

   function Allocate_Abstract_Subp_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Abstract_Subp_Decl
   is
      Result : constant Access_To_Subtype_For_Abstract_Subp_Decl :=
        Bare_Abstract_Subp_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Abstract_Subp_Decl;
      return Bare_Abstract_Subp_Decl (Result);
   end Allocate_Abstract_Subp_Decl;

   package Bare_Formal_Subp_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Formal_Subp_Decl, Token_Index);

   package Bare_Abstract_Formal_Subp_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Abstract_Formal_Subp_Decl, Token_Index);

   subtype Subtype_For_Abstract_Formal_Subp_Decl is
     Root_Node_Record (Ada_Abstract_Formal_Subp_Decl);
   type Access_To_Subtype_For_Abstract_Formal_Subp_Decl is
     access all Subtype_For_Abstract_Formal_Subp_Decl;
   package Bare_Abstract_Formal_Subp_Decl_Alloc is new Alloc
     (Subtype_For_Abstract_Formal_Subp_Decl,
      Access_To_Subtype_For_Abstract_Formal_Subp_Decl);

   function Allocate_Abstract_Formal_Subp_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Abstract_Formal_Subp_Decl;

   function Allocate_Abstract_Formal_Subp_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Abstract_Formal_Subp_Decl
   is
      Result : constant Access_To_Subtype_For_Abstract_Formal_Subp_Decl :=
        Bare_Abstract_Formal_Subp_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Abstract_Formal_Subp_Decl;
      return Bare_Abstract_Formal_Subp_Decl (Result);
   end Allocate_Abstract_Formal_Subp_Decl;

   package Bare_Concrete_Formal_Subp_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Concrete_Formal_Subp_Decl, Token_Index);

   subtype Subtype_For_Concrete_Formal_Subp_Decl is
     Root_Node_Record (Ada_Concrete_Formal_Subp_Decl);
   type Access_To_Subtype_For_Concrete_Formal_Subp_Decl is
     access all Subtype_For_Concrete_Formal_Subp_Decl;
   package Bare_Concrete_Formal_Subp_Decl_Alloc is new Alloc
     (Subtype_For_Concrete_Formal_Subp_Decl,
      Access_To_Subtype_For_Concrete_Formal_Subp_Decl);

   function Allocate_Concrete_Formal_Subp_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Concrete_Formal_Subp_Decl;

   function Allocate_Concrete_Formal_Subp_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Concrete_Formal_Subp_Decl
   is
      Result : constant Access_To_Subtype_For_Concrete_Formal_Subp_Decl :=
        Bare_Concrete_Formal_Subp_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Concrete_Formal_Subp_Decl;
      return Bare_Concrete_Formal_Subp_Decl (Result);
   end Allocate_Concrete_Formal_Subp_Decl;

   package Bare_Subp_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Subp_Decl, Token_Index);

   subtype Subtype_For_Subp_Decl is Root_Node_Record (Ada_Subp_Decl);
   type Access_To_Subtype_For_Subp_Decl is access all Subtype_For_Subp_Decl;
   package Bare_Subp_Decl_Alloc is new Alloc
     (Subtype_For_Subp_Decl, Access_To_Subtype_For_Subp_Decl);

   function Allocate_Subp_Decl (Pool : Bump_Ptr_Pool) return Bare_Subp_Decl;

   function Allocate_Subp_Decl (Pool : Bump_Ptr_Pool) return Bare_Subp_Decl is
      Result : constant Access_To_Subtype_For_Subp_Decl :=
        Bare_Subp_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Subp_Decl;
      return Bare_Subp_Decl (Result);
   end Allocate_Subp_Decl;

   package Bare_Entry_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Entry_Decl, Token_Index);

   subtype Subtype_For_Entry_Decl is Root_Node_Record (Ada_Entry_Decl);
   type Access_To_Subtype_For_Entry_Decl is access all Subtype_For_Entry_Decl;
   package Bare_Entry_Decl_Alloc is new Alloc
     (Subtype_For_Entry_Decl, Access_To_Subtype_For_Entry_Decl);

   function Allocate_Entry_Decl (Pool : Bump_Ptr_Pool) return Bare_Entry_Decl;

   function Allocate_Entry_Decl (Pool : Bump_Ptr_Pool) return Bare_Entry_Decl
   is
      Result : constant Access_To_Subtype_For_Entry_Decl :=
        Bare_Entry_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Entry_Decl;
      return Bare_Entry_Decl (Result);
   end Allocate_Entry_Decl;

   package Bare_Enum_Literal_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Enum_Literal_Decl, Token_Index);

   subtype Subtype_For_Enum_Literal_Decl is
     Root_Node_Record (Ada_Enum_Literal_Decl);
   type Access_To_Subtype_For_Enum_Literal_Decl is
     access all Subtype_For_Enum_Literal_Decl;
   package Bare_Enum_Literal_Decl_Alloc is new Alloc
     (Subtype_For_Enum_Literal_Decl, Access_To_Subtype_For_Enum_Literal_Decl);

   function Allocate_Enum_Literal_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Enum_Literal_Decl;

   function Allocate_Enum_Literal_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Enum_Literal_Decl
   is
      Result : constant Access_To_Subtype_For_Enum_Literal_Decl :=
        Bare_Enum_Literal_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Enum_Literal_Decl;
      return Bare_Enum_Literal_Decl (Result);
   end Allocate_Enum_Literal_Decl;

   package Bare_Generic_Subp_Internal_Memos is new Langkit_Support.Packrat
     (Bare_Generic_Subp_Internal, Token_Index);

   subtype Subtype_For_Generic_Subp_Internal is
     Root_Node_Record (Ada_Generic_Subp_Internal);
   type Access_To_Subtype_For_Generic_Subp_Internal is
     access all Subtype_For_Generic_Subp_Internal;
   package Bare_Generic_Subp_Internal_Alloc is new Alloc
     (Subtype_For_Generic_Subp_Internal,
      Access_To_Subtype_For_Generic_Subp_Internal);

   function Allocate_Generic_Subp_Internal
     (Pool : Bump_Ptr_Pool) return Bare_Generic_Subp_Internal;

   function Allocate_Generic_Subp_Internal
     (Pool : Bump_Ptr_Pool) return Bare_Generic_Subp_Internal
   is
      Result : constant Access_To_Subtype_For_Generic_Subp_Internal :=
        Bare_Generic_Subp_Internal_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Generic_Subp_Internal;
      return Bare_Generic_Subp_Internal (Result);
   end Allocate_Generic_Subp_Internal;

   package Bare_Body_Node_Memos is new Langkit_Support.Packrat
     (Bare_Body_Node, Token_Index);

   package Bare_Base_Subp_Body_Memos is new Langkit_Support.Packrat
     (Bare_Base_Subp_Body, Token_Index);

   package Bare_Expr_Function_Memos is new Langkit_Support.Packrat
     (Bare_Expr_Function, Token_Index);

   subtype Subtype_For_Expr_Function is Root_Node_Record (Ada_Expr_Function);
   type Access_To_Subtype_For_Expr_Function is
     access all Subtype_For_Expr_Function;
   package Bare_Expr_Function_Alloc is new Alloc
     (Subtype_For_Expr_Function, Access_To_Subtype_For_Expr_Function);

   function Allocate_Expr_Function
     (Pool : Bump_Ptr_Pool) return Bare_Expr_Function;

   function Allocate_Expr_Function
     (Pool : Bump_Ptr_Pool) return Bare_Expr_Function
   is
      Result : constant Access_To_Subtype_For_Expr_Function :=
        Bare_Expr_Function_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Expr_Function;
      return Bare_Expr_Function (Result);
   end Allocate_Expr_Function;

   package Bare_Null_Subp_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Null_Subp_Decl, Token_Index);

   subtype Subtype_For_Null_Subp_Decl is Root_Node_Record (Ada_Null_Subp_Decl);
   type Access_To_Subtype_For_Null_Subp_Decl is
     access all Subtype_For_Null_Subp_Decl;
   package Bare_Null_Subp_Decl_Alloc is new Alloc
     (Subtype_For_Null_Subp_Decl, Access_To_Subtype_For_Null_Subp_Decl);

   function Allocate_Null_Subp_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Null_Subp_Decl;

   function Allocate_Null_Subp_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Null_Subp_Decl
   is
      Result : constant Access_To_Subtype_For_Null_Subp_Decl :=
        Bare_Null_Subp_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Null_Subp_Decl;
      return Bare_Null_Subp_Decl (Result);
   end Allocate_Null_Subp_Decl;

   package Bare_Subp_Body_Memos is new Langkit_Support.Packrat
     (Bare_Subp_Body, Token_Index);

   subtype Subtype_For_Subp_Body is Root_Node_Record (Ada_Subp_Body);
   type Access_To_Subtype_For_Subp_Body is access all Subtype_For_Subp_Body;
   package Bare_Subp_Body_Alloc is new Alloc
     (Subtype_For_Subp_Body, Access_To_Subtype_For_Subp_Body);

   function Allocate_Subp_Body (Pool : Bump_Ptr_Pool) return Bare_Subp_Body;

   function Allocate_Subp_Body (Pool : Bump_Ptr_Pool) return Bare_Subp_Body is
      Result : constant Access_To_Subtype_For_Subp_Body :=
        Bare_Subp_Body_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Subp_Body;
      return Bare_Subp_Body (Result);
   end Allocate_Subp_Body;

   package Bare_Subp_Renaming_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Subp_Renaming_Decl, Token_Index);

   subtype Subtype_For_Subp_Renaming_Decl is
     Root_Node_Record (Ada_Subp_Renaming_Decl);
   type Access_To_Subtype_For_Subp_Renaming_Decl is
     access all Subtype_For_Subp_Renaming_Decl;
   package Bare_Subp_Renaming_Decl_Alloc is new Alloc
     (Subtype_For_Subp_Renaming_Decl,
      Access_To_Subtype_For_Subp_Renaming_Decl);

   function Allocate_Subp_Renaming_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Subp_Renaming_Decl;

   function Allocate_Subp_Renaming_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Subp_Renaming_Decl
   is
      Result : constant Access_To_Subtype_For_Subp_Renaming_Decl :=
        Bare_Subp_Renaming_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Subp_Renaming_Decl;
      return Bare_Subp_Renaming_Decl (Result);
   end Allocate_Subp_Renaming_Decl;

   package Bare_Body_Stub_Memos is new Langkit_Support.Packrat
     (Bare_Body_Stub, Token_Index);

   package Bare_Package_Body_Stub_Memos is new Langkit_Support.Packrat
     (Bare_Package_Body_Stub, Token_Index);

   subtype Subtype_For_Package_Body_Stub is
     Root_Node_Record (Ada_Package_Body_Stub);
   type Access_To_Subtype_For_Package_Body_Stub is
     access all Subtype_For_Package_Body_Stub;
   package Bare_Package_Body_Stub_Alloc is new Alloc
     (Subtype_For_Package_Body_Stub, Access_To_Subtype_For_Package_Body_Stub);

   function Allocate_Package_Body_Stub
     (Pool : Bump_Ptr_Pool) return Bare_Package_Body_Stub;

   function Allocate_Package_Body_Stub
     (Pool : Bump_Ptr_Pool) return Bare_Package_Body_Stub
   is
      Result : constant Access_To_Subtype_For_Package_Body_Stub :=
        Bare_Package_Body_Stub_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Package_Body_Stub;
      return Bare_Package_Body_Stub (Result);
   end Allocate_Package_Body_Stub;

   package Bare_Protected_Body_Stub_Memos is new Langkit_Support.Packrat
     (Bare_Protected_Body_Stub, Token_Index);

   subtype Subtype_For_Protected_Body_Stub is
     Root_Node_Record (Ada_Protected_Body_Stub);
   type Access_To_Subtype_For_Protected_Body_Stub is
     access all Subtype_For_Protected_Body_Stub;
   package Bare_Protected_Body_Stub_Alloc is new Alloc
     (Subtype_For_Protected_Body_Stub,
      Access_To_Subtype_For_Protected_Body_Stub);

   function Allocate_Protected_Body_Stub
     (Pool : Bump_Ptr_Pool) return Bare_Protected_Body_Stub;

   function Allocate_Protected_Body_Stub
     (Pool : Bump_Ptr_Pool) return Bare_Protected_Body_Stub
   is
      Result : constant Access_To_Subtype_For_Protected_Body_Stub :=
        Bare_Protected_Body_Stub_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Protected_Body_Stub;
      return Bare_Protected_Body_Stub (Result);
   end Allocate_Protected_Body_Stub;

   package Bare_Subp_Body_Stub_Memos is new Langkit_Support.Packrat
     (Bare_Subp_Body_Stub, Token_Index);

   subtype Subtype_For_Subp_Body_Stub is Root_Node_Record (Ada_Subp_Body_Stub);
   type Access_To_Subtype_For_Subp_Body_Stub is
     access all Subtype_For_Subp_Body_Stub;
   package Bare_Subp_Body_Stub_Alloc is new Alloc
     (Subtype_For_Subp_Body_Stub, Access_To_Subtype_For_Subp_Body_Stub);

   function Allocate_Subp_Body_Stub
     (Pool : Bump_Ptr_Pool) return Bare_Subp_Body_Stub;

   function Allocate_Subp_Body_Stub
     (Pool : Bump_Ptr_Pool) return Bare_Subp_Body_Stub
   is
      Result : constant Access_To_Subtype_For_Subp_Body_Stub :=
        Bare_Subp_Body_Stub_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Subp_Body_Stub;
      return Bare_Subp_Body_Stub (Result);
   end Allocate_Subp_Body_Stub;

   package Bare_Task_Body_Stub_Memos is new Langkit_Support.Packrat
     (Bare_Task_Body_Stub, Token_Index);

   subtype Subtype_For_Task_Body_Stub is Root_Node_Record (Ada_Task_Body_Stub);
   type Access_To_Subtype_For_Task_Body_Stub is
     access all Subtype_For_Task_Body_Stub;
   package Bare_Task_Body_Stub_Alloc is new Alloc
     (Subtype_For_Task_Body_Stub, Access_To_Subtype_For_Task_Body_Stub);

   function Allocate_Task_Body_Stub
     (Pool : Bump_Ptr_Pool) return Bare_Task_Body_Stub;

   function Allocate_Task_Body_Stub
     (Pool : Bump_Ptr_Pool) return Bare_Task_Body_Stub
   is
      Result : constant Access_To_Subtype_For_Task_Body_Stub :=
        Bare_Task_Body_Stub_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Task_Body_Stub;
      return Bare_Task_Body_Stub (Result);
   end Allocate_Task_Body_Stub;

   package Bare_Entry_Body_Memos is new Langkit_Support.Packrat
     (Bare_Entry_Body, Token_Index);

   subtype Subtype_For_Entry_Body is Root_Node_Record (Ada_Entry_Body);
   type Access_To_Subtype_For_Entry_Body is access all Subtype_For_Entry_Body;
   package Bare_Entry_Body_Alloc is new Alloc
     (Subtype_For_Entry_Body, Access_To_Subtype_For_Entry_Body);

   function Allocate_Entry_Body (Pool : Bump_Ptr_Pool) return Bare_Entry_Body;

   function Allocate_Entry_Body (Pool : Bump_Ptr_Pool) return Bare_Entry_Body
   is
      Result : constant Access_To_Subtype_For_Entry_Body :=
        Bare_Entry_Body_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Entry_Body;
      return Bare_Entry_Body (Result);
   end Allocate_Entry_Body;

   package Bare_Package_Body_Memos is new Langkit_Support.Packrat
     (Bare_Package_Body, Token_Index);

   subtype Subtype_For_Package_Body is Root_Node_Record (Ada_Package_Body);
   type Access_To_Subtype_For_Package_Body is
     access all Subtype_For_Package_Body;
   package Bare_Package_Body_Alloc is new Alloc
     (Subtype_For_Package_Body, Access_To_Subtype_For_Package_Body);

   function Allocate_Package_Body
     (Pool : Bump_Ptr_Pool) return Bare_Package_Body;

   function Allocate_Package_Body
     (Pool : Bump_Ptr_Pool) return Bare_Package_Body
   is
      Result : constant Access_To_Subtype_For_Package_Body :=
        Bare_Package_Body_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Package_Body;
      return Bare_Package_Body (Result);
   end Allocate_Package_Body;

   package Bare_Protected_Body_Memos is new Langkit_Support.Packrat
     (Bare_Protected_Body, Token_Index);

   subtype Subtype_For_Protected_Body is Root_Node_Record (Ada_Protected_Body);
   type Access_To_Subtype_For_Protected_Body is
     access all Subtype_For_Protected_Body;
   package Bare_Protected_Body_Alloc is new Alloc
     (Subtype_For_Protected_Body, Access_To_Subtype_For_Protected_Body);

   function Allocate_Protected_Body
     (Pool : Bump_Ptr_Pool) return Bare_Protected_Body;

   function Allocate_Protected_Body
     (Pool : Bump_Ptr_Pool) return Bare_Protected_Body
   is
      Result : constant Access_To_Subtype_For_Protected_Body :=
        Bare_Protected_Body_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Protected_Body;
      return Bare_Protected_Body (Result);
   end Allocate_Protected_Body;

   package Bare_Task_Body_Memos is new Langkit_Support.Packrat
     (Bare_Task_Body, Token_Index);

   subtype Subtype_For_Task_Body is Root_Node_Record (Ada_Task_Body);
   type Access_To_Subtype_For_Task_Body is access all Subtype_For_Task_Body;
   package Bare_Task_Body_Alloc is new Alloc
     (Subtype_For_Task_Body, Access_To_Subtype_For_Task_Body);

   function Allocate_Task_Body (Pool : Bump_Ptr_Pool) return Bare_Task_Body;

   function Allocate_Task_Body (Pool : Bump_Ptr_Pool) return Bare_Task_Body is
      Result : constant Access_To_Subtype_For_Task_Body :=
        Bare_Task_Body_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Task_Body;
      return Bare_Task_Body (Result);
   end Allocate_Task_Body;

   package Bare_Entry_Index_Spec_Memos is new Langkit_Support.Packrat
     (Bare_Entry_Index_Spec, Token_Index);

   subtype Subtype_For_Entry_Index_Spec is
     Root_Node_Record (Ada_Entry_Index_Spec);
   type Access_To_Subtype_For_Entry_Index_Spec is
     access all Subtype_For_Entry_Index_Spec;
   package Bare_Entry_Index_Spec_Alloc is new Alloc
     (Subtype_For_Entry_Index_Spec, Access_To_Subtype_For_Entry_Index_Spec);

   function Allocate_Entry_Index_Spec
     (Pool : Bump_Ptr_Pool) return Bare_Entry_Index_Spec;

   function Allocate_Entry_Index_Spec
     (Pool : Bump_Ptr_Pool) return Bare_Entry_Index_Spec
   is
      Result : constant Access_To_Subtype_For_Entry_Index_Spec :=
        Bare_Entry_Index_Spec_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Entry_Index_Spec;
      return Bare_Entry_Index_Spec (Result);
   end Allocate_Entry_Index_Spec;

   package Bare_Error_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Error_Decl, Token_Index);

   subtype Subtype_For_Error_Decl is Root_Node_Record (Ada_Error_Decl);
   type Access_To_Subtype_For_Error_Decl is access all Subtype_For_Error_Decl;
   package Bare_Error_Decl_Alloc is new Alloc
     (Subtype_For_Error_Decl, Access_To_Subtype_For_Error_Decl);

   function Allocate_Error_Decl (Pool : Bump_Ptr_Pool) return Bare_Error_Decl;

   function Allocate_Error_Decl (Pool : Bump_Ptr_Pool) return Bare_Error_Decl
   is
      Result : constant Access_To_Subtype_For_Error_Decl :=
        Bare_Error_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Error_Decl;
      return Bare_Error_Decl (Result);
   end Allocate_Error_Decl;

   package Bare_Exception_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Exception_Decl, Token_Index);

   subtype Subtype_For_Exception_Decl is Root_Node_Record (Ada_Exception_Decl);
   type Access_To_Subtype_For_Exception_Decl is
     access all Subtype_For_Exception_Decl;
   package Bare_Exception_Decl_Alloc is new Alloc
     (Subtype_For_Exception_Decl, Access_To_Subtype_For_Exception_Decl);

   function Allocate_Exception_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Exception_Decl;

   function Allocate_Exception_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Exception_Decl
   is
      Result : constant Access_To_Subtype_For_Exception_Decl :=
        Bare_Exception_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Exception_Decl;
      return Bare_Exception_Decl (Result);
   end Allocate_Exception_Decl;

   package Bare_Exception_Handler_Memos is new Langkit_Support.Packrat
     (Bare_Exception_Handler, Token_Index);

   subtype Subtype_For_Exception_Handler is
     Root_Node_Record (Ada_Exception_Handler);
   type Access_To_Subtype_For_Exception_Handler is
     access all Subtype_For_Exception_Handler;
   package Bare_Exception_Handler_Alloc is new Alloc
     (Subtype_For_Exception_Handler, Access_To_Subtype_For_Exception_Handler);

   function Allocate_Exception_Handler
     (Pool : Bump_Ptr_Pool) return Bare_Exception_Handler;

   function Allocate_Exception_Handler
     (Pool : Bump_Ptr_Pool) return Bare_Exception_Handler
   is
      Result : constant Access_To_Subtype_For_Exception_Handler :=
        Bare_Exception_Handler_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Exception_Handler;
      return Bare_Exception_Handler (Result);
   end Allocate_Exception_Handler;

   package Bare_For_Loop_Var_Decl_Memos is new Langkit_Support.Packrat
     (Bare_For_Loop_Var_Decl, Token_Index);

   subtype Subtype_For_For_Loop_Var_Decl is
     Root_Node_Record (Ada_For_Loop_Var_Decl);
   type Access_To_Subtype_For_For_Loop_Var_Decl is
     access all Subtype_For_For_Loop_Var_Decl;
   package Bare_For_Loop_Var_Decl_Alloc is new Alloc
     (Subtype_For_For_Loop_Var_Decl, Access_To_Subtype_For_For_Loop_Var_Decl);

   function Allocate_For_Loop_Var_Decl
     (Pool : Bump_Ptr_Pool) return Bare_For_Loop_Var_Decl;

   function Allocate_For_Loop_Var_Decl
     (Pool : Bump_Ptr_Pool) return Bare_For_Loop_Var_Decl
   is
      Result : constant Access_To_Subtype_For_For_Loop_Var_Decl :=
        Bare_For_Loop_Var_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_For_Loop_Var_Decl;
      return Bare_For_Loop_Var_Decl (Result);
   end Allocate_For_Loop_Var_Decl;

   package Bare_Generic_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Generic_Decl, Token_Index);

   package Bare_Generic_Package_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Generic_Package_Decl, Token_Index);

   subtype Subtype_For_Generic_Package_Decl is
     Root_Node_Record (Ada_Generic_Package_Decl);
   type Access_To_Subtype_For_Generic_Package_Decl is
     access all Subtype_For_Generic_Package_Decl;
   package Bare_Generic_Package_Decl_Alloc is new Alloc
     (Subtype_For_Generic_Package_Decl,
      Access_To_Subtype_For_Generic_Package_Decl);

   function Allocate_Generic_Package_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Generic_Package_Decl;

   function Allocate_Generic_Package_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Generic_Package_Decl
   is
      Result : constant Access_To_Subtype_For_Generic_Package_Decl :=
        Bare_Generic_Package_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Generic_Package_Decl;
      return Bare_Generic_Package_Decl (Result);
   end Allocate_Generic_Package_Decl;

   package Bare_Generic_Subp_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Generic_Subp_Decl, Token_Index);

   subtype Subtype_For_Generic_Subp_Decl is
     Root_Node_Record (Ada_Generic_Subp_Decl);
   type Access_To_Subtype_For_Generic_Subp_Decl is
     access all Subtype_For_Generic_Subp_Decl;
   package Bare_Generic_Subp_Decl_Alloc is new Alloc
     (Subtype_For_Generic_Subp_Decl, Access_To_Subtype_For_Generic_Subp_Decl);

   function Allocate_Generic_Subp_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Generic_Subp_Decl;

   function Allocate_Generic_Subp_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Generic_Subp_Decl
   is
      Result : constant Access_To_Subtype_For_Generic_Subp_Decl :=
        Bare_Generic_Subp_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Generic_Subp_Decl;
      return Bare_Generic_Subp_Decl (Result);
   end Allocate_Generic_Subp_Decl;

   package Bare_Generic_Instantiation_Memos is new Langkit_Support.Packrat
     (Bare_Generic_Instantiation, Token_Index);

   package Bare_Generic_Package_Instantiation_Memos is new Langkit_Support
     .Packrat
     (Bare_Generic_Package_Instantiation, Token_Index);

   subtype Subtype_For_Generic_Package_Instantiation is
     Root_Node_Record (Ada_Generic_Package_Instantiation);
   type Access_To_Subtype_For_Generic_Package_Instantiation is
     access all Subtype_For_Generic_Package_Instantiation;
   package Bare_Generic_Package_Instantiation_Alloc is new Alloc
     (Subtype_For_Generic_Package_Instantiation,
      Access_To_Subtype_For_Generic_Package_Instantiation);

   function Allocate_Generic_Package_Instantiation
     (Pool : Bump_Ptr_Pool) return Bare_Generic_Package_Instantiation;

   function Allocate_Generic_Package_Instantiation
     (Pool : Bump_Ptr_Pool) return Bare_Generic_Package_Instantiation
   is
      Result : constant Access_To_Subtype_For_Generic_Package_Instantiation :=
        Bare_Generic_Package_Instantiation_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Generic_Package_Instantiation;
      return Bare_Generic_Package_Instantiation (Result);
   end Allocate_Generic_Package_Instantiation;

   package Bare_Generic_Subp_Instantiation_Memos is new Langkit_Support.Packrat
     (Bare_Generic_Subp_Instantiation, Token_Index);

   subtype Subtype_For_Generic_Subp_Instantiation is
     Root_Node_Record (Ada_Generic_Subp_Instantiation);
   type Access_To_Subtype_For_Generic_Subp_Instantiation is
     access all Subtype_For_Generic_Subp_Instantiation;
   package Bare_Generic_Subp_Instantiation_Alloc is new Alloc
     (Subtype_For_Generic_Subp_Instantiation,
      Access_To_Subtype_For_Generic_Subp_Instantiation);

   function Allocate_Generic_Subp_Instantiation
     (Pool : Bump_Ptr_Pool) return Bare_Generic_Subp_Instantiation;

   function Allocate_Generic_Subp_Instantiation
     (Pool : Bump_Ptr_Pool) return Bare_Generic_Subp_Instantiation
   is
      Result : constant Access_To_Subtype_For_Generic_Subp_Instantiation :=
        Bare_Generic_Subp_Instantiation_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Generic_Subp_Instantiation;
      return Bare_Generic_Subp_Instantiation (Result);
   end Allocate_Generic_Subp_Instantiation;

   package Bare_Generic_Renaming_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Generic_Renaming_Decl, Token_Index);

   package Bare_Generic_Package_Renaming_Decl_Memos is new Langkit_Support
     .Packrat
     (Bare_Generic_Package_Renaming_Decl, Token_Index);

   subtype Subtype_For_Generic_Package_Renaming_Decl is
     Root_Node_Record (Ada_Generic_Package_Renaming_Decl);
   type Access_To_Subtype_For_Generic_Package_Renaming_Decl is
     access all Subtype_For_Generic_Package_Renaming_Decl;
   package Bare_Generic_Package_Renaming_Decl_Alloc is new Alloc
     (Subtype_For_Generic_Package_Renaming_Decl,
      Access_To_Subtype_For_Generic_Package_Renaming_Decl);

   function Allocate_Generic_Package_Renaming_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Generic_Package_Renaming_Decl;

   function Allocate_Generic_Package_Renaming_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Generic_Package_Renaming_Decl
   is
      Result : constant Access_To_Subtype_For_Generic_Package_Renaming_Decl :=
        Bare_Generic_Package_Renaming_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Generic_Package_Renaming_Decl;
      return Bare_Generic_Package_Renaming_Decl (Result);
   end Allocate_Generic_Package_Renaming_Decl;

   package Bare_Generic_Subp_Renaming_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Generic_Subp_Renaming_Decl, Token_Index);

   subtype Subtype_For_Generic_Subp_Renaming_Decl is
     Root_Node_Record (Ada_Generic_Subp_Renaming_Decl);
   type Access_To_Subtype_For_Generic_Subp_Renaming_Decl is
     access all Subtype_For_Generic_Subp_Renaming_Decl;
   package Bare_Generic_Subp_Renaming_Decl_Alloc is new Alloc
     (Subtype_For_Generic_Subp_Renaming_Decl,
      Access_To_Subtype_For_Generic_Subp_Renaming_Decl);

   function Allocate_Generic_Subp_Renaming_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Generic_Subp_Renaming_Decl;

   function Allocate_Generic_Subp_Renaming_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Generic_Subp_Renaming_Decl
   is
      Result : constant Access_To_Subtype_For_Generic_Subp_Renaming_Decl :=
        Bare_Generic_Subp_Renaming_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Generic_Subp_Renaming_Decl;
      return Bare_Generic_Subp_Renaming_Decl (Result);
   end Allocate_Generic_Subp_Renaming_Decl;

   package Bare_Label_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Label_Decl, Token_Index);

   subtype Subtype_For_Label_Decl is Root_Node_Record (Ada_Label_Decl);
   type Access_To_Subtype_For_Label_Decl is access all Subtype_For_Label_Decl;
   package Bare_Label_Decl_Alloc is new Alloc
     (Subtype_For_Label_Decl, Access_To_Subtype_For_Label_Decl);

   function Allocate_Label_Decl (Pool : Bump_Ptr_Pool) return Bare_Label_Decl;

   function Allocate_Label_Decl (Pool : Bump_Ptr_Pool) return Bare_Label_Decl
   is
      Result : constant Access_To_Subtype_For_Label_Decl :=
        Bare_Label_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Label_Decl;
      return Bare_Label_Decl (Result);
   end Allocate_Label_Decl;

   package Bare_Named_Stmt_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Named_Stmt_Decl, Token_Index);

   subtype Subtype_For_Named_Stmt_Decl is
     Root_Node_Record (Ada_Named_Stmt_Decl);
   type Access_To_Subtype_For_Named_Stmt_Decl is
     access all Subtype_For_Named_Stmt_Decl;
   package Bare_Named_Stmt_Decl_Alloc is new Alloc
     (Subtype_For_Named_Stmt_Decl, Access_To_Subtype_For_Named_Stmt_Decl);

   function Allocate_Named_Stmt_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Named_Stmt_Decl;

   function Allocate_Named_Stmt_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Named_Stmt_Decl
   is
      Result : constant Access_To_Subtype_For_Named_Stmt_Decl :=
        Bare_Named_Stmt_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Named_Stmt_Decl;
      return Bare_Named_Stmt_Decl (Result);
   end Allocate_Named_Stmt_Decl;

   package Bare_Number_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Number_Decl, Token_Index);

   subtype Subtype_For_Number_Decl is Root_Node_Record (Ada_Number_Decl);
   type Access_To_Subtype_For_Number_Decl is
     access all Subtype_For_Number_Decl;
   package Bare_Number_Decl_Alloc is new Alloc
     (Subtype_For_Number_Decl, Access_To_Subtype_For_Number_Decl);

   function Allocate_Number_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Number_Decl;

   function Allocate_Number_Decl (Pool : Bump_Ptr_Pool) return Bare_Number_Decl
   is
      Result : constant Access_To_Subtype_For_Number_Decl :=
        Bare_Number_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Number_Decl;
      return Bare_Number_Decl (Result);
   end Allocate_Number_Decl;

   package Bare_Object_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Object_Decl, Token_Index);

   subtype Subtype_For_Object_Decl is Root_Node_Record (Ada_Object_Decl);
   type Access_To_Subtype_For_Object_Decl is
     access all Subtype_For_Object_Decl;
   package Bare_Object_Decl_Alloc is new Alloc
     (Subtype_For_Object_Decl, Access_To_Subtype_For_Object_Decl);

   function Allocate_Object_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Object_Decl;

   function Allocate_Object_Decl (Pool : Bump_Ptr_Pool) return Bare_Object_Decl
   is
      Result : constant Access_To_Subtype_For_Object_Decl :=
        Bare_Object_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Object_Decl;
      return Bare_Object_Decl (Result);
   end Allocate_Object_Decl;

   package Bare_Anonymous_Object_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Anonymous_Object_Decl, Token_Index);

   subtype Subtype_For_Anonymous_Object_Decl is
     Root_Node_Record (Ada_Anonymous_Object_Decl);
   type Access_To_Subtype_For_Anonymous_Object_Decl is
     access all Subtype_For_Anonymous_Object_Decl;
   package Bare_Anonymous_Object_Decl_Alloc is new Alloc
     (Subtype_For_Anonymous_Object_Decl,
      Access_To_Subtype_For_Anonymous_Object_Decl);

   function Allocate_Anonymous_Object_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Anonymous_Object_Decl;

   function Allocate_Anonymous_Object_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Anonymous_Object_Decl
   is
      Result : constant Access_To_Subtype_For_Anonymous_Object_Decl :=
        Bare_Anonymous_Object_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Anonymous_Object_Decl;
      return Bare_Anonymous_Object_Decl (Result);
   end Allocate_Anonymous_Object_Decl;

   package Bare_Extended_Return_Stmt_Object_Decl_Memos is new Langkit_Support
     .Packrat
     (Bare_Extended_Return_Stmt_Object_Decl, Token_Index);

   subtype Subtype_For_Extended_Return_Stmt_Object_Decl is
     Root_Node_Record (Ada_Extended_Return_Stmt_Object_Decl);
   type Access_To_Subtype_For_Extended_Return_Stmt_Object_Decl is
     access all Subtype_For_Extended_Return_Stmt_Object_Decl;
   package Bare_Extended_Return_Stmt_Object_Decl_Alloc is new Alloc
     (Subtype_For_Extended_Return_Stmt_Object_Decl,
      Access_To_Subtype_For_Extended_Return_Stmt_Object_Decl);

   function Allocate_Extended_Return_Stmt_Object_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Extended_Return_Stmt_Object_Decl;

   function Allocate_Extended_Return_Stmt_Object_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Extended_Return_Stmt_Object_Decl
   is
      Result : constant Access_To_Subtype_For_Extended_Return_Stmt_Object_Decl :=
        Bare_Extended_Return_Stmt_Object_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Extended_Return_Stmt_Object_Decl;
      return Bare_Extended_Return_Stmt_Object_Decl (Result);
   end Allocate_Extended_Return_Stmt_Object_Decl;

   package Bare_Package_Renaming_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Package_Renaming_Decl, Token_Index);

   subtype Subtype_For_Package_Renaming_Decl is
     Root_Node_Record (Ada_Package_Renaming_Decl);
   type Access_To_Subtype_For_Package_Renaming_Decl is
     access all Subtype_For_Package_Renaming_Decl;
   package Bare_Package_Renaming_Decl_Alloc is new Alloc
     (Subtype_For_Package_Renaming_Decl,
      Access_To_Subtype_For_Package_Renaming_Decl);

   function Allocate_Package_Renaming_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Package_Renaming_Decl;

   function Allocate_Package_Renaming_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Package_Renaming_Decl
   is
      Result : constant Access_To_Subtype_For_Package_Renaming_Decl :=
        Bare_Package_Renaming_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Package_Renaming_Decl;
      return Bare_Package_Renaming_Decl (Result);
   end Allocate_Package_Renaming_Decl;

   package Bare_Single_Protected_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Single_Protected_Decl, Token_Index);

   subtype Subtype_For_Single_Protected_Decl is
     Root_Node_Record (Ada_Single_Protected_Decl);
   type Access_To_Subtype_For_Single_Protected_Decl is
     access all Subtype_For_Single_Protected_Decl;
   package Bare_Single_Protected_Decl_Alloc is new Alloc
     (Subtype_For_Single_Protected_Decl,
      Access_To_Subtype_For_Single_Protected_Decl);

   function Allocate_Single_Protected_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Single_Protected_Decl;

   function Allocate_Single_Protected_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Single_Protected_Decl
   is
      Result : constant Access_To_Subtype_For_Single_Protected_Decl :=
        Bare_Single_Protected_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Single_Protected_Decl;
      return Bare_Single_Protected_Decl (Result);
   end Allocate_Single_Protected_Decl;

   package Bare_Single_Task_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Single_Task_Decl, Token_Index);

   subtype Subtype_For_Single_Task_Decl is
     Root_Node_Record (Ada_Single_Task_Decl);
   type Access_To_Subtype_For_Single_Task_Decl is
     access all Subtype_For_Single_Task_Decl;
   package Bare_Single_Task_Decl_Alloc is new Alloc
     (Subtype_For_Single_Task_Decl, Access_To_Subtype_For_Single_Task_Decl);

   function Allocate_Single_Task_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Single_Task_Decl;

   function Allocate_Single_Task_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Single_Task_Decl
   is
      Result : constant Access_To_Subtype_For_Single_Task_Decl :=
        Bare_Single_Task_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Single_Task_Decl;
      return Bare_Single_Task_Decl (Result);
   end Allocate_Single_Task_Decl;

   package Bare_Case_Stmt_Alternative_Memos is new Langkit_Support.Packrat
     (Bare_Case_Stmt_Alternative, Token_Index);

   subtype Subtype_For_Case_Stmt_Alternative is
     Root_Node_Record (Ada_Case_Stmt_Alternative);
   type Access_To_Subtype_For_Case_Stmt_Alternative is
     access all Subtype_For_Case_Stmt_Alternative;
   package Bare_Case_Stmt_Alternative_Alloc is new Alloc
     (Subtype_For_Case_Stmt_Alternative,
      Access_To_Subtype_For_Case_Stmt_Alternative);

   function Allocate_Case_Stmt_Alternative
     (Pool : Bump_Ptr_Pool) return Bare_Case_Stmt_Alternative;

   function Allocate_Case_Stmt_Alternative
     (Pool : Bump_Ptr_Pool) return Bare_Case_Stmt_Alternative
   is
      Result : constant Access_To_Subtype_For_Case_Stmt_Alternative :=
        Bare_Case_Stmt_Alternative_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Case_Stmt_Alternative;
      return Bare_Case_Stmt_Alternative (Result);
   end Allocate_Case_Stmt_Alternative;

   package Bare_Compilation_Unit_Memos is new Langkit_Support.Packrat
     (Bare_Compilation_Unit, Token_Index);

   subtype Subtype_For_Compilation_Unit is
     Root_Node_Record (Ada_Compilation_Unit);
   type Access_To_Subtype_For_Compilation_Unit is
     access all Subtype_For_Compilation_Unit;
   package Bare_Compilation_Unit_Alloc is new Alloc
     (Subtype_For_Compilation_Unit, Access_To_Subtype_For_Compilation_Unit);

   function Allocate_Compilation_Unit
     (Pool : Bump_Ptr_Pool) return Bare_Compilation_Unit;

   function Allocate_Compilation_Unit
     (Pool : Bump_Ptr_Pool) return Bare_Compilation_Unit
   is
      Result : constant Access_To_Subtype_For_Compilation_Unit :=
        Bare_Compilation_Unit_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Compilation_Unit;
      return Bare_Compilation_Unit (Result);
   end Allocate_Compilation_Unit;

   package Bare_Component_Clause_Memos is new Langkit_Support.Packrat
     (Bare_Component_Clause, Token_Index);

   subtype Subtype_For_Component_Clause is
     Root_Node_Record (Ada_Component_Clause);
   type Access_To_Subtype_For_Component_Clause is
     access all Subtype_For_Component_Clause;
   package Bare_Component_Clause_Alloc is new Alloc
     (Subtype_For_Component_Clause, Access_To_Subtype_For_Component_Clause);

   function Allocate_Component_Clause
     (Pool : Bump_Ptr_Pool) return Bare_Component_Clause;

   function Allocate_Component_Clause
     (Pool : Bump_Ptr_Pool) return Bare_Component_Clause
   is
      Result : constant Access_To_Subtype_For_Component_Clause :=
        Bare_Component_Clause_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Component_Clause;
      return Bare_Component_Clause (Result);
   end Allocate_Component_Clause;

   package Bare_Component_Def_Memos is new Langkit_Support.Packrat
     (Bare_Component_Def, Token_Index);

   subtype Subtype_For_Component_Def is Root_Node_Record (Ada_Component_Def);
   type Access_To_Subtype_For_Component_Def is
     access all Subtype_For_Component_Def;
   package Bare_Component_Def_Alloc is new Alloc
     (Subtype_For_Component_Def, Access_To_Subtype_For_Component_Def);

   function Allocate_Component_Def
     (Pool : Bump_Ptr_Pool) return Bare_Component_Def;

   function Allocate_Component_Def
     (Pool : Bump_Ptr_Pool) return Bare_Component_Def
   is
      Result : constant Access_To_Subtype_For_Component_Def :=
        Bare_Component_Def_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Component_Def;
      return Bare_Component_Def (Result);
   end Allocate_Component_Def;

   package Bare_Constant_Node_Memos is new Langkit_Support.Packrat
     (Bare_Constant_Node, Token_Index);

   package Bare_Constant_Absent_Memos is new Langkit_Support.Packrat
     (Bare_Constant_Absent, Token_Index);

   subtype Subtype_For_Constant_Absent is
     Root_Node_Record (Ada_Constant_Absent);
   type Access_To_Subtype_For_Constant_Absent is
     access all Subtype_For_Constant_Absent;
   package Bare_Constant_Absent_Alloc is new Alloc
     (Subtype_For_Constant_Absent, Access_To_Subtype_For_Constant_Absent);

   function Allocate_Constant_Absent
     (Pool : Bump_Ptr_Pool) return Bare_Constant_Absent;

   function Allocate_Constant_Absent
     (Pool : Bump_Ptr_Pool) return Bare_Constant_Absent
   is
      Result : constant Access_To_Subtype_For_Constant_Absent :=
        Bare_Constant_Absent_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Constant_Absent;
      return Bare_Constant_Absent (Result);
   end Allocate_Constant_Absent;

   package Bare_Constant_Present_Memos is new Langkit_Support.Packrat
     (Bare_Constant_Present, Token_Index);

   subtype Subtype_For_Constant_Present is
     Root_Node_Record (Ada_Constant_Present);
   type Access_To_Subtype_For_Constant_Present is
     access all Subtype_For_Constant_Present;
   package Bare_Constant_Present_Alloc is new Alloc
     (Subtype_For_Constant_Present, Access_To_Subtype_For_Constant_Present);

   function Allocate_Constant_Present
     (Pool : Bump_Ptr_Pool) return Bare_Constant_Present;

   function Allocate_Constant_Present
     (Pool : Bump_Ptr_Pool) return Bare_Constant_Present
   is
      Result : constant Access_To_Subtype_For_Constant_Present :=
        Bare_Constant_Present_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Constant_Present;
      return Bare_Constant_Present (Result);
   end Allocate_Constant_Present;

   package Bare_Constraint_Memos is new Langkit_Support.Packrat
     (Bare_Constraint, Token_Index);

   package Bare_Delta_Constraint_Memos is new Langkit_Support.Packrat
     (Bare_Delta_Constraint, Token_Index);

   subtype Subtype_For_Delta_Constraint is
     Root_Node_Record (Ada_Delta_Constraint);
   type Access_To_Subtype_For_Delta_Constraint is
     access all Subtype_For_Delta_Constraint;
   package Bare_Delta_Constraint_Alloc is new Alloc
     (Subtype_For_Delta_Constraint, Access_To_Subtype_For_Delta_Constraint);

   function Allocate_Delta_Constraint
     (Pool : Bump_Ptr_Pool) return Bare_Delta_Constraint;

   function Allocate_Delta_Constraint
     (Pool : Bump_Ptr_Pool) return Bare_Delta_Constraint
   is
      Result : constant Access_To_Subtype_For_Delta_Constraint :=
        Bare_Delta_Constraint_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Delta_Constraint;
      return Bare_Delta_Constraint (Result);
   end Allocate_Delta_Constraint;

   package Bare_Digits_Constraint_Memos is new Langkit_Support.Packrat
     (Bare_Digits_Constraint, Token_Index);

   subtype Subtype_For_Digits_Constraint is
     Root_Node_Record (Ada_Digits_Constraint);
   type Access_To_Subtype_For_Digits_Constraint is
     access all Subtype_For_Digits_Constraint;
   package Bare_Digits_Constraint_Alloc is new Alloc
     (Subtype_For_Digits_Constraint, Access_To_Subtype_For_Digits_Constraint);

   function Allocate_Digits_Constraint
     (Pool : Bump_Ptr_Pool) return Bare_Digits_Constraint;

   function Allocate_Digits_Constraint
     (Pool : Bump_Ptr_Pool) return Bare_Digits_Constraint
   is
      Result : constant Access_To_Subtype_For_Digits_Constraint :=
        Bare_Digits_Constraint_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Digits_Constraint;
      return Bare_Digits_Constraint (Result);
   end Allocate_Digits_Constraint;

   package Bare_Discriminant_Constraint_Memos is new Langkit_Support.Packrat
     (Bare_Discriminant_Constraint, Token_Index);

   subtype Subtype_For_Discriminant_Constraint is
     Root_Node_Record (Ada_Discriminant_Constraint);
   type Access_To_Subtype_For_Discriminant_Constraint is
     access all Subtype_For_Discriminant_Constraint;
   package Bare_Discriminant_Constraint_Alloc is new Alloc
     (Subtype_For_Discriminant_Constraint,
      Access_To_Subtype_For_Discriminant_Constraint);

   function Allocate_Discriminant_Constraint
     (Pool : Bump_Ptr_Pool) return Bare_Discriminant_Constraint;

   function Allocate_Discriminant_Constraint
     (Pool : Bump_Ptr_Pool) return Bare_Discriminant_Constraint
   is
      Result : constant Access_To_Subtype_For_Discriminant_Constraint :=
        Bare_Discriminant_Constraint_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Discriminant_Constraint;
      return Bare_Discriminant_Constraint (Result);
   end Allocate_Discriminant_Constraint;

   package Bare_Index_Constraint_Memos is new Langkit_Support.Packrat
     (Bare_Index_Constraint, Token_Index);

   subtype Subtype_For_Index_Constraint is
     Root_Node_Record (Ada_Index_Constraint);
   type Access_To_Subtype_For_Index_Constraint is
     access all Subtype_For_Index_Constraint;
   package Bare_Index_Constraint_Alloc is new Alloc
     (Subtype_For_Index_Constraint, Access_To_Subtype_For_Index_Constraint);

   function Allocate_Index_Constraint
     (Pool : Bump_Ptr_Pool) return Bare_Index_Constraint;

   function Allocate_Index_Constraint
     (Pool : Bump_Ptr_Pool) return Bare_Index_Constraint
   is
      Result : constant Access_To_Subtype_For_Index_Constraint :=
        Bare_Index_Constraint_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Index_Constraint;
      return Bare_Index_Constraint (Result);
   end Allocate_Index_Constraint;

   package Bare_Range_Constraint_Memos is new Langkit_Support.Packrat
     (Bare_Range_Constraint, Token_Index);

   subtype Subtype_For_Range_Constraint is
     Root_Node_Record (Ada_Range_Constraint);
   type Access_To_Subtype_For_Range_Constraint is
     access all Subtype_For_Range_Constraint;
   package Bare_Range_Constraint_Alloc is new Alloc
     (Subtype_For_Range_Constraint, Access_To_Subtype_For_Range_Constraint);

   function Allocate_Range_Constraint
     (Pool : Bump_Ptr_Pool) return Bare_Range_Constraint;

   function Allocate_Range_Constraint
     (Pool : Bump_Ptr_Pool) return Bare_Range_Constraint
   is
      Result : constant Access_To_Subtype_For_Range_Constraint :=
        Bare_Range_Constraint_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Range_Constraint;
      return Bare_Range_Constraint (Result);
   end Allocate_Range_Constraint;

   package Bare_Declarative_Part_Memos is new Langkit_Support.Packrat
     (Bare_Declarative_Part, Token_Index);

   subtype Subtype_For_Declarative_Part is
     Root_Node_Record (Ada_Declarative_Part);
   type Access_To_Subtype_For_Declarative_Part is
     access all Subtype_For_Declarative_Part;
   package Bare_Declarative_Part_Alloc is new Alloc
     (Subtype_For_Declarative_Part, Access_To_Subtype_For_Declarative_Part);

   function Allocate_Declarative_Part
     (Pool : Bump_Ptr_Pool) return Bare_Declarative_Part;

   function Allocate_Declarative_Part
     (Pool : Bump_Ptr_Pool) return Bare_Declarative_Part
   is
      Result : constant Access_To_Subtype_For_Declarative_Part :=
        Bare_Declarative_Part_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Declarative_Part;
      return Bare_Declarative_Part (Result);
   end Allocate_Declarative_Part;

   package Bare_Private_Part_Memos is new Langkit_Support.Packrat
     (Bare_Private_Part, Token_Index);

   subtype Subtype_For_Private_Part is Root_Node_Record (Ada_Private_Part);
   type Access_To_Subtype_For_Private_Part is
     access all Subtype_For_Private_Part;
   package Bare_Private_Part_Alloc is new Alloc
     (Subtype_For_Private_Part, Access_To_Subtype_For_Private_Part);

   function Allocate_Private_Part
     (Pool : Bump_Ptr_Pool) return Bare_Private_Part;

   function Allocate_Private_Part
     (Pool : Bump_Ptr_Pool) return Bare_Private_Part
   is
      Result : constant Access_To_Subtype_For_Private_Part :=
        Bare_Private_Part_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Private_Part;
      return Bare_Private_Part (Result);
   end Allocate_Private_Part;

   package Bare_Public_Part_Memos is new Langkit_Support.Packrat
     (Bare_Public_Part, Token_Index);

   subtype Subtype_For_Public_Part is Root_Node_Record (Ada_Public_Part);
   type Access_To_Subtype_For_Public_Part is
     access all Subtype_For_Public_Part;
   package Bare_Public_Part_Alloc is new Alloc
     (Subtype_For_Public_Part, Access_To_Subtype_For_Public_Part);

   function Allocate_Public_Part
     (Pool : Bump_Ptr_Pool) return Bare_Public_Part;

   function Allocate_Public_Part (Pool : Bump_Ptr_Pool) return Bare_Public_Part
   is
      Result : constant Access_To_Subtype_For_Public_Part :=
        Bare_Public_Part_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Public_Part;
      return Bare_Public_Part (Result);
   end Allocate_Public_Part;

   package Bare_Elsif_Expr_Part_Memos is new Langkit_Support.Packrat
     (Bare_Elsif_Expr_Part, Token_Index);

   subtype Subtype_For_Elsif_Expr_Part is
     Root_Node_Record (Ada_Elsif_Expr_Part);
   type Access_To_Subtype_For_Elsif_Expr_Part is
     access all Subtype_For_Elsif_Expr_Part;
   package Bare_Elsif_Expr_Part_Alloc is new Alloc
     (Subtype_For_Elsif_Expr_Part, Access_To_Subtype_For_Elsif_Expr_Part);

   function Allocate_Elsif_Expr_Part
     (Pool : Bump_Ptr_Pool) return Bare_Elsif_Expr_Part;

   function Allocate_Elsif_Expr_Part
     (Pool : Bump_Ptr_Pool) return Bare_Elsif_Expr_Part
   is
      Result : constant Access_To_Subtype_For_Elsif_Expr_Part :=
        Bare_Elsif_Expr_Part_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Elsif_Expr_Part;
      return Bare_Elsif_Expr_Part (Result);
   end Allocate_Elsif_Expr_Part;

   package Bare_Elsif_Stmt_Part_Memos is new Langkit_Support.Packrat
     (Bare_Elsif_Stmt_Part, Token_Index);

   subtype Subtype_For_Elsif_Stmt_Part is
     Root_Node_Record (Ada_Elsif_Stmt_Part);
   type Access_To_Subtype_For_Elsif_Stmt_Part is
     access all Subtype_For_Elsif_Stmt_Part;
   package Bare_Elsif_Stmt_Part_Alloc is new Alloc
     (Subtype_For_Elsif_Stmt_Part, Access_To_Subtype_For_Elsif_Stmt_Part);

   function Allocate_Elsif_Stmt_Part
     (Pool : Bump_Ptr_Pool) return Bare_Elsif_Stmt_Part;

   function Allocate_Elsif_Stmt_Part
     (Pool : Bump_Ptr_Pool) return Bare_Elsif_Stmt_Part
   is
      Result : constant Access_To_Subtype_For_Elsif_Stmt_Part :=
        Bare_Elsif_Stmt_Part_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Elsif_Stmt_Part;
      return Bare_Elsif_Stmt_Part (Result);
   end Allocate_Elsif_Stmt_Part;

   package Bare_Expr_Memos is new Langkit_Support.Packrat
     (Bare_Expr, Token_Index);

   package Bare_Allocator_Memos is new Langkit_Support.Packrat
     (Bare_Allocator, Token_Index);

   subtype Subtype_For_Allocator is Root_Node_Record (Ada_Allocator);
   type Access_To_Subtype_For_Allocator is access all Subtype_For_Allocator;
   package Bare_Allocator_Alloc is new Alloc
     (Subtype_For_Allocator, Access_To_Subtype_For_Allocator);

   function Allocate_Allocator (Pool : Bump_Ptr_Pool) return Bare_Allocator;

   function Allocate_Allocator (Pool : Bump_Ptr_Pool) return Bare_Allocator is
      Result : constant Access_To_Subtype_For_Allocator :=
        Bare_Allocator_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Allocator;
      return Bare_Allocator (Result);
   end Allocate_Allocator;

   package Bare_Base_Aggregate_Memos is new Langkit_Support.Packrat
     (Bare_Base_Aggregate, Token_Index);

   package Bare_Aggregate_Memos is new Langkit_Support.Packrat
     (Bare_Aggregate, Token_Index);

   subtype Subtype_For_Aggregate is Root_Node_Record (Ada_Aggregate);
   type Access_To_Subtype_For_Aggregate is access all Subtype_For_Aggregate;
   package Bare_Aggregate_Alloc is new Alloc
     (Subtype_For_Aggregate, Access_To_Subtype_For_Aggregate);

   function Allocate_Aggregate (Pool : Bump_Ptr_Pool) return Bare_Aggregate;

   function Allocate_Aggregate (Pool : Bump_Ptr_Pool) return Bare_Aggregate is
      Result : constant Access_To_Subtype_For_Aggregate :=
        Bare_Aggregate_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Aggregate;
      return Bare_Aggregate (Result);
   end Allocate_Aggregate;

   package Bare_Null_Record_Aggregate_Memos is new Langkit_Support.Packrat
     (Bare_Null_Record_Aggregate, Token_Index);

   subtype Subtype_For_Null_Record_Aggregate is
     Root_Node_Record (Ada_Null_Record_Aggregate);
   type Access_To_Subtype_For_Null_Record_Aggregate is
     access all Subtype_For_Null_Record_Aggregate;
   package Bare_Null_Record_Aggregate_Alloc is new Alloc
     (Subtype_For_Null_Record_Aggregate,
      Access_To_Subtype_For_Null_Record_Aggregate);

   function Allocate_Null_Record_Aggregate
     (Pool : Bump_Ptr_Pool) return Bare_Null_Record_Aggregate;

   function Allocate_Null_Record_Aggregate
     (Pool : Bump_Ptr_Pool) return Bare_Null_Record_Aggregate
   is
      Result : constant Access_To_Subtype_For_Null_Record_Aggregate :=
        Bare_Null_Record_Aggregate_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Null_Record_Aggregate;
      return Bare_Null_Record_Aggregate (Result);
   end Allocate_Null_Record_Aggregate;

   package Bare_Bin_Op_Memos is new Langkit_Support.Packrat
     (Bare_Bin_Op, Token_Index);

   subtype Subtype_For_Bin_Op is Root_Node_Record (Ada_Bin_Op);
   type Access_To_Subtype_For_Bin_Op is access all Subtype_For_Bin_Op;
   package Bare_Bin_Op_Alloc is new Alloc
     (Subtype_For_Bin_Op, Access_To_Subtype_For_Bin_Op);

   function Allocate_Bin_Op (Pool : Bump_Ptr_Pool) return Bare_Bin_Op;

   function Allocate_Bin_Op (Pool : Bump_Ptr_Pool) return Bare_Bin_Op is
      Result : constant Access_To_Subtype_For_Bin_Op :=
        Bare_Bin_Op_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Bin_Op;
      return Bare_Bin_Op (Result);
   end Allocate_Bin_Op;

   package Bare_Relation_Op_Memos is new Langkit_Support.Packrat
     (Bare_Relation_Op, Token_Index);

   subtype Subtype_For_Relation_Op is Root_Node_Record (Ada_Relation_Op);
   type Access_To_Subtype_For_Relation_Op is
     access all Subtype_For_Relation_Op;
   package Bare_Relation_Op_Alloc is new Alloc
     (Subtype_For_Relation_Op, Access_To_Subtype_For_Relation_Op);

   function Allocate_Relation_Op
     (Pool : Bump_Ptr_Pool) return Bare_Relation_Op;

   function Allocate_Relation_Op (Pool : Bump_Ptr_Pool) return Bare_Relation_Op
   is
      Result : constant Access_To_Subtype_For_Relation_Op :=
        Bare_Relation_Op_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Relation_Op;
      return Bare_Relation_Op (Result);
   end Allocate_Relation_Op;

   package Bare_Box_Expr_Memos is new Langkit_Support.Packrat
     (Bare_Box_Expr, Token_Index);

   subtype Subtype_For_Box_Expr is Root_Node_Record (Ada_Box_Expr);
   type Access_To_Subtype_For_Box_Expr is access all Subtype_For_Box_Expr;
   package Bare_Box_Expr_Alloc is new Alloc
     (Subtype_For_Box_Expr, Access_To_Subtype_For_Box_Expr);

   function Allocate_Box_Expr (Pool : Bump_Ptr_Pool) return Bare_Box_Expr;

   function Allocate_Box_Expr (Pool : Bump_Ptr_Pool) return Bare_Box_Expr is
      Result : constant Access_To_Subtype_For_Box_Expr :=
        Bare_Box_Expr_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Box_Expr;
      return Bare_Box_Expr (Result);
   end Allocate_Box_Expr;

   package Bare_Case_Expr_Memos is new Langkit_Support.Packrat
     (Bare_Case_Expr, Token_Index);

   subtype Subtype_For_Case_Expr is Root_Node_Record (Ada_Case_Expr);
   type Access_To_Subtype_For_Case_Expr is access all Subtype_For_Case_Expr;
   package Bare_Case_Expr_Alloc is new Alloc
     (Subtype_For_Case_Expr, Access_To_Subtype_For_Case_Expr);

   function Allocate_Case_Expr (Pool : Bump_Ptr_Pool) return Bare_Case_Expr;

   function Allocate_Case_Expr (Pool : Bump_Ptr_Pool) return Bare_Case_Expr is
      Result : constant Access_To_Subtype_For_Case_Expr :=
        Bare_Case_Expr_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Case_Expr;
      return Bare_Case_Expr (Result);
   end Allocate_Case_Expr;

   package Bare_Case_Expr_Alternative_Memos is new Langkit_Support.Packrat
     (Bare_Case_Expr_Alternative, Token_Index);

   subtype Subtype_For_Case_Expr_Alternative is
     Root_Node_Record (Ada_Case_Expr_Alternative);
   type Access_To_Subtype_For_Case_Expr_Alternative is
     access all Subtype_For_Case_Expr_Alternative;
   package Bare_Case_Expr_Alternative_Alloc is new Alloc
     (Subtype_For_Case_Expr_Alternative,
      Access_To_Subtype_For_Case_Expr_Alternative);

   function Allocate_Case_Expr_Alternative
     (Pool : Bump_Ptr_Pool) return Bare_Case_Expr_Alternative;

   function Allocate_Case_Expr_Alternative
     (Pool : Bump_Ptr_Pool) return Bare_Case_Expr_Alternative
   is
      Result : constant Access_To_Subtype_For_Case_Expr_Alternative :=
        Bare_Case_Expr_Alternative_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Case_Expr_Alternative;
      return Bare_Case_Expr_Alternative (Result);
   end Allocate_Case_Expr_Alternative;

   package Bare_Contract_Cases_Memos is new Langkit_Support.Packrat
     (Bare_Contract_Cases, Token_Index);

   subtype Subtype_For_Contract_Cases is Root_Node_Record (Ada_Contract_Cases);
   type Access_To_Subtype_For_Contract_Cases is
     access all Subtype_For_Contract_Cases;
   package Bare_Contract_Cases_Alloc is new Alloc
     (Subtype_For_Contract_Cases, Access_To_Subtype_For_Contract_Cases);

   function Allocate_Contract_Cases
     (Pool : Bump_Ptr_Pool) return Bare_Contract_Cases;

   function Allocate_Contract_Cases
     (Pool : Bump_Ptr_Pool) return Bare_Contract_Cases
   is
      Result : constant Access_To_Subtype_For_Contract_Cases :=
        Bare_Contract_Cases_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Contract_Cases;
      return Bare_Contract_Cases (Result);
   end Allocate_Contract_Cases;

   package Bare_If_Expr_Memos is new Langkit_Support.Packrat
     (Bare_If_Expr, Token_Index);

   subtype Subtype_For_If_Expr is Root_Node_Record (Ada_If_Expr);
   type Access_To_Subtype_For_If_Expr is access all Subtype_For_If_Expr;
   package Bare_If_Expr_Alloc is new Alloc
     (Subtype_For_If_Expr, Access_To_Subtype_For_If_Expr);

   function Allocate_If_Expr (Pool : Bump_Ptr_Pool) return Bare_If_Expr;

   function Allocate_If_Expr (Pool : Bump_Ptr_Pool) return Bare_If_Expr is
      Result : constant Access_To_Subtype_For_If_Expr :=
        Bare_If_Expr_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_If_Expr;
      return Bare_If_Expr (Result);
   end Allocate_If_Expr;

   package Bare_Membership_Expr_Memos is new Langkit_Support.Packrat
     (Bare_Membership_Expr, Token_Index);

   subtype Subtype_For_Membership_Expr is
     Root_Node_Record (Ada_Membership_Expr);
   type Access_To_Subtype_For_Membership_Expr is
     access all Subtype_For_Membership_Expr;
   package Bare_Membership_Expr_Alloc is new Alloc
     (Subtype_For_Membership_Expr, Access_To_Subtype_For_Membership_Expr);

   function Allocate_Membership_Expr
     (Pool : Bump_Ptr_Pool) return Bare_Membership_Expr;

   function Allocate_Membership_Expr
     (Pool : Bump_Ptr_Pool) return Bare_Membership_Expr
   is
      Result : constant Access_To_Subtype_For_Membership_Expr :=
        Bare_Membership_Expr_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Membership_Expr;
      return Bare_Membership_Expr (Result);
   end Allocate_Membership_Expr;

   package Bare_Name_Memos is new Langkit_Support.Packrat
     (Bare_Name, Token_Index);

   package Bare_Attribute_Ref_Memos is new Langkit_Support.Packrat
     (Bare_Attribute_Ref, Token_Index);

   subtype Subtype_For_Attribute_Ref is Root_Node_Record (Ada_Attribute_Ref);
   type Access_To_Subtype_For_Attribute_Ref is
     access all Subtype_For_Attribute_Ref;
   package Bare_Attribute_Ref_Alloc is new Alloc
     (Subtype_For_Attribute_Ref, Access_To_Subtype_For_Attribute_Ref);

   function Allocate_Attribute_Ref
     (Pool : Bump_Ptr_Pool) return Bare_Attribute_Ref;

   function Allocate_Attribute_Ref
     (Pool : Bump_Ptr_Pool) return Bare_Attribute_Ref
   is
      Result : constant Access_To_Subtype_For_Attribute_Ref :=
        Bare_Attribute_Ref_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Attribute_Ref;
      return Bare_Attribute_Ref (Result);
   end Allocate_Attribute_Ref;

   package Bare_Update_Attribute_Ref_Memos is new Langkit_Support.Packrat
     (Bare_Update_Attribute_Ref, Token_Index);

   subtype Subtype_For_Update_Attribute_Ref is
     Root_Node_Record (Ada_Update_Attribute_Ref);
   type Access_To_Subtype_For_Update_Attribute_Ref is
     access all Subtype_For_Update_Attribute_Ref;
   package Bare_Update_Attribute_Ref_Alloc is new Alloc
     (Subtype_For_Update_Attribute_Ref,
      Access_To_Subtype_For_Update_Attribute_Ref);

   function Allocate_Update_Attribute_Ref
     (Pool : Bump_Ptr_Pool) return Bare_Update_Attribute_Ref;

   function Allocate_Update_Attribute_Ref
     (Pool : Bump_Ptr_Pool) return Bare_Update_Attribute_Ref
   is
      Result : constant Access_To_Subtype_For_Update_Attribute_Ref :=
        Bare_Update_Attribute_Ref_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Update_Attribute_Ref;
      return Bare_Update_Attribute_Ref (Result);
   end Allocate_Update_Attribute_Ref;

   package Bare_Call_Expr_Memos is new Langkit_Support.Packrat
     (Bare_Call_Expr, Token_Index);

   subtype Subtype_For_Call_Expr is Root_Node_Record (Ada_Call_Expr);
   type Access_To_Subtype_For_Call_Expr is access all Subtype_For_Call_Expr;
   package Bare_Call_Expr_Alloc is new Alloc
     (Subtype_For_Call_Expr, Access_To_Subtype_For_Call_Expr);

   function Allocate_Call_Expr (Pool : Bump_Ptr_Pool) return Bare_Call_Expr;

   function Allocate_Call_Expr (Pool : Bump_Ptr_Pool) return Bare_Call_Expr is
      Result : constant Access_To_Subtype_For_Call_Expr :=
        Bare_Call_Expr_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Call_Expr;
      return Bare_Call_Expr (Result);
   end Allocate_Call_Expr;

   package Bare_Defining_Name_Memos is new Langkit_Support.Packrat
     (Bare_Defining_Name, Token_Index);

   subtype Subtype_For_Defining_Name is Root_Node_Record (Ada_Defining_Name);
   type Access_To_Subtype_For_Defining_Name is
     access all Subtype_For_Defining_Name;
   package Bare_Defining_Name_Alloc is new Alloc
     (Subtype_For_Defining_Name, Access_To_Subtype_For_Defining_Name);

   function Allocate_Defining_Name
     (Pool : Bump_Ptr_Pool) return Bare_Defining_Name;

   function Allocate_Defining_Name
     (Pool : Bump_Ptr_Pool) return Bare_Defining_Name
   is
      Result : constant Access_To_Subtype_For_Defining_Name :=
        Bare_Defining_Name_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Defining_Name;
      return Bare_Defining_Name (Result);
   end Allocate_Defining_Name;

   package Bare_Discrete_Subtype_Name_Memos is new Langkit_Support.Packrat
     (Bare_Discrete_Subtype_Name, Token_Index);

   subtype Subtype_For_Discrete_Subtype_Name is
     Root_Node_Record (Ada_Discrete_Subtype_Name);
   type Access_To_Subtype_For_Discrete_Subtype_Name is
     access all Subtype_For_Discrete_Subtype_Name;
   package Bare_Discrete_Subtype_Name_Alloc is new Alloc
     (Subtype_For_Discrete_Subtype_Name,
      Access_To_Subtype_For_Discrete_Subtype_Name);

   function Allocate_Discrete_Subtype_Name
     (Pool : Bump_Ptr_Pool) return Bare_Discrete_Subtype_Name;

   function Allocate_Discrete_Subtype_Name
     (Pool : Bump_Ptr_Pool) return Bare_Discrete_Subtype_Name
   is
      Result : constant Access_To_Subtype_For_Discrete_Subtype_Name :=
        Bare_Discrete_Subtype_Name_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Discrete_Subtype_Name;
      return Bare_Discrete_Subtype_Name (Result);
   end Allocate_Discrete_Subtype_Name;

   package Bare_Dotted_Name_Memos is new Langkit_Support.Packrat
     (Bare_Dotted_Name, Token_Index);

   subtype Subtype_For_Dotted_Name is Root_Node_Record (Ada_Dotted_Name);
   type Access_To_Subtype_For_Dotted_Name is
     access all Subtype_For_Dotted_Name;
   package Bare_Dotted_Name_Alloc is new Alloc
     (Subtype_For_Dotted_Name, Access_To_Subtype_For_Dotted_Name);

   function Allocate_Dotted_Name
     (Pool : Bump_Ptr_Pool) return Bare_Dotted_Name;

   function Allocate_Dotted_Name (Pool : Bump_Ptr_Pool) return Bare_Dotted_Name
   is
      Result : constant Access_To_Subtype_For_Dotted_Name :=
        Bare_Dotted_Name_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Dotted_Name;
      return Bare_Dotted_Name (Result);
   end Allocate_Dotted_Name;

   package Bare_End_Name_Memos is new Langkit_Support.Packrat
     (Bare_End_Name, Token_Index);

   subtype Subtype_For_End_Name is Root_Node_Record (Ada_End_Name);
   type Access_To_Subtype_For_End_Name is access all Subtype_For_End_Name;
   package Bare_End_Name_Alloc is new Alloc
     (Subtype_For_End_Name, Access_To_Subtype_For_End_Name);

   function Allocate_End_Name (Pool : Bump_Ptr_Pool) return Bare_End_Name;

   function Allocate_End_Name (Pool : Bump_Ptr_Pool) return Bare_End_Name is
      Result : constant Access_To_Subtype_For_End_Name :=
        Bare_End_Name_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_End_Name;
      return Bare_End_Name (Result);
   end Allocate_End_Name;

   package Bare_Explicit_Deref_Memos is new Langkit_Support.Packrat
     (Bare_Explicit_Deref, Token_Index);

   subtype Subtype_For_Explicit_Deref is Root_Node_Record (Ada_Explicit_Deref);
   type Access_To_Subtype_For_Explicit_Deref is
     access all Subtype_For_Explicit_Deref;
   package Bare_Explicit_Deref_Alloc is new Alloc
     (Subtype_For_Explicit_Deref, Access_To_Subtype_For_Explicit_Deref);

   function Allocate_Explicit_Deref
     (Pool : Bump_Ptr_Pool) return Bare_Explicit_Deref;

   function Allocate_Explicit_Deref
     (Pool : Bump_Ptr_Pool) return Bare_Explicit_Deref
   is
      Result : constant Access_To_Subtype_For_Explicit_Deref :=
        Bare_Explicit_Deref_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Explicit_Deref;
      return Bare_Explicit_Deref (Result);
   end Allocate_Explicit_Deref;

   package Bare_Qual_Expr_Memos is new Langkit_Support.Packrat
     (Bare_Qual_Expr, Token_Index);

   subtype Subtype_For_Qual_Expr is Root_Node_Record (Ada_Qual_Expr);
   type Access_To_Subtype_For_Qual_Expr is access all Subtype_For_Qual_Expr;
   package Bare_Qual_Expr_Alloc is new Alloc
     (Subtype_For_Qual_Expr, Access_To_Subtype_For_Qual_Expr);

   function Allocate_Qual_Expr (Pool : Bump_Ptr_Pool) return Bare_Qual_Expr;

   function Allocate_Qual_Expr (Pool : Bump_Ptr_Pool) return Bare_Qual_Expr is
      Result : constant Access_To_Subtype_For_Qual_Expr :=
        Bare_Qual_Expr_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Qual_Expr;
      return Bare_Qual_Expr (Result);
   end Allocate_Qual_Expr;

   package Bare_Single_Tok_Node_Memos is new Langkit_Support.Packrat
     (Bare_Single_Tok_Node, Token_Index);

   package Bare_Base_Id_Memos is new Langkit_Support.Packrat
     (Bare_Base_Id, Token_Index);

   package Bare_Char_Literal_Memos is new Langkit_Support.Packrat
     (Bare_Char_Literal, Token_Index);

   subtype Subtype_For_Char_Literal is Root_Node_Record (Ada_Char_Literal);
   type Access_To_Subtype_For_Char_Literal is
     access all Subtype_For_Char_Literal;
   package Bare_Char_Literal_Alloc is new Alloc
     (Subtype_For_Char_Literal, Access_To_Subtype_For_Char_Literal);

   function Allocate_Char_Literal
     (Pool : Bump_Ptr_Pool) return Bare_Char_Literal;

   function Allocate_Char_Literal
     (Pool : Bump_Ptr_Pool) return Bare_Char_Literal
   is
      Result : constant Access_To_Subtype_For_Char_Literal :=
        Bare_Char_Literal_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Char_Literal;
      return Bare_Char_Literal (Result);
   end Allocate_Char_Literal;

   package Bare_Identifier_Memos is new Langkit_Support.Packrat
     (Bare_Identifier, Token_Index);

   subtype Subtype_For_Identifier is Root_Node_Record (Ada_Identifier);
   type Access_To_Subtype_For_Identifier is access all Subtype_For_Identifier;
   package Bare_Identifier_Alloc is new Alloc
     (Subtype_For_Identifier, Access_To_Subtype_For_Identifier);

   function Allocate_Identifier (Pool : Bump_Ptr_Pool) return Bare_Identifier;

   function Allocate_Identifier (Pool : Bump_Ptr_Pool) return Bare_Identifier
   is
      Result : constant Access_To_Subtype_For_Identifier :=
        Bare_Identifier_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Identifier;
      return Bare_Identifier (Result);
   end Allocate_Identifier;

   package Bare_Op_Memos is new Langkit_Support.Packrat (Bare_Op, Token_Index);

   package Bare_Op_Abs_Memos is new Langkit_Support.Packrat
     (Bare_Op_Abs, Token_Index);

   subtype Subtype_For_Op_Abs is Root_Node_Record (Ada_Op_Abs);
   type Access_To_Subtype_For_Op_Abs is access all Subtype_For_Op_Abs;
   package Bare_Op_Abs_Alloc is new Alloc
     (Subtype_For_Op_Abs, Access_To_Subtype_For_Op_Abs);

   function Allocate_Op_Abs (Pool : Bump_Ptr_Pool) return Bare_Op_Abs;

   function Allocate_Op_Abs (Pool : Bump_Ptr_Pool) return Bare_Op_Abs is
      Result : constant Access_To_Subtype_For_Op_Abs :=
        Bare_Op_Abs_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Op_Abs;
      return Bare_Op_Abs (Result);
   end Allocate_Op_Abs;

   package Bare_Op_And_Memos is new Langkit_Support.Packrat
     (Bare_Op_And, Token_Index);

   subtype Subtype_For_Op_And is Root_Node_Record (Ada_Op_And);
   type Access_To_Subtype_For_Op_And is access all Subtype_For_Op_And;
   package Bare_Op_And_Alloc is new Alloc
     (Subtype_For_Op_And, Access_To_Subtype_For_Op_And);

   function Allocate_Op_And (Pool : Bump_Ptr_Pool) return Bare_Op_And;

   function Allocate_Op_And (Pool : Bump_Ptr_Pool) return Bare_Op_And is
      Result : constant Access_To_Subtype_For_Op_And :=
        Bare_Op_And_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Op_And;
      return Bare_Op_And (Result);
   end Allocate_Op_And;

   package Bare_Op_And_Then_Memos is new Langkit_Support.Packrat
     (Bare_Op_And_Then, Token_Index);

   subtype Subtype_For_Op_And_Then is Root_Node_Record (Ada_Op_And_Then);
   type Access_To_Subtype_For_Op_And_Then is
     access all Subtype_For_Op_And_Then;
   package Bare_Op_And_Then_Alloc is new Alloc
     (Subtype_For_Op_And_Then, Access_To_Subtype_For_Op_And_Then);

   function Allocate_Op_And_Then
     (Pool : Bump_Ptr_Pool) return Bare_Op_And_Then;

   function Allocate_Op_And_Then (Pool : Bump_Ptr_Pool) return Bare_Op_And_Then
   is
      Result : constant Access_To_Subtype_For_Op_And_Then :=
        Bare_Op_And_Then_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Op_And_Then;
      return Bare_Op_And_Then (Result);
   end Allocate_Op_And_Then;

   package Bare_Op_Concat_Memos is new Langkit_Support.Packrat
     (Bare_Op_Concat, Token_Index);

   subtype Subtype_For_Op_Concat is Root_Node_Record (Ada_Op_Concat);
   type Access_To_Subtype_For_Op_Concat is access all Subtype_For_Op_Concat;
   package Bare_Op_Concat_Alloc is new Alloc
     (Subtype_For_Op_Concat, Access_To_Subtype_For_Op_Concat);

   function Allocate_Op_Concat (Pool : Bump_Ptr_Pool) return Bare_Op_Concat;

   function Allocate_Op_Concat (Pool : Bump_Ptr_Pool) return Bare_Op_Concat is
      Result : constant Access_To_Subtype_For_Op_Concat :=
        Bare_Op_Concat_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Op_Concat;
      return Bare_Op_Concat (Result);
   end Allocate_Op_Concat;

   package Bare_Op_Div_Memos is new Langkit_Support.Packrat
     (Bare_Op_Div, Token_Index);

   subtype Subtype_For_Op_Div is Root_Node_Record (Ada_Op_Div);
   type Access_To_Subtype_For_Op_Div is access all Subtype_For_Op_Div;
   package Bare_Op_Div_Alloc is new Alloc
     (Subtype_For_Op_Div, Access_To_Subtype_For_Op_Div);

   function Allocate_Op_Div (Pool : Bump_Ptr_Pool) return Bare_Op_Div;

   function Allocate_Op_Div (Pool : Bump_Ptr_Pool) return Bare_Op_Div is
      Result : constant Access_To_Subtype_For_Op_Div :=
        Bare_Op_Div_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Op_Div;
      return Bare_Op_Div (Result);
   end Allocate_Op_Div;

   package Bare_Op_Double_Dot_Memos is new Langkit_Support.Packrat
     (Bare_Op_Double_Dot, Token_Index);

   subtype Subtype_For_Op_Double_Dot is Root_Node_Record (Ada_Op_Double_Dot);
   type Access_To_Subtype_For_Op_Double_Dot is
     access all Subtype_For_Op_Double_Dot;
   package Bare_Op_Double_Dot_Alloc is new Alloc
     (Subtype_For_Op_Double_Dot, Access_To_Subtype_For_Op_Double_Dot);

   function Allocate_Op_Double_Dot
     (Pool : Bump_Ptr_Pool) return Bare_Op_Double_Dot;

   function Allocate_Op_Double_Dot
     (Pool : Bump_Ptr_Pool) return Bare_Op_Double_Dot
   is
      Result : constant Access_To_Subtype_For_Op_Double_Dot :=
        Bare_Op_Double_Dot_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Op_Double_Dot;
      return Bare_Op_Double_Dot (Result);
   end Allocate_Op_Double_Dot;

   package Bare_Op_Eq_Memos is new Langkit_Support.Packrat
     (Bare_Op_Eq, Token_Index);

   subtype Subtype_For_Op_Eq is Root_Node_Record (Ada_Op_Eq);
   type Access_To_Subtype_For_Op_Eq is access all Subtype_For_Op_Eq;
   package Bare_Op_Eq_Alloc is new Alloc
     (Subtype_For_Op_Eq, Access_To_Subtype_For_Op_Eq);

   function Allocate_Op_Eq (Pool : Bump_Ptr_Pool) return Bare_Op_Eq;

   function Allocate_Op_Eq (Pool : Bump_Ptr_Pool) return Bare_Op_Eq is
      Result : constant Access_To_Subtype_For_Op_Eq :=
        Bare_Op_Eq_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Op_Eq;
      return Bare_Op_Eq (Result);
   end Allocate_Op_Eq;

   package Bare_Op_Gt_Memos is new Langkit_Support.Packrat
     (Bare_Op_Gt, Token_Index);

   subtype Subtype_For_Op_Gt is Root_Node_Record (Ada_Op_Gt);
   type Access_To_Subtype_For_Op_Gt is access all Subtype_For_Op_Gt;
   package Bare_Op_Gt_Alloc is new Alloc
     (Subtype_For_Op_Gt, Access_To_Subtype_For_Op_Gt);

   function Allocate_Op_Gt (Pool : Bump_Ptr_Pool) return Bare_Op_Gt;

   function Allocate_Op_Gt (Pool : Bump_Ptr_Pool) return Bare_Op_Gt is
      Result : constant Access_To_Subtype_For_Op_Gt :=
        Bare_Op_Gt_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Op_Gt;
      return Bare_Op_Gt (Result);
   end Allocate_Op_Gt;

   package Bare_Op_Gte_Memos is new Langkit_Support.Packrat
     (Bare_Op_Gte, Token_Index);

   subtype Subtype_For_Op_Gte is Root_Node_Record (Ada_Op_Gte);
   type Access_To_Subtype_For_Op_Gte is access all Subtype_For_Op_Gte;
   package Bare_Op_Gte_Alloc is new Alloc
     (Subtype_For_Op_Gte, Access_To_Subtype_For_Op_Gte);

   function Allocate_Op_Gte (Pool : Bump_Ptr_Pool) return Bare_Op_Gte;

   function Allocate_Op_Gte (Pool : Bump_Ptr_Pool) return Bare_Op_Gte is
      Result : constant Access_To_Subtype_For_Op_Gte :=
        Bare_Op_Gte_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Op_Gte;
      return Bare_Op_Gte (Result);
   end Allocate_Op_Gte;

   package Bare_Op_In_Memos is new Langkit_Support.Packrat
     (Bare_Op_In, Token_Index);

   subtype Subtype_For_Op_In is Root_Node_Record (Ada_Op_In);
   type Access_To_Subtype_For_Op_In is access all Subtype_For_Op_In;
   package Bare_Op_In_Alloc is new Alloc
     (Subtype_For_Op_In, Access_To_Subtype_For_Op_In);

   function Allocate_Op_In (Pool : Bump_Ptr_Pool) return Bare_Op_In;

   function Allocate_Op_In (Pool : Bump_Ptr_Pool) return Bare_Op_In is
      Result : constant Access_To_Subtype_For_Op_In :=
        Bare_Op_In_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Op_In;
      return Bare_Op_In (Result);
   end Allocate_Op_In;

   package Bare_Op_Lt_Memos is new Langkit_Support.Packrat
     (Bare_Op_Lt, Token_Index);

   subtype Subtype_For_Op_Lt is Root_Node_Record (Ada_Op_Lt);
   type Access_To_Subtype_For_Op_Lt is access all Subtype_For_Op_Lt;
   package Bare_Op_Lt_Alloc is new Alloc
     (Subtype_For_Op_Lt, Access_To_Subtype_For_Op_Lt);

   function Allocate_Op_Lt (Pool : Bump_Ptr_Pool) return Bare_Op_Lt;

   function Allocate_Op_Lt (Pool : Bump_Ptr_Pool) return Bare_Op_Lt is
      Result : constant Access_To_Subtype_For_Op_Lt :=
        Bare_Op_Lt_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Op_Lt;
      return Bare_Op_Lt (Result);
   end Allocate_Op_Lt;

   package Bare_Op_Lte_Memos is new Langkit_Support.Packrat
     (Bare_Op_Lte, Token_Index);

   subtype Subtype_For_Op_Lte is Root_Node_Record (Ada_Op_Lte);
   type Access_To_Subtype_For_Op_Lte is access all Subtype_For_Op_Lte;
   package Bare_Op_Lte_Alloc is new Alloc
     (Subtype_For_Op_Lte, Access_To_Subtype_For_Op_Lte);

   function Allocate_Op_Lte (Pool : Bump_Ptr_Pool) return Bare_Op_Lte;

   function Allocate_Op_Lte (Pool : Bump_Ptr_Pool) return Bare_Op_Lte is
      Result : constant Access_To_Subtype_For_Op_Lte :=
        Bare_Op_Lte_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Op_Lte;
      return Bare_Op_Lte (Result);
   end Allocate_Op_Lte;

   package Bare_Op_Minus_Memos is new Langkit_Support.Packrat
     (Bare_Op_Minus, Token_Index);

   subtype Subtype_For_Op_Minus is Root_Node_Record (Ada_Op_Minus);
   type Access_To_Subtype_For_Op_Minus is access all Subtype_For_Op_Minus;
   package Bare_Op_Minus_Alloc is new Alloc
     (Subtype_For_Op_Minus, Access_To_Subtype_For_Op_Minus);

   function Allocate_Op_Minus (Pool : Bump_Ptr_Pool) return Bare_Op_Minus;

   function Allocate_Op_Minus (Pool : Bump_Ptr_Pool) return Bare_Op_Minus is
      Result : constant Access_To_Subtype_For_Op_Minus :=
        Bare_Op_Minus_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Op_Minus;
      return Bare_Op_Minus (Result);
   end Allocate_Op_Minus;

   package Bare_Op_Mod_Memos is new Langkit_Support.Packrat
     (Bare_Op_Mod, Token_Index);

   subtype Subtype_For_Op_Mod is Root_Node_Record (Ada_Op_Mod);
   type Access_To_Subtype_For_Op_Mod is access all Subtype_For_Op_Mod;
   package Bare_Op_Mod_Alloc is new Alloc
     (Subtype_For_Op_Mod, Access_To_Subtype_For_Op_Mod);

   function Allocate_Op_Mod (Pool : Bump_Ptr_Pool) return Bare_Op_Mod;

   function Allocate_Op_Mod (Pool : Bump_Ptr_Pool) return Bare_Op_Mod is
      Result : constant Access_To_Subtype_For_Op_Mod :=
        Bare_Op_Mod_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Op_Mod;
      return Bare_Op_Mod (Result);
   end Allocate_Op_Mod;

   package Bare_Op_Mult_Memos is new Langkit_Support.Packrat
     (Bare_Op_Mult, Token_Index);

   subtype Subtype_For_Op_Mult is Root_Node_Record (Ada_Op_Mult);
   type Access_To_Subtype_For_Op_Mult is access all Subtype_For_Op_Mult;
   package Bare_Op_Mult_Alloc is new Alloc
     (Subtype_For_Op_Mult, Access_To_Subtype_For_Op_Mult);

   function Allocate_Op_Mult (Pool : Bump_Ptr_Pool) return Bare_Op_Mult;

   function Allocate_Op_Mult (Pool : Bump_Ptr_Pool) return Bare_Op_Mult is
      Result : constant Access_To_Subtype_For_Op_Mult :=
        Bare_Op_Mult_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Op_Mult;
      return Bare_Op_Mult (Result);
   end Allocate_Op_Mult;

   package Bare_Op_Neq_Memos is new Langkit_Support.Packrat
     (Bare_Op_Neq, Token_Index);

   subtype Subtype_For_Op_Neq is Root_Node_Record (Ada_Op_Neq);
   type Access_To_Subtype_For_Op_Neq is access all Subtype_For_Op_Neq;
   package Bare_Op_Neq_Alloc is new Alloc
     (Subtype_For_Op_Neq, Access_To_Subtype_For_Op_Neq);

   function Allocate_Op_Neq (Pool : Bump_Ptr_Pool) return Bare_Op_Neq;

   function Allocate_Op_Neq (Pool : Bump_Ptr_Pool) return Bare_Op_Neq is
      Result : constant Access_To_Subtype_For_Op_Neq :=
        Bare_Op_Neq_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Op_Neq;
      return Bare_Op_Neq (Result);
   end Allocate_Op_Neq;

   package Bare_Op_Not_Memos is new Langkit_Support.Packrat
     (Bare_Op_Not, Token_Index);

   subtype Subtype_For_Op_Not is Root_Node_Record (Ada_Op_Not);
   type Access_To_Subtype_For_Op_Not is access all Subtype_For_Op_Not;
   package Bare_Op_Not_Alloc is new Alloc
     (Subtype_For_Op_Not, Access_To_Subtype_For_Op_Not);

   function Allocate_Op_Not (Pool : Bump_Ptr_Pool) return Bare_Op_Not;

   function Allocate_Op_Not (Pool : Bump_Ptr_Pool) return Bare_Op_Not is
      Result : constant Access_To_Subtype_For_Op_Not :=
        Bare_Op_Not_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Op_Not;
      return Bare_Op_Not (Result);
   end Allocate_Op_Not;

   package Bare_Op_Not_In_Memos is new Langkit_Support.Packrat
     (Bare_Op_Not_In, Token_Index);

   subtype Subtype_For_Op_Not_In is Root_Node_Record (Ada_Op_Not_In);
   type Access_To_Subtype_For_Op_Not_In is access all Subtype_For_Op_Not_In;
   package Bare_Op_Not_In_Alloc is new Alloc
     (Subtype_For_Op_Not_In, Access_To_Subtype_For_Op_Not_In);

   function Allocate_Op_Not_In (Pool : Bump_Ptr_Pool) return Bare_Op_Not_In;

   function Allocate_Op_Not_In (Pool : Bump_Ptr_Pool) return Bare_Op_Not_In is
      Result : constant Access_To_Subtype_For_Op_Not_In :=
        Bare_Op_Not_In_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Op_Not_In;
      return Bare_Op_Not_In (Result);
   end Allocate_Op_Not_In;

   package Bare_Op_Or_Memos is new Langkit_Support.Packrat
     (Bare_Op_Or, Token_Index);

   subtype Subtype_For_Op_Or is Root_Node_Record (Ada_Op_Or);
   type Access_To_Subtype_For_Op_Or is access all Subtype_For_Op_Or;
   package Bare_Op_Or_Alloc is new Alloc
     (Subtype_For_Op_Or, Access_To_Subtype_For_Op_Or);

   function Allocate_Op_Or (Pool : Bump_Ptr_Pool) return Bare_Op_Or;

   function Allocate_Op_Or (Pool : Bump_Ptr_Pool) return Bare_Op_Or is
      Result : constant Access_To_Subtype_For_Op_Or :=
        Bare_Op_Or_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Op_Or;
      return Bare_Op_Or (Result);
   end Allocate_Op_Or;

   package Bare_Op_Or_Else_Memos is new Langkit_Support.Packrat
     (Bare_Op_Or_Else, Token_Index);

   subtype Subtype_For_Op_Or_Else is Root_Node_Record (Ada_Op_Or_Else);
   type Access_To_Subtype_For_Op_Or_Else is access all Subtype_For_Op_Or_Else;
   package Bare_Op_Or_Else_Alloc is new Alloc
     (Subtype_For_Op_Or_Else, Access_To_Subtype_For_Op_Or_Else);

   function Allocate_Op_Or_Else (Pool : Bump_Ptr_Pool) return Bare_Op_Or_Else;

   function Allocate_Op_Or_Else (Pool : Bump_Ptr_Pool) return Bare_Op_Or_Else
   is
      Result : constant Access_To_Subtype_For_Op_Or_Else :=
        Bare_Op_Or_Else_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Op_Or_Else;
      return Bare_Op_Or_Else (Result);
   end Allocate_Op_Or_Else;

   package Bare_Op_Plus_Memos is new Langkit_Support.Packrat
     (Bare_Op_Plus, Token_Index);

   subtype Subtype_For_Op_Plus is Root_Node_Record (Ada_Op_Plus);
   type Access_To_Subtype_For_Op_Plus is access all Subtype_For_Op_Plus;
   package Bare_Op_Plus_Alloc is new Alloc
     (Subtype_For_Op_Plus, Access_To_Subtype_For_Op_Plus);

   function Allocate_Op_Plus (Pool : Bump_Ptr_Pool) return Bare_Op_Plus;

   function Allocate_Op_Plus (Pool : Bump_Ptr_Pool) return Bare_Op_Plus is
      Result : constant Access_To_Subtype_For_Op_Plus :=
        Bare_Op_Plus_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Op_Plus;
      return Bare_Op_Plus (Result);
   end Allocate_Op_Plus;

   package Bare_Op_Pow_Memos is new Langkit_Support.Packrat
     (Bare_Op_Pow, Token_Index);

   subtype Subtype_For_Op_Pow is Root_Node_Record (Ada_Op_Pow);
   type Access_To_Subtype_For_Op_Pow is access all Subtype_For_Op_Pow;
   package Bare_Op_Pow_Alloc is new Alloc
     (Subtype_For_Op_Pow, Access_To_Subtype_For_Op_Pow);

   function Allocate_Op_Pow (Pool : Bump_Ptr_Pool) return Bare_Op_Pow;

   function Allocate_Op_Pow (Pool : Bump_Ptr_Pool) return Bare_Op_Pow is
      Result : constant Access_To_Subtype_For_Op_Pow :=
        Bare_Op_Pow_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Op_Pow;
      return Bare_Op_Pow (Result);
   end Allocate_Op_Pow;

   package Bare_Op_Rem_Memos is new Langkit_Support.Packrat
     (Bare_Op_Rem, Token_Index);

   subtype Subtype_For_Op_Rem is Root_Node_Record (Ada_Op_Rem);
   type Access_To_Subtype_For_Op_Rem is access all Subtype_For_Op_Rem;
   package Bare_Op_Rem_Alloc is new Alloc
     (Subtype_For_Op_Rem, Access_To_Subtype_For_Op_Rem);

   function Allocate_Op_Rem (Pool : Bump_Ptr_Pool) return Bare_Op_Rem;

   function Allocate_Op_Rem (Pool : Bump_Ptr_Pool) return Bare_Op_Rem is
      Result : constant Access_To_Subtype_For_Op_Rem :=
        Bare_Op_Rem_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Op_Rem;
      return Bare_Op_Rem (Result);
   end Allocate_Op_Rem;

   package Bare_Op_Xor_Memos is new Langkit_Support.Packrat
     (Bare_Op_Xor, Token_Index);

   subtype Subtype_For_Op_Xor is Root_Node_Record (Ada_Op_Xor);
   type Access_To_Subtype_For_Op_Xor is access all Subtype_For_Op_Xor;
   package Bare_Op_Xor_Alloc is new Alloc
     (Subtype_For_Op_Xor, Access_To_Subtype_For_Op_Xor);

   function Allocate_Op_Xor (Pool : Bump_Ptr_Pool) return Bare_Op_Xor;

   function Allocate_Op_Xor (Pool : Bump_Ptr_Pool) return Bare_Op_Xor is
      Result : constant Access_To_Subtype_For_Op_Xor :=
        Bare_Op_Xor_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Op_Xor;
      return Bare_Op_Xor (Result);
   end Allocate_Op_Xor;

   package Bare_String_Literal_Memos is new Langkit_Support.Packrat
     (Bare_String_Literal, Token_Index);

   subtype Subtype_For_String_Literal is Root_Node_Record (Ada_String_Literal);
   type Access_To_Subtype_For_String_Literal is
     access all Subtype_For_String_Literal;
   package Bare_String_Literal_Alloc is new Alloc
     (Subtype_For_String_Literal, Access_To_Subtype_For_String_Literal);

   function Allocate_String_Literal
     (Pool : Bump_Ptr_Pool) return Bare_String_Literal;

   function Allocate_String_Literal
     (Pool : Bump_Ptr_Pool) return Bare_String_Literal
   is
      Result : constant Access_To_Subtype_For_String_Literal :=
        Bare_String_Literal_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_String_Literal;
      return Bare_String_Literal (Result);
   end Allocate_String_Literal;

   package Bare_Null_Literal_Memos is new Langkit_Support.Packrat
     (Bare_Null_Literal, Token_Index);

   subtype Subtype_For_Null_Literal is Root_Node_Record (Ada_Null_Literal);
   type Access_To_Subtype_For_Null_Literal is
     access all Subtype_For_Null_Literal;
   package Bare_Null_Literal_Alloc is new Alloc
     (Subtype_For_Null_Literal, Access_To_Subtype_For_Null_Literal);

   function Allocate_Null_Literal
     (Pool : Bump_Ptr_Pool) return Bare_Null_Literal;

   function Allocate_Null_Literal
     (Pool : Bump_Ptr_Pool) return Bare_Null_Literal
   is
      Result : constant Access_To_Subtype_For_Null_Literal :=
        Bare_Null_Literal_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Null_Literal;
      return Bare_Null_Literal (Result);
   end Allocate_Null_Literal;

   package Bare_Num_Literal_Memos is new Langkit_Support.Packrat
     (Bare_Num_Literal, Token_Index);

   package Bare_Int_Literal_Memos is new Langkit_Support.Packrat
     (Bare_Int_Literal, Token_Index);

   subtype Subtype_For_Int_Literal is Root_Node_Record (Ada_Int_Literal);
   type Access_To_Subtype_For_Int_Literal is
     access all Subtype_For_Int_Literal;
   package Bare_Int_Literal_Alloc is new Alloc
     (Subtype_For_Int_Literal, Access_To_Subtype_For_Int_Literal);

   function Allocate_Int_Literal
     (Pool : Bump_Ptr_Pool) return Bare_Int_Literal;

   function Allocate_Int_Literal (Pool : Bump_Ptr_Pool) return Bare_Int_Literal
   is
      Result : constant Access_To_Subtype_For_Int_Literal :=
        Bare_Int_Literal_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Int_Literal;
      return Bare_Int_Literal (Result);
   end Allocate_Int_Literal;

   package Bare_Real_Literal_Memos is new Langkit_Support.Packrat
     (Bare_Real_Literal, Token_Index);

   subtype Subtype_For_Real_Literal is Root_Node_Record (Ada_Real_Literal);
   type Access_To_Subtype_For_Real_Literal is
     access all Subtype_For_Real_Literal;
   package Bare_Real_Literal_Alloc is new Alloc
     (Subtype_For_Real_Literal, Access_To_Subtype_For_Real_Literal);

   function Allocate_Real_Literal
     (Pool : Bump_Ptr_Pool) return Bare_Real_Literal;

   function Allocate_Real_Literal
     (Pool : Bump_Ptr_Pool) return Bare_Real_Literal
   is
      Result : constant Access_To_Subtype_For_Real_Literal :=
        Bare_Real_Literal_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Real_Literal;
      return Bare_Real_Literal (Result);
   end Allocate_Real_Literal;

   package Bare_Target_Name_Memos is new Langkit_Support.Packrat
     (Bare_Target_Name, Token_Index);

   subtype Subtype_For_Target_Name is Root_Node_Record (Ada_Target_Name);
   type Access_To_Subtype_For_Target_Name is
     access all Subtype_For_Target_Name;
   package Bare_Target_Name_Alloc is new Alloc
     (Subtype_For_Target_Name, Access_To_Subtype_For_Target_Name);

   function Allocate_Target_Name
     (Pool : Bump_Ptr_Pool) return Bare_Target_Name;

   function Allocate_Target_Name (Pool : Bump_Ptr_Pool) return Bare_Target_Name
   is
      Result : constant Access_To_Subtype_For_Target_Name :=
        Bare_Target_Name_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Target_Name;
      return Bare_Target_Name (Result);
   end Allocate_Target_Name;

   package Bare_Paren_Expr_Memos is new Langkit_Support.Packrat
     (Bare_Paren_Expr, Token_Index);

   subtype Subtype_For_Paren_Expr is Root_Node_Record (Ada_Paren_Expr);
   type Access_To_Subtype_For_Paren_Expr is access all Subtype_For_Paren_Expr;
   package Bare_Paren_Expr_Alloc is new Alloc
     (Subtype_For_Paren_Expr, Access_To_Subtype_For_Paren_Expr);

   function Allocate_Paren_Expr (Pool : Bump_Ptr_Pool) return Bare_Paren_Expr;

   function Allocate_Paren_Expr (Pool : Bump_Ptr_Pool) return Bare_Paren_Expr
   is
      Result : constant Access_To_Subtype_For_Paren_Expr :=
        Bare_Paren_Expr_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Paren_Expr;
      return Bare_Paren_Expr (Result);
   end Allocate_Paren_Expr;

   package Bare_Quantified_Expr_Memos is new Langkit_Support.Packrat
     (Bare_Quantified_Expr, Token_Index);

   subtype Subtype_For_Quantified_Expr is
     Root_Node_Record (Ada_Quantified_Expr);
   type Access_To_Subtype_For_Quantified_Expr is
     access all Subtype_For_Quantified_Expr;
   package Bare_Quantified_Expr_Alloc is new Alloc
     (Subtype_For_Quantified_Expr, Access_To_Subtype_For_Quantified_Expr);

   function Allocate_Quantified_Expr
     (Pool : Bump_Ptr_Pool) return Bare_Quantified_Expr;

   function Allocate_Quantified_Expr
     (Pool : Bump_Ptr_Pool) return Bare_Quantified_Expr
   is
      Result : constant Access_To_Subtype_For_Quantified_Expr :=
        Bare_Quantified_Expr_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Quantified_Expr;
      return Bare_Quantified_Expr (Result);
   end Allocate_Quantified_Expr;

   package Bare_Raise_Expr_Memos is new Langkit_Support.Packrat
     (Bare_Raise_Expr, Token_Index);

   subtype Subtype_For_Raise_Expr is Root_Node_Record (Ada_Raise_Expr);
   type Access_To_Subtype_For_Raise_Expr is access all Subtype_For_Raise_Expr;
   package Bare_Raise_Expr_Alloc is new Alloc
     (Subtype_For_Raise_Expr, Access_To_Subtype_For_Raise_Expr);

   function Allocate_Raise_Expr (Pool : Bump_Ptr_Pool) return Bare_Raise_Expr;

   function Allocate_Raise_Expr (Pool : Bump_Ptr_Pool) return Bare_Raise_Expr
   is
      Result : constant Access_To_Subtype_For_Raise_Expr :=
        Bare_Raise_Expr_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Raise_Expr;
      return Bare_Raise_Expr (Result);
   end Allocate_Raise_Expr;

   package Bare_Un_Op_Memos is new Langkit_Support.Packrat
     (Bare_Un_Op, Token_Index);

   subtype Subtype_For_Un_Op is Root_Node_Record (Ada_Un_Op);
   type Access_To_Subtype_For_Un_Op is access all Subtype_For_Un_Op;
   package Bare_Un_Op_Alloc is new Alloc
     (Subtype_For_Un_Op, Access_To_Subtype_For_Un_Op);

   function Allocate_Un_Op (Pool : Bump_Ptr_Pool) return Bare_Un_Op;

   function Allocate_Un_Op (Pool : Bump_Ptr_Pool) return Bare_Un_Op is
      Result : constant Access_To_Subtype_For_Un_Op :=
        Bare_Un_Op_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Un_Op;
      return Bare_Un_Op (Result);
   end Allocate_Un_Op;

   package Bare_Handled_Stmts_Memos is new Langkit_Support.Packrat
     (Bare_Handled_Stmts, Token_Index);

   subtype Subtype_For_Handled_Stmts is Root_Node_Record (Ada_Handled_Stmts);
   type Access_To_Subtype_For_Handled_Stmts is
     access all Subtype_For_Handled_Stmts;
   package Bare_Handled_Stmts_Alloc is new Alloc
     (Subtype_For_Handled_Stmts, Access_To_Subtype_For_Handled_Stmts);

   function Allocate_Handled_Stmts
     (Pool : Bump_Ptr_Pool) return Bare_Handled_Stmts;

   function Allocate_Handled_Stmts
     (Pool : Bump_Ptr_Pool) return Bare_Handled_Stmts
   is
      Result : constant Access_To_Subtype_For_Handled_Stmts :=
        Bare_Handled_Stmts_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Handled_Stmts;
      return Bare_Handled_Stmts (Result);
   end Allocate_Handled_Stmts;

   package Bare_Interface_Kind_Memos is new Langkit_Support.Packrat
     (Bare_Interface_Kind, Token_Index);

   package Bare_Interface_Kind_Limited_Memos is new Langkit_Support.Packrat
     (Bare_Interface_Kind_Limited, Token_Index);

   subtype Subtype_For_Interface_Kind_Limited is
     Root_Node_Record (Ada_Interface_Kind_Limited);
   type Access_To_Subtype_For_Interface_Kind_Limited is
     access all Subtype_For_Interface_Kind_Limited;
   package Bare_Interface_Kind_Limited_Alloc is new Alloc
     (Subtype_For_Interface_Kind_Limited,
      Access_To_Subtype_For_Interface_Kind_Limited);

   function Allocate_Interface_Kind_Limited
     (Pool : Bump_Ptr_Pool) return Bare_Interface_Kind_Limited;

   function Allocate_Interface_Kind_Limited
     (Pool : Bump_Ptr_Pool) return Bare_Interface_Kind_Limited
   is
      Result : constant Access_To_Subtype_For_Interface_Kind_Limited :=
        Bare_Interface_Kind_Limited_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Interface_Kind_Limited;
      return Bare_Interface_Kind_Limited (Result);
   end Allocate_Interface_Kind_Limited;

   package Bare_Interface_Kind_Protected_Memos is new Langkit_Support.Packrat
     (Bare_Interface_Kind_Protected, Token_Index);

   subtype Subtype_For_Interface_Kind_Protected is
     Root_Node_Record (Ada_Interface_Kind_Protected);
   type Access_To_Subtype_For_Interface_Kind_Protected is
     access all Subtype_For_Interface_Kind_Protected;
   package Bare_Interface_Kind_Protected_Alloc is new Alloc
     (Subtype_For_Interface_Kind_Protected,
      Access_To_Subtype_For_Interface_Kind_Protected);

   function Allocate_Interface_Kind_Protected
     (Pool : Bump_Ptr_Pool) return Bare_Interface_Kind_Protected;

   function Allocate_Interface_Kind_Protected
     (Pool : Bump_Ptr_Pool) return Bare_Interface_Kind_Protected
   is
      Result : constant Access_To_Subtype_For_Interface_Kind_Protected :=
        Bare_Interface_Kind_Protected_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Interface_Kind_Protected;
      return Bare_Interface_Kind_Protected (Result);
   end Allocate_Interface_Kind_Protected;

   package Bare_Interface_Kind_Synchronized_Memos is new Langkit_Support
     .Packrat
     (Bare_Interface_Kind_Synchronized, Token_Index);

   subtype Subtype_For_Interface_Kind_Synchronized is
     Root_Node_Record (Ada_Interface_Kind_Synchronized);
   type Access_To_Subtype_For_Interface_Kind_Synchronized is
     access all Subtype_For_Interface_Kind_Synchronized;
   package Bare_Interface_Kind_Synchronized_Alloc is new Alloc
     (Subtype_For_Interface_Kind_Synchronized,
      Access_To_Subtype_For_Interface_Kind_Synchronized);

   function Allocate_Interface_Kind_Synchronized
     (Pool : Bump_Ptr_Pool) return Bare_Interface_Kind_Synchronized;

   function Allocate_Interface_Kind_Synchronized
     (Pool : Bump_Ptr_Pool) return Bare_Interface_Kind_Synchronized
   is
      Result : constant Access_To_Subtype_For_Interface_Kind_Synchronized :=
        Bare_Interface_Kind_Synchronized_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Interface_Kind_Synchronized;
      return Bare_Interface_Kind_Synchronized (Result);
   end Allocate_Interface_Kind_Synchronized;

   package Bare_Interface_Kind_Task_Memos is new Langkit_Support.Packrat
     (Bare_Interface_Kind_Task, Token_Index);

   subtype Subtype_For_Interface_Kind_Task is
     Root_Node_Record (Ada_Interface_Kind_Task);
   type Access_To_Subtype_For_Interface_Kind_Task is
     access all Subtype_For_Interface_Kind_Task;
   package Bare_Interface_Kind_Task_Alloc is new Alloc
     (Subtype_For_Interface_Kind_Task,
      Access_To_Subtype_For_Interface_Kind_Task);

   function Allocate_Interface_Kind_Task
     (Pool : Bump_Ptr_Pool) return Bare_Interface_Kind_Task;

   function Allocate_Interface_Kind_Task
     (Pool : Bump_Ptr_Pool) return Bare_Interface_Kind_Task
   is
      Result : constant Access_To_Subtype_For_Interface_Kind_Task :=
        Bare_Interface_Kind_Task_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Interface_Kind_Task;
      return Bare_Interface_Kind_Task (Result);
   end Allocate_Interface_Kind_Task;

   package Bare_Iter_Type_Memos is new Langkit_Support.Packrat
     (Bare_Iter_Type, Token_Index);

   package Bare_Iter_Type_In_Memos is new Langkit_Support.Packrat
     (Bare_Iter_Type_In, Token_Index);

   subtype Subtype_For_Iter_Type_In is Root_Node_Record (Ada_Iter_Type_In);
   type Access_To_Subtype_For_Iter_Type_In is
     access all Subtype_For_Iter_Type_In;
   package Bare_Iter_Type_In_Alloc is new Alloc
     (Subtype_For_Iter_Type_In, Access_To_Subtype_For_Iter_Type_In);

   function Allocate_Iter_Type_In
     (Pool : Bump_Ptr_Pool) return Bare_Iter_Type_In;

   function Allocate_Iter_Type_In
     (Pool : Bump_Ptr_Pool) return Bare_Iter_Type_In
   is
      Result : constant Access_To_Subtype_For_Iter_Type_In :=
        Bare_Iter_Type_In_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Iter_Type_In;
      return Bare_Iter_Type_In (Result);
   end Allocate_Iter_Type_In;

   package Bare_Iter_Type_Of_Memos is new Langkit_Support.Packrat
     (Bare_Iter_Type_Of, Token_Index);

   subtype Subtype_For_Iter_Type_Of is Root_Node_Record (Ada_Iter_Type_Of);
   type Access_To_Subtype_For_Iter_Type_Of is
     access all Subtype_For_Iter_Type_Of;
   package Bare_Iter_Type_Of_Alloc is new Alloc
     (Subtype_For_Iter_Type_Of, Access_To_Subtype_For_Iter_Type_Of);

   function Allocate_Iter_Type_Of
     (Pool : Bump_Ptr_Pool) return Bare_Iter_Type_Of;

   function Allocate_Iter_Type_Of
     (Pool : Bump_Ptr_Pool) return Bare_Iter_Type_Of
   is
      Result : constant Access_To_Subtype_For_Iter_Type_Of :=
        Bare_Iter_Type_Of_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Iter_Type_Of;
      return Bare_Iter_Type_Of (Result);
   end Allocate_Iter_Type_Of;

   package Bare_Library_Item_Memos is new Langkit_Support.Packrat
     (Bare_Library_Item, Token_Index);

   subtype Subtype_For_Library_Item is Root_Node_Record (Ada_Library_Item);
   type Access_To_Subtype_For_Library_Item is
     access all Subtype_For_Library_Item;
   package Bare_Library_Item_Alloc is new Alloc
     (Subtype_For_Library_Item, Access_To_Subtype_For_Library_Item);

   function Allocate_Library_Item
     (Pool : Bump_Ptr_Pool) return Bare_Library_Item;

   function Allocate_Library_Item
     (Pool : Bump_Ptr_Pool) return Bare_Library_Item
   is
      Result : constant Access_To_Subtype_For_Library_Item :=
        Bare_Library_Item_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Library_Item;
      return Bare_Library_Item (Result);
   end Allocate_Library_Item;

   package Bare_Limited_Node_Memos is new Langkit_Support.Packrat
     (Bare_Limited_Node, Token_Index);

   package Bare_Limited_Absent_Memos is new Langkit_Support.Packrat
     (Bare_Limited_Absent, Token_Index);

   subtype Subtype_For_Limited_Absent is Root_Node_Record (Ada_Limited_Absent);
   type Access_To_Subtype_For_Limited_Absent is
     access all Subtype_For_Limited_Absent;
   package Bare_Limited_Absent_Alloc is new Alloc
     (Subtype_For_Limited_Absent, Access_To_Subtype_For_Limited_Absent);

   function Allocate_Limited_Absent
     (Pool : Bump_Ptr_Pool) return Bare_Limited_Absent;

   function Allocate_Limited_Absent
     (Pool : Bump_Ptr_Pool) return Bare_Limited_Absent
   is
      Result : constant Access_To_Subtype_For_Limited_Absent :=
        Bare_Limited_Absent_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Limited_Absent;
      return Bare_Limited_Absent (Result);
   end Allocate_Limited_Absent;

   package Bare_Limited_Present_Memos is new Langkit_Support.Packrat
     (Bare_Limited_Present, Token_Index);

   subtype Subtype_For_Limited_Present is
     Root_Node_Record (Ada_Limited_Present);
   type Access_To_Subtype_For_Limited_Present is
     access all Subtype_For_Limited_Present;
   package Bare_Limited_Present_Alloc is new Alloc
     (Subtype_For_Limited_Present, Access_To_Subtype_For_Limited_Present);

   function Allocate_Limited_Present
     (Pool : Bump_Ptr_Pool) return Bare_Limited_Present;

   function Allocate_Limited_Present
     (Pool : Bump_Ptr_Pool) return Bare_Limited_Present
   is
      Result : constant Access_To_Subtype_For_Limited_Present :=
        Bare_Limited_Present_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Limited_Present;
      return Bare_Limited_Present (Result);
   end Allocate_Limited_Present;

   package Bare_Loop_Spec_Memos is new Langkit_Support.Packrat
     (Bare_Loop_Spec, Token_Index);

   package Bare_For_Loop_Spec_Memos is new Langkit_Support.Packrat
     (Bare_For_Loop_Spec, Token_Index);

   subtype Subtype_For_For_Loop_Spec is Root_Node_Record (Ada_For_Loop_Spec);
   type Access_To_Subtype_For_For_Loop_Spec is
     access all Subtype_For_For_Loop_Spec;
   package Bare_For_Loop_Spec_Alloc is new Alloc
     (Subtype_For_For_Loop_Spec, Access_To_Subtype_For_For_Loop_Spec);

   function Allocate_For_Loop_Spec
     (Pool : Bump_Ptr_Pool) return Bare_For_Loop_Spec;

   function Allocate_For_Loop_Spec
     (Pool : Bump_Ptr_Pool) return Bare_For_Loop_Spec
   is
      Result : constant Access_To_Subtype_For_For_Loop_Spec :=
        Bare_For_Loop_Spec_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_For_Loop_Spec;
      return Bare_For_Loop_Spec (Result);
   end Allocate_For_Loop_Spec;

   package Bare_While_Loop_Spec_Memos is new Langkit_Support.Packrat
     (Bare_While_Loop_Spec, Token_Index);

   subtype Subtype_For_While_Loop_Spec is
     Root_Node_Record (Ada_While_Loop_Spec);
   type Access_To_Subtype_For_While_Loop_Spec is
     access all Subtype_For_While_Loop_Spec;
   package Bare_While_Loop_Spec_Alloc is new Alloc
     (Subtype_For_While_Loop_Spec, Access_To_Subtype_For_While_Loop_Spec);

   function Allocate_While_Loop_Spec
     (Pool : Bump_Ptr_Pool) return Bare_While_Loop_Spec;

   function Allocate_While_Loop_Spec
     (Pool : Bump_Ptr_Pool) return Bare_While_Loop_Spec
   is
      Result : constant Access_To_Subtype_For_While_Loop_Spec :=
        Bare_While_Loop_Spec_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_While_Loop_Spec;
      return Bare_While_Loop_Spec (Result);
   end Allocate_While_Loop_Spec;

   package Bare_Mode_Memos is new Langkit_Support.Packrat
     (Bare_Mode, Token_Index);

   package Bare_Mode_Default_Memos is new Langkit_Support.Packrat
     (Bare_Mode_Default, Token_Index);

   subtype Subtype_For_Mode_Default is Root_Node_Record (Ada_Mode_Default);
   type Access_To_Subtype_For_Mode_Default is
     access all Subtype_For_Mode_Default;
   package Bare_Mode_Default_Alloc is new Alloc
     (Subtype_For_Mode_Default, Access_To_Subtype_For_Mode_Default);

   function Allocate_Mode_Default
     (Pool : Bump_Ptr_Pool) return Bare_Mode_Default;

   function Allocate_Mode_Default
     (Pool : Bump_Ptr_Pool) return Bare_Mode_Default
   is
      Result : constant Access_To_Subtype_For_Mode_Default :=
        Bare_Mode_Default_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Mode_Default;
      return Bare_Mode_Default (Result);
   end Allocate_Mode_Default;

   package Bare_Mode_In_Memos is new Langkit_Support.Packrat
     (Bare_Mode_In, Token_Index);

   subtype Subtype_For_Mode_In is Root_Node_Record (Ada_Mode_In);
   type Access_To_Subtype_For_Mode_In is access all Subtype_For_Mode_In;
   package Bare_Mode_In_Alloc is new Alloc
     (Subtype_For_Mode_In, Access_To_Subtype_For_Mode_In);

   function Allocate_Mode_In (Pool : Bump_Ptr_Pool) return Bare_Mode_In;

   function Allocate_Mode_In (Pool : Bump_Ptr_Pool) return Bare_Mode_In is
      Result : constant Access_To_Subtype_For_Mode_In :=
        Bare_Mode_In_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Mode_In;
      return Bare_Mode_In (Result);
   end Allocate_Mode_In;

   package Bare_Mode_In_Out_Memos is new Langkit_Support.Packrat
     (Bare_Mode_In_Out, Token_Index);

   subtype Subtype_For_Mode_In_Out is Root_Node_Record (Ada_Mode_In_Out);
   type Access_To_Subtype_For_Mode_In_Out is
     access all Subtype_For_Mode_In_Out;
   package Bare_Mode_In_Out_Alloc is new Alloc
     (Subtype_For_Mode_In_Out, Access_To_Subtype_For_Mode_In_Out);

   function Allocate_Mode_In_Out
     (Pool : Bump_Ptr_Pool) return Bare_Mode_In_Out;

   function Allocate_Mode_In_Out (Pool : Bump_Ptr_Pool) return Bare_Mode_In_Out
   is
      Result : constant Access_To_Subtype_For_Mode_In_Out :=
        Bare_Mode_In_Out_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Mode_In_Out;
      return Bare_Mode_In_Out (Result);
   end Allocate_Mode_In_Out;

   package Bare_Mode_Out_Memos is new Langkit_Support.Packrat
     (Bare_Mode_Out, Token_Index);

   subtype Subtype_For_Mode_Out is Root_Node_Record (Ada_Mode_Out);
   type Access_To_Subtype_For_Mode_Out is access all Subtype_For_Mode_Out;
   package Bare_Mode_Out_Alloc is new Alloc
     (Subtype_For_Mode_Out, Access_To_Subtype_For_Mode_Out);

   function Allocate_Mode_Out (Pool : Bump_Ptr_Pool) return Bare_Mode_Out;

   function Allocate_Mode_Out (Pool : Bump_Ptr_Pool) return Bare_Mode_Out is
      Result : constant Access_To_Subtype_For_Mode_Out :=
        Bare_Mode_Out_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Mode_Out;
      return Bare_Mode_Out (Result);
   end Allocate_Mode_Out;

   package Bare_Not_Null_Memos is new Langkit_Support.Packrat
     (Bare_Not_Null, Token_Index);

   package Bare_Not_Null_Absent_Memos is new Langkit_Support.Packrat
     (Bare_Not_Null_Absent, Token_Index);

   subtype Subtype_For_Not_Null_Absent is
     Root_Node_Record (Ada_Not_Null_Absent);
   type Access_To_Subtype_For_Not_Null_Absent is
     access all Subtype_For_Not_Null_Absent;
   package Bare_Not_Null_Absent_Alloc is new Alloc
     (Subtype_For_Not_Null_Absent, Access_To_Subtype_For_Not_Null_Absent);

   function Allocate_Not_Null_Absent
     (Pool : Bump_Ptr_Pool) return Bare_Not_Null_Absent;

   function Allocate_Not_Null_Absent
     (Pool : Bump_Ptr_Pool) return Bare_Not_Null_Absent
   is
      Result : constant Access_To_Subtype_For_Not_Null_Absent :=
        Bare_Not_Null_Absent_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Not_Null_Absent;
      return Bare_Not_Null_Absent (Result);
   end Allocate_Not_Null_Absent;

   package Bare_Not_Null_Present_Memos is new Langkit_Support.Packrat
     (Bare_Not_Null_Present, Token_Index);

   subtype Subtype_For_Not_Null_Present is
     Root_Node_Record (Ada_Not_Null_Present);
   type Access_To_Subtype_For_Not_Null_Present is
     access all Subtype_For_Not_Null_Present;
   package Bare_Not_Null_Present_Alloc is new Alloc
     (Subtype_For_Not_Null_Present, Access_To_Subtype_For_Not_Null_Present);

   function Allocate_Not_Null_Present
     (Pool : Bump_Ptr_Pool) return Bare_Not_Null_Present;

   function Allocate_Not_Null_Present
     (Pool : Bump_Ptr_Pool) return Bare_Not_Null_Present
   is
      Result : constant Access_To_Subtype_For_Not_Null_Present :=
        Bare_Not_Null_Present_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Not_Null_Present;
      return Bare_Not_Null_Present (Result);
   end Allocate_Not_Null_Present;

   package Bare_Null_Component_Decl_Memos is new Langkit_Support.Packrat
     (Bare_Null_Component_Decl, Token_Index);

   subtype Subtype_For_Null_Component_Decl is
     Root_Node_Record (Ada_Null_Component_Decl);
   type Access_To_Subtype_For_Null_Component_Decl is
     access all Subtype_For_Null_Component_Decl;
   package Bare_Null_Component_Decl_Alloc is new Alloc
     (Subtype_For_Null_Component_Decl,
      Access_To_Subtype_For_Null_Component_Decl);

   function Allocate_Null_Component_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Null_Component_Decl;

   function Allocate_Null_Component_Decl
     (Pool : Bump_Ptr_Pool) return Bare_Null_Component_Decl
   is
      Result : constant Access_To_Subtype_For_Null_Component_Decl :=
        Bare_Null_Component_Decl_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Null_Component_Decl;
      return Bare_Null_Component_Decl (Result);
   end Allocate_Null_Component_Decl;

   package Bare_Others_Designator_Memos is new Langkit_Support.Packrat
     (Bare_Others_Designator, Token_Index);

   subtype Subtype_For_Others_Designator is
     Root_Node_Record (Ada_Others_Designator);
   type Access_To_Subtype_For_Others_Designator is
     access all Subtype_For_Others_Designator;
   package Bare_Others_Designator_Alloc is new Alloc
     (Subtype_For_Others_Designator, Access_To_Subtype_For_Others_Designator);

   function Allocate_Others_Designator
     (Pool : Bump_Ptr_Pool) return Bare_Others_Designator;

   function Allocate_Others_Designator
     (Pool : Bump_Ptr_Pool) return Bare_Others_Designator
   is
      Result : constant Access_To_Subtype_For_Others_Designator :=
        Bare_Others_Designator_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Others_Designator;
      return Bare_Others_Designator (Result);
   end Allocate_Others_Designator;

   package Bare_Overriding_Node_Memos is new Langkit_Support.Packrat
     (Bare_Overriding_Node, Token_Index);

   package Bare_Overriding_Not_Overriding_Memos is new Langkit_Support.Packrat
     (Bare_Overriding_Not_Overriding, Token_Index);

   subtype Subtype_For_Overriding_Not_Overriding is
     Root_Node_Record (Ada_Overriding_Not_Overriding);
   type Access_To_Subtype_For_Overriding_Not_Overriding is
     access all Subtype_For_Overriding_Not_Overriding;
   package Bare_Overriding_Not_Overriding_Alloc is new Alloc
     (Subtype_For_Overriding_Not_Overriding,
      Access_To_Subtype_For_Overriding_Not_Overriding);

   function Allocate_Overriding_Not_Overriding
     (Pool : Bump_Ptr_Pool) return Bare_Overriding_Not_Overriding;

   function Allocate_Overriding_Not_Overriding
     (Pool : Bump_Ptr_Pool) return Bare_Overriding_Not_Overriding
   is
      Result : constant Access_To_Subtype_For_Overriding_Not_Overriding :=
        Bare_Overriding_Not_Overriding_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Overriding_Not_Overriding;
      return Bare_Overriding_Not_Overriding (Result);
   end Allocate_Overriding_Not_Overriding;

   package Bare_Overriding_Overriding_Memos is new Langkit_Support.Packrat
     (Bare_Overriding_Overriding, Token_Index);

   subtype Subtype_For_Overriding_Overriding is
     Root_Node_Record (Ada_Overriding_Overriding);
   type Access_To_Subtype_For_Overriding_Overriding is
     access all Subtype_For_Overriding_Overriding;
   package Bare_Overriding_Overriding_Alloc is new Alloc
     (Subtype_For_Overriding_Overriding,
      Access_To_Subtype_For_Overriding_Overriding);

   function Allocate_Overriding_Overriding
     (Pool : Bump_Ptr_Pool) return Bare_Overriding_Overriding;

   function Allocate_Overriding_Overriding
     (Pool : Bump_Ptr_Pool) return Bare_Overriding_Overriding
   is
      Result : constant Access_To_Subtype_For_Overriding_Overriding :=
        Bare_Overriding_Overriding_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Overriding_Overriding;
      return Bare_Overriding_Overriding (Result);
   end Allocate_Overriding_Overriding;

   package Bare_Overriding_Unspecified_Memos is new Langkit_Support.Packrat
     (Bare_Overriding_Unspecified, Token_Index);

   subtype Subtype_For_Overriding_Unspecified is
     Root_Node_Record (Ada_Overriding_Unspecified);
   type Access_To_Subtype_For_Overriding_Unspecified is
     access all Subtype_For_Overriding_Unspecified;
   package Bare_Overriding_Unspecified_Alloc is new Alloc
     (Subtype_For_Overriding_Unspecified,
      Access_To_Subtype_For_Overriding_Unspecified);

   function Allocate_Overriding_Unspecified
     (Pool : Bump_Ptr_Pool) return Bare_Overriding_Unspecified;

   function Allocate_Overriding_Unspecified
     (Pool : Bump_Ptr_Pool) return Bare_Overriding_Unspecified
   is
      Result : constant Access_To_Subtype_For_Overriding_Unspecified :=
        Bare_Overriding_Unspecified_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Overriding_Unspecified;
      return Bare_Overriding_Unspecified (Result);
   end Allocate_Overriding_Unspecified;

   package Bare_Params_Memos is new Langkit_Support.Packrat
     (Bare_Params, Token_Index);

   subtype Subtype_For_Params is Root_Node_Record (Ada_Params);
   type Access_To_Subtype_For_Params is access all Subtype_For_Params;
   package Bare_Params_Alloc is new Alloc
     (Subtype_For_Params, Access_To_Subtype_For_Params);

   function Allocate_Params (Pool : Bump_Ptr_Pool) return Bare_Params;

   function Allocate_Params (Pool : Bump_Ptr_Pool) return Bare_Params is
      Result : constant Access_To_Subtype_For_Params :=
        Bare_Params_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Params;
      return Bare_Params (Result);
   end Allocate_Params;

   package Bare_Pragma_Node_Memos is new Langkit_Support.Packrat
     (Bare_Pragma_Node, Token_Index);

   subtype Subtype_For_Pragma_Node is Root_Node_Record (Ada_Pragma_Node);
   type Access_To_Subtype_For_Pragma_Node is
     access all Subtype_For_Pragma_Node;
   package Bare_Pragma_Node_Alloc is new Alloc
     (Subtype_For_Pragma_Node, Access_To_Subtype_For_Pragma_Node);

   function Allocate_Pragma_Node
     (Pool : Bump_Ptr_Pool) return Bare_Pragma_Node;

   function Allocate_Pragma_Node (Pool : Bump_Ptr_Pool) return Bare_Pragma_Node
   is
      Result : constant Access_To_Subtype_For_Pragma_Node :=
        Bare_Pragma_Node_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Pragma_Node;
      return Bare_Pragma_Node (Result);
   end Allocate_Pragma_Node;

   package Bare_Prim_Type_Accessor_Memos is new Langkit_Support.Packrat
     (Bare_Prim_Type_Accessor, Token_Index);

   subtype Subtype_For_Prim_Type_Accessor is
     Root_Node_Record (Ada_Prim_Type_Accessor);
   type Access_To_Subtype_For_Prim_Type_Accessor is
     access all Subtype_For_Prim_Type_Accessor;
   package Bare_Prim_Type_Accessor_Alloc is new Alloc
     (Subtype_For_Prim_Type_Accessor,
      Access_To_Subtype_For_Prim_Type_Accessor);

   function Allocate_Prim_Type_Accessor
     (Pool : Bump_Ptr_Pool) return Bare_Prim_Type_Accessor;

   function Allocate_Prim_Type_Accessor
     (Pool : Bump_Ptr_Pool) return Bare_Prim_Type_Accessor
   is
      Result : constant Access_To_Subtype_For_Prim_Type_Accessor :=
        Bare_Prim_Type_Accessor_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Prim_Type_Accessor;
      return Bare_Prim_Type_Accessor (Result);
   end Allocate_Prim_Type_Accessor;

   package Bare_Private_Node_Memos is new Langkit_Support.Packrat
     (Bare_Private_Node, Token_Index);

   package Bare_Private_Absent_Memos is new Langkit_Support.Packrat
     (Bare_Private_Absent, Token_Index);

   subtype Subtype_For_Private_Absent is Root_Node_Record (Ada_Private_Absent);
   type Access_To_Subtype_For_Private_Absent is
     access all Subtype_For_Private_Absent;
   package Bare_Private_Absent_Alloc is new Alloc
     (Subtype_For_Private_Absent, Access_To_Subtype_For_Private_Absent);

   function Allocate_Private_Absent
     (Pool : Bump_Ptr_Pool) return Bare_Private_Absent;

   function Allocate_Private_Absent
     (Pool : Bump_Ptr_Pool) return Bare_Private_Absent
   is
      Result : constant Access_To_Subtype_For_Private_Absent :=
        Bare_Private_Absent_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Private_Absent;
      return Bare_Private_Absent (Result);
   end Allocate_Private_Absent;

   package Bare_Private_Present_Memos is new Langkit_Support.Packrat
     (Bare_Private_Present, Token_Index);

   subtype Subtype_For_Private_Present is
     Root_Node_Record (Ada_Private_Present);
   type Access_To_Subtype_For_Private_Present is
     access all Subtype_For_Private_Present;
   package Bare_Private_Present_Alloc is new Alloc
     (Subtype_For_Private_Present, Access_To_Subtype_For_Private_Present);

   function Allocate_Private_Present
     (Pool : Bump_Ptr_Pool) return Bare_Private_Present;

   function Allocate_Private_Present
     (Pool : Bump_Ptr_Pool) return Bare_Private_Present
   is
      Result : constant Access_To_Subtype_For_Private_Present :=
        Bare_Private_Present_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Private_Present;
      return Bare_Private_Present (Result);
   end Allocate_Private_Present;

   package Bare_Protected_Def_Memos is new Langkit_Support.Packrat
     (Bare_Protected_Def, Token_Index);

   subtype Subtype_For_Protected_Def is Root_Node_Record (Ada_Protected_Def);
   type Access_To_Subtype_For_Protected_Def is
     access all Subtype_For_Protected_Def;
   package Bare_Protected_Def_Alloc is new Alloc
     (Subtype_For_Protected_Def, Access_To_Subtype_For_Protected_Def);

   function Allocate_Protected_Def
     (Pool : Bump_Ptr_Pool) return Bare_Protected_Def;

   function Allocate_Protected_Def
     (Pool : Bump_Ptr_Pool) return Bare_Protected_Def
   is
      Result : constant Access_To_Subtype_For_Protected_Def :=
        Bare_Protected_Def_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Protected_Def;
      return Bare_Protected_Def (Result);
   end Allocate_Protected_Def;

   package Bare_Protected_Node_Memos is new Langkit_Support.Packrat
     (Bare_Protected_Node, Token_Index);

   package Bare_Protected_Absent_Memos is new Langkit_Support.Packrat
     (Bare_Protected_Absent, Token_Index);

   subtype Subtype_For_Protected_Absent is
     Root_Node_Record (Ada_Protected_Absent);
   type Access_To_Subtype_For_Protected_Absent is
     access all Subtype_For_Protected_Absent;
   package Bare_Protected_Absent_Alloc is new Alloc
     (Subtype_For_Protected_Absent, Access_To_Subtype_For_Protected_Absent);

   function Allocate_Protected_Absent
     (Pool : Bump_Ptr_Pool) return Bare_Protected_Absent;

   function Allocate_Protected_Absent
     (Pool : Bump_Ptr_Pool) return Bare_Protected_Absent
   is
      Result : constant Access_To_Subtype_For_Protected_Absent :=
        Bare_Protected_Absent_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Protected_Absent;
      return Bare_Protected_Absent (Result);
   end Allocate_Protected_Absent;

   package Bare_Protected_Present_Memos is new Langkit_Support.Packrat
     (Bare_Protected_Present, Token_Index);

   subtype Subtype_For_Protected_Present is
     Root_Node_Record (Ada_Protected_Present);
   type Access_To_Subtype_For_Protected_Present is
     access all Subtype_For_Protected_Present;
   package Bare_Protected_Present_Alloc is new Alloc
     (Subtype_For_Protected_Present, Access_To_Subtype_For_Protected_Present);

   function Allocate_Protected_Present
     (Pool : Bump_Ptr_Pool) return Bare_Protected_Present;

   function Allocate_Protected_Present
     (Pool : Bump_Ptr_Pool) return Bare_Protected_Present
   is
      Result : constant Access_To_Subtype_For_Protected_Present :=
        Bare_Protected_Present_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Protected_Present;
      return Bare_Protected_Present (Result);
   end Allocate_Protected_Present;

   package Bare_Quantifier_Memos is new Langkit_Support.Packrat
     (Bare_Quantifier, Token_Index);

   package Bare_Quantifier_All_Memos is new Langkit_Support.Packrat
     (Bare_Quantifier_All, Token_Index);

   subtype Subtype_For_Quantifier_All is Root_Node_Record (Ada_Quantifier_All);
   type Access_To_Subtype_For_Quantifier_All is
     access all Subtype_For_Quantifier_All;
   package Bare_Quantifier_All_Alloc is new Alloc
     (Subtype_For_Quantifier_All, Access_To_Subtype_For_Quantifier_All);

   function Allocate_Quantifier_All
     (Pool : Bump_Ptr_Pool) return Bare_Quantifier_All;

   function Allocate_Quantifier_All
     (Pool : Bump_Ptr_Pool) return Bare_Quantifier_All
   is
      Result : constant Access_To_Subtype_For_Quantifier_All :=
        Bare_Quantifier_All_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Quantifier_All;
      return Bare_Quantifier_All (Result);
   end Allocate_Quantifier_All;

   package Bare_Quantifier_Some_Memos is new Langkit_Support.Packrat
     (Bare_Quantifier_Some, Token_Index);

   subtype Subtype_For_Quantifier_Some is
     Root_Node_Record (Ada_Quantifier_Some);
   type Access_To_Subtype_For_Quantifier_Some is
     access all Subtype_For_Quantifier_Some;
   package Bare_Quantifier_Some_Alloc is new Alloc
     (Subtype_For_Quantifier_Some, Access_To_Subtype_For_Quantifier_Some);

   function Allocate_Quantifier_Some
     (Pool : Bump_Ptr_Pool) return Bare_Quantifier_Some;

   function Allocate_Quantifier_Some
     (Pool : Bump_Ptr_Pool) return Bare_Quantifier_Some
   is
      Result : constant Access_To_Subtype_For_Quantifier_Some :=
        Bare_Quantifier_Some_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Quantifier_Some;
      return Bare_Quantifier_Some (Result);
   end Allocate_Quantifier_Some;

   package Bare_Range_Spec_Memos is new Langkit_Support.Packrat
     (Bare_Range_Spec, Token_Index);

   subtype Subtype_For_Range_Spec is Root_Node_Record (Ada_Range_Spec);
   type Access_To_Subtype_For_Range_Spec is access all Subtype_For_Range_Spec;
   package Bare_Range_Spec_Alloc is new Alloc
     (Subtype_For_Range_Spec, Access_To_Subtype_For_Range_Spec);

   function Allocate_Range_Spec (Pool : Bump_Ptr_Pool) return Bare_Range_Spec;

   function Allocate_Range_Spec (Pool : Bump_Ptr_Pool) return Bare_Range_Spec
   is
      Result : constant Access_To_Subtype_For_Range_Spec :=
        Bare_Range_Spec_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Range_Spec;
      return Bare_Range_Spec (Result);
   end Allocate_Range_Spec;

   package Bare_Renaming_Clause_Memos is new Langkit_Support.Packrat
     (Bare_Renaming_Clause, Token_Index);

   subtype Subtype_For_Renaming_Clause is
     Root_Node_Record (Ada_Renaming_Clause);
   type Access_To_Subtype_For_Renaming_Clause is
     access all Subtype_For_Renaming_Clause;
   package Bare_Renaming_Clause_Alloc is new Alloc
     (Subtype_For_Renaming_Clause, Access_To_Subtype_For_Renaming_Clause);

   function Allocate_Renaming_Clause
     (Pool : Bump_Ptr_Pool) return Bare_Renaming_Clause;

   function Allocate_Renaming_Clause
     (Pool : Bump_Ptr_Pool) return Bare_Renaming_Clause
   is
      Result : constant Access_To_Subtype_For_Renaming_Clause :=
        Bare_Renaming_Clause_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Renaming_Clause;
      return Bare_Renaming_Clause (Result);
   end Allocate_Renaming_Clause;

   package Bare_Synthetic_Renaming_Clause_Memos is new Langkit_Support.Packrat
     (Bare_Synthetic_Renaming_Clause, Token_Index);

   subtype Subtype_For_Synthetic_Renaming_Clause is
     Root_Node_Record (Ada_Synthetic_Renaming_Clause);
   type Access_To_Subtype_For_Synthetic_Renaming_Clause is
     access all Subtype_For_Synthetic_Renaming_Clause;
   package Bare_Synthetic_Renaming_Clause_Alloc is new Alloc
     (Subtype_For_Synthetic_Renaming_Clause,
      Access_To_Subtype_For_Synthetic_Renaming_Clause);

   function Allocate_Synthetic_Renaming_Clause
     (Pool : Bump_Ptr_Pool) return Bare_Synthetic_Renaming_Clause;

   function Allocate_Synthetic_Renaming_Clause
     (Pool : Bump_Ptr_Pool) return Bare_Synthetic_Renaming_Clause
   is
      Result : constant Access_To_Subtype_For_Synthetic_Renaming_Clause :=
        Bare_Synthetic_Renaming_Clause_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Synthetic_Renaming_Clause;
      return Bare_Synthetic_Renaming_Clause (Result);
   end Allocate_Synthetic_Renaming_Clause;

   package Bare_Reverse_Node_Memos is new Langkit_Support.Packrat
     (Bare_Reverse_Node, Token_Index);

   package Bare_Reverse_Absent_Memos is new Langkit_Support.Packrat
     (Bare_Reverse_Absent, Token_Index);

   subtype Subtype_For_Reverse_Absent is Root_Node_Record (Ada_Reverse_Absent);
   type Access_To_Subtype_For_Reverse_Absent is
     access all Subtype_For_Reverse_Absent;
   package Bare_Reverse_Absent_Alloc is new Alloc
     (Subtype_For_Reverse_Absent, Access_To_Subtype_For_Reverse_Absent);

   function Allocate_Reverse_Absent
     (Pool : Bump_Ptr_Pool) return Bare_Reverse_Absent;

   function Allocate_Reverse_Absent
     (Pool : Bump_Ptr_Pool) return Bare_Reverse_Absent
   is
      Result : constant Access_To_Subtype_For_Reverse_Absent :=
        Bare_Reverse_Absent_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Reverse_Absent;
      return Bare_Reverse_Absent (Result);
   end Allocate_Reverse_Absent;

   package Bare_Reverse_Present_Memos is new Langkit_Support.Packrat
     (Bare_Reverse_Present, Token_Index);

   subtype Subtype_For_Reverse_Present is
     Root_Node_Record (Ada_Reverse_Present);
   type Access_To_Subtype_For_Reverse_Present is
     access all Subtype_For_Reverse_Present;
   package Bare_Reverse_Present_Alloc is new Alloc
     (Subtype_For_Reverse_Present, Access_To_Subtype_For_Reverse_Present);

   function Allocate_Reverse_Present
     (Pool : Bump_Ptr_Pool) return Bare_Reverse_Present;

   function Allocate_Reverse_Present
     (Pool : Bump_Ptr_Pool) return Bare_Reverse_Present
   is
      Result : constant Access_To_Subtype_For_Reverse_Present :=
        Bare_Reverse_Present_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Reverse_Present;
      return Bare_Reverse_Present (Result);
   end Allocate_Reverse_Present;

   package Bare_Select_When_Part_Memos is new Langkit_Support.Packrat
     (Bare_Select_When_Part, Token_Index);

   subtype Subtype_For_Select_When_Part is
     Root_Node_Record (Ada_Select_When_Part);
   type Access_To_Subtype_For_Select_When_Part is
     access all Subtype_For_Select_When_Part;
   package Bare_Select_When_Part_Alloc is new Alloc
     (Subtype_For_Select_When_Part, Access_To_Subtype_For_Select_When_Part);

   function Allocate_Select_When_Part
     (Pool : Bump_Ptr_Pool) return Bare_Select_When_Part;

   function Allocate_Select_When_Part
     (Pool : Bump_Ptr_Pool) return Bare_Select_When_Part
   is
      Result : constant Access_To_Subtype_For_Select_When_Part :=
        Bare_Select_When_Part_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Select_When_Part;
      return Bare_Select_When_Part (Result);
   end Allocate_Select_When_Part;

   package Bare_Stmt_Memos is new Langkit_Support.Packrat
     (Bare_Stmt, Token_Index);

   package Bare_Composite_Stmt_Memos is new Langkit_Support.Packrat
     (Bare_Composite_Stmt, Token_Index);

   package Bare_Accept_Stmt_Memos is new Langkit_Support.Packrat
     (Bare_Accept_Stmt, Token_Index);

   subtype Subtype_For_Accept_Stmt is Root_Node_Record (Ada_Accept_Stmt);
   type Access_To_Subtype_For_Accept_Stmt is
     access all Subtype_For_Accept_Stmt;
   package Bare_Accept_Stmt_Alloc is new Alloc
     (Subtype_For_Accept_Stmt, Access_To_Subtype_For_Accept_Stmt);

   function Allocate_Accept_Stmt
     (Pool : Bump_Ptr_Pool) return Bare_Accept_Stmt;

   function Allocate_Accept_Stmt (Pool : Bump_Ptr_Pool) return Bare_Accept_Stmt
   is
      Result : constant Access_To_Subtype_For_Accept_Stmt :=
        Bare_Accept_Stmt_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Accept_Stmt;
      return Bare_Accept_Stmt (Result);
   end Allocate_Accept_Stmt;

   package Bare_Accept_Stmt_With_Stmts_Memos is new Langkit_Support.Packrat
     (Bare_Accept_Stmt_With_Stmts, Token_Index);

   subtype Subtype_For_Accept_Stmt_With_Stmts is
     Root_Node_Record (Ada_Accept_Stmt_With_Stmts);
   type Access_To_Subtype_For_Accept_Stmt_With_Stmts is
     access all Subtype_For_Accept_Stmt_With_Stmts;
   package Bare_Accept_Stmt_With_Stmts_Alloc is new Alloc
     (Subtype_For_Accept_Stmt_With_Stmts,
      Access_To_Subtype_For_Accept_Stmt_With_Stmts);

   function Allocate_Accept_Stmt_With_Stmts
     (Pool : Bump_Ptr_Pool) return Bare_Accept_Stmt_With_Stmts;

   function Allocate_Accept_Stmt_With_Stmts
     (Pool : Bump_Ptr_Pool) return Bare_Accept_Stmt_With_Stmts
   is
      Result : constant Access_To_Subtype_For_Accept_Stmt_With_Stmts :=
        Bare_Accept_Stmt_With_Stmts_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Accept_Stmt_With_Stmts;
      return Bare_Accept_Stmt_With_Stmts (Result);
   end Allocate_Accept_Stmt_With_Stmts;

   package Bare_Base_Loop_Stmt_Memos is new Langkit_Support.Packrat
     (Bare_Base_Loop_Stmt, Token_Index);

   package Bare_For_Loop_Stmt_Memos is new Langkit_Support.Packrat
     (Bare_For_Loop_Stmt, Token_Index);

   subtype Subtype_For_For_Loop_Stmt is Root_Node_Record (Ada_For_Loop_Stmt);
   type Access_To_Subtype_For_For_Loop_Stmt is
     access all Subtype_For_For_Loop_Stmt;
   package Bare_For_Loop_Stmt_Alloc is new Alloc
     (Subtype_For_For_Loop_Stmt, Access_To_Subtype_For_For_Loop_Stmt);

   function Allocate_For_Loop_Stmt
     (Pool : Bump_Ptr_Pool) return Bare_For_Loop_Stmt;

   function Allocate_For_Loop_Stmt
     (Pool : Bump_Ptr_Pool) return Bare_For_Loop_Stmt
   is
      Result : constant Access_To_Subtype_For_For_Loop_Stmt :=
        Bare_For_Loop_Stmt_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_For_Loop_Stmt;
      return Bare_For_Loop_Stmt (Result);
   end Allocate_For_Loop_Stmt;

   package Bare_Loop_Stmt_Memos is new Langkit_Support.Packrat
     (Bare_Loop_Stmt, Token_Index);

   subtype Subtype_For_Loop_Stmt is Root_Node_Record (Ada_Loop_Stmt);
   type Access_To_Subtype_For_Loop_Stmt is access all Subtype_For_Loop_Stmt;
   package Bare_Loop_Stmt_Alloc is new Alloc
     (Subtype_For_Loop_Stmt, Access_To_Subtype_For_Loop_Stmt);

   function Allocate_Loop_Stmt (Pool : Bump_Ptr_Pool) return Bare_Loop_Stmt;

   function Allocate_Loop_Stmt (Pool : Bump_Ptr_Pool) return Bare_Loop_Stmt is
      Result : constant Access_To_Subtype_For_Loop_Stmt :=
        Bare_Loop_Stmt_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Loop_Stmt;
      return Bare_Loop_Stmt (Result);
   end Allocate_Loop_Stmt;

   package Bare_While_Loop_Stmt_Memos is new Langkit_Support.Packrat
     (Bare_While_Loop_Stmt, Token_Index);

   subtype Subtype_For_While_Loop_Stmt is
     Root_Node_Record (Ada_While_Loop_Stmt);
   type Access_To_Subtype_For_While_Loop_Stmt is
     access all Subtype_For_While_Loop_Stmt;
   package Bare_While_Loop_Stmt_Alloc is new Alloc
     (Subtype_For_While_Loop_Stmt, Access_To_Subtype_For_While_Loop_Stmt);

   function Allocate_While_Loop_Stmt
     (Pool : Bump_Ptr_Pool) return Bare_While_Loop_Stmt;

   function Allocate_While_Loop_Stmt
     (Pool : Bump_Ptr_Pool) return Bare_While_Loop_Stmt
   is
      Result : constant Access_To_Subtype_For_While_Loop_Stmt :=
        Bare_While_Loop_Stmt_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_While_Loop_Stmt;
      return Bare_While_Loop_Stmt (Result);
   end Allocate_While_Loop_Stmt;

   package Bare_Block_Stmt_Memos is new Langkit_Support.Packrat
     (Bare_Block_Stmt, Token_Index);

   package Bare_Begin_Block_Memos is new Langkit_Support.Packrat
     (Bare_Begin_Block, Token_Index);

   subtype Subtype_For_Begin_Block is Root_Node_Record (Ada_Begin_Block);
   type Access_To_Subtype_For_Begin_Block is
     access all Subtype_For_Begin_Block;
   package Bare_Begin_Block_Alloc is new Alloc
     (Subtype_For_Begin_Block, Access_To_Subtype_For_Begin_Block);

   function Allocate_Begin_Block
     (Pool : Bump_Ptr_Pool) return Bare_Begin_Block;

   function Allocate_Begin_Block (Pool : Bump_Ptr_Pool) return Bare_Begin_Block
   is
      Result : constant Access_To_Subtype_For_Begin_Block :=
        Bare_Begin_Block_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Begin_Block;
      return Bare_Begin_Block (Result);
   end Allocate_Begin_Block;

   package Bare_Decl_Block_Memos is new Langkit_Support.Packrat
     (Bare_Decl_Block, Token_Index);

   subtype Subtype_For_Decl_Block is Root_Node_Record (Ada_Decl_Block);
   type Access_To_Subtype_For_Decl_Block is access all Subtype_For_Decl_Block;
   package Bare_Decl_Block_Alloc is new Alloc
     (Subtype_For_Decl_Block, Access_To_Subtype_For_Decl_Block);

   function Allocate_Decl_Block (Pool : Bump_Ptr_Pool) return Bare_Decl_Block;

   function Allocate_Decl_Block (Pool : Bump_Ptr_Pool) return Bare_Decl_Block
   is
      Result : constant Access_To_Subtype_For_Decl_Block :=
        Bare_Decl_Block_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Decl_Block;
      return Bare_Decl_Block (Result);
   end Allocate_Decl_Block;

   package Bare_Case_Stmt_Memos is new Langkit_Support.Packrat
     (Bare_Case_Stmt, Token_Index);

   subtype Subtype_For_Case_Stmt is Root_Node_Record (Ada_Case_Stmt);
   type Access_To_Subtype_For_Case_Stmt is access all Subtype_For_Case_Stmt;
   package Bare_Case_Stmt_Alloc is new Alloc
     (Subtype_For_Case_Stmt, Access_To_Subtype_For_Case_Stmt);

   function Allocate_Case_Stmt (Pool : Bump_Ptr_Pool) return Bare_Case_Stmt;

   function Allocate_Case_Stmt (Pool : Bump_Ptr_Pool) return Bare_Case_Stmt is
      Result : constant Access_To_Subtype_For_Case_Stmt :=
        Bare_Case_Stmt_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Case_Stmt;
      return Bare_Case_Stmt (Result);
   end Allocate_Case_Stmt;

   package Bare_Extended_Return_Stmt_Memos is new Langkit_Support.Packrat
     (Bare_Extended_Return_Stmt, Token_Index);

   subtype Subtype_For_Extended_Return_Stmt is
     Root_Node_Record (Ada_Extended_Return_Stmt);
   type Access_To_Subtype_For_Extended_Return_Stmt is
     access all Subtype_For_Extended_Return_Stmt;
   package Bare_Extended_Return_Stmt_Alloc is new Alloc
     (Subtype_For_Extended_Return_Stmt,
      Access_To_Subtype_For_Extended_Return_Stmt);

   function Allocate_Extended_Return_Stmt
     (Pool : Bump_Ptr_Pool) return Bare_Extended_Return_Stmt;

   function Allocate_Extended_Return_Stmt
     (Pool : Bump_Ptr_Pool) return Bare_Extended_Return_Stmt
   is
      Result : constant Access_To_Subtype_For_Extended_Return_Stmt :=
        Bare_Extended_Return_Stmt_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Extended_Return_Stmt;
      return Bare_Extended_Return_Stmt (Result);
   end Allocate_Extended_Return_Stmt;

   package Bare_If_Stmt_Memos is new Langkit_Support.Packrat
     (Bare_If_Stmt, Token_Index);

   subtype Subtype_For_If_Stmt is Root_Node_Record (Ada_If_Stmt);
   type Access_To_Subtype_For_If_Stmt is access all Subtype_For_If_Stmt;
   package Bare_If_Stmt_Alloc is new Alloc
     (Subtype_For_If_Stmt, Access_To_Subtype_For_If_Stmt);

   function Allocate_If_Stmt (Pool : Bump_Ptr_Pool) return Bare_If_Stmt;

   function Allocate_If_Stmt (Pool : Bump_Ptr_Pool) return Bare_If_Stmt is
      Result : constant Access_To_Subtype_For_If_Stmt :=
        Bare_If_Stmt_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_If_Stmt;
      return Bare_If_Stmt (Result);
   end Allocate_If_Stmt;

   package Bare_Named_Stmt_Memos is new Langkit_Support.Packrat
     (Bare_Named_Stmt, Token_Index);

   subtype Subtype_For_Named_Stmt is Root_Node_Record (Ada_Named_Stmt);
   type Access_To_Subtype_For_Named_Stmt is access all Subtype_For_Named_Stmt;
   package Bare_Named_Stmt_Alloc is new Alloc
     (Subtype_For_Named_Stmt, Access_To_Subtype_For_Named_Stmt);

   function Allocate_Named_Stmt (Pool : Bump_Ptr_Pool) return Bare_Named_Stmt;

   function Allocate_Named_Stmt (Pool : Bump_Ptr_Pool) return Bare_Named_Stmt
   is
      Result : constant Access_To_Subtype_For_Named_Stmt :=
        Bare_Named_Stmt_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Named_Stmt;
      return Bare_Named_Stmt (Result);
   end Allocate_Named_Stmt;

   package Bare_Select_Stmt_Memos is new Langkit_Support.Packrat
     (Bare_Select_Stmt, Token_Index);

   subtype Subtype_For_Select_Stmt is Root_Node_Record (Ada_Select_Stmt);
   type Access_To_Subtype_For_Select_Stmt is
     access all Subtype_For_Select_Stmt;
   package Bare_Select_Stmt_Alloc is new Alloc
     (Subtype_For_Select_Stmt, Access_To_Subtype_For_Select_Stmt);

   function Allocate_Select_Stmt
     (Pool : Bump_Ptr_Pool) return Bare_Select_Stmt;

   function Allocate_Select_Stmt (Pool : Bump_Ptr_Pool) return Bare_Select_Stmt
   is
      Result : constant Access_To_Subtype_For_Select_Stmt :=
        Bare_Select_Stmt_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Select_Stmt;
      return Bare_Select_Stmt (Result);
   end Allocate_Select_Stmt;

   package Bare_Error_Stmt_Memos is new Langkit_Support.Packrat
     (Bare_Error_Stmt, Token_Index);

   subtype Subtype_For_Error_Stmt is Root_Node_Record (Ada_Error_Stmt);
   type Access_To_Subtype_For_Error_Stmt is access all Subtype_For_Error_Stmt;
   package Bare_Error_Stmt_Alloc is new Alloc
     (Subtype_For_Error_Stmt, Access_To_Subtype_For_Error_Stmt);

   function Allocate_Error_Stmt (Pool : Bump_Ptr_Pool) return Bare_Error_Stmt;

   function Allocate_Error_Stmt (Pool : Bump_Ptr_Pool) return Bare_Error_Stmt
   is
      Result : constant Access_To_Subtype_For_Error_Stmt :=
        Bare_Error_Stmt_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Error_Stmt;
      return Bare_Error_Stmt (Result);
   end Allocate_Error_Stmt;

   package Bare_Simple_Stmt_Memos is new Langkit_Support.Packrat
     (Bare_Simple_Stmt, Token_Index);

   package Bare_Abort_Stmt_Memos is new Langkit_Support.Packrat
     (Bare_Abort_Stmt, Token_Index);

   subtype Subtype_For_Abort_Stmt is Root_Node_Record (Ada_Abort_Stmt);
   type Access_To_Subtype_For_Abort_Stmt is access all Subtype_For_Abort_Stmt;
   package Bare_Abort_Stmt_Alloc is new Alloc
     (Subtype_For_Abort_Stmt, Access_To_Subtype_For_Abort_Stmt);

   function Allocate_Abort_Stmt (Pool : Bump_Ptr_Pool) return Bare_Abort_Stmt;

   function Allocate_Abort_Stmt (Pool : Bump_Ptr_Pool) return Bare_Abort_Stmt
   is
      Result : constant Access_To_Subtype_For_Abort_Stmt :=
        Bare_Abort_Stmt_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Abort_Stmt;
      return Bare_Abort_Stmt (Result);
   end Allocate_Abort_Stmt;

   package Bare_Assign_Stmt_Memos is new Langkit_Support.Packrat
     (Bare_Assign_Stmt, Token_Index);

   subtype Subtype_For_Assign_Stmt is Root_Node_Record (Ada_Assign_Stmt);
   type Access_To_Subtype_For_Assign_Stmt is
     access all Subtype_For_Assign_Stmt;
   package Bare_Assign_Stmt_Alloc is new Alloc
     (Subtype_For_Assign_Stmt, Access_To_Subtype_For_Assign_Stmt);

   function Allocate_Assign_Stmt
     (Pool : Bump_Ptr_Pool) return Bare_Assign_Stmt;

   function Allocate_Assign_Stmt (Pool : Bump_Ptr_Pool) return Bare_Assign_Stmt
   is
      Result : constant Access_To_Subtype_For_Assign_Stmt :=
        Bare_Assign_Stmt_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Assign_Stmt;
      return Bare_Assign_Stmt (Result);
   end Allocate_Assign_Stmt;

   package Bare_Call_Stmt_Memos is new Langkit_Support.Packrat
     (Bare_Call_Stmt, Token_Index);

   subtype Subtype_For_Call_Stmt is Root_Node_Record (Ada_Call_Stmt);
   type Access_To_Subtype_For_Call_Stmt is access all Subtype_For_Call_Stmt;
   package Bare_Call_Stmt_Alloc is new Alloc
     (Subtype_For_Call_Stmt, Access_To_Subtype_For_Call_Stmt);

   function Allocate_Call_Stmt (Pool : Bump_Ptr_Pool) return Bare_Call_Stmt;

   function Allocate_Call_Stmt (Pool : Bump_Ptr_Pool) return Bare_Call_Stmt is
      Result : constant Access_To_Subtype_For_Call_Stmt :=
        Bare_Call_Stmt_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Call_Stmt;
      return Bare_Call_Stmt (Result);
   end Allocate_Call_Stmt;

   package Bare_Delay_Stmt_Memos is new Langkit_Support.Packrat
     (Bare_Delay_Stmt, Token_Index);

   subtype Subtype_For_Delay_Stmt is Root_Node_Record (Ada_Delay_Stmt);
   type Access_To_Subtype_For_Delay_Stmt is access all Subtype_For_Delay_Stmt;
   package Bare_Delay_Stmt_Alloc is new Alloc
     (Subtype_For_Delay_Stmt, Access_To_Subtype_For_Delay_Stmt);

   function Allocate_Delay_Stmt (Pool : Bump_Ptr_Pool) return Bare_Delay_Stmt;

   function Allocate_Delay_Stmt (Pool : Bump_Ptr_Pool) return Bare_Delay_Stmt
   is
      Result : constant Access_To_Subtype_For_Delay_Stmt :=
        Bare_Delay_Stmt_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Delay_Stmt;
      return Bare_Delay_Stmt (Result);
   end Allocate_Delay_Stmt;

   package Bare_Exit_Stmt_Memos is new Langkit_Support.Packrat
     (Bare_Exit_Stmt, Token_Index);

   subtype Subtype_For_Exit_Stmt is Root_Node_Record (Ada_Exit_Stmt);
   type Access_To_Subtype_For_Exit_Stmt is access all Subtype_For_Exit_Stmt;
   package Bare_Exit_Stmt_Alloc is new Alloc
     (Subtype_For_Exit_Stmt, Access_To_Subtype_For_Exit_Stmt);

   function Allocate_Exit_Stmt (Pool : Bump_Ptr_Pool) return Bare_Exit_Stmt;

   function Allocate_Exit_Stmt (Pool : Bump_Ptr_Pool) return Bare_Exit_Stmt is
      Result : constant Access_To_Subtype_For_Exit_Stmt :=
        Bare_Exit_Stmt_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Exit_Stmt;
      return Bare_Exit_Stmt (Result);
   end Allocate_Exit_Stmt;

   package Bare_Goto_Stmt_Memos is new Langkit_Support.Packrat
     (Bare_Goto_Stmt, Token_Index);

   subtype Subtype_For_Goto_Stmt is Root_Node_Record (Ada_Goto_Stmt);
   type Access_To_Subtype_For_Goto_Stmt is access all Subtype_For_Goto_Stmt;
   package Bare_Goto_Stmt_Alloc is new Alloc
     (Subtype_For_Goto_Stmt, Access_To_Subtype_For_Goto_Stmt);

   function Allocate_Goto_Stmt (Pool : Bump_Ptr_Pool) return Bare_Goto_Stmt;

   function Allocate_Goto_Stmt (Pool : Bump_Ptr_Pool) return Bare_Goto_Stmt is
      Result : constant Access_To_Subtype_For_Goto_Stmt :=
        Bare_Goto_Stmt_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Goto_Stmt;
      return Bare_Goto_Stmt (Result);
   end Allocate_Goto_Stmt;

   package Bare_Label_Memos is new Langkit_Support.Packrat
     (Bare_Label, Token_Index);

   subtype Subtype_For_Label is Root_Node_Record (Ada_Label);
   type Access_To_Subtype_For_Label is access all Subtype_For_Label;
   package Bare_Label_Alloc is new Alloc
     (Subtype_For_Label, Access_To_Subtype_For_Label);

   function Allocate_Label (Pool : Bump_Ptr_Pool) return Bare_Label;

   function Allocate_Label (Pool : Bump_Ptr_Pool) return Bare_Label is
      Result : constant Access_To_Subtype_For_Label :=
        Bare_Label_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Label;
      return Bare_Label (Result);
   end Allocate_Label;

   package Bare_Null_Stmt_Memos is new Langkit_Support.Packrat
     (Bare_Null_Stmt, Token_Index);

   subtype Subtype_For_Null_Stmt is Root_Node_Record (Ada_Null_Stmt);
   type Access_To_Subtype_For_Null_Stmt is access all Subtype_For_Null_Stmt;
   package Bare_Null_Stmt_Alloc is new Alloc
     (Subtype_For_Null_Stmt, Access_To_Subtype_For_Null_Stmt);

   function Allocate_Null_Stmt (Pool : Bump_Ptr_Pool) return Bare_Null_Stmt;

   function Allocate_Null_Stmt (Pool : Bump_Ptr_Pool) return Bare_Null_Stmt is
      Result : constant Access_To_Subtype_For_Null_Stmt :=
        Bare_Null_Stmt_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Null_Stmt;
      return Bare_Null_Stmt (Result);
   end Allocate_Null_Stmt;

   package Bare_Raise_Stmt_Memos is new Langkit_Support.Packrat
     (Bare_Raise_Stmt, Token_Index);

   subtype Subtype_For_Raise_Stmt is Root_Node_Record (Ada_Raise_Stmt);
   type Access_To_Subtype_For_Raise_Stmt is access all Subtype_For_Raise_Stmt;
   package Bare_Raise_Stmt_Alloc is new Alloc
     (Subtype_For_Raise_Stmt, Access_To_Subtype_For_Raise_Stmt);

   function Allocate_Raise_Stmt (Pool : Bump_Ptr_Pool) return Bare_Raise_Stmt;

   function Allocate_Raise_Stmt (Pool : Bump_Ptr_Pool) return Bare_Raise_Stmt
   is
      Result : constant Access_To_Subtype_For_Raise_Stmt :=
        Bare_Raise_Stmt_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Raise_Stmt;
      return Bare_Raise_Stmt (Result);
   end Allocate_Raise_Stmt;

   package Bare_Requeue_Stmt_Memos is new Langkit_Support.Packrat
     (Bare_Requeue_Stmt, Token_Index);

   subtype Subtype_For_Requeue_Stmt is Root_Node_Record (Ada_Requeue_Stmt);
   type Access_To_Subtype_For_Requeue_Stmt is
     access all Subtype_For_Requeue_Stmt;
   package Bare_Requeue_Stmt_Alloc is new Alloc
     (Subtype_For_Requeue_Stmt, Access_To_Subtype_For_Requeue_Stmt);

   function Allocate_Requeue_Stmt
     (Pool : Bump_Ptr_Pool) return Bare_Requeue_Stmt;

   function Allocate_Requeue_Stmt
     (Pool : Bump_Ptr_Pool) return Bare_Requeue_Stmt
   is
      Result : constant Access_To_Subtype_For_Requeue_Stmt :=
        Bare_Requeue_Stmt_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Requeue_Stmt;
      return Bare_Requeue_Stmt (Result);
   end Allocate_Requeue_Stmt;

   package Bare_Return_Stmt_Memos is new Langkit_Support.Packrat
     (Bare_Return_Stmt, Token_Index);

   subtype Subtype_For_Return_Stmt is Root_Node_Record (Ada_Return_Stmt);
   type Access_To_Subtype_For_Return_Stmt is
     access all Subtype_For_Return_Stmt;
   package Bare_Return_Stmt_Alloc is new Alloc
     (Subtype_For_Return_Stmt, Access_To_Subtype_For_Return_Stmt);

   function Allocate_Return_Stmt
     (Pool : Bump_Ptr_Pool) return Bare_Return_Stmt;

   function Allocate_Return_Stmt (Pool : Bump_Ptr_Pool) return Bare_Return_Stmt
   is
      Result : constant Access_To_Subtype_For_Return_Stmt :=
        Bare_Return_Stmt_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Return_Stmt;
      return Bare_Return_Stmt (Result);
   end Allocate_Return_Stmt;

   package Bare_Terminate_Alternative_Memos is new Langkit_Support.Packrat
     (Bare_Terminate_Alternative, Token_Index);

   subtype Subtype_For_Terminate_Alternative is
     Root_Node_Record (Ada_Terminate_Alternative);
   type Access_To_Subtype_For_Terminate_Alternative is
     access all Subtype_For_Terminate_Alternative;
   package Bare_Terminate_Alternative_Alloc is new Alloc
     (Subtype_For_Terminate_Alternative,
      Access_To_Subtype_For_Terminate_Alternative);

   function Allocate_Terminate_Alternative
     (Pool : Bump_Ptr_Pool) return Bare_Terminate_Alternative;

   function Allocate_Terminate_Alternative
     (Pool : Bump_Ptr_Pool) return Bare_Terminate_Alternative
   is
      Result : constant Access_To_Subtype_For_Terminate_Alternative :=
        Bare_Terminate_Alternative_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Terminate_Alternative;
      return Bare_Terminate_Alternative (Result);
   end Allocate_Terminate_Alternative;

   package Bare_Subp_Kind_Memos is new Langkit_Support.Packrat
     (Bare_Subp_Kind, Token_Index);

   package Bare_Subp_Kind_Function_Memos is new Langkit_Support.Packrat
     (Bare_Subp_Kind_Function, Token_Index);

   subtype Subtype_For_Subp_Kind_Function is
     Root_Node_Record (Ada_Subp_Kind_Function);
   type Access_To_Subtype_For_Subp_Kind_Function is
     access all Subtype_For_Subp_Kind_Function;
   package Bare_Subp_Kind_Function_Alloc is new Alloc
     (Subtype_For_Subp_Kind_Function,
      Access_To_Subtype_For_Subp_Kind_Function);

   function Allocate_Subp_Kind_Function
     (Pool : Bump_Ptr_Pool) return Bare_Subp_Kind_Function;

   function Allocate_Subp_Kind_Function
     (Pool : Bump_Ptr_Pool) return Bare_Subp_Kind_Function
   is
      Result : constant Access_To_Subtype_For_Subp_Kind_Function :=
        Bare_Subp_Kind_Function_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Subp_Kind_Function;
      return Bare_Subp_Kind_Function (Result);
   end Allocate_Subp_Kind_Function;

   package Bare_Subp_Kind_Procedure_Memos is new Langkit_Support.Packrat
     (Bare_Subp_Kind_Procedure, Token_Index);

   subtype Subtype_For_Subp_Kind_Procedure is
     Root_Node_Record (Ada_Subp_Kind_Procedure);
   type Access_To_Subtype_For_Subp_Kind_Procedure is
     access all Subtype_For_Subp_Kind_Procedure;
   package Bare_Subp_Kind_Procedure_Alloc is new Alloc
     (Subtype_For_Subp_Kind_Procedure,
      Access_To_Subtype_For_Subp_Kind_Procedure);

   function Allocate_Subp_Kind_Procedure
     (Pool : Bump_Ptr_Pool) return Bare_Subp_Kind_Procedure;

   function Allocate_Subp_Kind_Procedure
     (Pool : Bump_Ptr_Pool) return Bare_Subp_Kind_Procedure
   is
      Result : constant Access_To_Subtype_For_Subp_Kind_Procedure :=
        Bare_Subp_Kind_Procedure_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Subp_Kind_Procedure;
      return Bare_Subp_Kind_Procedure (Result);
   end Allocate_Subp_Kind_Procedure;

   package Bare_Subunit_Memos is new Langkit_Support.Packrat
     (Bare_Subunit, Token_Index);

   subtype Subtype_For_Subunit is Root_Node_Record (Ada_Subunit);
   type Access_To_Subtype_For_Subunit is access all Subtype_For_Subunit;
   package Bare_Subunit_Alloc is new Alloc
     (Subtype_For_Subunit, Access_To_Subtype_For_Subunit);

   function Allocate_Subunit (Pool : Bump_Ptr_Pool) return Bare_Subunit;

   function Allocate_Subunit (Pool : Bump_Ptr_Pool) return Bare_Subunit is
      Result : constant Access_To_Subtype_For_Subunit :=
        Bare_Subunit_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Subunit;
      return Bare_Subunit (Result);
   end Allocate_Subunit;

   package Bare_Synchronized_Node_Memos is new Langkit_Support.Packrat
     (Bare_Synchronized_Node, Token_Index);

   package Bare_Synchronized_Absent_Memos is new Langkit_Support.Packrat
     (Bare_Synchronized_Absent, Token_Index);

   subtype Subtype_For_Synchronized_Absent is
     Root_Node_Record (Ada_Synchronized_Absent);
   type Access_To_Subtype_For_Synchronized_Absent is
     access all Subtype_For_Synchronized_Absent;
   package Bare_Synchronized_Absent_Alloc is new Alloc
     (Subtype_For_Synchronized_Absent,
      Access_To_Subtype_For_Synchronized_Absent);

   function Allocate_Synchronized_Absent
     (Pool : Bump_Ptr_Pool) return Bare_Synchronized_Absent;

   function Allocate_Synchronized_Absent
     (Pool : Bump_Ptr_Pool) return Bare_Synchronized_Absent
   is
      Result : constant Access_To_Subtype_For_Synchronized_Absent :=
        Bare_Synchronized_Absent_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Synchronized_Absent;
      return Bare_Synchronized_Absent (Result);
   end Allocate_Synchronized_Absent;

   package Bare_Synchronized_Present_Memos is new Langkit_Support.Packrat
     (Bare_Synchronized_Present, Token_Index);

   subtype Subtype_For_Synchronized_Present is
     Root_Node_Record (Ada_Synchronized_Present);
   type Access_To_Subtype_For_Synchronized_Present is
     access all Subtype_For_Synchronized_Present;
   package Bare_Synchronized_Present_Alloc is new Alloc
     (Subtype_For_Synchronized_Present,
      Access_To_Subtype_For_Synchronized_Present);

   function Allocate_Synchronized_Present
     (Pool : Bump_Ptr_Pool) return Bare_Synchronized_Present;

   function Allocate_Synchronized_Present
     (Pool : Bump_Ptr_Pool) return Bare_Synchronized_Present
   is
      Result : constant Access_To_Subtype_For_Synchronized_Present :=
        Bare_Synchronized_Present_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Synchronized_Present;
      return Bare_Synchronized_Present (Result);
   end Allocate_Synchronized_Present;

   package Bare_Tagged_Node_Memos is new Langkit_Support.Packrat
     (Bare_Tagged_Node, Token_Index);

   package Bare_Tagged_Absent_Memos is new Langkit_Support.Packrat
     (Bare_Tagged_Absent, Token_Index);

   subtype Subtype_For_Tagged_Absent is Root_Node_Record (Ada_Tagged_Absent);
   type Access_To_Subtype_For_Tagged_Absent is
     access all Subtype_For_Tagged_Absent;
   package Bare_Tagged_Absent_Alloc is new Alloc
     (Subtype_For_Tagged_Absent, Access_To_Subtype_For_Tagged_Absent);

   function Allocate_Tagged_Absent
     (Pool : Bump_Ptr_Pool) return Bare_Tagged_Absent;

   function Allocate_Tagged_Absent
     (Pool : Bump_Ptr_Pool) return Bare_Tagged_Absent
   is
      Result : constant Access_To_Subtype_For_Tagged_Absent :=
        Bare_Tagged_Absent_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Tagged_Absent;
      return Bare_Tagged_Absent (Result);
   end Allocate_Tagged_Absent;

   package Bare_Tagged_Present_Memos is new Langkit_Support.Packrat
     (Bare_Tagged_Present, Token_Index);

   subtype Subtype_For_Tagged_Present is Root_Node_Record (Ada_Tagged_Present);
   type Access_To_Subtype_For_Tagged_Present is
     access all Subtype_For_Tagged_Present;
   package Bare_Tagged_Present_Alloc is new Alloc
     (Subtype_For_Tagged_Present, Access_To_Subtype_For_Tagged_Present);

   function Allocate_Tagged_Present
     (Pool : Bump_Ptr_Pool) return Bare_Tagged_Present;

   function Allocate_Tagged_Present
     (Pool : Bump_Ptr_Pool) return Bare_Tagged_Present
   is
      Result : constant Access_To_Subtype_For_Tagged_Present :=
        Bare_Tagged_Present_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Tagged_Present;
      return Bare_Tagged_Present (Result);
   end Allocate_Tagged_Present;

   package Bare_Task_Def_Memos is new Langkit_Support.Packrat
     (Bare_Task_Def, Token_Index);

   subtype Subtype_For_Task_Def is Root_Node_Record (Ada_Task_Def);
   type Access_To_Subtype_For_Task_Def is access all Subtype_For_Task_Def;
   package Bare_Task_Def_Alloc is new Alloc
     (Subtype_For_Task_Def, Access_To_Subtype_For_Task_Def);

   function Allocate_Task_Def (Pool : Bump_Ptr_Pool) return Bare_Task_Def;

   function Allocate_Task_Def (Pool : Bump_Ptr_Pool) return Bare_Task_Def is
      Result : constant Access_To_Subtype_For_Task_Def :=
        Bare_Task_Def_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Task_Def;
      return Bare_Task_Def (Result);
   end Allocate_Task_Def;

   package Bare_Type_Def_Memos is new Langkit_Support.Packrat
     (Bare_Type_Def, Token_Index);

   package Bare_Access_Def_Memos is new Langkit_Support.Packrat
     (Bare_Access_Def, Token_Index);

   package Bare_Access_To_Subp_Def_Memos is new Langkit_Support.Packrat
     (Bare_Access_To_Subp_Def, Token_Index);

   subtype Subtype_For_Access_To_Subp_Def is
     Root_Node_Record (Ada_Access_To_Subp_Def);
   type Access_To_Subtype_For_Access_To_Subp_Def is
     access all Subtype_For_Access_To_Subp_Def;
   package Bare_Access_To_Subp_Def_Alloc is new Alloc
     (Subtype_For_Access_To_Subp_Def,
      Access_To_Subtype_For_Access_To_Subp_Def);

   function Allocate_Access_To_Subp_Def
     (Pool : Bump_Ptr_Pool) return Bare_Access_To_Subp_Def;

   function Allocate_Access_To_Subp_Def
     (Pool : Bump_Ptr_Pool) return Bare_Access_To_Subp_Def
   is
      Result : constant Access_To_Subtype_For_Access_To_Subp_Def :=
        Bare_Access_To_Subp_Def_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Access_To_Subp_Def;
      return Bare_Access_To_Subp_Def (Result);
   end Allocate_Access_To_Subp_Def;

   package Bare_Base_Type_Access_Def_Memos is new Langkit_Support.Packrat
     (Bare_Base_Type_Access_Def, Token_Index);

   package Bare_Anonymous_Type_Access_Def_Memos is new Langkit_Support.Packrat
     (Bare_Anonymous_Type_Access_Def, Token_Index);

   subtype Subtype_For_Anonymous_Type_Access_Def is
     Root_Node_Record (Ada_Anonymous_Type_Access_Def);
   type Access_To_Subtype_For_Anonymous_Type_Access_Def is
     access all Subtype_For_Anonymous_Type_Access_Def;
   package Bare_Anonymous_Type_Access_Def_Alloc is new Alloc
     (Subtype_For_Anonymous_Type_Access_Def,
      Access_To_Subtype_For_Anonymous_Type_Access_Def);

   function Allocate_Anonymous_Type_Access_Def
     (Pool : Bump_Ptr_Pool) return Bare_Anonymous_Type_Access_Def;

   function Allocate_Anonymous_Type_Access_Def
     (Pool : Bump_Ptr_Pool) return Bare_Anonymous_Type_Access_Def
   is
      Result : constant Access_To_Subtype_For_Anonymous_Type_Access_Def :=
        Bare_Anonymous_Type_Access_Def_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Anonymous_Type_Access_Def;
      return Bare_Anonymous_Type_Access_Def (Result);
   end Allocate_Anonymous_Type_Access_Def;

   package Bare_Type_Access_Def_Memos is new Langkit_Support.Packrat
     (Bare_Type_Access_Def, Token_Index);

   subtype Subtype_For_Type_Access_Def is
     Root_Node_Record (Ada_Type_Access_Def);
   type Access_To_Subtype_For_Type_Access_Def is
     access all Subtype_For_Type_Access_Def;
   package Bare_Type_Access_Def_Alloc is new Alloc
     (Subtype_For_Type_Access_Def, Access_To_Subtype_For_Type_Access_Def);

   function Allocate_Type_Access_Def
     (Pool : Bump_Ptr_Pool) return Bare_Type_Access_Def;

   function Allocate_Type_Access_Def
     (Pool : Bump_Ptr_Pool) return Bare_Type_Access_Def
   is
      Result : constant Access_To_Subtype_For_Type_Access_Def :=
        Bare_Type_Access_Def_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Type_Access_Def;
      return Bare_Type_Access_Def (Result);
   end Allocate_Type_Access_Def;

   package Bare_Array_Type_Def_Memos is new Langkit_Support.Packrat
     (Bare_Array_Type_Def, Token_Index);

   subtype Subtype_For_Array_Type_Def is Root_Node_Record (Ada_Array_Type_Def);
   type Access_To_Subtype_For_Array_Type_Def is
     access all Subtype_For_Array_Type_Def;
   package Bare_Array_Type_Def_Alloc is new Alloc
     (Subtype_For_Array_Type_Def, Access_To_Subtype_For_Array_Type_Def);

   function Allocate_Array_Type_Def
     (Pool : Bump_Ptr_Pool) return Bare_Array_Type_Def;

   function Allocate_Array_Type_Def
     (Pool : Bump_Ptr_Pool) return Bare_Array_Type_Def
   is
      Result : constant Access_To_Subtype_For_Array_Type_Def :=
        Bare_Array_Type_Def_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Array_Type_Def;
      return Bare_Array_Type_Def (Result);
   end Allocate_Array_Type_Def;

   package Bare_Derived_Type_Def_Memos is new Langkit_Support.Packrat
     (Bare_Derived_Type_Def, Token_Index);

   subtype Subtype_For_Derived_Type_Def is
     Root_Node_Record (Ada_Derived_Type_Def);
   type Access_To_Subtype_For_Derived_Type_Def is
     access all Subtype_For_Derived_Type_Def;
   package Bare_Derived_Type_Def_Alloc is new Alloc
     (Subtype_For_Derived_Type_Def, Access_To_Subtype_For_Derived_Type_Def);

   function Allocate_Derived_Type_Def
     (Pool : Bump_Ptr_Pool) return Bare_Derived_Type_Def;

   function Allocate_Derived_Type_Def
     (Pool : Bump_Ptr_Pool) return Bare_Derived_Type_Def
   is
      Result : constant Access_To_Subtype_For_Derived_Type_Def :=
        Bare_Derived_Type_Def_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Derived_Type_Def;
      return Bare_Derived_Type_Def (Result);
   end Allocate_Derived_Type_Def;

   package Bare_Enum_Type_Def_Memos is new Langkit_Support.Packrat
     (Bare_Enum_Type_Def, Token_Index);

   subtype Subtype_For_Enum_Type_Def is Root_Node_Record (Ada_Enum_Type_Def);
   type Access_To_Subtype_For_Enum_Type_Def is
     access all Subtype_For_Enum_Type_Def;
   package Bare_Enum_Type_Def_Alloc is new Alloc
     (Subtype_For_Enum_Type_Def, Access_To_Subtype_For_Enum_Type_Def);

   function Allocate_Enum_Type_Def
     (Pool : Bump_Ptr_Pool) return Bare_Enum_Type_Def;

   function Allocate_Enum_Type_Def
     (Pool : Bump_Ptr_Pool) return Bare_Enum_Type_Def
   is
      Result : constant Access_To_Subtype_For_Enum_Type_Def :=
        Bare_Enum_Type_Def_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Enum_Type_Def;
      return Bare_Enum_Type_Def (Result);
   end Allocate_Enum_Type_Def;

   package Bare_Formal_Discrete_Type_Def_Memos is new Langkit_Support.Packrat
     (Bare_Formal_Discrete_Type_Def, Token_Index);

   subtype Subtype_For_Formal_Discrete_Type_Def is
     Root_Node_Record (Ada_Formal_Discrete_Type_Def);
   type Access_To_Subtype_For_Formal_Discrete_Type_Def is
     access all Subtype_For_Formal_Discrete_Type_Def;
   package Bare_Formal_Discrete_Type_Def_Alloc is new Alloc
     (Subtype_For_Formal_Discrete_Type_Def,
      Access_To_Subtype_For_Formal_Discrete_Type_Def);

   function Allocate_Formal_Discrete_Type_Def
     (Pool : Bump_Ptr_Pool) return Bare_Formal_Discrete_Type_Def;

   function Allocate_Formal_Discrete_Type_Def
     (Pool : Bump_Ptr_Pool) return Bare_Formal_Discrete_Type_Def
   is
      Result : constant Access_To_Subtype_For_Formal_Discrete_Type_Def :=
        Bare_Formal_Discrete_Type_Def_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Formal_Discrete_Type_Def;
      return Bare_Formal_Discrete_Type_Def (Result);
   end Allocate_Formal_Discrete_Type_Def;

   package Bare_Interface_Type_Def_Memos is new Langkit_Support.Packrat
     (Bare_Interface_Type_Def, Token_Index);

   subtype Subtype_For_Interface_Type_Def is
     Root_Node_Record (Ada_Interface_Type_Def);
   type Access_To_Subtype_For_Interface_Type_Def is
     access all Subtype_For_Interface_Type_Def;
   package Bare_Interface_Type_Def_Alloc is new Alloc
     (Subtype_For_Interface_Type_Def,
      Access_To_Subtype_For_Interface_Type_Def);

   function Allocate_Interface_Type_Def
     (Pool : Bump_Ptr_Pool) return Bare_Interface_Type_Def;

   function Allocate_Interface_Type_Def
     (Pool : Bump_Ptr_Pool) return Bare_Interface_Type_Def
   is
      Result : constant Access_To_Subtype_For_Interface_Type_Def :=
        Bare_Interface_Type_Def_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Interface_Type_Def;
      return Bare_Interface_Type_Def (Result);
   end Allocate_Interface_Type_Def;

   package Bare_Mod_Int_Type_Def_Memos is new Langkit_Support.Packrat
     (Bare_Mod_Int_Type_Def, Token_Index);

   subtype Subtype_For_Mod_Int_Type_Def is
     Root_Node_Record (Ada_Mod_Int_Type_Def);
   type Access_To_Subtype_For_Mod_Int_Type_Def is
     access all Subtype_For_Mod_Int_Type_Def;
   package Bare_Mod_Int_Type_Def_Alloc is new Alloc
     (Subtype_For_Mod_Int_Type_Def, Access_To_Subtype_For_Mod_Int_Type_Def);

   function Allocate_Mod_Int_Type_Def
     (Pool : Bump_Ptr_Pool) return Bare_Mod_Int_Type_Def;

   function Allocate_Mod_Int_Type_Def
     (Pool : Bump_Ptr_Pool) return Bare_Mod_Int_Type_Def
   is
      Result : constant Access_To_Subtype_For_Mod_Int_Type_Def :=
        Bare_Mod_Int_Type_Def_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Mod_Int_Type_Def;
      return Bare_Mod_Int_Type_Def (Result);
   end Allocate_Mod_Int_Type_Def;

   package Bare_Private_Type_Def_Memos is new Langkit_Support.Packrat
     (Bare_Private_Type_Def, Token_Index);

   subtype Subtype_For_Private_Type_Def is
     Root_Node_Record (Ada_Private_Type_Def);
   type Access_To_Subtype_For_Private_Type_Def is
     access all Subtype_For_Private_Type_Def;
   package Bare_Private_Type_Def_Alloc is new Alloc
     (Subtype_For_Private_Type_Def, Access_To_Subtype_For_Private_Type_Def);

   function Allocate_Private_Type_Def
     (Pool : Bump_Ptr_Pool) return Bare_Private_Type_Def;

   function Allocate_Private_Type_Def
     (Pool : Bump_Ptr_Pool) return Bare_Private_Type_Def
   is
      Result : constant Access_To_Subtype_For_Private_Type_Def :=
        Bare_Private_Type_Def_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Private_Type_Def;
      return Bare_Private_Type_Def (Result);
   end Allocate_Private_Type_Def;

   package Bare_Real_Type_Def_Memos is new Langkit_Support.Packrat
     (Bare_Real_Type_Def, Token_Index);

   package Bare_Decimal_Fixed_Point_Def_Memos is new Langkit_Support.Packrat
     (Bare_Decimal_Fixed_Point_Def, Token_Index);

   subtype Subtype_For_Decimal_Fixed_Point_Def is
     Root_Node_Record (Ada_Decimal_Fixed_Point_Def);
   type Access_To_Subtype_For_Decimal_Fixed_Point_Def is
     access all Subtype_For_Decimal_Fixed_Point_Def;
   package Bare_Decimal_Fixed_Point_Def_Alloc is new Alloc
     (Subtype_For_Decimal_Fixed_Point_Def,
      Access_To_Subtype_For_Decimal_Fixed_Point_Def);

   function Allocate_Decimal_Fixed_Point_Def
     (Pool : Bump_Ptr_Pool) return Bare_Decimal_Fixed_Point_Def;

   function Allocate_Decimal_Fixed_Point_Def
     (Pool : Bump_Ptr_Pool) return Bare_Decimal_Fixed_Point_Def
   is
      Result : constant Access_To_Subtype_For_Decimal_Fixed_Point_Def :=
        Bare_Decimal_Fixed_Point_Def_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Decimal_Fixed_Point_Def;
      return Bare_Decimal_Fixed_Point_Def (Result);
   end Allocate_Decimal_Fixed_Point_Def;

   package Bare_Floating_Point_Def_Memos is new Langkit_Support.Packrat
     (Bare_Floating_Point_Def, Token_Index);

   subtype Subtype_For_Floating_Point_Def is
     Root_Node_Record (Ada_Floating_Point_Def);
   type Access_To_Subtype_For_Floating_Point_Def is
     access all Subtype_For_Floating_Point_Def;
   package Bare_Floating_Point_Def_Alloc is new Alloc
     (Subtype_For_Floating_Point_Def,
      Access_To_Subtype_For_Floating_Point_Def);

   function Allocate_Floating_Point_Def
     (Pool : Bump_Ptr_Pool) return Bare_Floating_Point_Def;

   function Allocate_Floating_Point_Def
     (Pool : Bump_Ptr_Pool) return Bare_Floating_Point_Def
   is
      Result : constant Access_To_Subtype_For_Floating_Point_Def :=
        Bare_Floating_Point_Def_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Floating_Point_Def;
      return Bare_Floating_Point_Def (Result);
   end Allocate_Floating_Point_Def;

   package Bare_Ordinary_Fixed_Point_Def_Memos is new Langkit_Support.Packrat
     (Bare_Ordinary_Fixed_Point_Def, Token_Index);

   subtype Subtype_For_Ordinary_Fixed_Point_Def is
     Root_Node_Record (Ada_Ordinary_Fixed_Point_Def);
   type Access_To_Subtype_For_Ordinary_Fixed_Point_Def is
     access all Subtype_For_Ordinary_Fixed_Point_Def;
   package Bare_Ordinary_Fixed_Point_Def_Alloc is new Alloc
     (Subtype_For_Ordinary_Fixed_Point_Def,
      Access_To_Subtype_For_Ordinary_Fixed_Point_Def);

   function Allocate_Ordinary_Fixed_Point_Def
     (Pool : Bump_Ptr_Pool) return Bare_Ordinary_Fixed_Point_Def;

   function Allocate_Ordinary_Fixed_Point_Def
     (Pool : Bump_Ptr_Pool) return Bare_Ordinary_Fixed_Point_Def
   is
      Result : constant Access_To_Subtype_For_Ordinary_Fixed_Point_Def :=
        Bare_Ordinary_Fixed_Point_Def_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Ordinary_Fixed_Point_Def;
      return Bare_Ordinary_Fixed_Point_Def (Result);
   end Allocate_Ordinary_Fixed_Point_Def;

   package Bare_Record_Type_Def_Memos is new Langkit_Support.Packrat
     (Bare_Record_Type_Def, Token_Index);

   subtype Subtype_For_Record_Type_Def is
     Root_Node_Record (Ada_Record_Type_Def);
   type Access_To_Subtype_For_Record_Type_Def is
     access all Subtype_For_Record_Type_Def;
   package Bare_Record_Type_Def_Alloc is new Alloc
     (Subtype_For_Record_Type_Def, Access_To_Subtype_For_Record_Type_Def);

   function Allocate_Record_Type_Def
     (Pool : Bump_Ptr_Pool) return Bare_Record_Type_Def;

   function Allocate_Record_Type_Def
     (Pool : Bump_Ptr_Pool) return Bare_Record_Type_Def
   is
      Result : constant Access_To_Subtype_For_Record_Type_Def :=
        Bare_Record_Type_Def_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Record_Type_Def;
      return Bare_Record_Type_Def (Result);
   end Allocate_Record_Type_Def;

   package Bare_Signed_Int_Type_Def_Memos is new Langkit_Support.Packrat
     (Bare_Signed_Int_Type_Def, Token_Index);

   subtype Subtype_For_Signed_Int_Type_Def is
     Root_Node_Record (Ada_Signed_Int_Type_Def);
   type Access_To_Subtype_For_Signed_Int_Type_Def is
     access all Subtype_For_Signed_Int_Type_Def;
   package Bare_Signed_Int_Type_Def_Alloc is new Alloc
     (Subtype_For_Signed_Int_Type_Def,
      Access_To_Subtype_For_Signed_Int_Type_Def);

   function Allocate_Signed_Int_Type_Def
     (Pool : Bump_Ptr_Pool) return Bare_Signed_Int_Type_Def;

   function Allocate_Signed_Int_Type_Def
     (Pool : Bump_Ptr_Pool) return Bare_Signed_Int_Type_Def
   is
      Result : constant Access_To_Subtype_For_Signed_Int_Type_Def :=
        Bare_Signed_Int_Type_Def_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Signed_Int_Type_Def;
      return Bare_Signed_Int_Type_Def (Result);
   end Allocate_Signed_Int_Type_Def;

   package Bare_Type_Expr_Memos is new Langkit_Support.Packrat
     (Bare_Type_Expr, Token_Index);

   package Bare_Anonymous_Type_Memos is new Langkit_Support.Packrat
     (Bare_Anonymous_Type, Token_Index);

   subtype Subtype_For_Anonymous_Type is Root_Node_Record (Ada_Anonymous_Type);
   type Access_To_Subtype_For_Anonymous_Type is
     access all Subtype_For_Anonymous_Type;
   package Bare_Anonymous_Type_Alloc is new Alloc
     (Subtype_For_Anonymous_Type, Access_To_Subtype_For_Anonymous_Type);

   function Allocate_Anonymous_Type
     (Pool : Bump_Ptr_Pool) return Bare_Anonymous_Type;

   function Allocate_Anonymous_Type
     (Pool : Bump_Ptr_Pool) return Bare_Anonymous_Type
   is
      Result : constant Access_To_Subtype_For_Anonymous_Type :=
        Bare_Anonymous_Type_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Anonymous_Type;
      return Bare_Anonymous_Type (Result);
   end Allocate_Anonymous_Type;

   package Bare_Enum_Lit_Synth_Type_Expr_Memos is new Langkit_Support.Packrat
     (Bare_Enum_Lit_Synth_Type_Expr, Token_Index);

   subtype Subtype_For_Enum_Lit_Synth_Type_Expr is
     Root_Node_Record (Ada_Enum_Lit_Synth_Type_Expr);
   type Access_To_Subtype_For_Enum_Lit_Synth_Type_Expr is
     access all Subtype_For_Enum_Lit_Synth_Type_Expr;
   package Bare_Enum_Lit_Synth_Type_Expr_Alloc is new Alloc
     (Subtype_For_Enum_Lit_Synth_Type_Expr,
      Access_To_Subtype_For_Enum_Lit_Synth_Type_Expr);

   function Allocate_Enum_Lit_Synth_Type_Expr
     (Pool : Bump_Ptr_Pool) return Bare_Enum_Lit_Synth_Type_Expr;

   function Allocate_Enum_Lit_Synth_Type_Expr
     (Pool : Bump_Ptr_Pool) return Bare_Enum_Lit_Synth_Type_Expr
   is
      Result : constant Access_To_Subtype_For_Enum_Lit_Synth_Type_Expr :=
        Bare_Enum_Lit_Synth_Type_Expr_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Enum_Lit_Synth_Type_Expr;
      return Bare_Enum_Lit_Synth_Type_Expr (Result);
   end Allocate_Enum_Lit_Synth_Type_Expr;

   package Bare_Subtype_Indication_Memos is new Langkit_Support.Packrat
     (Bare_Subtype_Indication, Token_Index);

   subtype Subtype_For_Subtype_Indication is
     Root_Node_Record (Ada_Subtype_Indication);
   type Access_To_Subtype_For_Subtype_Indication is
     access all Subtype_For_Subtype_Indication;
   package Bare_Subtype_Indication_Alloc is new Alloc
     (Subtype_For_Subtype_Indication,
      Access_To_Subtype_For_Subtype_Indication);

   function Allocate_Subtype_Indication
     (Pool : Bump_Ptr_Pool) return Bare_Subtype_Indication;

   function Allocate_Subtype_Indication
     (Pool : Bump_Ptr_Pool) return Bare_Subtype_Indication
   is
      Result : constant Access_To_Subtype_For_Subtype_Indication :=
        Bare_Subtype_Indication_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Subtype_Indication;
      return Bare_Subtype_Indication (Result);
   end Allocate_Subtype_Indication;

   package Bare_Constrained_Subtype_Indication_Memos is new Langkit_Support
     .Packrat
     (Bare_Constrained_Subtype_Indication, Token_Index);

   subtype Subtype_For_Constrained_Subtype_Indication is
     Root_Node_Record (Ada_Constrained_Subtype_Indication);
   type Access_To_Subtype_For_Constrained_Subtype_Indication is
     access all Subtype_For_Constrained_Subtype_Indication;
   package Bare_Constrained_Subtype_Indication_Alloc is new Alloc
     (Subtype_For_Constrained_Subtype_Indication,
      Access_To_Subtype_For_Constrained_Subtype_Indication);

   function Allocate_Constrained_Subtype_Indication
     (Pool : Bump_Ptr_Pool) return Bare_Constrained_Subtype_Indication;

   function Allocate_Constrained_Subtype_Indication
     (Pool : Bump_Ptr_Pool) return Bare_Constrained_Subtype_Indication
   is
      Result : constant Access_To_Subtype_For_Constrained_Subtype_Indication :=
        Bare_Constrained_Subtype_Indication_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Constrained_Subtype_Indication;
      return Bare_Constrained_Subtype_Indication (Result);
   end Allocate_Constrained_Subtype_Indication;

   package Bare_Discrete_Subtype_Indication_Memos is new Langkit_Support
     .Packrat
     (Bare_Discrete_Subtype_Indication, Token_Index);

   subtype Subtype_For_Discrete_Subtype_Indication is
     Root_Node_Record (Ada_Discrete_Subtype_Indication);
   type Access_To_Subtype_For_Discrete_Subtype_Indication is
     access all Subtype_For_Discrete_Subtype_Indication;
   package Bare_Discrete_Subtype_Indication_Alloc is new Alloc
     (Subtype_For_Discrete_Subtype_Indication,
      Access_To_Subtype_For_Discrete_Subtype_Indication);

   function Allocate_Discrete_Subtype_Indication
     (Pool : Bump_Ptr_Pool) return Bare_Discrete_Subtype_Indication;

   function Allocate_Discrete_Subtype_Indication
     (Pool : Bump_Ptr_Pool) return Bare_Discrete_Subtype_Indication
   is
      Result : constant Access_To_Subtype_For_Discrete_Subtype_Indication :=
        Bare_Discrete_Subtype_Indication_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Discrete_Subtype_Indication;
      return Bare_Discrete_Subtype_Indication (Result);
   end Allocate_Discrete_Subtype_Indication;

   package Bare_Unconstrained_Array_Index_Memos is new Langkit_Support.Packrat
     (Bare_Unconstrained_Array_Index, Token_Index);

   subtype Subtype_For_Unconstrained_Array_Index is
     Root_Node_Record (Ada_Unconstrained_Array_Index);
   type Access_To_Subtype_For_Unconstrained_Array_Index is
     access all Subtype_For_Unconstrained_Array_Index;
   package Bare_Unconstrained_Array_Index_Alloc is new Alloc
     (Subtype_For_Unconstrained_Array_Index,
      Access_To_Subtype_For_Unconstrained_Array_Index);

   function Allocate_Unconstrained_Array_Index
     (Pool : Bump_Ptr_Pool) return Bare_Unconstrained_Array_Index;

   function Allocate_Unconstrained_Array_Index
     (Pool : Bump_Ptr_Pool) return Bare_Unconstrained_Array_Index
   is
      Result : constant Access_To_Subtype_For_Unconstrained_Array_Index :=
        Bare_Unconstrained_Array_Index_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Unconstrained_Array_Index;
      return Bare_Unconstrained_Array_Index (Result);
   end Allocate_Unconstrained_Array_Index;

   package Bare_Until_Node_Memos is new Langkit_Support.Packrat
     (Bare_Until_Node, Token_Index);

   package Bare_Until_Absent_Memos is new Langkit_Support.Packrat
     (Bare_Until_Absent, Token_Index);

   subtype Subtype_For_Until_Absent is Root_Node_Record (Ada_Until_Absent);
   type Access_To_Subtype_For_Until_Absent is
     access all Subtype_For_Until_Absent;
   package Bare_Until_Absent_Alloc is new Alloc
     (Subtype_For_Until_Absent, Access_To_Subtype_For_Until_Absent);

   function Allocate_Until_Absent
     (Pool : Bump_Ptr_Pool) return Bare_Until_Absent;

   function Allocate_Until_Absent
     (Pool : Bump_Ptr_Pool) return Bare_Until_Absent
   is
      Result : constant Access_To_Subtype_For_Until_Absent :=
        Bare_Until_Absent_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Until_Absent;
      return Bare_Until_Absent (Result);
   end Allocate_Until_Absent;

   package Bare_Until_Present_Memos is new Langkit_Support.Packrat
     (Bare_Until_Present, Token_Index);

   subtype Subtype_For_Until_Present is Root_Node_Record (Ada_Until_Present);
   type Access_To_Subtype_For_Until_Present is
     access all Subtype_For_Until_Present;
   package Bare_Until_Present_Alloc is new Alloc
     (Subtype_For_Until_Present, Access_To_Subtype_For_Until_Present);

   function Allocate_Until_Present
     (Pool : Bump_Ptr_Pool) return Bare_Until_Present;

   function Allocate_Until_Present
     (Pool : Bump_Ptr_Pool) return Bare_Until_Present
   is
      Result : constant Access_To_Subtype_For_Until_Present :=
        Bare_Until_Present_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Until_Present;
      return Bare_Until_Present (Result);
   end Allocate_Until_Present;

   package Bare_Use_Clause_Memos is new Langkit_Support.Packrat
     (Bare_Use_Clause, Token_Index);

   package Bare_Use_Package_Clause_Memos is new Langkit_Support.Packrat
     (Bare_Use_Package_Clause, Token_Index);

   subtype Subtype_For_Use_Package_Clause is
     Root_Node_Record (Ada_Use_Package_Clause);
   type Access_To_Subtype_For_Use_Package_Clause is
     access all Subtype_For_Use_Package_Clause;
   package Bare_Use_Package_Clause_Alloc is new Alloc
     (Subtype_For_Use_Package_Clause,
      Access_To_Subtype_For_Use_Package_Clause);

   function Allocate_Use_Package_Clause
     (Pool : Bump_Ptr_Pool) return Bare_Use_Package_Clause;

   function Allocate_Use_Package_Clause
     (Pool : Bump_Ptr_Pool) return Bare_Use_Package_Clause
   is
      Result : constant Access_To_Subtype_For_Use_Package_Clause :=
        Bare_Use_Package_Clause_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Use_Package_Clause;
      return Bare_Use_Package_Clause (Result);
   end Allocate_Use_Package_Clause;

   package Bare_Use_Type_Clause_Memos is new Langkit_Support.Packrat
     (Bare_Use_Type_Clause, Token_Index);

   subtype Subtype_For_Use_Type_Clause is
     Root_Node_Record (Ada_Use_Type_Clause);
   type Access_To_Subtype_For_Use_Type_Clause is
     access all Subtype_For_Use_Type_Clause;
   package Bare_Use_Type_Clause_Alloc is new Alloc
     (Subtype_For_Use_Type_Clause, Access_To_Subtype_For_Use_Type_Clause);

   function Allocate_Use_Type_Clause
     (Pool : Bump_Ptr_Pool) return Bare_Use_Type_Clause;

   function Allocate_Use_Type_Clause
     (Pool : Bump_Ptr_Pool) return Bare_Use_Type_Clause
   is
      Result : constant Access_To_Subtype_For_Use_Type_Clause :=
        Bare_Use_Type_Clause_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Use_Type_Clause;
      return Bare_Use_Type_Clause (Result);
   end Allocate_Use_Type_Clause;

   package Bare_Variant_Memos is new Langkit_Support.Packrat
     (Bare_Variant, Token_Index);

   subtype Subtype_For_Variant is Root_Node_Record (Ada_Variant);
   type Access_To_Subtype_For_Variant is access all Subtype_For_Variant;
   package Bare_Variant_Alloc is new Alloc
     (Subtype_For_Variant, Access_To_Subtype_For_Variant);

   function Allocate_Variant (Pool : Bump_Ptr_Pool) return Bare_Variant;

   function Allocate_Variant (Pool : Bump_Ptr_Pool) return Bare_Variant is
      Result : constant Access_To_Subtype_For_Variant :=
        Bare_Variant_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Variant;
      return Bare_Variant (Result);
   end Allocate_Variant;

   package Bare_Variant_Part_Memos is new Langkit_Support.Packrat
     (Bare_Variant_Part, Token_Index);

   subtype Subtype_For_Variant_Part is Root_Node_Record (Ada_Variant_Part);
   type Access_To_Subtype_For_Variant_Part is
     access all Subtype_For_Variant_Part;
   package Bare_Variant_Part_Alloc is new Alloc
     (Subtype_For_Variant_Part, Access_To_Subtype_For_Variant_Part);

   function Allocate_Variant_Part
     (Pool : Bump_Ptr_Pool) return Bare_Variant_Part;

   function Allocate_Variant_Part
     (Pool : Bump_Ptr_Pool) return Bare_Variant_Part
   is
      Result : constant Access_To_Subtype_For_Variant_Part :=
        Bare_Variant_Part_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_Variant_Part;
      return Bare_Variant_Part (Result);
   end Allocate_Variant_Part;

   package Bare_With_Clause_Memos is new Langkit_Support.Packrat
     (Bare_With_Clause, Token_Index);

   subtype Subtype_For_With_Clause is Root_Node_Record (Ada_With_Clause);
   type Access_To_Subtype_For_With_Clause is
     access all Subtype_For_With_Clause;
   package Bare_With_Clause_Alloc is new Alloc
     (Subtype_For_With_Clause, Access_To_Subtype_For_With_Clause);

   function Allocate_With_Clause
     (Pool : Bump_Ptr_Pool) return Bare_With_Clause;

   function Allocate_With_Clause (Pool : Bump_Ptr_Pool) return Bare_With_Clause
   is
      Result : constant Access_To_Subtype_For_With_Clause :=
        Bare_With_Clause_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_With_Clause;
      return Bare_With_Clause (Result);
   end Allocate_With_Clause;

   package Bare_With_Private_Memos is new Langkit_Support.Packrat
     (Bare_With_Private, Token_Index);

   package Bare_With_Private_Absent_Memos is new Langkit_Support.Packrat
     (Bare_With_Private_Absent, Token_Index);

   subtype Subtype_For_With_Private_Absent is
     Root_Node_Record (Ada_With_Private_Absent);
   type Access_To_Subtype_For_With_Private_Absent is
     access all Subtype_For_With_Private_Absent;
   package Bare_With_Private_Absent_Alloc is new Alloc
     (Subtype_For_With_Private_Absent,
      Access_To_Subtype_For_With_Private_Absent);

   function Allocate_With_Private_Absent
     (Pool : Bump_Ptr_Pool) return Bare_With_Private_Absent;

   function Allocate_With_Private_Absent
     (Pool : Bump_Ptr_Pool) return Bare_With_Private_Absent
   is
      Result : constant Access_To_Subtype_For_With_Private_Absent :=
        Bare_With_Private_Absent_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_With_Private_Absent;
      return Bare_With_Private_Absent (Result);
   end Allocate_With_Private_Absent;

   package Bare_With_Private_Present_Memos is new Langkit_Support.Packrat
     (Bare_With_Private_Present, Token_Index);

   subtype Subtype_For_With_Private_Present is
     Root_Node_Record (Ada_With_Private_Present);
   type Access_To_Subtype_For_With_Private_Present is
     access all Subtype_For_With_Private_Present;
   package Bare_With_Private_Present_Alloc is new Alloc
     (Subtype_For_With_Private_Present,
      Access_To_Subtype_For_With_Private_Present);

   function Allocate_With_Private_Present
     (Pool : Bump_Ptr_Pool) return Bare_With_Private_Present;

   function Allocate_With_Private_Present
     (Pool : Bump_Ptr_Pool) return Bare_With_Private_Present
   is
      Result : constant Access_To_Subtype_For_With_Private_Present :=
        Bare_With_Private_Present_Alloc.Alloc (Pool);
      Result_Kind : Ada_Node_Kind_Type with
         Import,
         Address => Result.Kind'Address;
         --  Result.Kind is a discriminant, so we can't modify it directly. We
         --  need to initialize it manually, though, as we don't use a standard
         --  Ada allocator for nodes. Use an overlay to workaround Ada's
         --  restrictions.
   begin
      Result_Kind := Ada_With_Private_Present;
      return Bare_With_Private_Present (Result);
   end Allocate_With_Private_Present;

   pragma Warnings (On, "is not referenced");
   pragma Warnings (On, "possible aliasing problem for type");

   procedure Initialize_List
     (Self : Bare_Ada_List; Parser : Parser_Type; Count : Natural);
   --  Helper for parsers, to initialize the list of children in a freshly
   --  allocated list node.

   type Dontskip_Parser_Function is access function
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   package Dont_Skip_Fn_Vectors is new Ada.Containers.Vectors
     (Natural, Dontskip_Parser_Function);

   type Free_Parse_List_Record;
   type Free_Parse_List is access all Free_Parse_List_Record;
   --  Cache of temporary lists of AST nodes used in List parsers

   type Free_Parse_List_Record is record
      Nodes : Bare_Ada_Node_Vectors.Vector;
      Next  : Free_Parse_List;
   end record;

   type Parser_Private_Part_Type is record
      Parse_Lists : Free_Parse_List;

      Abort_Stmt_Transform_Parse_0_Memo : Bare_Abort_Stmt_Memos.Memo_Type;

      Abstract_Subp_Decl_Transform_Parse_0_Memo : Bare_Abstract_Subp_Decl_Memos
        .Memo_Type;

      Accept_Stmt_Or_Parse_0_Memo : Bare_Accept_Stmt_Memos.Memo_Type;

      Access_Def_Or_Parse_0_Memo : Bare_Access_Def_Memos.Memo_Type;

      Aggregate_Assoc_Transform_Parse_0_Memo : Bare_Aggregate_Assoc_Memos
        .Memo_Type;

      Aggregate_Or_Parse_0_Memo : Bare_Base_Aggregate_Memos.Memo_Type;

      Allocator_Transform_Parse_0_Memo : Bare_Allocator_Memos.Memo_Type;

      Anonymous_Type_Decl_Transform_Parse_0_Memo : Bare_Anonymous_Type_Decl_Memos
        .Memo_Type;

      Anonymous_Type_Transform_Parse_0_Memo : Bare_Anonymous_Type_Memos
        .Memo_Type;

      Array_Type_Def_Transform_Parse_2_Memo : Bare_Array_Type_Def_Memos
        .Memo_Type;

      Aspect_Assoc_Transform_Parse_0_Memo : Bare_Aspect_Assoc_Memos.Memo_Type;

      Aspect_Clause_Or_Parse_1_Memo : Bare_Aspect_Clause_Memos.Memo_Type;

      Aspect_Spec_Opt_Parse_0_Memo : Bare_Aspect_Spec_Memos.Memo_Type;

      Assignment_Stmt_Transform_Parse_0_Memo : Bare_Assign_Stmt_Memos
        .Memo_Type;

      Basic_Decl_Or_Parse_0_Memo : Bare_Ada_Node_Memos.Memo_Type;

      Basic_Decls_List_Parse_0_Memo : Bare_Ada_Node_List_Memos.Memo_Type;

      Block_Stmt_Or_Parse_0_Memo : Bare_Composite_Stmt_Memos.Memo_Type;

      Body_Or_Parse_0_Memo : Bare_Body_Node_Memos.Memo_Type;

      Body_Stub_Or_Parse_0_Memo : Bare_Body_Stub_Memos.Memo_Type;

      Boolean_Op_Or_Parse_0_Memo : Bare_Op_Memos.Memo_Type;

      Box_Expr_Transform_Parse_0_Memo : Bare_Box_Expr_Memos.Memo_Type;

      Call_Stmt_Transform_Parse_0_Memo : Bare_Call_Stmt_Memos.Memo_Type;

      Call_Suffix_Or_Parse_0_Memo : Bare_Ada_Node_Memos.Memo_Type;

      Case_Alt_Transform_Parse_0_Memo : Bare_Case_Stmt_Alternative_Memos
        .Memo_Type;

      Case_Expr_Alt_Transform_Parse_0_Memo : Bare_Case_Expr_Alternative_Memos
        .Memo_Type;

      Case_Expr_Transform_Parse_0_Memo : Bare_Case_Expr_Memos.Memo_Type;

      Case_Stmt_Transform_Parse_0_Memo : Bare_Case_Stmt_Memos.Memo_Type;

      Char_Literal_Transform_Parse_0_Memo : Bare_Char_Literal_Memos.Memo_Type;

      Choice_List_List_Parse_0_Memo : Bare_Alternatives_List_Memos.Memo_Type;

      Choice_Or_Parse_0_Memo : Bare_Ada_Node_Memos.Memo_Type;

      Compilation_Or_Parse_0_Memo : Bare_Ada_Node_Memos.Memo_Type;

      Compilation_Unit_Transform_Parse_0_Memo : Bare_Compilation_Unit_Memos
        .Memo_Type;

      Component_Clause_Transform_Parse_0_Memo : Bare_Component_Clause_Memos
        .Memo_Type;

      Component_Decl_Transform_Parse_0_Memo : Bare_Component_Decl_Memos
        .Memo_Type;

      Component_Def_Transform_Parse_0_Memo : Bare_Component_Def_Memos
        .Memo_Type;

      Component_Item_Or_Parse_0_Memo : Bare_Ada_Node_Memos.Memo_Type;

      Component_List_Transform_Parse_0_Memo : Bare_Component_List_Memos
        .Memo_Type;

      Compound_Stmt_Or_Parse_0_Memo : Bare_Composite_Stmt_Memos.Memo_Type;

      Conditional_Expr_Or_Parse_0_Memo : Bare_Expr_Memos.Memo_Type;

      Constrained_Subtype_Indication_Transform_Parse_0_Memo : Bare_Constrained_Subtype_Indication_Memos
        .Memo_Type;

      Constraint_List_List_Parse_0_Memo : Bare_Constraint_List_Memos.Memo_Type;

      Constraint_Or_Parse_0_Memo : Bare_Constraint_Memos.Memo_Type;

      Context_Item_Or_Parse_0_Memo : Bare_Ada_Node_Memos.Memo_Type;

      Contract_Case_Assoc_Transform_Parse_0_Memo : Bare_Contract_Case_Assoc_Memos
        .Memo_Type;

      Contract_Cases_Expr_Transform_Parse_0_Memo : Bare_Contract_Cases_Memos
        .Memo_Type;

      Dec_Literal_Transform_Parse_0_Memo : Bare_Real_Literal_Memos.Memo_Type;

      Decimal_Fixed_Point_Def_Transform_Parse_0_Memo : Bare_Decimal_Fixed_Point_Def_Memos
        .Memo_Type;

      Decl_Part_Transform_Parse_0_Memo : Bare_Declarative_Part_Memos.Memo_Type;

      Defining_Id_List_List_Parse_0_Memo : Bare_Defining_Name_List_Memos
        .Memo_Type;

      Defining_Id_Transform_Parse_0_Memo : Bare_Defining_Name_Memos.Memo_Type;

      Defining_Name_Transform_Parse_0_Memo : Bare_Defining_Name_Memos
        .Memo_Type;

      Delay_Stmt_Transform_Parse_0_Memo : Bare_Delay_Stmt_Memos.Memo_Type;

      Delta_Constraint_Transform_Parse_0_Memo : Bare_Delta_Constraint_Memos
        .Memo_Type;

      Derived_Type_Def_Transform_Parse_0_Memo : Bare_Derived_Type_Def_Memos
        .Memo_Type;

      Digits_Constraint_Transform_Parse_0_Memo : Bare_Digits_Constraint_Memos
        .Memo_Type;

      Direct_Name_Or_Parse_0_Memo : Bare_Base_Id_Memos.Memo_Type;

      Direct_Name_Or_Target_Name_Or_Parse_0_Memo : Bare_Name_Memos.Memo_Type;

      Discr_Spec_List_List_Parse_0_Memo : Bare_Discriminant_Spec_List_Memos
        .Memo_Type;

      Discrete_Range_Or_Parse_0_Memo : Bare_Expr_Memos.Memo_Type;

      Discrete_Subtype_Definition_Or_Parse_0_Memo : Bare_Ada_Node_Memos
        .Memo_Type;

      Discrete_Subtype_Indication_Transform_Parse_0_Memo : Bare_Discrete_Subtype_Indication_Memos
        .Memo_Type;

      Discriminant_Assoc_Transform_Parse_0_Memo : Bare_Discriminant_Assoc_Memos
        .Memo_Type;

      Discriminant_Constraint_Transform_Parse_0_Memo : Bare_Discriminant_Constraint_Memos
        .Memo_Type;

      Discriminant_Part_Or_Parse_0_Memo : Bare_Discriminant_Part_Memos
        .Memo_Type;

      Discriminant_Spec_Transform_Parse_0_Memo : Bare_Discriminant_Spec_Memos
        .Memo_Type;

      Dontskip_Case_Alt_0_Extract_Parse_0_Memo : Bare_Ada_Node_Memos.Memo_Type;

      Dontskip_Exception_Handler_0_Extract_Parse_0_Memo : Bare_Ada_Node_Memos
        .Memo_Type;

      Dontskip_Generic_Decl_0_Extract_Parse_0_Memo : Bare_Ada_Node_Memos
        .Memo_Type;

      Dontskip_Generic_Decl_1_Extract_Parse_0_Memo : Bare_Ada_Node_Memos
        .Memo_Type;

      Dontskip_Handled_Stmts_0_Extract_Parse_0_Memo : Bare_Ada_Node_Memos
        .Memo_Type;

      Dontskip_If_Stmt_0_Extract_Parse_0_Memo : Bare_Ada_Node_Memos.Memo_Type;

      Dontskip_If_Stmt_1_Extract_Parse_0_Memo : Bare_Ada_Node_Memos.Memo_Type;

      Dontskip_If_Stmt_2_Extract_Parse_0_Memo : Bare_Ada_Node_Memos.Memo_Type;

      Dontskip_Iloop_Stmt_0_Extract_Parse_0_Memo : Bare_Ada_Node_Memos
        .Memo_Type;

      Dontskip_Iloop_Stmt_1_Extract_Parse_0_Memo : Bare_Ada_Node_Memos
        .Memo_Type;

      Dontskip_Iloop_Stmt_2_Extract_Parse_0_Memo : Bare_Ada_Node_Memos
        .Memo_Type;

      Dontskip_Package_Body_0_Extract_Parse_0_Memo : Bare_Ada_Node_Memos
        .Memo_Type;

      Dontskip_Package_Decl_0_Extract_Parse_0_Memo : Bare_Ada_Node_Memos
        .Memo_Type;

      Dontskip_Package_Decl_1_Extract_Parse_0_Memo : Bare_Ada_Node_Memos
        .Memo_Type;

      Dontskip_Protected_Body_0_Extract_Parse_0_Memo : Bare_Ada_Node_Memos
        .Memo_Type;

      Dontskip_Recov_Decl_Part_0_Extract_Parse_0_Memo : Bare_Ada_Node_Memos
        .Memo_Type;

      Dontskip_Select_Stmt_0_Extract_Parse_0_Memo : Bare_Ada_Node_Memos
        .Memo_Type;

      Dontskip_Select_Stmt_1_Extract_Parse_0_Memo : Bare_Ada_Node_Memos
        .Memo_Type;

      Dontskip_Select_Stmt_2_Extract_Parse_0_Memo : Bare_Ada_Node_Memos
        .Memo_Type;

      Entry_Body_Transform_Parse_3_Memo : Bare_Entry_Body_Memos.Memo_Type;

      Entry_Decl_Transform_Parse_1_Memo : Bare_Entry_Decl_Memos.Memo_Type;

      Enum_Literal_Decl_Transform_Parse_1_Memo : Bare_Enum_Literal_Decl_Memos
        .Memo_Type;

      Enum_Type_Def_Transform_Parse_0_Memo : Bare_Enum_Type_Def_Memos
        .Memo_Type;

      Exception_Decl_Transform_Parse_0_Memo : Bare_Exception_Decl_Memos
        .Memo_Type;

      Exception_Handler_Transform_Parse_0_Memo : Bare_Exception_Handler_Memos
        .Memo_Type;

      Exit_Stmt_Transform_Parse_0_Memo : Bare_Exit_Stmt_Memos.Memo_Type;

      Expr_Fn_Transform_Parse_0_Memo : Bare_Expr_Function_Memos.Memo_Type;

      Expr_Or_Parse_0_Memo : Bare_Expr_Memos.Memo_Type;

      Ext_Ret_Stmt_Object_Decl_Transform_Parse_0_Memo : Bare_Extended_Return_Stmt_Object_Decl_Memos
        .Memo_Type;

      Ext_Return_Stmt_Transform_Parse_0_Memo : Bare_Extended_Return_Stmt_Memos
        .Memo_Type;

      Factor_Or_Parse_1_Memo : Bare_Expr_Memos.Memo_Type;

      Floating_Point_Def_Transform_Parse_0_Memo : Bare_Floating_Point_Def_Memos
        .Memo_Type;

      For_Loop_Param_Spec_Transform_Parse_3_Memo : Bare_For_Loop_Spec_Memos
        .Memo_Type;

      Formal_Discrete_Type_Def_Transform_Parse_0_Memo : Bare_Formal_Discrete_Type_Def_Memos
        .Memo_Type;

      Formal_Subp_Decl_Or_Parse_2_Memo : Bare_Formal_Subp_Decl_Memos.Memo_Type;

      Generic_Decl_Or_Parse_0_Memo : Bare_Generic_Decl_Memos.Memo_Type;

      Generic_Formal_Decl_Or_Parse_0_Memo : Bare_Ada_Node_Memos.Memo_Type;

      Generic_Formal_Part_Transform_Parse_0_Memo : Bare_Generic_Formal_Part_Memos
        .Memo_Type;

      Generic_Instantiation_Or_Parse_1_Memo : Bare_Generic_Instantiation_Memos
        .Memo_Type;

      Generic_Renaming_Decl_Or_Parse_1_Memo : Bare_Generic_Renaming_Decl_Memos
        .Memo_Type;

      Goto_Stmt_Transform_Parse_0_Memo : Bare_Goto_Stmt_Memos.Memo_Type;

      Handled_Stmts_Transform_Parse_0_Memo : Bare_Handled_Stmts_Memos
        .Memo_Type;

      Iblock_Stmt_Or_Parse_0_Memo : Bare_Block_Stmt_Memos.Memo_Type;

      Identifier_Transform_Parse_0_Memo : Bare_Identifier_Memos.Memo_Type;

      If_Expr_Transform_Parse_1_Memo : Bare_If_Expr_Memos.Memo_Type;

      If_Stmt_Transform_Parse_1_Memo : Bare_If_Stmt_Memos.Memo_Type;

      Iloop_Stmt_Or_Parse_0_Memo : Bare_Base_Loop_Stmt_Memos.Memo_Type;

      Index_Constraint_Transform_Parse_0_Memo : Bare_Index_Constraint_Memos
        .Memo_Type;

      Int_Literal_Transform_Parse_0_Memo : Bare_Int_Literal_Memos.Memo_Type;

      Interface_Type_Def_Transform_Parse_4_Memo : Bare_Interface_Type_Def_Memos
        .Memo_Type;

      Label_Transform_Parse_1_Memo : Bare_Label_Memos.Memo_Type;

      Library_Item_Transform_Parse_1_Memo : Bare_Library_Item_Memos.Memo_Type;

      Library_Unit_Body_Or_Parse_0_Memo : Bare_Body_Node_Memos.Memo_Type;

      Library_Unit_Renaming_Decl_Or_Parse_0_Memo : Bare_Basic_Decl_Memos
        .Memo_Type;

      Loop_Stmt_Or_Parse_0_Memo : Bare_Composite_Stmt_Memos.Memo_Type;

      Membership_Choice_List_List_Parse_0_Memo : Bare_Expr_Alternatives_List_Memos
        .Memo_Type;

      Membership_Choice_Or_Parse_0_Memo : Bare_Expr_Memos.Memo_Type;

      Mod_Int_Type_Def_Transform_Parse_0_Memo : Bare_Mod_Int_Type_Def_Memos
        .Memo_Type;

      Mode_Or_Parse_0_Memo : Bare_Mode_Memos.Memo_Type;

      Multidim_Array_Assoc_Transform_Parse_0_Memo : Bare_Multi_Dim_Array_Assoc_Memos
        .Memo_Type;

      Name_Or_Parse_1_Memo : Bare_Name_Memos.Memo_Type;

      Null_Literal_Transform_Parse_0_Memo : Bare_Null_Literal_Memos.Memo_Type;

      Null_Stmt_Transform_Parse_0_Memo : Bare_Null_Stmt_Memos.Memo_Type;

      Null_Subp_Decl_Transform_Parse_0_Memo : Bare_Null_Subp_Decl_Memos
        .Memo_Type;

      Num_Literal_Or_Parse_0_Memo : Bare_Num_Literal_Memos.Memo_Type;

      Number_Decl_Transform_Parse_0_Memo : Bare_Number_Decl_Memos.Memo_Type;

      Object_Decl_Or_Parse_0_Memo : Bare_Basic_Decl_Memos.Memo_Type;

      Ordinary_Fixed_Point_Def_Transform_Parse_0_Memo : Bare_Ordinary_Fixed_Point_Def_Memos
        .Memo_Type;

      Others_Designator_Transform_Parse_0_Memo : Bare_Others_Designator_Memos
        .Memo_Type;

      Overriding_Indicator_Or_Parse_0_Memo : Bare_Overriding_Node_Memos
        .Memo_Type;

      Package_Body_Stub_Transform_Parse_0_Memo : Bare_Package_Body_Stub_Memos
        .Memo_Type;

      Package_Body_Transform_Parse_1_Memo : Bare_Package_Body_Memos.Memo_Type;

      Package_Decl_Transform_Parse_3_Memo : Bare_Package_Decl_Memos.Memo_Type;

      Package_Renaming_Decl_Transform_Parse_0_Memo : Bare_Package_Renaming_Decl_Memos
        .Memo_Type;

      Param_Assoc_Transform_Parse_0_Memo : Bare_Param_Assoc_Memos.Memo_Type;

      Param_Spec_Transform_Parse_0_Memo : Bare_Param_Spec_Memos.Memo_Type;

      Param_Specs_Transform_Parse_0_Memo : Bare_Params_Memos.Memo_Type;

      Paren_Expr_Transform_Parse_0_Memo : Bare_Paren_Expr_Memos.Memo_Type;

      Parent_List_List_Parse_0_Memo : Bare_Parent_List_Memos.Memo_Type;

      Pragma_Argument_Transform_Parse_0_Memo : Bare_Pragma_Argument_Assoc_Memos
        .Memo_Type;

      Pragma_Transform_Parse_0_Memo : Bare_Pragma_Node_Memos.Memo_Type;

      Primary_Or_Parse_0_Memo : Bare_Expr_Memos.Memo_Type;

      Protected_Body_Stub_Transform_Parse_0_Memo : Bare_Protected_Body_Stub_Memos
        .Memo_Type;

      Protected_Body_Transform_Parse_1_Memo : Bare_Protected_Body_Memos
        .Memo_Type;

      Protected_Decl_Transform_Parse_0_Memo : Bare_Single_Protected_Decl_Memos
        .Memo_Type;

      Protected_Def_Transform_Parse_3_Memo : Bare_Protected_Def_Memos
        .Memo_Type;

      Protected_El_Or_Parse_0_Memo : Bare_Ada_Node_Memos.Memo_Type;

      Protected_Op_Or_Parse_0_Memo : Bare_Ada_Node_Memos.Memo_Type;

      Protected_Type_Decl_Transform_Parse_0_Memo : Bare_Protected_Type_Decl_Memos
        .Memo_Type;

      Qual_Name_Internal_Or_Parse_0_Memo : Bare_Name_Memos.Memo_Type;

      Qualified_Name_Transform_Parse_0_Memo : Bare_Qual_Expr_Memos.Memo_Type;

      Quantified_Expr_Transform_Parse_2_Memo : Bare_Quantified_Expr_Memos
        .Memo_Type;

      Raise_Expr_Or_Parse_0_Memo : Bare_Raise_Expr_Memos.Memo_Type;

      Raise_Stmt_Or_Parse_0_Memo : Bare_Raise_Stmt_Memos.Memo_Type;

      Range_Constraint_Transform_Parse_1_Memo : Bare_Range_Constraint_Memos
        .Memo_Type;

      Range_Spec_Transform_Parse_0_Memo : Bare_Range_Spec_Memos.Memo_Type;

      Real_Type_Def_Or_Parse_0_Memo : Bare_Real_Type_Def_Memos.Memo_Type;

      Record_Def_Or_Parse_0_Memo : Bare_Base_Record_Def_Memos.Memo_Type;

      Record_Type_Def_Transform_Parse_0_Memo : Bare_Record_Type_Def_Memos
        .Memo_Type;

      Recov_Decl_Part_Dont_Skip_Parse_0_Memo : Bare_Declarative_Part_Memos
        .Memo_Type;

      Rel_Op_Or_Parse_0_Memo : Bare_Op_Memos.Memo_Type;

      Relation_Or_Parse_1_Memo : Bare_Expr_Memos.Memo_Type;

      Renaming_Clause_Transform_Parse_0_Memo : Bare_Renaming_Clause_Memos
        .Memo_Type;

      Requeue_Stmt_Transform_Parse_0_Memo : Bare_Requeue_Stmt_Memos.Memo_Type;

      Return_Stmt_Transform_Parse_0_Memo : Bare_Return_Stmt_Memos.Memo_Type;

      Select_Stmt_Transform_Parse_1_Memo : Bare_Select_Stmt_Memos.Memo_Type;

      Sexpr_Or_Box_Or_Parse_0_Memo : Bare_Expr_Memos.Memo_Type;

      Signed_Int_Type_Def_Transform_Parse_0_Memo : Bare_Signed_Int_Type_Def_Memos
        .Memo_Type;

      Simple_Expr_Or_Parse_1_Memo : Bare_Expr_Memos.Memo_Type;

      Simple_Stmt_Or_Parse_0_Memo : Bare_Ada_Node_Memos.Memo_Type;

      Simple_Subp_Decl_Transform_Parse_0_Memo : Bare_Subp_Decl_Memos.Memo_Type;

      Single_Task_Decl_Transform_Parse_1_Memo : Bare_Single_Task_Decl_Memos
        .Memo_Type;

      Static_Name_Or_Parse_0_Memo : Bare_Name_Memos.Memo_Type;

      Stmt_Or_Parse_0_Memo : Bare_Ada_Node_Memos.Memo_Type;

      Stmts_List_Parse_0_Memo : Bare_Stmt_List_Memos.Memo_Type;

      String_Literal_Transform_Parse_0_Memo : Bare_String_Literal_Memos
        .Memo_Type;

      Sub_Object_Decl_Transform_Parse_0_Memo : Bare_Object_Decl_Memos
        .Memo_Type;

      Subp_Body_Stub_Transform_Parse_0_Memo : Bare_Subp_Body_Stub_Memos
        .Memo_Type;

      Subp_Body_Transform_Parse_1_Memo : Bare_Subp_Body_Memos.Memo_Type;

      Subp_Decl_Or_Parse_0_Memo : Bare_Basic_Decl_Memos.Memo_Type;

      Subp_Renaming_Decl_Transform_Parse_0_Memo : Bare_Subp_Renaming_Decl_Memos
        .Memo_Type;

      Subp_Spec_Transform_Parse_2_Memo : Bare_Subp_Spec_Memos.Memo_Type;

      Subtype_Decl_Transform_Parse_0_Memo : Bare_Subtype_Decl_Memos.Memo_Type;

      Subtype_Indication_Transform_Parse_0_Memo : Bare_Subtype_Indication_Memos
        .Memo_Type;

      Subtype_Name_Or_Parse_0_Memo : Bare_Name_Memos.Memo_Type;

      Subunit_Transform_Parse_0_Memo : Bare_Subunit_Memos.Memo_Type;

      Target_Name_Transform_Parse_0_Memo : Bare_Target_Name_Memos.Memo_Type;

      Task_Body_Stub_Transform_Parse_0_Memo : Bare_Task_Body_Stub_Memos
        .Memo_Type;

      Task_Body_Transform_Parse_1_Memo : Bare_Task_Body_Memos.Memo_Type;

      Task_Def_Transform_Parse_3_Memo : Bare_Task_Def_Memos.Memo_Type;

      Task_Item_Or_Parse_0_Memo : Bare_Ada_Node_Memos.Memo_Type;

      Task_Type_Decl_Transform_Parse_0_Memo : Bare_Task_Type_Decl_Memos
        .Memo_Type;

      Term_Or_Parse_1_Memo : Bare_Expr_Memos.Memo_Type;

      Terminate_Alternative_Transform_Parse_0_Memo : Bare_Terminate_Alternative_Memos
        .Memo_Type;

      Type_Decl_Or_Parse_1_Memo : Bare_Base_Type_Decl_Memos.Memo_Type;

      Type_Def_Or_Parse_0_Memo : Bare_Type_Def_Memos.Memo_Type;

      Type_Expr_Or_Parse_0_Memo : Bare_Type_Expr_Memos.Memo_Type;

      Unconstrained_Index_Transform_Parse_0_Memo : Bare_Unconstrained_Array_Index_Memos
        .Memo_Type;

      Unop_Term_Or_Parse_1_Memo : Bare_Expr_Memos.Memo_Type;

      Update_Attr_Aggregate_Or_Parse_0_Memo : Bare_Base_Aggregate_Memos
        .Memo_Type;

      Update_Attr_Content_List_Parse_0_Memo : Bare_Assoc_List_Memos.Memo_Type;

      Use_Clause_Or_Parse_0_Memo : Bare_Use_Clause_Memos.Memo_Type;

      Use_Package_Clause_Transform_Parse_0_Memo : Bare_Use_Package_Clause_Memos
        .Memo_Type;

      Use_Type_Clause_Transform_Parse_0_Memo : Bare_Use_Type_Clause_Memos
        .Memo_Type;

      Variant_Part_Transform_Parse_0_Memo : Bare_Variant_Part_Memos.Memo_Type;

      Variant_Transform_Parse_0_Memo : Bare_Variant_Memos.Memo_Type;

      With_Clause_Transform_Parse_0_Memo : Bare_With_Clause_Memos.Memo_Type;

      Dont_Skip : Dont_Skip_Fn_Vectors.Vector;
   end record;

   function Dec_Literal_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Real_Literal;

   function Int_Literal_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Int_Literal;

   function Num_Literal_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Num_Literal;

   function Null_Literal_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Null_Literal;

   function Identifier_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Identifier;

   function String_Literal_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_String_Literal;

   function Char_Literal_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Char_Literal;

   function Direct_Name_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Base_Id;

   function Subtype_Name_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Name;

   function Discrete_Range_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Expr;

   function Range_Constraint_Transform_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Range_Constraint;

   function Discrete_Subtype_Indication_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Discrete_Subtype_Indication;

   function Others_Designator_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Others_Designator;

   function Boolean_Op_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Op;

   function Rel_Op_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Op;

   function Membership_Choice_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Expr;

   function Membership_Choice_List_List_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Expr_Alternatives_List;

   function Relation_Or_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Expr;

   function Expr_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Expr;

   function Box_Expr_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Box_Expr;

   function Param_Assoc_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Param_Assoc;

   function Call_Suffix_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Choice_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Choice_List_List_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Alternatives_List;

   function Aggregate_Assoc_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Aggregate_Assoc;

   function Aggregate_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Base_Aggregate;

   function Multidim_Array_Assoc_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Multi_Dim_Array_Assoc;

   function Update_Attr_Content_List_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Assoc_List;

   function Update_Attr_Aggregate_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Base_Aggregate;

   function Paren_Expr_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Paren_Expr;

   function Target_Name_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Target_Name;

   function Direct_Name_Or_Target_Name_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Name;

   function Name_Or_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Name;

   function Qual_Name_Internal_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Name;

   function Qualified_Name_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Qual_Expr;

   function Range_Spec_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Range_Spec;

   function Digits_Constraint_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Digits_Constraint;

   function Delta_Constraint_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Delta_Constraint;

   function Discriminant_Assoc_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Discriminant_Assoc;

   function Discriminant_Constraint_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Discriminant_Constraint;

   function Discrete_Subtype_Definition_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Constraint_List_List_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Constraint_List;

   function Index_Constraint_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Index_Constraint;

   function Constraint_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Constraint;

   function Subtype_Indication_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Subtype_Indication;

   function Allocator_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Allocator;

   function If_Expr_Transform_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_If_Expr;

   function Case_Expr_Alt_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Case_Expr_Alternative;

   function Case_Expr_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Case_Expr;

   function Defining_Id_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Defining_Name;

   function For_Loop_Param_Spec_Transform_Parse_3
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_For_Loop_Spec;

   function Quantified_Expr_Transform_Parse_2
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Quantified_Expr;

   function Conditional_Expr_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Expr;

   function Raise_Expr_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Raise_Expr;

   function Primary_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Expr;

   function Factor_Or_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Expr;

   function Term_Or_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Expr;

   function Unop_Term_Or_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Expr;

   function Simple_Expr_Or_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Expr;

   function Sexpr_Or_Box_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Expr;

   function Decimal_Fixed_Point_Def_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Decimal_Fixed_Point_Def;

   function Dontskip_Generic_Decl_0_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Contract_Case_Assoc_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Contract_Case_Assoc;

   function Contract_Cases_Expr_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Contract_Cases;

   function Aspect_Assoc_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Aspect_Assoc;

   function Aspect_Spec_Opt_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Aspect_Spec;

   function Overriding_Indicator_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Overriding_Node;

   function Static_Name_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Name;

   function Defining_Name_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Defining_Name;

   function Mode_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Mode;

   function Unconstrained_Index_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Unconstrained_Array_Index;

   function Component_Def_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Component_Def;

   function Array_Type_Def_Transform_Parse_2
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Array_Type_Def;

   function Access_Def_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Access_Def;

   function Anonymous_Type_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Anonymous_Type_Decl;

   function Anonymous_Type_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Anonymous_Type;

   function Type_Expr_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Type_Expr;

   function Param_Spec_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Param_Spec;

   function Param_Specs_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Params;

   function Subp_Spec_Transform_Parse_2
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Subp_Spec;

   function Simple_Subp_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Subp_Decl;

   function Formal_Subp_Decl_Or_Parse_2
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Formal_Subp_Decl;

   function Null_Subp_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Null_Subp_Decl;

   function Abstract_Subp_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Abstract_Subp_Decl;

   function Expr_Fn_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Expr_Function;

   function Renaming_Clause_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Renaming_Clause;

   function Subp_Renaming_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Subp_Renaming_Decl;

   function Subp_Body_Stub_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Subp_Body_Stub;

   function Package_Body_Stub_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Package_Body_Stub;

   function Task_Body_Stub_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Task_Body_Stub;

   function Protected_Body_Stub_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Protected_Body_Stub;

   function Body_Stub_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Body_Stub;

   function Generic_Instantiation_Or_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Generic_Instantiation;

   function Recov_Decl_Part_Dont_Skip_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Declarative_Part;

   function If_Stmt_Transform_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_If_Stmt;

   function Iblock_Stmt_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Block_Stmt;

   function Block_Stmt_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Composite_Stmt;

   function Iloop_Stmt_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Base_Loop_Stmt;

   function Loop_Stmt_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Composite_Stmt;

   function Defining_Id_List_List_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Defining_Name_List;

   function Ext_Ret_Stmt_Object_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Extended_Return_Stmt_Object_Decl;

   function Ext_Return_Stmt_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Extended_Return_Stmt;

   function Case_Alt_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Case_Stmt_Alternative;

   function Case_Stmt_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Case_Stmt;

   function Accept_Stmt_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Accept_Stmt;

   function Select_Stmt_Transform_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Select_Stmt;

   function Compound_Stmt_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Composite_Stmt;

   function Null_Stmt_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Null_Stmt;

   function Assignment_Stmt_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Assign_Stmt;

   function Goto_Stmt_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Goto_Stmt;

   function Exit_Stmt_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Exit_Stmt;

   function Return_Stmt_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Return_Stmt;

   function Requeue_Stmt_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Requeue_Stmt;

   function Call_Stmt_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Call_Stmt;

   function Abort_Stmt_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Abort_Stmt;

   function Delay_Stmt_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Delay_Stmt;

   function Raise_Stmt_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Raise_Stmt;

   function Terminate_Alternative_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Terminate_Alternative;

   function Pragma_Argument_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Pragma_Argument_Assoc;

   function Pragma_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Pragma_Node;

   function Simple_Stmt_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Stmt_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Label_Transform_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Label;

   function Stmts_List_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Stmt_List;

   function Exception_Handler_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Exception_Handler;

   function Handled_Stmts_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Handled_Stmts;

   function Subp_Body_Transform_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Subp_Body;

   function Package_Body_Transform_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Package_Body;

   function Task_Body_Transform_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Task_Body;

   function Protected_Body_Transform_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Protected_Body;

   function Entry_Body_Transform_Parse_3
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Entry_Body;

   function Body_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Body_Node;

   function Discriminant_Spec_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Discriminant_Spec;

   function Discr_Spec_List_List_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Discriminant_Spec_List;

   function Discriminant_Part_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Discriminant_Part;

   function Component_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Component_Decl;

   function Component_Clause_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Component_Clause;

   function Aspect_Clause_Or_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Aspect_Clause;

   function Component_Item_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Variant_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Variant;

   function Variant_Part_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Variant_Part;

   function Component_List_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Component_List;

   function Record_Def_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Base_Record_Def;

   function Record_Type_Def_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Record_Type_Def;

   function Floating_Point_Def_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Floating_Point_Def;

   function Ordinary_Fixed_Point_Def_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Ordinary_Fixed_Point_Def;

   function Real_Type_Def_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Real_Type_Def;

   function Parent_List_List_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Parent_List;

   function Derived_Type_Def_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Derived_Type_Def;

   function Signed_Int_Type_Def_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Signed_Int_Type_Def;

   function Mod_Int_Type_Def_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Mod_Int_Type_Def;

   function Interface_Type_Def_Transform_Parse_4
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Interface_Type_Def;

   function Formal_Discrete_Type_Def_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Formal_Discrete_Type_Def;

   function Enum_Literal_Decl_Transform_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Enum_Literal_Decl;

   function Enum_Type_Def_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Enum_Type_Def;

   function Type_Def_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Type_Def;

   function Type_Decl_Or_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Base_Type_Decl;

   function Constrained_Subtype_Indication_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Constrained_Subtype_Indication;

   function Entry_Decl_Transform_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Entry_Decl;

   function Task_Item_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Task_Def_Transform_Parse_3
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Task_Def;

   function Task_Type_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Task_Type_Decl;

   function Subp_Decl_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Basic_Decl;

   function Protected_Op_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Protected_El_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Protected_Def_Transform_Parse_3
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Protected_Def;

   function Protected_Type_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Protected_Type_Decl;

   function Subtype_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Subtype_Decl;

   function Sub_Object_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Object_Decl;

   function Single_Task_Decl_Transform_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Single_Task_Decl;

   function Protected_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Single_Protected_Decl;

   function Number_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Number_Decl;

   function Object_Decl_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Basic_Decl;

   function Package_Decl_Transform_Parse_3
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Package_Decl;

   function Use_Package_Clause_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Use_Package_Clause;

   function Use_Type_Clause_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Use_Type_Clause;

   function Use_Clause_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Use_Clause;

   function Exception_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Exception_Decl;

   function Package_Renaming_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Package_Renaming_Decl;

   function Generic_Renaming_Decl_Or_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Generic_Renaming_Decl;

   function Generic_Formal_Decl_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Generic_Formal_Part_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Generic_Formal_Part;

   function Generic_Decl_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Generic_Decl;

   function Basic_Decl_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Basic_Decls_List_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Ada_Node_List;

   function Decl_Part_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Declarative_Part;

   function Dontskip_Exception_Handler_0_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function With_Clause_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_With_Clause;

   function Context_Item_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Subunit_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Subunit;

   function Library_Unit_Body_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Body_Node;

   function Library_Unit_Renaming_Decl_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Basic_Decl;

   function Library_Item_Transform_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Library_Item;

   function Compilation_Unit_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Compilation_Unit;

   function Dontskip_Case_Alt_0_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Dontskip_Select_Stmt_2_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Dontskip_Select_Stmt_1_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Dontskip_Iloop_Stmt_1_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Dontskip_Package_Decl_0_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Dontskip_Package_Decl_1_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Compilation_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Dontskip_If_Stmt_1_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Dontskip_If_Stmt_2_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Dontskip_If_Stmt_0_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Dontskip_Iloop_Stmt_2_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Dontskip_Generic_Decl_1_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Dontskip_Select_Stmt_0_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Dontskip_Iloop_Stmt_0_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Dontskip_Package_Body_0_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Dontskip_Protected_Body_0_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Dontskip_Recov_Decl_Part_0_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   function Dontskip_Handled_Stmts_0_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node;

   procedure Process_Parsing_Error
     (Parser : in out Parser_Type; Check_Complete : Boolean := True);
   --  Helper for the user parsing function, to be called after a low-level
   --  parsing function. Check_Complete has the same semantics as in Parse.
   --  If the parsing failed (Parser.Current_Pos = No_Token_Index), append
   --  corresponding diagnostics to Parser.Diagnostics, do nothing instead.

   procedure Add_Last_Fail_Diagnostic (Parser : in out Parser_Type);
   --  Add a diagnostic for the last fail position of the parser

   function Get_Parse_List (Parser : Parser_Type) return Free_Parse_List;
   --  Get a free parse list, or allocate one if there is no free parse
   --  list in Parser. When done with the result, the caller must invoke
   --  Release_Parse_List.

   procedure Release_Parse_List
     (Parser : Parser_Type; List : in out Free_Parse_List);
   --  Release a parse list, putting it in Parsers' free list. Set List to
   --  null.

   ---------------------
   -- Initialize_List --
   ---------------------

   procedure Initialize_List
     (Self : Bare_Ada_List; Parser : Parser_Type; Count : Natural)
   is
   begin
      Self.Count := Count;
      Self.Nodes := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, 0);
   end Initialize_List;

   -----------------
   -- Init_Parser --
   -----------------

   procedure Init_Parser
     (Input : Internal_Lexer_Input; Tab_Stop : Positive; With_Trivia : Boolean;
      Unit  : access Implementation.Analysis_Unit_Type;
      TDH   : Token_Data_Handler_Access; Parser : in out Parser_Type)
   is
   begin
      Reset (Parser);
      Extract_Tokens
        (Input, Tab_Stop, With_Trivia, TDH.all, Parser.Diagnostics);
      Parser.Unit := Unit;
      Parser.TDH  := TDH;
   end Init_Parser;

   ------------------------------
   -- Add_Last_Fail_Diagnostic --
   ------------------------------

   procedure Add_Last_Fail_Diagnostic (Parser : in out Parser_Type) is
      Last_Token : Stored_Token_Data renames
        Get_Token (Parser.TDH.all, Parser.Last_Fail.Pos);
      D : constant Diagnostic :=
        (if Parser.Last_Fail.Kind = Token_Fail then
           Create
             (Last_Token.Sloc_Range,
              To_Text
                ("Expected " &
                 Token_Error_Image (Parser.Last_Fail.Expected_Token_Id) &
                 ", got " &
                 Token_Error_Image (Parser.Last_Fail.Found_Token_Id)))
         else Create
             (Last_Token.Sloc_Range,
              To_Text (Parser.Last_Fail.Custom_Message.all)));
   begin
      Parser.Diagnostics.Append (D);
   end Add_Last_Fail_Diagnostic;

   ---------------------------
   -- Process_Parsing_Error --
   ---------------------------

   procedure Process_Parsing_Error
     (Parser : in out Parser_Type; Check_Complete : Boolean := True)
   is
   begin

      if Parser.Current_Pos = No_Token_Index then
         Add_Last_Fail_Diagnostic (Parser);
      elsif Check_Complete
        and then Parser.Current_Pos /= Last_Token (Parser.TDH.all)
      then
         --  If the fail pos is the current position of the parser or after,
         --  it means that the longest parse is the correct result, and that
         --  we have some garbage afterwards.
         if Parser.Current_Pos >= Parser.Last_Fail.Pos then
            declare
               First_Garbage_Token : Stored_Token_Data renames
                 Get_Token (Parser.TDH.all, Parser.Current_Pos);
            begin
               Append
                 (Parser.Diagnostics, First_Garbage_Token.Sloc_Range,
                  To_Text
                    ("End of input expected, got """ &
                     Token_Kind_Name
                       (To_Token_Kind (First_Garbage_Token.Kind)) &
                     """"));
            end;

            --  Else, the last fail pos is further down the line, and we want
            --  to have the diagnostic of what exactly failed.
         else
            Add_Last_Fail_Diagnostic (Parser);
         end if;
      end if;

   end Process_Parsing_Error;

   -----------
   -- Parse --
   -----------

   function Parse
     (Parser : in out Parser_Type; Check_Complete : Boolean := True;
      Rule   :        Grammar_Rule) return Parsed_Node
   is
      Result : Bare_Ada_Node;
   begin
      case Rule is
         when Decimal_Fixed_Point_Def_Rule =>
            Result :=
              Decimal_Fixed_Point_Def_Transform_Parse_0
                (Parser, First_Token_Index);
         when Relation_Rule =>
            Result := Relation_Or_Parse_1 (Parser, First_Token_Index);
         when Aspect_Spec_Rule =>
            Result := Aspect_Spec_Opt_Parse_0 (Parser, First_Token_Index);
         when Simple_Subp_Decl_Rule =>
            Result :=
              Simple_Subp_Decl_Transform_Parse_0 (Parser, First_Token_Index);
         when Anonymous_Type_Decl_Rule =>
            Result :=
              Anonymous_Type_Decl_Transform_Parse_0
                (Parser, First_Token_Index);
         when Formal_Subp_Decl_Rule =>
            Result := Formal_Subp_Decl_Or_Parse_2 (Parser, First_Token_Index);
         when Param_Spec_Rule =>
            Result := Param_Spec_Transform_Parse_0 (Parser, First_Token_Index);
         when Decl_Part_Rule =>
            Result := Decl_Part_Transform_Parse_0 (Parser, First_Token_Index);
         when Aspect_Clause_Rule =>
            Result := Aspect_Clause_Or_Parse_1 (Parser, First_Token_Index);
         when If_Expr_Rule =>
            Result := If_Expr_Transform_Parse_1 (Parser, First_Token_Index);
         when Task_Def_Rule =>
            Result := Task_Def_Transform_Parse_3 (Parser, First_Token_Index);
         when Select_Stmt_Rule =>
            Result :=
              Select_Stmt_Transform_Parse_1 (Parser, First_Token_Index);
         when Param_Specs_Rule =>
            Result :=
              Param_Specs_Transform_Parse_0 (Parser, First_Token_Index);
         when Iloop_Stmt_Rule =>
            Result := Iloop_Stmt_Or_Parse_0 (Parser, First_Token_Index);
         when Defining_Id_List_Rule =>
            Result :=
              Defining_Id_List_List_Parse_0 (Parser, First_Token_Index);
         when Int_Literal_Rule =>
            Result :=
              Int_Literal_Transform_Parse_0 (Parser, First_Token_Index);
         when Protected_Body_Stub_Rule =>
            Result :=
              Protected_Body_Stub_Transform_Parse_0
                (Parser, First_Token_Index);
         when Update_Attr_Aggregate_Rule =>
            Result :=
              Update_Attr_Aggregate_Or_Parse_0 (Parser, First_Token_Index);
         when Array_Type_Def_Rule =>
            Result :=
              Array_Type_Def_Transform_Parse_2 (Parser, First_Token_Index);
         when Protected_El_Rule =>
            Result := Protected_El_Or_Parse_0 (Parser, First_Token_Index);
         when Simple_Stmt_Rule =>
            Result := Simple_Stmt_Or_Parse_0 (Parser, First_Token_Index);
         when Interface_Type_Def_Rule =>
            Result :=
              Interface_Type_Def_Transform_Parse_4 (Parser, First_Token_Index);
         when Compilation_Unit_Rule =>
            Result :=
              Compilation_Unit_Transform_Parse_0 (Parser, First_Token_Index);
         when Component_Clause_Rule =>
            Result :=
              Component_Clause_Transform_Parse_0 (Parser, First_Token_Index);
         when Signed_Int_Type_Def_Rule =>
            Result :=
              Signed_Int_Type_Def_Transform_Parse_0
                (Parser, First_Token_Index);
         when Null_Literal_Rule =>
            Result :=
              Null_Literal_Transform_Parse_0 (Parser, First_Token_Index);
         when Type_Decl_Rule =>
            Result := Type_Decl_Or_Parse_1 (Parser, First_Token_Index);
         when Range_Spec_Rule =>
            Result := Range_Spec_Transform_Parse_0 (Parser, First_Token_Index);
         when Paren_Expr_Rule =>
            Result := Paren_Expr_Transform_Parse_0 (Parser, First_Token_Index);
         when Derived_Type_Def_Rule =>
            Result :=
              Derived_Type_Def_Transform_Parse_0 (Parser, First_Token_Index);
         when Box_Expr_Rule =>
            Result := Box_Expr_Transform_Parse_0 (Parser, First_Token_Index);
         when Term_Rule =>
            Result := Term_Or_Parse_1 (Parser, First_Token_Index);
         when Others_Designator_Rule =>
            Result :=
              Others_Designator_Transform_Parse_0 (Parser, First_Token_Index);
         when If_Stmt_Rule =>
            Result := If_Stmt_Transform_Parse_1 (Parser, First_Token_Index);
         when Generic_Formal_Part_Rule =>
            Result :=
              Generic_Formal_Part_Transform_Parse_0
                (Parser, First_Token_Index);
         when Discriminant_Part_Rule =>
            Result := Discriminant_Part_Or_Parse_0 (Parser, First_Token_Index);
         when Protected_Def_Rule =>
            Result :=
              Protected_Def_Transform_Parse_3 (Parser, First_Token_Index);
         when Renaming_Clause_Rule =>
            Result :=
              Renaming_Clause_Transform_Parse_0 (Parser, First_Token_Index);
         when Single_Task_Decl_Rule =>
            Result :=
              Single_Task_Decl_Transform_Parse_1 (Parser, First_Token_Index);
         when Discrete_Subtype_Indication_Rule =>
            Result :=
              Discrete_Subtype_Indication_Transform_Parse_0
                (Parser, First_Token_Index);
         when Boolean_Op_Rule =>
            Result := Boolean_Op_Or_Parse_0 (Parser, First_Token_Index);
         when Mode_Rule =>
            Result := Mode_Or_Parse_0 (Parser, First_Token_Index);
         when Rel_Op_Rule =>
            Result := Rel_Op_Or_Parse_0 (Parser, First_Token_Index);
         when Accept_Stmt_Rule =>
            Result := Accept_Stmt_Or_Parse_0 (Parser, First_Token_Index);
         when Task_Body_Stub_Rule =>
            Result :=
              Task_Body_Stub_Transform_Parse_0 (Parser, First_Token_Index);
         when Discriminant_Constraint_Rule =>
            Result :=
              Discriminant_Constraint_Transform_Parse_0
                (Parser, First_Token_Index);
         when Subtype_Decl_Rule =>
            Result :=
              Subtype_Decl_Transform_Parse_0 (Parser, First_Token_Index);
         when Membership_Choice_List_Rule =>
            Result :=
              Membership_Choice_List_List_Parse_0 (Parser, First_Token_Index);
         when Delta_Constraint_Rule =>
            Result :=
              Delta_Constraint_Transform_Parse_0 (Parser, First_Token_Index);
         when Static_Name_Rule =>
            Result := Static_Name_Or_Parse_0 (Parser, First_Token_Index);
         when Char_Literal_Rule =>
            Result :=
              Char_Literal_Transform_Parse_0 (Parser, First_Token_Index);
         when Discrete_Subtype_Definition_Rule =>
            Result :=
              Discrete_Subtype_Definition_Or_Parse_0
                (Parser, First_Token_Index);
         when Overriding_Indicator_Rule =>
            Result :=
              Overriding_Indicator_Or_Parse_0 (Parser, First_Token_Index);
         when Range_Constraint_Rule =>
            Result :=
              Range_Constraint_Transform_Parse_1 (Parser, First_Token_Index);
         when Recov_Decl_Part_Rule =>
            Result :=
              Recov_Decl_Part_Dont_Skip_Parse_0 (Parser, First_Token_Index);
         when Package_Renaming_Decl_Rule =>
            Result :=
              Package_Renaming_Decl_Transform_Parse_0
                (Parser, First_Token_Index);
         when String_Literal_Rule =>
            Result :=
              String_Literal_Transform_Parse_0 (Parser, First_Token_Index);
         when Package_Body_Rule =>
            Result :=
              Package_Body_Transform_Parse_1 (Parser, First_Token_Index);
         when Case_Stmt_Rule =>
            Result := Case_Stmt_Transform_Parse_0 (Parser, First_Token_Index);
         when Record_Def_Rule =>
            Result := Record_Def_Or_Parse_0 (Parser, First_Token_Index);
         when Stmts_Rule =>
            Result := Stmts_List_Parse_0 (Parser, First_Token_Index);
         when Contract_Cases_Expr_Rule =>
            Result :=
              Contract_Cases_Expr_Transform_Parse_0
                (Parser, First_Token_Index);
         when Block_Stmt_Rule =>
            Result := Block_Stmt_Or_Parse_0 (Parser, First_Token_Index);
         when Label_Rule =>
            Result := Label_Transform_Parse_1 (Parser, First_Token_Index);
         when Abstract_Subp_Decl_Rule =>
            Result :=
              Abstract_Subp_Decl_Transform_Parse_0 (Parser, First_Token_Index);
         when For_Loop_Param_Spec_Rule =>
            Result :=
              For_Loop_Param_Spec_Transform_Parse_3
                (Parser, First_Token_Index);
         when Direct_Name_Or_Target_Name_Rule =>
            Result :=
              Direct_Name_Or_Target_Name_Or_Parse_0
                (Parser, First_Token_Index);
         when Assignment_Stmt_Rule =>
            Result :=
              Assignment_Stmt_Transform_Parse_0 (Parser, First_Token_Index);
         when Sub_Object_Decl_Rule =>
            Result :=
              Sub_Object_Decl_Transform_Parse_0 (Parser, First_Token_Index);
         when Subunit_Rule =>
            Result := Subunit_Transform_Parse_0 (Parser, First_Token_Index);
         when Param_Assoc_Rule =>
            Result :=
              Param_Assoc_Transform_Parse_0 (Parser, First_Token_Index);
         when Floating_Point_Def_Rule =>
            Result :=
              Floating_Point_Def_Transform_Parse_0 (Parser, First_Token_Index);
         when Compound_Stmt_Rule =>
            Result := Compound_Stmt_Or_Parse_0 (Parser, First_Token_Index);
         when Package_Body_Stub_Rule =>
            Result :=
              Package_Body_Stub_Transform_Parse_0 (Parser, First_Token_Index);
         when Body_Rule =>
            Result := Body_Or_Parse_0 (Parser, First_Token_Index);
         when Discr_Spec_List_Rule =>
            Result := Discr_Spec_List_List_Parse_0 (Parser, First_Token_Index);
         when Object_Decl_Rule =>
            Result := Object_Decl_Or_Parse_0 (Parser, First_Token_Index);
         when Record_Type_Def_Rule =>
            Result :=
              Record_Type_Def_Transform_Parse_0 (Parser, First_Token_Index);
         when Compilation_Rule =>
            Result := Compilation_Or_Parse_0 (Parser, First_Token_Index);
         when Library_Unit_Renaming_Decl_Rule =>
            Result :=
              Library_Unit_Renaming_Decl_Or_Parse_0
                (Parser, First_Token_Index);
         when Stmt_Rule =>
            Result := Stmt_Or_Parse_0 (Parser, First_Token_Index);
         when Entry_Body_Rule =>
            Result := Entry_Body_Transform_Parse_3 (Parser, First_Token_Index);
         when With_Clause_Rule =>
            Result :=
              With_Clause_Transform_Parse_0 (Parser, First_Token_Index);
         when Terminate_Alternative_Rule =>
            Result :=
              Terminate_Alternative_Transform_Parse_0
                (Parser, First_Token_Index);
         when Ext_Ret_Stmt_Object_Decl_Rule =>
            Result :=
              Ext_Ret_Stmt_Object_Decl_Transform_Parse_0
                (Parser, First_Token_Index);
         when Subtype_Indication_Rule =>
            Result :=
              Subtype_Indication_Transform_Parse_0 (Parser, First_Token_Index);
         when Identifier_Rule =>
            Result := Identifier_Transform_Parse_0 (Parser, First_Token_Index);
         when Library_Unit_Body_Rule =>
            Result := Library_Unit_Body_Or_Parse_0 (Parser, First_Token_Index);
         when Constraint_Rule =>
            Result := Constraint_Or_Parse_0 (Parser, First_Token_Index);
         when Sexpr_Or_Box_Rule =>
            Result := Sexpr_Or_Box_Or_Parse_0 (Parser, First_Token_Index);
         when Use_Clause_Rule =>
            Result := Use_Clause_Or_Parse_0 (Parser, First_Token_Index);
         when Subp_Spec_Rule =>
            Result := Subp_Spec_Transform_Parse_2 (Parser, First_Token_Index);
         when Unop_Term_Rule =>
            Result := Unop_Term_Or_Parse_1 (Parser, First_Token_Index);
         when Null_Subp_Decl_Rule =>
            Result :=
              Null_Subp_Decl_Transform_Parse_0 (Parser, First_Token_Index);
         when Ext_Return_Stmt_Rule =>
            Result :=
              Ext_Return_Stmt_Transform_Parse_0 (Parser, First_Token_Index);
         when Use_Package_Clause_Rule =>
            Result :=
              Use_Package_Clause_Transform_Parse_0 (Parser, First_Token_Index);
         when Variant_Part_Rule =>
            Result :=
              Variant_Part_Transform_Parse_0 (Parser, First_Token_Index);
         when Membership_Choice_Rule =>
            Result := Membership_Choice_Or_Parse_0 (Parser, First_Token_Index);
         when Exception_Handler_Rule =>
            Result :=
              Exception_Handler_Transform_Parse_0 (Parser, First_Token_Index);
         when Primary_Rule =>
            Result := Primary_Or_Parse_0 (Parser, First_Token_Index);
         when Constraint_List_Rule =>
            Result := Constraint_List_List_Parse_0 (Parser, First_Token_Index);
         when Raise_Expr_Rule =>
            Result := Raise_Expr_Or_Parse_0 (Parser, First_Token_Index);
         when Return_Stmt_Rule =>
            Result :=
              Return_Stmt_Transform_Parse_0 (Parser, First_Token_Index);
         when Generic_Decl_Rule =>
            Result := Generic_Decl_Or_Parse_0 (Parser, First_Token_Index);
         when Component_Decl_Rule =>
            Result :=
              Component_Decl_Transform_Parse_0 (Parser, First_Token_Index);
         when Anonymous_Type_Rule =>
            Result :=
              Anonymous_Type_Transform_Parse_0 (Parser, First_Token_Index);
         when Mod_Int_Type_Def_Rule =>
            Result :=
              Mod_Int_Type_Def_Transform_Parse_0 (Parser, First_Token_Index);
         when Pragma_Argument_Rule =>
            Result :=
              Pragma_Argument_Transform_Parse_0 (Parser, First_Token_Index);
         when Component_Def_Rule =>
            Result :=
              Component_Def_Transform_Parse_0 (Parser, First_Token_Index);
         when Aggregate_Assoc_Rule =>
            Result :=
              Aggregate_Assoc_Transform_Parse_0 (Parser, First_Token_Index);
         when Expr_Fn_Rule =>
            Result := Expr_Fn_Transform_Parse_0 (Parser, First_Token_Index);
         when Call_Suffix_Rule =>
            Result := Call_Suffix_Or_Parse_0 (Parser, First_Token_Index);
         when Aspect_Assoc_Rule =>
            Result :=
              Aspect_Assoc_Transform_Parse_0 (Parser, First_Token_Index);
         when Protected_Body_Rule =>
            Result :=
              Protected_Body_Transform_Parse_1 (Parser, First_Token_Index);
         when Iblock_Stmt_Rule =>
            Result := Iblock_Stmt_Or_Parse_0 (Parser, First_Token_Index);
         when Name_Rule =>
            Result := Name_Or_Parse_1 (Parser, First_Token_Index);
         when Context_Item_Rule =>
            Result := Context_Item_Or_Parse_0 (Parser, First_Token_Index);
         when Task_Type_Decl_Rule =>
            Result :=
              Task_Type_Decl_Transform_Parse_0 (Parser, First_Token_Index);
         when Discriminant_Spec_Rule =>
            Result :=
              Discriminant_Spec_Transform_Parse_0 (Parser, First_Token_Index);
         when Generic_Renaming_Decl_Rule =>
            Result :=
              Generic_Renaming_Decl_Or_Parse_1 (Parser, First_Token_Index);
         when Delay_Stmt_Rule =>
            Result := Delay_Stmt_Transform_Parse_0 (Parser, First_Token_Index);
         when Use_Type_Clause_Rule =>
            Result :=
              Use_Type_Clause_Transform_Parse_0 (Parser, First_Token_Index);
         when Real_Type_Def_Rule =>
            Result := Real_Type_Def_Or_Parse_0 (Parser, First_Token_Index);
         when Call_Stmt_Rule =>
            Result := Call_Stmt_Transform_Parse_0 (Parser, First_Token_Index);
         when Body_Stub_Rule =>
            Result := Body_Stub_Or_Parse_0 (Parser, First_Token_Index);
         when Factor_Rule =>
            Result := Factor_Or_Parse_1 (Parser, First_Token_Index);
         when Defining_Id_Rule =>
            Result :=
              Defining_Id_Transform_Parse_0 (Parser, First_Token_Index);
         when Entry_Decl_Rule =>
            Result := Entry_Decl_Transform_Parse_1 (Parser, First_Token_Index);
         when Protected_Type_Decl_Rule =>
            Result :=
              Protected_Type_Decl_Transform_Parse_0
                (Parser, First_Token_Index);
         when Formal_Discrete_Type_Def_Rule =>
            Result :=
              Formal_Discrete_Type_Def_Transform_Parse_0
                (Parser, First_Token_Index);
         when Discrete_Range_Rule =>
            Result := Discrete_Range_Or_Parse_0 (Parser, First_Token_Index);
         when Pragma_Rule =>
            Result := Pragma_Transform_Parse_0 (Parser, First_Token_Index);
         when Requeue_Stmt_Rule =>
            Result :=
              Requeue_Stmt_Transform_Parse_0 (Parser, First_Token_Index);
         when Raise_Stmt_Rule =>
            Result := Raise_Stmt_Or_Parse_0 (Parser, First_Token_Index);
         when Type_Def_Rule =>
            Result := Type_Def_Or_Parse_0 (Parser, First_Token_Index);
         when Qual_Name_Internal_Rule =>
            Result :=
              Qual_Name_Internal_Or_Parse_0 (Parser, First_Token_Index);
         when Conditional_Expr_Rule =>
            Result := Conditional_Expr_Or_Parse_0 (Parser, First_Token_Index);
         when Contract_Case_Assoc_Rule =>
            Result :=
              Contract_Case_Assoc_Transform_Parse_0
                (Parser, First_Token_Index);
         when Basic_Decl_Rule =>
            Result := Basic_Decl_Or_Parse_0 (Parser, First_Token_Index);
         when Expr_Rule =>
            Result := Expr_Or_Parse_0 (Parser, First_Token_Index);
         when Subp_Renaming_Decl_Rule =>
            Result :=
              Subp_Renaming_Decl_Transform_Parse_0 (Parser, First_Token_Index);
         when Simple_Expr_Rule =>
            Result := Simple_Expr_Or_Parse_1 (Parser, First_Token_Index);
         when Case_Alt_Rule =>
            Result := Case_Alt_Transform_Parse_0 (Parser, First_Token_Index);
         when Generic_Formal_Decl_Rule =>
            Result :=
              Generic_Formal_Decl_Or_Parse_0 (Parser, First_Token_Index);
         when Enum_Literal_Decl_Rule =>
            Result :=
              Enum_Literal_Decl_Transform_Parse_1 (Parser, First_Token_Index);
         when Digits_Constraint_Rule =>
            Result :=
              Digits_Constraint_Transform_Parse_0 (Parser, First_Token_Index);
         when Goto_Stmt_Rule =>
            Result := Goto_Stmt_Transform_Parse_0 (Parser, First_Token_Index);
         when Direct_Name_Rule =>
            Result := Direct_Name_Or_Parse_0 (Parser, First_Token_Index);
         when Handled_Stmts_Rule =>
            Result :=
              Handled_Stmts_Transform_Parse_0 (Parser, First_Token_Index);
         when Task_Item_Rule =>
            Result := Task_Item_Or_Parse_0 (Parser, First_Token_Index);
         when Case_Expr_Rule =>
            Result := Case_Expr_Transform_Parse_0 (Parser, First_Token_Index);
         when Target_Name_Rule =>
            Result :=
              Target_Name_Transform_Parse_0 (Parser, First_Token_Index);
         when Protected_Decl_Rule =>
            Result :=
              Protected_Decl_Transform_Parse_0 (Parser, First_Token_Index);
         when Task_Body_Rule =>
            Result := Task_Body_Transform_Parse_1 (Parser, First_Token_Index);
         when Abort_Stmt_Rule =>
            Result := Abort_Stmt_Transform_Parse_0 (Parser, First_Token_Index);
         when Dec_Literal_Rule =>
            Result :=
              Dec_Literal_Transform_Parse_0 (Parser, First_Token_Index);
         when Exception_Decl_Rule =>
            Result :=
              Exception_Decl_Transform_Parse_0 (Parser, First_Token_Index);
         when Package_Decl_Rule =>
            Result :=
              Package_Decl_Transform_Parse_3 (Parser, First_Token_Index);
         when Subp_Body_Stub_Rule =>
            Result :=
              Subp_Body_Stub_Transform_Parse_0 (Parser, First_Token_Index);
         when Discriminant_Assoc_Rule =>
            Result :=
              Discriminant_Assoc_Transform_Parse_0 (Parser, First_Token_Index);
         when Qualified_Name_Rule =>
            Result :=
              Qualified_Name_Transform_Parse_0 (Parser, First_Token_Index);
         when Enum_Type_Def_Rule =>
            Result :=
              Enum_Type_Def_Transform_Parse_0 (Parser, First_Token_Index);
         when Choice_List_Rule =>
            Result := Choice_List_List_Parse_0 (Parser, First_Token_Index);
         when Allocator_Rule =>
            Result := Allocator_Transform_Parse_0 (Parser, First_Token_Index);
         when Defining_Name_Rule =>
            Result :=
              Defining_Name_Transform_Parse_0 (Parser, First_Token_Index);
         when Subp_Body_Rule =>
            Result := Subp_Body_Transform_Parse_1 (Parser, First_Token_Index);
         when Update_Attr_Content_Rule =>
            Result :=
              Update_Attr_Content_List_Parse_0 (Parser, First_Token_Index);
         when Case_Expr_Alt_Rule =>
            Result :=
              Case_Expr_Alt_Transform_Parse_0 (Parser, First_Token_Index);
         when Generic_Instantiation_Rule =>
            Result :=
              Generic_Instantiation_Or_Parse_1 (Parser, First_Token_Index);
         when Library_Item_Rule =>
            Result :=
              Library_Item_Transform_Parse_1 (Parser, First_Token_Index);
         when Exit_Stmt_Rule =>
            Result := Exit_Stmt_Transform_Parse_0 (Parser, First_Token_Index);
         when Constrained_Subtype_Indication_Rule =>
            Result :=
              Constrained_Subtype_Indication_Transform_Parse_0
                (Parser, First_Token_Index);
         when Variant_Rule =>
            Result := Variant_Transform_Parse_0 (Parser, First_Token_Index);
         when Subtype_Name_Rule =>
            Result := Subtype_Name_Or_Parse_0 (Parser, First_Token_Index);
         when Index_Constraint_Rule =>
            Result :=
              Index_Constraint_Transform_Parse_0 (Parser, First_Token_Index);
         when Protected_Op_Rule =>
            Result := Protected_Op_Or_Parse_0 (Parser, First_Token_Index);
         when Loop_Stmt_Rule =>
            Result := Loop_Stmt_Or_Parse_0 (Parser, First_Token_Index);
         when Aggregate_Rule =>
            Result := Aggregate_Or_Parse_0 (Parser, First_Token_Index);
         when Choice_Rule =>
            Result := Choice_Or_Parse_0 (Parser, First_Token_Index);
         when Num_Literal_Rule =>
            Result := Num_Literal_Or_Parse_0 (Parser, First_Token_Index);
         when Quantified_Expr_Rule =>
            Result :=
              Quantified_Expr_Transform_Parse_2 (Parser, First_Token_Index);
         when Unconstrained_Index_Rule =>
            Result :=
              Unconstrained_Index_Transform_Parse_0
                (Parser, First_Token_Index);
         when Parent_List_Rule =>
            Result := Parent_List_List_Parse_0 (Parser, First_Token_Index);
         when Component_Item_Rule =>
            Result := Component_Item_Or_Parse_0 (Parser, First_Token_Index);
         when Type_Expr_Rule =>
            Result := Type_Expr_Or_Parse_0 (Parser, First_Token_Index);
         when Subp_Decl_Rule =>
            Result := Subp_Decl_Or_Parse_0 (Parser, First_Token_Index);
         when Component_List_Rule =>
            Result :=
              Component_List_Transform_Parse_0 (Parser, First_Token_Index);
         when Multidim_Array_Assoc_Rule =>
            Result :=
              Multidim_Array_Assoc_Transform_Parse_0
                (Parser, First_Token_Index);
         when Access_Def_Rule =>
            Result := Access_Def_Or_Parse_0 (Parser, First_Token_Index);
         when Null_Stmt_Rule =>
            Result := Null_Stmt_Transform_Parse_0 (Parser, First_Token_Index);
         when Number_Decl_Rule =>
            Result :=
              Number_Decl_Transform_Parse_0 (Parser, First_Token_Index);
         when Ordinary_Fixed_Point_Def_Rule =>
            Result :=
              Ordinary_Fixed_Point_Def_Transform_Parse_0
                (Parser, First_Token_Index);
         when Basic_Decls_Rule =>
            Result := Basic_Decls_List_Parse_0 (Parser, First_Token_Index);
      end case;
      Process_Parsing_Error (Parser, Check_Complete);
      Set_Parents (Result, null);
      return Parsed_Node (Result);
   end Parse;

   function Dec_Literal_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Real_Literal
   is
      use Bare_Real_Literal_Memos;

      Row_Pos_15       : Token_Index       := No_Token_Index;
      Token_Pos_12     : Token_Index       := No_Token_Index;
      Token_Res_12     : Token_Index       := No_Token_Index;
      Transform_Res_15 : Bare_Real_Literal := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Dec_Literal_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_15   := M.Instance;
         return Transform_Res_15;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_15;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_15 := Pos;

--  Start tok_code

      Token_Res_12 := Row_Pos_15;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_12));
      begin
         if T.Kind /= From_Token_Kind (Ada_Decimal) then
            Token_Pos_12 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_15 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_15,
                  Expected_Token_Id => Ada_Decimal,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_12 := Row_Pos_15 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_12 /= No_Token_Index then

         Row_Pos_15 := Token_Pos_12;

      else
         Row_Pos_15 := No_Token_Index;
         goto Exit_Row_13_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_13_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_15 /= No_Token_Index then

         Transform_Res_15 := Allocate_Real_Literal (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_15, Kind => Ada_Real_Literal,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_15 = Pos then No_Token_Index else Row_Pos_15 - 1));

         Initialize_Fields_For_Real_Literal (Self => Transform_Res_15);

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Dec_Literal_Transform_Parse_0_Memo,
         Row_Pos_15 /= No_Token_Index, Transform_Res_15, Pos, Row_Pos_15);

      Parser.Current_Pos := Row_Pos_15;

      return Transform_Res_15;
   end Dec_Literal_Transform_Parse_0;

   function Int_Literal_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Int_Literal
   is
      use Bare_Int_Literal_Memos;

      Row_Pos_16       : Token_Index      := No_Token_Index;
      Token_Pos_13     : Token_Index      := No_Token_Index;
      Token_Res_13     : Token_Index      := No_Token_Index;
      Transform_Res_16 : Bare_Int_Literal := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Int_Literal_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_16   := M.Instance;
         return Transform_Res_16;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_16;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_16 := Pos;

--  Start tok_code

      Token_Res_13 := Row_Pos_16;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_13));
      begin
         if T.Kind /= From_Token_Kind (Ada_Integer) then
            Token_Pos_13 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_16 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_16,
                  Expected_Token_Id => Ada_Integer,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_13 := Row_Pos_16 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_13 /= No_Token_Index then

         Row_Pos_16 := Token_Pos_13;

      else
         Row_Pos_16 := No_Token_Index;
         goto Exit_Row_14_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_14_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_16 /= No_Token_Index then

         Transform_Res_16 := Allocate_Int_Literal (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_16, Kind => Ada_Int_Literal,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_16 = Pos then No_Token_Index else Row_Pos_16 - 1));

         Initialize_Fields_For_Int_Literal (Self => Transform_Res_16);

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Int_Literal_Transform_Parse_0_Memo,
         Row_Pos_16 /= No_Token_Index, Transform_Res_16, Pos, Row_Pos_16);

      Parser.Current_Pos := Row_Pos_16;

      return Transform_Res_16;
   end Int_Literal_Transform_Parse_0;

   function Num_Literal_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Num_Literal
   is
      use Bare_Num_Literal_Memos;

      Defer_Pos_23 : Token_Index       := No_Token_Index;
      Defer_Res_23 : Bare_Real_Literal := No_Bare_Ada_Node;
      Defer_Pos_24 : Token_Index       := No_Token_Index;
      Defer_Res_24 : Bare_Int_Literal  := No_Bare_Ada_Node;
      Or_Pos_8     : Token_Index       := No_Token_Index;
      Or_Res_8     : Bare_Num_Literal  := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Num_Literal_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_8           := M.Instance;
         return Or_Res_8;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_8;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_8 := No_Token_Index;
      Or_Res_8 := No_Bare_Ada_Node;

      Defer_Res_23 := Dec_Literal_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_23 := Parser.Current_Pos;

      if Defer_Pos_23 /= No_Token_Index then
         Or_Pos_8 := Defer_Pos_23;
         Or_Res_8 := Defer_Res_23;
         goto Exit_Or_8;
      end if;

      Defer_Res_24 := Int_Literal_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_24 := Parser.Current_Pos;

      if Defer_Pos_24 /= No_Token_Index then
         Or_Pos_8 := Defer_Pos_24;
         Or_Res_8 := Defer_Res_24;
         goto Exit_Or_8;
      end if;
      <<Exit_Or_8>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Num_Literal_Or_Parse_0_Memo,
         Or_Pos_8 /= No_Token_Index, Or_Res_8, Pos, Or_Pos_8);

      Parser.Current_Pos := Or_Pos_8;

      return Or_Res_8;
   end Num_Literal_Or_Parse_0;

   function Null_Literal_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Null_Literal
   is
      use Bare_Null_Literal_Memos;

      Row_Pos_17       : Token_Index       := No_Token_Index;
      Token_Pos_14     : Token_Index       := No_Token_Index;
      Token_Res_14     : Token_Index       := No_Token_Index;
      Transform_Res_17 : Bare_Null_Literal := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Null_Literal_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_17   := M.Instance;
         return Transform_Res_17;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_17;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_17 := Pos;

--  Start tok_code

      Token_Res_14 := Row_Pos_17;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_14));
      begin
         if T.Kind /= From_Token_Kind (Ada_Null) then
            Token_Pos_14 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_17 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_17,
                  Expected_Token_Id => Ada_Null,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_14 := Row_Pos_17 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_14 /= No_Token_Index then

         Row_Pos_17 := Token_Pos_14;

      else
         Row_Pos_17 := No_Token_Index;
         goto Exit_Row_15_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_15_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_17 /= No_Token_Index then

         Transform_Res_17 := Allocate_Null_Literal (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_17, Kind => Ada_Null_Literal,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_17 = Pos then No_Token_Index else Row_Pos_17 - 1));

         Initialize_Fields_For_Null_Literal (Self => Transform_Res_17);

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Null_Literal_Transform_Parse_0_Memo,
         Row_Pos_17 /= No_Token_Index, Transform_Res_17, Pos, Row_Pos_17);

      Parser.Current_Pos := Row_Pos_17;

      return Transform_Res_17;
   end Null_Literal_Transform_Parse_0;

   function Identifier_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Identifier
   is
      use Bare_Identifier_Memos;

      Row_Pos_32       : Token_Index     := No_Token_Index;
      Token_Pos_34     : Token_Index     := No_Token_Index;
      Token_Res_34     : Token_Index     := No_Token_Index;
      Transform_Res_29 : Bare_Identifier := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Identifier_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_29   := M.Instance;
         return Transform_Res_29;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_29;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_32 := Pos;

--  Start tok_code

      Token_Res_34 := Row_Pos_32;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_34));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier) then
            Token_Pos_34 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_32 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_32,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_34 := Row_Pos_32 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_34 /= No_Token_Index then

         Row_Pos_32 := Token_Pos_34;

      else
         Row_Pos_32 := No_Token_Index;
         goto Exit_Row_20_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_20_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_32 /= No_Token_Index then

         Transform_Res_29 := Allocate_Identifier (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_29, Kind => Ada_Identifier,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_32 = Pos then No_Token_Index else Row_Pos_32 - 1));

         Initialize_Fields_For_Identifier (Self => Transform_Res_29);

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Identifier_Transform_Parse_0_Memo,
         Row_Pos_32 /= No_Token_Index, Transform_Res_29, Pos, Row_Pos_32);

      Parser.Current_Pos := Row_Pos_32;

      return Transform_Res_29;
   end Identifier_Transform_Parse_0;

   function String_Literal_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_String_Literal
   is
      use Bare_String_Literal_Memos;

      Row_Pos_33       : Token_Index         := No_Token_Index;
      Token_Pos_35     : Token_Index         := No_Token_Index;
      Token_Res_35     : Token_Index         := No_Token_Index;
      Transform_Res_30 : Bare_String_Literal := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.String_Literal_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_30   := M.Instance;
         return Transform_Res_30;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_30;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_33 := Pos;

--  Start tok_code

      Token_Res_35 := Row_Pos_33;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_35));
      begin
         if T.Kind /= From_Token_Kind (Ada_String) then
            Token_Pos_35 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_33 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_33,
                  Expected_Token_Id => Ada_String,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_35 := Row_Pos_33 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_35 /= No_Token_Index then

         Row_Pos_33 := Token_Pos_35;

      else
         Row_Pos_33 := No_Token_Index;
         goto Exit_Row_21_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_21_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_33 /= No_Token_Index then

         Transform_Res_30 := Allocate_String_Literal (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_30, Kind => Ada_String_Literal,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_33 = Pos then No_Token_Index else Row_Pos_33 - 1));

         Initialize_Fields_For_String_Literal (Self => Transform_Res_30);

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.String_Literal_Transform_Parse_0_Memo,
         Row_Pos_33 /= No_Token_Index, Transform_Res_30, Pos, Row_Pos_33);

      Parser.Current_Pos := Row_Pos_33;

      return Transform_Res_30;
   end String_Literal_Transform_Parse_0;

   function Char_Literal_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Char_Literal
   is
      use Bare_Char_Literal_Memos;

      Row_Pos_34       : Token_Index       := No_Token_Index;
      Token_Pos_36     : Token_Index       := No_Token_Index;
      Token_Res_36     : Token_Index       := No_Token_Index;
      Transform_Res_31 : Bare_Char_Literal := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Char_Literal_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_31   := M.Instance;
         return Transform_Res_31;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_31;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_34 := Pos;

--  Start tok_code

      Token_Res_36 := Row_Pos_34;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_36));
      begin
         if T.Kind /= From_Token_Kind (Ada_Char) then
            Token_Pos_36 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_34 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_34,
                  Expected_Token_Id => Ada_Char,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_36 := Row_Pos_34 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_36 /= No_Token_Index then

         Row_Pos_34 := Token_Pos_36;

      else
         Row_Pos_34 := No_Token_Index;
         goto Exit_Row_22_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_22_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_34 /= No_Token_Index then

         Transform_Res_31 := Allocate_Char_Literal (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_31, Kind => Ada_Char_Literal,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_34 = Pos then No_Token_Index else Row_Pos_34 - 1));

         Initialize_Fields_For_Char_Literal (Self => Transform_Res_31);

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Char_Literal_Transform_Parse_0_Memo,
         Row_Pos_34 /= No_Token_Index, Transform_Res_31, Pos, Row_Pos_34);

      Parser.Current_Pos := Row_Pos_34;

      return Transform_Res_31;
   end Char_Literal_Transform_Parse_0;

   function Direct_Name_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Base_Id
   is
      use Bare_Base_Id_Memos;

      Defer_Pos_52 : Token_Index         := No_Token_Index;
      Defer_Res_52 : Bare_Identifier     := No_Bare_Ada_Node;
      Defer_Pos_53 : Token_Index         := No_Token_Index;
      Defer_Res_53 : Bare_String_Literal := No_Bare_Ada_Node;
      Defer_Pos_54 : Token_Index         := No_Token_Index;
      Defer_Res_54 : Bare_Char_Literal   := No_Bare_Ada_Node;
      Or_Pos_13    : Token_Index         := No_Token_Index;
      Or_Res_13    : Bare_Base_Id        := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Direct_Name_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_13          := M.Instance;
         return Or_Res_13;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_13;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_13 := No_Token_Index;
      Or_Res_13 := No_Bare_Ada_Node;

      Defer_Res_52 := Identifier_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_52 := Parser.Current_Pos;

      if Defer_Pos_52 /= No_Token_Index then
         Or_Pos_13 := Defer_Pos_52;
         Or_Res_13 := Defer_Res_52;
         goto Exit_Or_12;
      end if;

      Defer_Res_53 := String_Literal_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_53 := Parser.Current_Pos;

      if Defer_Pos_53 /= No_Token_Index then
         Or_Pos_13 := Defer_Pos_53;
         Or_Res_13 := Defer_Res_53;
         goto Exit_Or_12;
      end if;

      Defer_Res_54 := Char_Literal_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_54 := Parser.Current_Pos;

      if Defer_Pos_54 /= No_Token_Index then
         Or_Pos_13 := Defer_Pos_54;
         Or_Res_13 := Defer_Res_54;
         goto Exit_Or_12;
      end if;
      <<Exit_Or_12>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Direct_Name_Or_Parse_0_Memo,
         Or_Pos_13 /= No_Token_Index, Or_Res_13, Pos, Or_Pos_13);

      Parser.Current_Pos := Or_Pos_13;

      return Or_Res_13;
   end Direct_Name_Or_Parse_0;

   function Subtype_Name_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Name
   is
      use Bare_Name_Memos;

      Row_Pos_29       : Token_Index        := No_Token_Index;
      Defer_Pos_46     : Token_Index        := No_Token_Index;
      Defer_Res_46     : Bare_Name          := No_Bare_Ada_Node;
      Token_Pos_30     : Token_Index        := No_Token_Index;
      Token_Res_30     : Token_Index        := No_Token_Index;
      Defer_Pos_47     : Token_Index        := No_Token_Index;
      Defer_Res_47     : Bare_Base_Id       := No_Bare_Ada_Node;
      Transform_Res_27 : Bare_Dotted_Name   := No_Bare_Ada_Node;
      Row_Pos_30       : Token_Index        := No_Token_Index;
      Defer_Pos_48     : Token_Index        := No_Token_Index;
      Defer_Res_48     : Bare_Name          := No_Bare_Ada_Node;
      Token_Pos_31     : Token_Index        := No_Token_Index;
      Token_Res_31     : Token_Index        := No_Token_Index;
      Defer_Pos_49     : Token_Index        := No_Token_Index;
      Defer_Res_49     : Bare_Identifier    := No_Bare_Ada_Node;
      Row_Pos_31       : Token_Index        := No_Token_Index;
      Token_Pos_32     : Token_Index        := No_Token_Index;
      Token_Res_32     : Token_Index        := No_Token_Index;
      Defer_Pos_50     : Token_Index        := No_Token_Index;
      Defer_Res_50     : Bare_Ada_Node      := No_Bare_Ada_Node;
      Token_Pos_33     : Token_Index        := No_Token_Index;
      Token_Res_33     : Token_Index        := No_Token_Index;
      Transform_Res_28 : Bare_Attribute_Ref := No_Bare_Ada_Node;
      Defer_Pos_51     : Token_Index        := No_Token_Index;
      Defer_Res_51     : Bare_Base_Id       := No_Bare_Ada_Node;
      Or_Pos_12        : Token_Index        := No_Token_Index;
      Or_Res_12        : Bare_Name          := No_Bare_Ada_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Name   := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Subtype_Name_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_12          := M.Instance;
         return Or_Res_12;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_12;
      end if;

      Set
        (Parser.Private_Part.Subtype_Name_Or_Parse_0_Memo, False, Or_Res_12,
         Pos, Mem_Pos);

      <<Try_Again>>

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_12 := No_Token_Index;
      Or_Res_12 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_29 := Pos;

      Defer_Res_46 := Subtype_Name_Or_Parse_0 (Parser, Row_Pos_29);
      Defer_Pos_46 := Parser.Current_Pos;

      if Defer_Pos_46 /= No_Token_Index then

         Row_Pos_29 := Defer_Pos_46;

      else
         Row_Pos_29 := No_Token_Index;
         goto Exit_Row_19_0;

      end if;

--  Start tok_code

      Token_Res_30 := Row_Pos_29;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_30));
      begin
         if T.Kind /= From_Token_Kind (Ada_Dot) then
            Token_Pos_30 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_29 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_29,
                  Expected_Token_Id => Ada_Dot,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_30 := Row_Pos_29 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_30 /= No_Token_Index then

         Row_Pos_29 := Token_Pos_30;

      else
         Row_Pos_29 := No_Token_Index;
         goto Exit_Row_19_0;

      end if;

      Defer_Res_47 := Direct_Name_Or_Parse_0 (Parser, Row_Pos_29);
      Defer_Pos_47 := Parser.Current_Pos;

      if Defer_Pos_47 /= No_Token_Index then

         Row_Pos_29 := Defer_Pos_47;

      else
         Row_Pos_29 := No_Token_Index;
         goto Exit_Row_19_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_19_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_29 /= No_Token_Index then

         Transform_Res_27 := Allocate_Dotted_Name (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_27, Kind => Ada_Dotted_Name,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_29 = Pos then No_Token_Index else Row_Pos_29 - 1));

         Initialize_Fields_For_Dotted_Name
           (Self => Transform_Res_27, Dotted_Name_F_Prefix => Defer_Res_46,
            Dotted_Name_F_Suffix => Defer_Res_47);

         if Defer_Res_46 /= null and then Is_Incomplete (Defer_Res_46) then
            Transform_Res_27.Last_Attempted_Child := 0;
         elsif Defer_Res_46 /= null and then not Is_Ghost (Defer_Res_46) then
            Transform_Res_27.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_47 /= null and then Is_Incomplete (Defer_Res_47) then
            Transform_Res_27.Last_Attempted_Child := 0;
         elsif Defer_Res_47 /= null and then not Is_Ghost (Defer_Res_47) then
            Transform_Res_27.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_29 /= No_Token_Index then
         Or_Pos_12 := Row_Pos_29;
         Or_Res_12 := Transform_Res_27;
         goto Exit_Or_11;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_30 := Pos;

      Defer_Res_48 := Subtype_Name_Or_Parse_0 (Parser, Row_Pos_30);
      Defer_Pos_48 := Parser.Current_Pos;

      if Defer_Pos_48 /= No_Token_Index then

         Row_Pos_30 := Defer_Pos_48;

      else
         Row_Pos_30 := No_Token_Index;
         goto Exit_Row_23_0;

      end if;

--  Start tok_code

      Token_Res_31 := Row_Pos_30;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_31));
      begin
         if T.Kind /= From_Token_Kind (Ada_Tick) then
            Token_Pos_31 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_30 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_30,
                  Expected_Token_Id => Ada_Tick,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_31 := Row_Pos_30 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_31 /= No_Token_Index then

         Row_Pos_30 := Token_Pos_31;

      else
         Row_Pos_30 := No_Token_Index;
         goto Exit_Row_23_0;

      end if;

      Defer_Res_49 := Identifier_Transform_Parse_0 (Parser, Row_Pos_30);
      Defer_Pos_49 := Parser.Current_Pos;

      if Defer_Pos_49 /= No_Token_Index then

         Row_Pos_30 := Defer_Pos_49;

      else
         Row_Pos_30 := No_Token_Index;
         goto Exit_Row_23_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_31 := Row_Pos_30;

--  Start tok_code

      Token_Res_32 := Row_Pos_31;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_32));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Open) then
            Token_Pos_32 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_31 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_31,
                  Expected_Token_Id => Ada_Par_Open,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_32 := Row_Pos_31 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_32 /= No_Token_Index then

         Row_Pos_31 := Token_Pos_32;

      else
         Row_Pos_31 := No_Token_Index;
         goto Exit_Row_24_0;

      end if;

      Defer_Res_50 := Call_Suffix_Or_Parse_0 (Parser, Row_Pos_31);
      Defer_Pos_50 := Parser.Current_Pos;

      if Defer_Pos_50 /= No_Token_Index then

         Row_Pos_31 := Defer_Pos_50;

      else
         Row_Pos_31 := No_Token_Index;
         goto Exit_Row_24_0;

      end if;

--  Start tok_code

      Token_Res_33 := Row_Pos_31;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_33));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Close) then
            Token_Pos_33 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_31 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_31,
                  Expected_Token_Id => Ada_Par_Close,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_33 := Row_Pos_31 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_33 /= No_Token_Index then

         Row_Pos_31 := Token_Pos_33;

      else
         Row_Pos_31 := No_Token_Index;
         goto Exit_Row_24_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_24_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_31 = No_Token_Index then

         Defer_Res_50 := No_Bare_Ada_Node;

         Row_Pos_31 := Row_Pos_30;

      end if;

--  End opt_code

      if Row_Pos_31 /= No_Token_Index then

         Row_Pos_30 := Row_Pos_31;

      else
         Row_Pos_30 := No_Token_Index;
         goto Exit_Row_23_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_23_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_30 /= No_Token_Index then

         Transform_Res_28 := Allocate_Attribute_Ref (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_28, Kind => Ada_Attribute_Ref,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_30 = Pos then No_Token_Index else Row_Pos_30 - 1));

         Initialize_Fields_For_Attribute_Ref
           (Self => Transform_Res_28, Attribute_Ref_F_Prefix => Defer_Res_48,
            Attribute_Ref_F_Attribute => Defer_Res_49,
            Attribute_Ref_F_Args      => Defer_Res_50);

         if Defer_Res_48 /= null and then Is_Incomplete (Defer_Res_48) then
            Transform_Res_28.Last_Attempted_Child := 0;
         elsif Defer_Res_48 /= null and then not Is_Ghost (Defer_Res_48) then
            Transform_Res_28.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_49 /= null and then Is_Incomplete (Defer_Res_49) then
            Transform_Res_28.Last_Attempted_Child := 0;
         elsif Defer_Res_49 /= null and then not Is_Ghost (Defer_Res_49) then
            Transform_Res_28.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_50 /= null and then Is_Incomplete (Defer_Res_50) then
            Transform_Res_28.Last_Attempted_Child := 0;
         elsif Defer_Res_50 /= null and then not Is_Ghost (Defer_Res_50) then
            Transform_Res_28.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_30 /= No_Token_Index then
         Or_Pos_12 := Row_Pos_30;
         Or_Res_12 := Transform_Res_28;
         goto Exit_Or_11;
      end if;

      Defer_Res_51 := Direct_Name_Or_Parse_0 (Parser, Pos);
      Defer_Pos_51 := Parser.Current_Pos;

      if Defer_Pos_51 /= No_Token_Index then
         Or_Pos_12 := Defer_Pos_51;
         Or_Res_12 := Defer_Res_51;
         goto Exit_Or_11;
      end if;
      <<Exit_Or_11>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      if Or_Pos_12 > Mem_Pos then
         Mem_Pos := Or_Pos_12;
         Mem_Res := Or_Res_12;
         Set
           (Parser.Private_Part.Subtype_Name_Or_Parse_0_Memo,
            Or_Pos_12 /= No_Token_Index, Or_Res_12, Pos, Or_Pos_12);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res_12 := Mem_Res;
         Or_Pos_12 := Mem_Pos;
         goto No_Memo;
      end if;

      Set
        (Parser.Private_Part.Subtype_Name_Or_Parse_0_Memo,
         Or_Pos_12 /= No_Token_Index, Or_Res_12, Pos, Or_Pos_12);

      <<No_Memo>>

      Parser.Current_Pos := Or_Pos_12;

      return Or_Res_12;
   end Subtype_Name_Or_Parse_0;

   function Discrete_Range_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Expr
   is
      use Bare_Expr_Memos;

      Row_Pos_37       : Token_Index        := No_Token_Index;
      Defer_Pos_57     : Token_Index        := No_Token_Index;
      Defer_Res_57     : Bare_Expr          := No_Bare_Ada_Node;
      Row_Pos_38       : Token_Index        := No_Token_Index;
      Token_Pos_38     : Token_Index        := No_Token_Index;
      Token_Res_38     : Token_Index        := No_Token_Index;
      Transform_Res_34 : Bare_Op_Double_Dot := No_Bare_Ada_Node;
      Defer_Pos_58     : Token_Index        := No_Token_Index;
      Defer_Res_58     : Bare_Expr          := No_Bare_Ada_Node;
      Transform_Res_35 : Bare_Bin_Op        := No_Bare_Ada_Node;
      Defer_Pos_59     : Token_Index        := No_Token_Index;
      Defer_Res_59     : Bare_Name          := No_Bare_Ada_Node;
      Predicate_Pos_1  : Token_Index        := No_Token_Index;
      Predicate_Res_1  : Bare_Name          := No_Bare_Ada_Node;
      Or_Pos_15        : Token_Index        := No_Token_Index;
      Or_Res_15        : Bare_Expr          := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Discrete_Range_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_15          := M.Instance;
         return Or_Res_15;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_15;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_15 := No_Token_Index;
      Or_Res_15 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_37 := Pos;

      Defer_Res_57 := Simple_Expr_Or_Parse_1 (Parser, Row_Pos_37);
      Defer_Pos_57 := Parser.Current_Pos;

      if Defer_Pos_57 /= No_Token_Index then

         Row_Pos_37 := Defer_Pos_57;

      else
         Row_Pos_37 := No_Token_Index;
         goto Exit_Row_27_0;

      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_38 := Row_Pos_37;

--  Start tok_code

      Token_Res_38 := Row_Pos_38;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_38));
      begin
         if T.Kind /= From_Token_Kind (Ada_Doubledot) then
            Token_Pos_38 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_38 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_38,
                  Expected_Token_Id => Ada_Doubledot,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_38 := Row_Pos_38 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_38 /= No_Token_Index then

         Row_Pos_38 := Token_Pos_38;

      else
         Row_Pos_38 := No_Token_Index;
         goto Exit_Row_28_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_28_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_38 /= No_Token_Index then

         Transform_Res_34 := Allocate_Op_Double_Dot (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_34, Kind => Ada_Op_Double_Dot,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_37,
            Token_End_Index =>
              (if Row_Pos_38 = Row_Pos_37 then No_Token_Index
               else Row_Pos_38 - 1));

         Initialize_Fields_For_Op_Double_Dot (Self => Transform_Res_34);

      end if;

--  End transform_code

      if Row_Pos_38 /= No_Token_Index then

         Row_Pos_37 := Row_Pos_38;

      else
         Row_Pos_37 := No_Token_Index;
         goto Exit_Row_27_0;

      end if;

      Defer_Res_58 := Simple_Expr_Or_Parse_1 (Parser, Row_Pos_37);
      Defer_Pos_58 := Parser.Current_Pos;

      if Defer_Pos_58 /= No_Token_Index then

         Row_Pos_37 := Defer_Pos_58;

      else
         Row_Pos_37 := No_Token_Index;
         goto Exit_Row_27_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_27_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_37 /= No_Token_Index then

         Transform_Res_35 := Allocate_Bin_Op (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_35, Kind => Ada_Bin_Op, Unit => Parser.Unit,

            Token_Start_Index => Pos,
            Token_End_Index   =>
              (if Row_Pos_37 = Pos then No_Token_Index else Row_Pos_37 - 1));

         Initialize_Fields_For_Bin_Op
           (Self        => Transform_Res_35, Bin_Op_F_Left => Defer_Res_57,
            Bin_Op_F_Op => Transform_Res_34, Bin_Op_F_Right => Defer_Res_58);

         if Defer_Res_57 /= null and then Is_Incomplete (Defer_Res_57) then
            Transform_Res_35.Last_Attempted_Child := 0;
         elsif Defer_Res_57 /= null and then not Is_Ghost (Defer_Res_57) then
            Transform_Res_35.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_34 /= null and then Is_Incomplete (Transform_Res_34)
         then
            Transform_Res_35.Last_Attempted_Child := 0;
         elsif Transform_Res_34 /= null
           and then not Is_Ghost (Transform_Res_34)
         then
            Transform_Res_35.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_58 /= null and then Is_Incomplete (Defer_Res_58) then
            Transform_Res_35.Last_Attempted_Child := 0;
         elsif Defer_Res_58 /= null and then not Is_Ghost (Defer_Res_58) then
            Transform_Res_35.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_37 /= No_Token_Index then
         Or_Pos_15 := Row_Pos_37;
         Or_Res_15 := Transform_Res_35;
         goto Exit_Or_14;
      end if;

--  Start predicate_code

      Defer_Res_59 := Name_Or_Parse_1 (Parser, Pos);
      Defer_Pos_59 := Parser.Current_Pos;

      if Defer_Res_59 /= null and then Name_P_Is_Range_Attribute (Defer_Res_59)
      then
         Predicate_Res_1 := Defer_Res_59;
         Predicate_Pos_1 := Defer_Pos_59;
      else
         Predicate_Pos_1 := No_Token_Index;
         Predicate_Res_1 := null;

         if Parser.Last_Fail.Pos <= Pos then
            Parser.Last_Fail :=
              (Kind           => Custom_Fail, Pos => Pos,
               Custom_Message => Generic_Parsing_Error_Message_Access);
         end if;
      end if;

--  End predicate_code

      if Predicate_Pos_1 /= No_Token_Index then
         Or_Pos_15 := Predicate_Pos_1;
         Or_Res_15 := Predicate_Res_1;
         goto Exit_Or_14;
      end if;
      <<Exit_Or_14>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Discrete_Range_Or_Parse_0_Memo,
         Or_Pos_15 /= No_Token_Index, Or_Res_15, Pos, Or_Pos_15);

      Parser.Current_Pos := Or_Pos_15;

      return Or_Res_15;
   end Discrete_Range_Or_Parse_0;

   function Range_Constraint_Transform_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Range_Constraint
   is
      use Bare_Range_Constraint_Memos;

      Row_Pos_35       : Token_Index           := No_Token_Index;
      Row_Pos_36       : Token_Index           := No_Token_Index;
      Token_Pos_37     : Token_Index           := No_Token_Index;
      Token_Res_37     : Token_Index           := No_Token_Index;
      Defer_Pos_55     : Token_Index           := No_Token_Index;
      Defer_Res_55     : Bare_Expr             := No_Bare_Ada_Node;
      Defer_Pos_56     : Token_Index           := No_Token_Index;
      Defer_Res_56     : Bare_Name             := No_Bare_Ada_Node;
      Or_Pos_14        : Token_Index           := No_Token_Index;
      Or_Res_14        : Bare_Expr             := No_Bare_Ada_Node;
      Transform_Res_32 : Bare_Range_Spec       := No_Bare_Ada_Node;
      Transform_Res_33 : Bare_Range_Constraint := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Range_Constraint_Transform_Parse_1_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_33   := M.Instance;
         return Transform_Res_33;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_33;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_35 := Pos;

--  Start transform_code

--  Start row_code

      Row_Pos_36 := Row_Pos_35;

--  Start tok_code

      Token_Res_37 := Row_Pos_36;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_37));
      begin
         if T.Kind /= From_Token_Kind (Ada_Range) then
            Token_Pos_37 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_36 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_36,
                  Expected_Token_Id => Ada_Range,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_37 := Row_Pos_36 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_37 /= No_Token_Index then

         Row_Pos_36 := Token_Pos_37;

      else
         Row_Pos_36 := No_Token_Index;
         goto Exit_Row_26_0;

      end if;

--  Start or_code

      Or_Pos_14 := No_Token_Index;
      Or_Res_14 := No_Bare_Ada_Node;

      Defer_Res_55 := Discrete_Range_Or_Parse_0 (Parser, Row_Pos_36);
      Defer_Pos_55 := Parser.Current_Pos;

      if Defer_Pos_55 /= No_Token_Index then
         Or_Pos_14 := Defer_Pos_55;
         Or_Res_14 := Defer_Res_55;
         goto Exit_Or_13;
      end if;

      Defer_Res_56 := Name_Or_Parse_1 (Parser, Row_Pos_36);
      Defer_Pos_56 := Parser.Current_Pos;

      if Defer_Pos_56 /= No_Token_Index then
         Or_Pos_14 := Defer_Pos_56;
         Or_Res_14 := Defer_Res_56;
         goto Exit_Or_13;
      end if;
      <<Exit_Or_13>>

--  End or_code

      if Or_Pos_14 /= No_Token_Index then

         Row_Pos_36 := Or_Pos_14;

      else
         Row_Pos_36 := No_Token_Index;
         goto Exit_Row_26_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_26_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_36 /= No_Token_Index then

         Transform_Res_32 := Allocate_Range_Spec (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_32, Kind => Ada_Range_Spec,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_35,
            Token_End_Index =>
              (if Row_Pos_36 = Row_Pos_35 then No_Token_Index
               else Row_Pos_36 - 1));

         Initialize_Fields_For_Range_Spec
           (Self => Transform_Res_32, Range_Spec_F_Range => Or_Res_14);

         if Or_Res_14 /= null and then Is_Incomplete (Or_Res_14) then
            Transform_Res_32.Last_Attempted_Child := 0;
         elsif Or_Res_14 /= null and then not Is_Ghost (Or_Res_14) then
            Transform_Res_32.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_36 /= No_Token_Index then

         Row_Pos_35 := Row_Pos_36;

      else
         Row_Pos_35 := No_Token_Index;
         goto Exit_Row_25_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_25_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_35 /= No_Token_Index then

         Transform_Res_33 := Allocate_Range_Constraint (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_33, Kind => Ada_Range_Constraint,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_35 = Pos then No_Token_Index else Row_Pos_35 - 1));

         Initialize_Fields_For_Range_Constraint
           (Self                     => Transform_Res_33,
            Range_Constraint_F_Range => Transform_Res_32);

         if Transform_Res_32 /= null and then Is_Incomplete (Transform_Res_32)
         then
            Transform_Res_33.Last_Attempted_Child := 0;
         elsif Transform_Res_32 /= null
           and then not Is_Ghost (Transform_Res_32)
         then
            Transform_Res_33.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Range_Constraint_Transform_Parse_1_Memo,
         Row_Pos_35 /= No_Token_Index, Transform_Res_33, Pos, Row_Pos_35);

      Parser.Current_Pos := Row_Pos_35;

      return Transform_Res_33;
   end Range_Constraint_Transform_Parse_1;

   function Discrete_Subtype_Indication_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Discrete_Subtype_Indication
   is
      use Bare_Discrete_Subtype_Indication_Memos;

      Row_Pos_27       : Token_Index                      := No_Token_Index;
      Row_Pos_28       : Token_Index                      := No_Token_Index;
      Token_Pos_28     : Token_Index                      := No_Token_Index;
      Token_Res_28     : Token_Index                      := No_Token_Index;
      Token_Pos_29     : Token_Index                      := No_Token_Index;
      Token_Res_29     : Token_Index                      := No_Token_Index;
      Opt_Res_0        : Bare_Not_Null                    := No_Bare_Ada_Node;
      Defer_Pos_44     : Token_Index                      := No_Token_Index;
      Defer_Res_44     : Bare_Name                        := No_Bare_Ada_Node;
      Defer_Pos_45     : Token_Index                      := No_Token_Index;
      Defer_Res_45     : Bare_Range_Constraint            := No_Bare_Ada_Node;
      Transform_Res_26 : Bare_Discrete_Subtype_Indication := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part
             .Discrete_Subtype_Indication_Transform_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_26   := M.Instance;
         return Transform_Res_26;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_26;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_27 := Pos;

--  Start opt_code

--  Start row_code

      Row_Pos_28 := Row_Pos_27;

--  Start tok_code

      Token_Res_28 := Row_Pos_28;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_28));
      begin
         if T.Kind /= From_Token_Kind (Ada_Not) then
            Token_Pos_28 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_28 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_28,
                  Expected_Token_Id => Ada_Not,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_28 := Row_Pos_28 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_28 /= No_Token_Index then

         Row_Pos_28 := Token_Pos_28;

      else
         Row_Pos_28 := No_Token_Index;
         goto Exit_Row_18_0;

      end if;

--  Start tok_code

      Token_Res_29 := Row_Pos_28;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_29));
      begin
         if T.Kind /= From_Token_Kind (Ada_Null) then
            Token_Pos_29 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_28 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_28,
                  Expected_Token_Id => Ada_Null,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_29 := Row_Pos_28 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_29 /= No_Token_Index then

         Row_Pos_28 := Token_Pos_29;

      else
         Row_Pos_28 := No_Token_Index;
         goto Exit_Row_18_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_18_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_28 = No_Token_Index then

         Opt_Res_0 := Allocate_Not_Null_Absent (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_0, Kind => Ada_Not_Null_Absent,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_27,
            Token_End_Index => No_Token_Index);

         Row_Pos_28 := Row_Pos_27;

      else

         Opt_Res_0 := Allocate_Not_Null_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_0, Kind => Ada_Not_Null_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_27,
            Token_End_Index => Row_Pos_28 - 1);

      end if;

--  End opt_code

      if Row_Pos_28 /= No_Token_Index then

         Row_Pos_27 := Row_Pos_28;

      else
         Row_Pos_27 := No_Token_Index;
         goto Exit_Row_17_0;

      end if;

      Defer_Res_44 := Subtype_Name_Or_Parse_0 (Parser, Row_Pos_27);
      Defer_Pos_44 := Parser.Current_Pos;

      if Defer_Pos_44 /= No_Token_Index then

         Row_Pos_27 := Defer_Pos_44;

      else
         Row_Pos_27 := No_Token_Index;
         goto Exit_Row_17_0;

      end if;

      Defer_Res_45 := Range_Constraint_Transform_Parse_1 (Parser, Row_Pos_27);
      Defer_Pos_45 := Parser.Current_Pos;

      if Defer_Pos_45 /= No_Token_Index then

         Row_Pos_27 := Defer_Pos_45;

      else
         Row_Pos_27 := No_Token_Index;
         goto Exit_Row_17_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_17_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_27 /= No_Token_Index then

         Transform_Res_26 :=
           Allocate_Discrete_Subtype_Indication (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_26, Kind => Ada_Discrete_Subtype_Indication,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_27 = Pos then No_Token_Index else Row_Pos_27 - 1));

         Initialize_Fields_For_Discrete_Subtype_Indication
           (Self                              => Transform_Res_26,
            Subtype_Indication_F_Has_Not_Null => Opt_Res_0,
            Subtype_Indication_F_Name         => Defer_Res_44,
            Subtype_Indication_F_Constraint   => Defer_Res_45);

         if Opt_Res_0 /= null and then Is_Incomplete (Opt_Res_0) then
            Transform_Res_26.Last_Attempted_Child := 0;
         elsif Opt_Res_0 /= null and then not Is_Ghost (Opt_Res_0) then
            Transform_Res_26.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_44 /= null and then Is_Incomplete (Defer_Res_44) then
            Transform_Res_26.Last_Attempted_Child := 0;
         elsif Defer_Res_44 /= null and then not Is_Ghost (Defer_Res_44) then
            Transform_Res_26.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_45 /= null and then Is_Incomplete (Defer_Res_45) then
            Transform_Res_26.Last_Attempted_Child := 0;
         elsif Defer_Res_45 /= null and then not Is_Ghost (Defer_Res_45) then
            Transform_Res_26.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part
           .Discrete_Subtype_Indication_Transform_Parse_0_Memo,
         Row_Pos_27 /= No_Token_Index, Transform_Res_26, Pos, Row_Pos_27);

      Parser.Current_Pos := Row_Pos_27;

      return Transform_Res_26;
   end Discrete_Subtype_Indication_Transform_Parse_0;

   function Others_Designator_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Others_Designator
   is
      use Bare_Others_Designator_Memos;

      Row_Pos_41       : Token_Index            := No_Token_Index;
      Token_Pos_40     : Token_Index            := No_Token_Index;
      Token_Res_40     : Token_Index            := No_Token_Index;
      Transform_Res_37 : Bare_Others_Designator := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Others_Designator_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_37   := M.Instance;
         return Transform_Res_37;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_37;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_41 := Pos;

--  Start tok_code

      Token_Res_40 := Row_Pos_41;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_40));
      begin
         if T.Kind /= From_Token_Kind (Ada_Others) then
            Token_Pos_40 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_41 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_41,
                  Expected_Token_Id => Ada_Others,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_40 := Row_Pos_41 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_40 /= No_Token_Index then

         Row_Pos_41 := Token_Pos_40;

      else
         Row_Pos_41 := No_Token_Index;
         goto Exit_Row_31_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_31_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_41 /= No_Token_Index then

         Transform_Res_37 := Allocate_Others_Designator (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_37, Kind => Ada_Others_Designator,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_41 = Pos then No_Token_Index else Row_Pos_41 - 1));

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Others_Designator_Transform_Parse_0_Memo,
         Row_Pos_41 /= No_Token_Index, Transform_Res_37, Pos, Row_Pos_41);

      Parser.Current_Pos := Row_Pos_41;

      return Transform_Res_37;
   end Others_Designator_Transform_Parse_0;

   function Boolean_Op_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Op
   is
      use Bare_Op_Memos;

      Row_Pos_43       : Token_Index      := No_Token_Index;
      Token_Pos_41     : Token_Index      := No_Token_Index;
      Token_Res_41     : Token_Index      := No_Token_Index;
      Transform_Res_39 : Bare_Op_Xor      := No_Bare_Ada_Node;
      Row_Pos_44       : Token_Index      := No_Token_Index;
      Token_Pos_42     : Token_Index      := No_Token_Index;
      Token_Res_42     : Token_Index      := No_Token_Index;
      Token_Pos_43     : Token_Index      := No_Token_Index;
      Token_Res_43     : Token_Index      := No_Token_Index;
      Transform_Res_40 : Bare_Op_And_Then := No_Bare_Ada_Node;
      Row_Pos_45       : Token_Index      := No_Token_Index;
      Token_Pos_44     : Token_Index      := No_Token_Index;
      Token_Res_44     : Token_Index      := No_Token_Index;
      Transform_Res_41 : Bare_Op_And      := No_Bare_Ada_Node;
      Row_Pos_46       : Token_Index      := No_Token_Index;
      Token_Pos_45     : Token_Index      := No_Token_Index;
      Token_Res_45     : Token_Index      := No_Token_Index;
      Token_Pos_46     : Token_Index      := No_Token_Index;
      Token_Res_46     : Token_Index      := No_Token_Index;
      Transform_Res_42 : Bare_Op_Or_Else  := No_Bare_Ada_Node;
      Row_Pos_47       : Token_Index      := No_Token_Index;
      Token_Pos_47     : Token_Index      := No_Token_Index;
      Token_Res_47     : Token_Index      := No_Token_Index;
      Transform_Res_43 : Bare_Op_Or       := No_Bare_Ada_Node;
      Or_Pos_19        : Token_Index      := No_Token_Index;
      Or_Res_19        : Bare_Op          := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Boolean_Op_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_19          := M.Instance;
         return Or_Res_19;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_19;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_19 := No_Token_Index;
      Or_Res_19 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_43 := Pos;

--  Start tok_code

      Token_Res_41 := Row_Pos_43;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_41));
      begin
         if T.Kind /= From_Token_Kind (Ada_Xor) then
            Token_Pos_41 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_43 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_43,
                  Expected_Token_Id => Ada_Xor,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_41 := Row_Pos_43 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_41 /= No_Token_Index then

         Row_Pos_43 := Token_Pos_41;

      else
         Row_Pos_43 := No_Token_Index;
         goto Exit_Row_33_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_33_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_43 /= No_Token_Index then

         Transform_Res_39 := Allocate_Op_Xor (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_39, Kind => Ada_Op_Xor, Unit => Parser.Unit,

            Token_Start_Index => Pos,
            Token_End_Index   =>
              (if Row_Pos_43 = Pos then No_Token_Index else Row_Pos_43 - 1));

         Initialize_Fields_For_Op_Xor (Self => Transform_Res_39);

      end if;

--  End transform_code

      if Row_Pos_43 /= No_Token_Index then
         Or_Pos_19 := Row_Pos_43;
         Or_Res_19 := Transform_Res_39;
         goto Exit_Or_18;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_44 := Pos;

--  Start tok_code

      Token_Res_42 := Row_Pos_44;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_42));
      begin
         if T.Kind /= From_Token_Kind (Ada_And) then
            Token_Pos_42 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_44 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_44,
                  Expected_Token_Id => Ada_And,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_42 := Row_Pos_44 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_42 /= No_Token_Index then

         Row_Pos_44 := Token_Pos_42;

      else
         Row_Pos_44 := No_Token_Index;
         goto Exit_Row_34_0;

      end if;

--  Start tok_code

      Token_Res_43 := Row_Pos_44;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_43));
      begin
         if T.Kind /= From_Token_Kind (Ada_Then) then
            Token_Pos_43 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_44 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_44,
                  Expected_Token_Id => Ada_Then,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_43 := Row_Pos_44 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_43 /= No_Token_Index then

         Row_Pos_44 := Token_Pos_43;

      else
         Row_Pos_44 := No_Token_Index;
         goto Exit_Row_34_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_34_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_44 /= No_Token_Index then

         Transform_Res_40 := Allocate_Op_And_Then (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_40, Kind => Ada_Op_And_Then,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_44 = Pos then No_Token_Index else Row_Pos_44 - 1));

         Initialize_Fields_For_Op_And_Then (Self => Transform_Res_40);

      end if;

--  End transform_code

      if Row_Pos_44 /= No_Token_Index then
         Or_Pos_19 := Row_Pos_44;
         Or_Res_19 := Transform_Res_40;
         goto Exit_Or_18;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_45 := Pos;

--  Start tok_code

      Token_Res_44 := Row_Pos_45;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_44));
      begin
         if T.Kind /= From_Token_Kind (Ada_And) then
            Token_Pos_44 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_45 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_45,
                  Expected_Token_Id => Ada_And,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_44 := Row_Pos_45 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_44 /= No_Token_Index then

         Row_Pos_45 := Token_Pos_44;

      else
         Row_Pos_45 := No_Token_Index;
         goto Exit_Row_35_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_35_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_45 /= No_Token_Index then

         Transform_Res_41 := Allocate_Op_And (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_41, Kind => Ada_Op_And, Unit => Parser.Unit,

            Token_Start_Index => Pos,
            Token_End_Index   =>
              (if Row_Pos_45 = Pos then No_Token_Index else Row_Pos_45 - 1));

         Initialize_Fields_For_Op_And (Self => Transform_Res_41);

      end if;

--  End transform_code

      if Row_Pos_45 /= No_Token_Index then
         Or_Pos_19 := Row_Pos_45;
         Or_Res_19 := Transform_Res_41;
         goto Exit_Or_18;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_46 := Pos;

--  Start tok_code

      Token_Res_45 := Row_Pos_46;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_45));
      begin
         if T.Kind /= From_Token_Kind (Ada_Or) then
            Token_Pos_45 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_46 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_46,
                  Expected_Token_Id => Ada_Or,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_45 := Row_Pos_46 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_45 /= No_Token_Index then

         Row_Pos_46 := Token_Pos_45;

      else
         Row_Pos_46 := No_Token_Index;
         goto Exit_Row_36_0;

      end if;

--  Start tok_code

      Token_Res_46 := Row_Pos_46;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_46));
      begin
         if T.Kind /= From_Token_Kind (Ada_Else) then
            Token_Pos_46 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_46 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_46,
                  Expected_Token_Id => Ada_Else,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_46 := Row_Pos_46 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_46 /= No_Token_Index then

         Row_Pos_46 := Token_Pos_46;

      else
         Row_Pos_46 := No_Token_Index;
         goto Exit_Row_36_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_36_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_46 /= No_Token_Index then

         Transform_Res_42 := Allocate_Op_Or_Else (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_42, Kind => Ada_Op_Or_Else,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_46 = Pos then No_Token_Index else Row_Pos_46 - 1));

         Initialize_Fields_For_Op_Or_Else (Self => Transform_Res_42);

      end if;

--  End transform_code

      if Row_Pos_46 /= No_Token_Index then
         Or_Pos_19 := Row_Pos_46;
         Or_Res_19 := Transform_Res_42;
         goto Exit_Or_18;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_47 := Pos;

--  Start tok_code

      Token_Res_47 := Row_Pos_47;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_47));
      begin
         if T.Kind /= From_Token_Kind (Ada_Or) then
            Token_Pos_47 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_47 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_47,
                  Expected_Token_Id => Ada_Or,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_47 := Row_Pos_47 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_47 /= No_Token_Index then

         Row_Pos_47 := Token_Pos_47;

      else
         Row_Pos_47 := No_Token_Index;
         goto Exit_Row_37_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_37_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_47 /= No_Token_Index then

         Transform_Res_43 := Allocate_Op_Or (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_43, Kind => Ada_Op_Or, Unit => Parser.Unit,

            Token_Start_Index => Pos,
            Token_End_Index   =>
              (if Row_Pos_47 = Pos then No_Token_Index else Row_Pos_47 - 1));

         Initialize_Fields_For_Op_Or (Self => Transform_Res_43);

      end if;

--  End transform_code

      if Row_Pos_47 /= No_Token_Index then
         Or_Pos_19 := Row_Pos_47;
         Or_Res_19 := Transform_Res_43;
         goto Exit_Or_18;
      end if;
      <<Exit_Or_18>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Boolean_Op_Or_Parse_0_Memo,
         Or_Pos_19 /= No_Token_Index, Or_Res_19, Pos, Or_Pos_19);

      Parser.Current_Pos := Or_Pos_19;

      return Or_Res_19;
   end Boolean_Op_Or_Parse_0;

   function Rel_Op_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Op
   is
      use Bare_Op_Memos;

      Row_Pos_56       : Token_Index    := No_Token_Index;
      Token_Pos_54     : Token_Index    := No_Token_Index;
      Token_Res_54     : Token_Index    := No_Token_Index;
      Token_Pos_55     : Token_Index    := No_Token_Index;
      Token_Res_55     : Token_Index    := No_Token_Index;
      Transform_Res_52 : Bare_Op_Not_In := No_Bare_Ada_Node;
      Row_Pos_57       : Token_Index    := No_Token_Index;
      Token_Pos_56     : Token_Index    := No_Token_Index;
      Token_Res_56     : Token_Index    := No_Token_Index;
      Transform_Res_53 : Bare_Op_In     := No_Bare_Ada_Node;
      Or_Pos_22        : Token_Index    := No_Token_Index;
      Or_Res_22        : Bare_Op        := No_Bare_Ada_Node;

      M : Memo_Entry := Get (Parser.Private_Part.Rel_Op_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_22          := M.Instance;
         return Or_Res_22;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_22;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_22 := No_Token_Index;
      Or_Res_22 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_56 := Pos;

--  Start tok_code

      Token_Res_54 := Row_Pos_56;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_54));
      begin
         if T.Kind /= From_Token_Kind (Ada_Not) then
            Token_Pos_54 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_56 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_56,
                  Expected_Token_Id => Ada_Not,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_54 := Row_Pos_56 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_54 /= No_Token_Index then

         Row_Pos_56 := Token_Pos_54;

      else
         Row_Pos_56 := No_Token_Index;
         goto Exit_Row_46_0;

      end if;

--  Start tok_code

      Token_Res_55 := Row_Pos_56;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_55));
      begin
         if T.Kind /= From_Token_Kind (Ada_In) then
            Token_Pos_55 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_56 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_56,
                  Expected_Token_Id => Ada_In,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_55 := Row_Pos_56 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_55 /= No_Token_Index then

         Row_Pos_56 := Token_Pos_55;

      else
         Row_Pos_56 := No_Token_Index;
         goto Exit_Row_46_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_46_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_56 /= No_Token_Index then

         Transform_Res_52 := Allocate_Op_Not_In (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_52, Kind => Ada_Op_Not_In,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_56 = Pos then No_Token_Index else Row_Pos_56 - 1));

         Initialize_Fields_For_Op_Not_In (Self => Transform_Res_52);

      end if;

--  End transform_code

      if Row_Pos_56 /= No_Token_Index then
         Or_Pos_22 := Row_Pos_56;
         Or_Res_22 := Transform_Res_52;
         goto Exit_Or_21;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_57 := Pos;

--  Start tok_code

      Token_Res_56 := Row_Pos_57;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_56));
      begin
         if T.Kind /= From_Token_Kind (Ada_In) then
            Token_Pos_56 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_57 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_57,
                  Expected_Token_Id => Ada_In,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_56 := Row_Pos_57 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_56 /= No_Token_Index then

         Row_Pos_57 := Token_Pos_56;

      else
         Row_Pos_57 := No_Token_Index;
         goto Exit_Row_47_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_47_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_57 /= No_Token_Index then

         Transform_Res_53 := Allocate_Op_In (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_53, Kind => Ada_Op_In, Unit => Parser.Unit,

            Token_Start_Index => Pos,
            Token_End_Index   =>
              (if Row_Pos_57 = Pos then No_Token_Index else Row_Pos_57 - 1));

         Initialize_Fields_For_Op_In (Self => Transform_Res_53);

      end if;

--  End transform_code

      if Row_Pos_57 /= No_Token_Index then
         Or_Pos_22 := Row_Pos_57;
         Or_Res_22 := Transform_Res_53;
         goto Exit_Or_21;
      end if;
      <<Exit_Or_21>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Rel_Op_Or_Parse_0_Memo,
         Or_Pos_22 /= No_Token_Index, Or_Res_22, Pos, Or_Pos_22);

      Parser.Current_Pos := Or_Pos_22;

      return Or_Res_22;
   end Rel_Op_Or_Parse_0;

   function Membership_Choice_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Expr
   is
      use Bare_Expr_Memos;

      Defer_Pos_76     : Token_Index                      := No_Token_Index;
      Defer_Res_76     : Bare_Expr                        := No_Bare_Ada_Node;
      Row_Pos_58       : Token_Index                      := No_Token_Index;
      Defer_Pos_77     : Token_Index                      := No_Token_Index;
      Defer_Res_77     : Bare_Discrete_Subtype_Indication := No_Bare_Ada_Node;
      Transform_Res_54 : Bare_Discrete_Subtype_Name       := No_Bare_Ada_Node;
      Defer_Pos_78     : Token_Index                      := No_Token_Index;
      Defer_Res_78     : Bare_Expr                        := No_Bare_Ada_Node;
      Or_Pos_23        : Token_Index                      := No_Token_Index;
      Or_Res_23        : Bare_Expr                        := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Membership_Choice_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_23          := M.Instance;
         return Or_Res_23;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_23;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_23 := No_Token_Index;
      Or_Res_23 := No_Bare_Ada_Node;

      Defer_Res_76 := Discrete_Range_Or_Parse_0 (Parser, Pos);
      Defer_Pos_76 := Parser.Current_Pos;

      if Defer_Pos_76 /= No_Token_Index then
         Or_Pos_23 := Defer_Pos_76;
         Or_Res_23 := Defer_Res_76;
         goto Exit_Or_22;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_58 := Pos;

      Defer_Res_77 :=
        Discrete_Subtype_Indication_Transform_Parse_0 (Parser, Row_Pos_58);
      Defer_Pos_77 := Parser.Current_Pos;

      if Defer_Pos_77 /= No_Token_Index then

         Row_Pos_58 := Defer_Pos_77;

      else
         Row_Pos_58 := No_Token_Index;
         goto Exit_Row_48_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_48_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_58 /= No_Token_Index then

         Transform_Res_54 := Allocate_Discrete_Subtype_Name (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_54, Kind => Ada_Discrete_Subtype_Name,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_58 = Pos then No_Token_Index else Row_Pos_58 - 1));

         Initialize_Fields_For_Discrete_Subtype_Name
           (Self                            => Transform_Res_54,
            Discrete_Subtype_Name_F_Subtype => Defer_Res_77);

         if Defer_Res_77 /= null and then Is_Incomplete (Defer_Res_77) then
            Transform_Res_54.Last_Attempted_Child := 0;
         elsif Defer_Res_77 /= null and then not Is_Ghost (Defer_Res_77) then
            Transform_Res_54.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_58 /= No_Token_Index then
         Or_Pos_23 := Row_Pos_58;
         Or_Res_23 := Transform_Res_54;
         goto Exit_Or_22;
      end if;

      Defer_Res_78 := Simple_Expr_Or_Parse_1 (Parser, Pos);
      Defer_Pos_78 := Parser.Current_Pos;

      if Defer_Pos_78 /= No_Token_Index then
         Or_Pos_23 := Defer_Pos_78;
         Or_Res_23 := Defer_Res_78;
         goto Exit_Or_22;
      end if;
      <<Exit_Or_22>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Membership_Choice_Or_Parse_0_Memo,
         Or_Pos_23 /= No_Token_Index, Or_Res_23, Pos, Or_Pos_23);

      Parser.Current_Pos := Or_Pos_23;

      return Or_Res_23;
   end Membership_Choice_Or_Parse_0;

   function Membership_Choice_List_List_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Expr_Alternatives_List
   is
      use Bare_Expr_Alternatives_List_Memos;

      Lst_Cpos_1   : Token_Index                 := No_Token_Index;
      Tmp_List_1   : Free_Parse_List;
      Defer_Pos_75 : Token_Index                 := No_Token_Index;
      Defer_Res_75 : Bare_Expr                   := No_Bare_Ada_Node;
      Token_Pos_57 : Token_Index                 := No_Token_Index;
      Token_Res_57 : Token_Index                 := No_Token_Index;
      List_Pos_1   : Token_Index                 := No_Token_Index;
      List_Res_1   : Bare_Expr_Alternatives_List := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Membership_Choice_List_List_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         List_Res_1         := M.Instance;
         return List_Res_1;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return List_Res_1;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start list_code

      List_Pos_1 := No_Token_Index;

      Lst_Cpos_1 := Pos;
      Tmp_List_1 := Get_Parse_List (Parser);

      loop

         Defer_Res_75 := Membership_Choice_Or_Parse_0 (Parser, Lst_Cpos_1);
         Defer_Pos_75 := Parser.Current_Pos;

         exit when Defer_Pos_75 = No_Token_Index;

         List_Pos_1 := Defer_Pos_75;
         Lst_Cpos_1 := List_Pos_1;

         Tmp_List_1.Nodes.Append (Defer_Res_75);

--  Start tok_code

         Token_Res_57 := Lst_Cpos_1;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_57));
         begin
            if T.Kind /= From_Token_Kind (Ada_Pipe) then
               Token_Pos_57 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_1 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_1,
                     Expected_Token_Id => Ada_Pipe,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_57 := Lst_Cpos_1 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_57 /= No_Token_Index then
            Lst_Cpos_1 := Token_Pos_57;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_1.Nodes.Length;
      begin
         List_Res_1 := Allocate_Expr_Alternatives_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Pos;
            Token_End   := (if Lst_Cpos_1 = Pos then Pos else Lst_Cpos_1 - 1);

         else
            Token_Start := Token_Index'Max (Pos, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self            => List_Res_1, Kind => Ada_Expr_Alternatives_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_1, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_1.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_1.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_1);

--  End list_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Membership_Choice_List_List_Parse_0_Memo,
         List_Pos_1 /= No_Token_Index, List_Res_1, Pos, List_Pos_1);

      Parser.Current_Pos := List_Pos_1;

      return List_Res_1;
   end Membership_Choice_List_List_Parse_0;

   function Relation_Or_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Expr
   is
      use Bare_Expr_Memos;

      Nobt_7                 : Boolean                     := False;
      Row_Pos_48             : Token_Index                 := No_Token_Index;
      Defer_Pos_69           : Token_Index                 := No_Token_Index;
      Defer_Res_69           : Bare_Expr                   := No_Bare_Ada_Node;
      Row_Pos_49             : Token_Index                 := No_Token_Index;
      Token_Pos_48           : Token_Index                 := No_Token_Index;
      Token_Res_48           : Token_Index                 := No_Token_Index;
      Transform_Res_44       : Bare_Op_Eq                  := No_Bare_Ada_Node;
      Row_Pos_50             : Token_Index                 := No_Token_Index;
      Token_Pos_49           : Token_Index                 := No_Token_Index;
      Token_Res_49           : Token_Index                 := No_Token_Index;
      Transform_Res_45       : Bare_Op_Neq                 := No_Bare_Ada_Node;
      Row_Pos_51             : Token_Index                 := No_Token_Index;
      Token_Pos_50           : Token_Index                 := No_Token_Index;
      Token_Res_50           : Token_Index                 := No_Token_Index;
      Transform_Res_46       : Bare_Op_Lt                  := No_Bare_Ada_Node;
      Row_Pos_52             : Token_Index                 := No_Token_Index;
      Token_Pos_51           : Token_Index                 := No_Token_Index;
      Token_Res_51           : Token_Index                 := No_Token_Index;
      Transform_Res_47       : Bare_Op_Lte                 := No_Bare_Ada_Node;
      Row_Pos_53             : Token_Index                 := No_Token_Index;
      Token_Pos_52           : Token_Index                 := No_Token_Index;
      Token_Res_52           : Token_Index                 := No_Token_Index;
      Transform_Res_48       : Bare_Op_Gt                  := No_Bare_Ada_Node;
      Row_Pos_54             : Token_Index                 := No_Token_Index;
      Token_Pos_53           : Token_Index                 := No_Token_Index;
      Token_Res_53           : Token_Index                 := No_Token_Index;
      Transform_Res_49       : Bare_Op_Gte                 := No_Bare_Ada_Node;
      Or_Pos_20              : Token_Index                 := No_Token_Index;
      Or_Res_20              : Bare_Op                     := No_Bare_Ada_Node;
      Defer_Pos_70           : Token_Index                 := No_Token_Index;
      Defer_Res_70           : Bare_Expr                   := No_Bare_Ada_Node;
      Row_Progress_7         : Integer                     := 0;
      Transform_Res_50       : Bare_Relation_Op            := No_Bare_Ada_Node;
      Transform_Has_Failed_7 : Boolean                     := False;
      Row_Pos_55             : Token_Index                 := No_Token_Index;
      Defer_Pos_71           : Token_Index                 := No_Token_Index;
      Defer_Res_71           : Bare_Expr                   := No_Bare_Ada_Node;
      Defer_Pos_72           : Token_Index                 := No_Token_Index;
      Defer_Res_72           : Bare_Op                     := No_Bare_Ada_Node;
      Defer_Pos_73           : Token_Index                 := No_Token_Index;
      Defer_Res_73           : Bare_Expr_Alternatives_List := No_Bare_Ada_Node;
      Transform_Res_51       : Bare_Membership_Expr        := No_Bare_Ada_Node;
      Defer_Pos_74           : Token_Index                 := No_Token_Index;
      Defer_Res_74           : Bare_Expr                   := No_Bare_Ada_Node;
      Or_Pos_21              : Token_Index                 := No_Token_Index;
      Or_Res_21              : Bare_Expr                   := No_Bare_Ada_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Expr   := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Relation_Or_Parse_1_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_21          := M.Instance;
         return Or_Res_21;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_21;
      end if;

      Set
        (Parser.Private_Part.Relation_Or_Parse_1_Memo, False, Or_Res_21, Pos,
         Mem_Pos);

      <<Try_Again>>

      Nobt_7 := False;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_21 := No_Token_Index;
      Or_Res_21 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_48 := Pos;

      Defer_Res_69 := Relation_Or_Parse_1 (Parser, Row_Pos_48);
      Defer_Pos_69 := Parser.Current_Pos;

      Row_Progress_7 := 1;

      if Defer_Pos_69 /= No_Token_Index then

         Row_Pos_48 := Defer_Pos_69;

      else
         Row_Pos_48 := No_Token_Index;
         goto Exit_Row_38_0;

      end if;

--  Start or_code

      Or_Pos_20 := No_Token_Index;
      Or_Res_20 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_49 := Row_Pos_48;

--  Start tok_code

      Token_Res_48 := Row_Pos_49;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_48));
      begin
         if T.Kind /= From_Token_Kind (Ada_Equal) then
            Token_Pos_48 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_49 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_49,
                  Expected_Token_Id => Ada_Equal,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_48 := Row_Pos_49 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_48 /= No_Token_Index then

         Row_Pos_49 := Token_Pos_48;

      else
         Row_Pos_49 := No_Token_Index;
         goto Exit_Row_39_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_39_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_49 /= No_Token_Index then

         Transform_Res_44 := Allocate_Op_Eq (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_44, Kind => Ada_Op_Eq, Unit => Parser.Unit,

            Token_Start_Index => Row_Pos_48,
            Token_End_Index   =>
              (if Row_Pos_49 = Row_Pos_48 then No_Token_Index
               else Row_Pos_49 - 1));

         Initialize_Fields_For_Op_Eq (Self => Transform_Res_44);

      end if;

--  End transform_code

      if Row_Pos_49 /= No_Token_Index then
         Or_Pos_20 := Row_Pos_49;
         Or_Res_20 := Transform_Res_44;
         goto Exit_Or_20;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_50 := Row_Pos_48;

--  Start tok_code

      Token_Res_49 := Row_Pos_50;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_49));
      begin
         if T.Kind /= From_Token_Kind (Ada_Notequal) then
            Token_Pos_49 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_50 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_50,
                  Expected_Token_Id => Ada_Notequal,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_49 := Row_Pos_50 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_49 /= No_Token_Index then

         Row_Pos_50 := Token_Pos_49;

      else
         Row_Pos_50 := No_Token_Index;
         goto Exit_Row_40_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_40_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_50 /= No_Token_Index then

         Transform_Res_45 := Allocate_Op_Neq (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_45, Kind => Ada_Op_Neq, Unit => Parser.Unit,

            Token_Start_Index => Row_Pos_48,
            Token_End_Index   =>
              (if Row_Pos_50 = Row_Pos_48 then No_Token_Index
               else Row_Pos_50 - 1));

         Initialize_Fields_For_Op_Neq (Self => Transform_Res_45);

      end if;

--  End transform_code

      if Row_Pos_50 /= No_Token_Index then
         Or_Pos_20 := Row_Pos_50;
         Or_Res_20 := Transform_Res_45;
         goto Exit_Or_20;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_51 := Row_Pos_48;

--  Start tok_code

      Token_Res_50 := Row_Pos_51;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_50));
      begin
         if T.Kind /= From_Token_Kind (Ada_Lt) then
            Token_Pos_50 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_51 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_51,
                  Expected_Token_Id => Ada_Lt,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_50 := Row_Pos_51 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_50 /= No_Token_Index then

         Row_Pos_51 := Token_Pos_50;

      else
         Row_Pos_51 := No_Token_Index;
         goto Exit_Row_41_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_41_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_51 /= No_Token_Index then

         Transform_Res_46 := Allocate_Op_Lt (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_46, Kind => Ada_Op_Lt, Unit => Parser.Unit,

            Token_Start_Index => Row_Pos_48,
            Token_End_Index   =>
              (if Row_Pos_51 = Row_Pos_48 then No_Token_Index
               else Row_Pos_51 - 1));

         Initialize_Fields_For_Op_Lt (Self => Transform_Res_46);

      end if;

--  End transform_code

      if Row_Pos_51 /= No_Token_Index then
         Or_Pos_20 := Row_Pos_51;
         Or_Res_20 := Transform_Res_46;
         goto Exit_Or_20;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_52 := Row_Pos_48;

--  Start tok_code

      Token_Res_51 := Row_Pos_52;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_51));
      begin
         if T.Kind /= From_Token_Kind (Ada_Lte) then
            Token_Pos_51 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_52 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_52,
                  Expected_Token_Id => Ada_Lte,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_51 := Row_Pos_52 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_51 /= No_Token_Index then

         Row_Pos_52 := Token_Pos_51;

      else
         Row_Pos_52 := No_Token_Index;
         goto Exit_Row_42_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_42_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_52 /= No_Token_Index then

         Transform_Res_47 := Allocate_Op_Lte (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_47, Kind => Ada_Op_Lte, Unit => Parser.Unit,

            Token_Start_Index => Row_Pos_48,
            Token_End_Index   =>
              (if Row_Pos_52 = Row_Pos_48 then No_Token_Index
               else Row_Pos_52 - 1));

         Initialize_Fields_For_Op_Lte (Self => Transform_Res_47);

      end if;

--  End transform_code

      if Row_Pos_52 /= No_Token_Index then
         Or_Pos_20 := Row_Pos_52;
         Or_Res_20 := Transform_Res_47;
         goto Exit_Or_20;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_53 := Row_Pos_48;

--  Start tok_code

      Token_Res_52 := Row_Pos_53;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_52));
      begin
         if T.Kind /= From_Token_Kind (Ada_Gt) then
            Token_Pos_52 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_53 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_53,
                  Expected_Token_Id => Ada_Gt,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_52 := Row_Pos_53 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_52 /= No_Token_Index then

         Row_Pos_53 := Token_Pos_52;

      else
         Row_Pos_53 := No_Token_Index;
         goto Exit_Row_43_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_43_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_53 /= No_Token_Index then

         Transform_Res_48 := Allocate_Op_Gt (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_48, Kind => Ada_Op_Gt, Unit => Parser.Unit,

            Token_Start_Index => Row_Pos_48,
            Token_End_Index   =>
              (if Row_Pos_53 = Row_Pos_48 then No_Token_Index
               else Row_Pos_53 - 1));

         Initialize_Fields_For_Op_Gt (Self => Transform_Res_48);

      end if;

--  End transform_code

      if Row_Pos_53 /= No_Token_Index then
         Or_Pos_20 := Row_Pos_53;
         Or_Res_20 := Transform_Res_48;
         goto Exit_Or_20;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_54 := Row_Pos_48;

--  Start tok_code

      Token_Res_53 := Row_Pos_54;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_53));
      begin
         if T.Kind /= From_Token_Kind (Ada_Gte) then
            Token_Pos_53 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_54 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_54,
                  Expected_Token_Id => Ada_Gte,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_53 := Row_Pos_54 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_53 /= No_Token_Index then

         Row_Pos_54 := Token_Pos_53;

      else
         Row_Pos_54 := No_Token_Index;
         goto Exit_Row_44_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_44_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_54 /= No_Token_Index then

         Transform_Res_49 := Allocate_Op_Gte (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_49, Kind => Ada_Op_Gte, Unit => Parser.Unit,

            Token_Start_Index => Row_Pos_48,
            Token_End_Index   =>
              (if Row_Pos_54 = Row_Pos_48 then No_Token_Index
               else Row_Pos_54 - 1));

         Initialize_Fields_For_Op_Gte (Self => Transform_Res_49);

      end if;

--  End transform_code

      if Row_Pos_54 /= No_Token_Index then
         Or_Pos_20 := Row_Pos_54;
         Or_Res_20 := Transform_Res_49;
         goto Exit_Or_20;
      end if;
      <<Exit_Or_20>>

--  End or_code

      Row_Progress_7 := 2;

      if Or_Pos_20 /= No_Token_Index then

         Row_Pos_48 := Or_Pos_20;

      else
         Row_Pos_48 := No_Token_Index;
         goto Exit_Row_38_0;

      end if;

      Nobt_7 := True;

      Row_Progress_7 := 3;

      if Row_Pos_48 /= No_Token_Index then

         Row_Pos_48 := Row_Pos_48;

      else
         Row_Pos_48 := No_Token_Index;
         goto Exit_Row_38_0;

      end if;

      Defer_Res_70 := Simple_Expr_Or_Parse_1 (Parser, Row_Pos_48);
      Defer_Pos_70 := Parser.Current_Pos;

      Row_Progress_7 := 4;

      if Defer_Pos_70 /= No_Token_Index then

         Row_Pos_48 := Defer_Pos_70;

      else
         Row_Pos_48 := No_Token_Index;
         goto Exit_Row_38_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_38_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_48 = No_Token_Index and then Nobt_7 then
         Row_Pos_48             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_7 := True;
      end if;

      if Row_Pos_48 /= No_Token_Index then

         Transform_Res_50 := Allocate_Relation_Op (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_50, Kind => Ada_Relation_Op,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_48 = Pos then No_Token_Index else Row_Pos_48 - 1));

         Initialize_Fields_For_Relation_Op
           (Self        => Transform_Res_50, Bin_Op_F_Left => Defer_Res_69,
            Bin_Op_F_Op => Or_Res_20, Bin_Op_F_Right => Defer_Res_70);

         if Defer_Res_69 /= null and then Is_Incomplete (Defer_Res_69) then
            Transform_Res_50.Last_Attempted_Child := 0;
         elsif Defer_Res_69 /= null and then not Is_Ghost (Defer_Res_69) then
            Transform_Res_50.Last_Attempted_Child := -1;
         end if;
         if Or_Res_20 /= null and then Is_Incomplete (Or_Res_20) then
            Transform_Res_50.Last_Attempted_Child := 0;
         elsif Or_Res_20 /= null and then not Is_Ghost (Or_Res_20) then
            Transform_Res_50.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_70 /= null and then Is_Incomplete (Defer_Res_70) then
            Transform_Res_50.Last_Attempted_Child := 0;
         elsif Defer_Res_70 /= null and then not Is_Ghost (Defer_Res_70) then
            Transform_Res_50.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_7 then
            Transform_Res_50.Last_Attempted_Child := Row_Progress_7;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <relation>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      if Row_Pos_48 /= No_Token_Index then
         Or_Pos_21 := Row_Pos_48;
         Or_Res_21 := Transform_Res_50;
         goto Exit_Or_19;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_55 := Pos;

      Defer_Res_71 := Relation_Or_Parse_1 (Parser, Row_Pos_55);
      Defer_Pos_71 := Parser.Current_Pos;

      if Defer_Pos_71 /= No_Token_Index then

         Row_Pos_55 := Defer_Pos_71;

      else
         Row_Pos_55 := No_Token_Index;
         goto Exit_Row_45_0;

      end if;

      Defer_Res_72 := Rel_Op_Or_Parse_0 (Parser, Row_Pos_55);
      Defer_Pos_72 := Parser.Current_Pos;

      if Defer_Pos_72 /= No_Token_Index then

         Row_Pos_55 := Defer_Pos_72;

      else
         Row_Pos_55 := No_Token_Index;
         goto Exit_Row_45_0;

      end if;

      Defer_Res_73 := Membership_Choice_List_List_Parse_0 (Parser, Row_Pos_55);
      Defer_Pos_73 := Parser.Current_Pos;

      if Defer_Pos_73 /= No_Token_Index then

         Row_Pos_55 := Defer_Pos_73;

      else
         Row_Pos_55 := No_Token_Index;
         goto Exit_Row_45_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_45_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_55 /= No_Token_Index then

         Transform_Res_51 := Allocate_Membership_Expr (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_51, Kind => Ada_Membership_Expr,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_55 = Pos then No_Token_Index else Row_Pos_55 - 1));

         Initialize_Fields_For_Membership_Expr
           (Self => Transform_Res_51, Membership_Expr_F_Expr => Defer_Res_71,
            Membership_Expr_F_Op               => Defer_Res_72,
            Membership_Expr_F_Membership_Exprs => Defer_Res_73);

         if Defer_Res_71 /= null and then Is_Incomplete (Defer_Res_71) then
            Transform_Res_51.Last_Attempted_Child := 0;
         elsif Defer_Res_71 /= null and then not Is_Ghost (Defer_Res_71) then
            Transform_Res_51.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_72 /= null and then Is_Incomplete (Defer_Res_72) then
            Transform_Res_51.Last_Attempted_Child := 0;
         elsif Defer_Res_72 /= null and then not Is_Ghost (Defer_Res_72) then
            Transform_Res_51.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_73 /= null and then Is_Incomplete (Defer_Res_73) then
            Transform_Res_51.Last_Attempted_Child := 0;
         elsif Defer_Res_73 /= null and then not Is_Ghost (Defer_Res_73) then
            Transform_Res_51.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_55 /= No_Token_Index then
         Or_Pos_21 := Row_Pos_55;
         Or_Res_21 := Transform_Res_51;
         goto Exit_Or_19;
      end if;

      Defer_Res_74 := Simple_Expr_Or_Parse_1 (Parser, Pos);
      Defer_Pos_74 := Parser.Current_Pos;

      if Defer_Pos_74 /= No_Token_Index then
         Or_Pos_21 := Defer_Pos_74;
         Or_Res_21 := Defer_Res_74;
         goto Exit_Or_19;
      end if;
      <<Exit_Or_19>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      if Or_Pos_21 > Mem_Pos then
         Mem_Pos := Or_Pos_21;
         Mem_Res := Or_Res_21;
         Set
           (Parser.Private_Part.Relation_Or_Parse_1_Memo,
            Or_Pos_21 /= No_Token_Index, Or_Res_21, Pos, Or_Pos_21);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res_21 := Mem_Res;
         Or_Pos_21 := Mem_Pos;
         goto No_Memo;
      end if;

      Set
        (Parser.Private_Part.Relation_Or_Parse_1_Memo,
         Or_Pos_21 /= No_Token_Index, Or_Res_21, Pos, Or_Pos_21);

      <<No_Memo>>

      Parser.Current_Pos := Or_Pos_21;

      return Or_Res_21;
   end Relation_Or_Parse_1;

   function Expr_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Expr
   is
      use Bare_Expr_Memos;

      Nobt_6                 : Boolean     := False;
      Row_Pos_42             : Token_Index := No_Token_Index;
      Defer_Pos_65           : Token_Index := No_Token_Index;
      Defer_Res_65           : Bare_Expr   := No_Bare_Ada_Node;
      Defer_Pos_66           : Token_Index := No_Token_Index;
      Defer_Res_66           : Bare_Op     := No_Bare_Ada_Node;
      Defer_Pos_67           : Token_Index := No_Token_Index;
      Defer_Res_67           : Bare_Expr   := No_Bare_Ada_Node;
      Row_Progress_6         : Integer     := 0;
      Transform_Res_38       : Bare_Bin_Op := No_Bare_Ada_Node;
      Transform_Has_Failed_6 : Boolean     := False;
      Defer_Pos_68           : Token_Index := No_Token_Index;
      Defer_Res_68           : Bare_Expr   := No_Bare_Ada_Node;
      Or_Pos_18              : Token_Index := No_Token_Index;
      Or_Res_18              : Bare_Expr   := No_Bare_Ada_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Expr   := No_Bare_Ada_Node;

      M : Memo_Entry := Get (Parser.Private_Part.Expr_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_18          := M.Instance;
         return Or_Res_18;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_18;
      end if;

      Set
        (Parser.Private_Part.Expr_Or_Parse_0_Memo, False, Or_Res_18, Pos,
         Mem_Pos);

      <<Try_Again>>

      Nobt_6 := False;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_18 := No_Token_Index;
      Or_Res_18 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_42 := Pos;

      Defer_Res_65 := Expr_Or_Parse_0 (Parser, Row_Pos_42);
      Defer_Pos_65 := Parser.Current_Pos;

      Row_Progress_6 := 1;

      if Defer_Pos_65 /= No_Token_Index then

         Row_Pos_42 := Defer_Pos_65;

      else
         Row_Pos_42 := No_Token_Index;
         goto Exit_Row_32_0;

      end if;

      Defer_Res_66 := Boolean_Op_Or_Parse_0 (Parser, Row_Pos_42);
      Defer_Pos_66 := Parser.Current_Pos;

      Row_Progress_6 := 2;

      if Defer_Pos_66 /= No_Token_Index then

         Row_Pos_42 := Defer_Pos_66;

      else
         Row_Pos_42 := No_Token_Index;
         goto Exit_Row_32_0;

      end if;

      Nobt_6 := True;

      Row_Progress_6 := 3;

      if Row_Pos_42 /= No_Token_Index then

         Row_Pos_42 := Row_Pos_42;

      else
         Row_Pos_42 := No_Token_Index;
         goto Exit_Row_32_0;

      end if;

      Defer_Res_67 := Relation_Or_Parse_1 (Parser, Row_Pos_42);
      Defer_Pos_67 := Parser.Current_Pos;

      Row_Progress_6 := 4;

      if Defer_Pos_67 /= No_Token_Index then

         Row_Pos_42 := Defer_Pos_67;

      else
         Row_Pos_42 := No_Token_Index;
         goto Exit_Row_32_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_32_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_42 = No_Token_Index and then Nobt_6 then
         Row_Pos_42             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_6 := True;
      end if;

      if Row_Pos_42 /= No_Token_Index then

         Transform_Res_38 := Allocate_Bin_Op (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_38, Kind => Ada_Bin_Op, Unit => Parser.Unit,

            Token_Start_Index => Pos,
            Token_End_Index   =>
              (if Row_Pos_42 = Pos then No_Token_Index else Row_Pos_42 - 1));

         Initialize_Fields_For_Bin_Op
           (Self        => Transform_Res_38, Bin_Op_F_Left => Defer_Res_65,
            Bin_Op_F_Op => Defer_Res_66, Bin_Op_F_Right => Defer_Res_67);

         if Defer_Res_65 /= null and then Is_Incomplete (Defer_Res_65) then
            Transform_Res_38.Last_Attempted_Child := 0;
         elsif Defer_Res_65 /= null and then not Is_Ghost (Defer_Res_65) then
            Transform_Res_38.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_66 /= null and then Is_Incomplete (Defer_Res_66) then
            Transform_Res_38.Last_Attempted_Child := 0;
         elsif Defer_Res_66 /= null and then not Is_Ghost (Defer_Res_66) then
            Transform_Res_38.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_67 /= null and then Is_Incomplete (Defer_Res_67) then
            Transform_Res_38.Last_Attempted_Child := 0;
         elsif Defer_Res_67 /= null and then not Is_Ghost (Defer_Res_67) then
            Transform_Res_38.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_6 then
            Transform_Res_38.Last_Attempted_Child := Row_Progress_6;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <expr>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      if Row_Pos_42 /= No_Token_Index then
         Or_Pos_18 := Row_Pos_42;
         Or_Res_18 := Transform_Res_38;
         goto Exit_Or_17;
      end if;

      Defer_Res_68 := Relation_Or_Parse_1 (Parser, Pos);
      Defer_Pos_68 := Parser.Current_Pos;

      if Defer_Pos_68 /= No_Token_Index then
         Or_Pos_18 := Defer_Pos_68;
         Or_Res_18 := Defer_Res_68;
         goto Exit_Or_17;
      end if;
      <<Exit_Or_17>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      if Or_Pos_18 > Mem_Pos then
         Mem_Pos := Or_Pos_18;
         Mem_Res := Or_Res_18;
         Set
           (Parser.Private_Part.Expr_Or_Parse_0_Memo,
            Or_Pos_18 /= No_Token_Index, Or_Res_18, Pos, Or_Pos_18);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res_18 := Mem_Res;
         Or_Pos_18 := Mem_Pos;
         goto No_Memo;
      end if;

      Set
        (Parser.Private_Part.Expr_Or_Parse_0_Memo, Or_Pos_18 /= No_Token_Index,
         Or_Res_18, Pos, Or_Pos_18);

      <<No_Memo>>

      Parser.Current_Pos := Or_Pos_18;

      return Or_Res_18;
   end Expr_Or_Parse_0;

   function Box_Expr_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Box_Expr
   is
      use Bare_Box_Expr_Memos;

      Row_Pos_59       : Token_Index   := No_Token_Index;
      Token_Pos_58     : Token_Index   := No_Token_Index;
      Token_Res_58     : Token_Index   := No_Token_Index;
      Transform_Res_55 : Bare_Box_Expr := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Box_Expr_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_55   := M.Instance;
         return Transform_Res_55;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_55;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_59 := Pos;

--  Start tok_code

      Token_Res_58 := Row_Pos_59;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_58));
      begin
         if T.Kind /= From_Token_Kind (Ada_Diamond) then
            Token_Pos_58 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_59 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_59,
                  Expected_Token_Id => Ada_Diamond,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_58 := Row_Pos_59 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_58 /= No_Token_Index then

         Row_Pos_59 := Token_Pos_58;

      else
         Row_Pos_59 := No_Token_Index;
         goto Exit_Row_49_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_49_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_59 /= No_Token_Index then

         Transform_Res_55 := Allocate_Box_Expr (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_55, Kind => Ada_Box_Expr,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_59 = Pos then No_Token_Index else Row_Pos_59 - 1));

         Initialize_Fields_For_Box_Expr (Self => Transform_Res_55);

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Box_Expr_Transform_Parse_0_Memo,
         Row_Pos_59 /= No_Token_Index, Transform_Res_55, Pos, Row_Pos_59);

      Parser.Current_Pos := Row_Pos_59;

      return Transform_Res_55;
   end Box_Expr_Transform_Parse_0;

   function Param_Assoc_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Param_Assoc
   is
      use Bare_Param_Assoc_Memos;

      Row_Pos_39       : Token_Index            := No_Token_Index;
      Row_Pos_40       : Token_Index            := No_Token_Index;
      Defer_Pos_60     : Token_Index            := No_Token_Index;
      Defer_Res_60     : Bare_Identifier        := No_Bare_Ada_Node;
      Defer_Pos_61     : Token_Index            := No_Token_Index;
      Defer_Res_61     : Bare_Others_Designator := No_Bare_Ada_Node;
      Defer_Pos_62     : Token_Index            := No_Token_Index;
      Defer_Res_62     : Bare_String_Literal    := No_Bare_Ada_Node;
      Or_Pos_16        : Token_Index            := No_Token_Index;
      Or_Res_16        : Bare_Ada_Node          := No_Bare_Ada_Node;
      Token_Pos_39     : Token_Index            := No_Token_Index;
      Token_Res_39     : Token_Index            := No_Token_Index;
      Defer_Pos_63     : Token_Index            := No_Token_Index;
      Defer_Res_63     : Bare_Expr              := No_Bare_Ada_Node;
      Defer_Pos_64     : Token_Index            := No_Token_Index;
      Defer_Res_64     : Bare_Box_Expr          := No_Bare_Ada_Node;
      Or_Pos_17        : Token_Index            := No_Token_Index;
      Or_Res_17        : Bare_Expr              := No_Bare_Ada_Node;
      Transform_Res_36 : Bare_Param_Assoc       := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Param_Assoc_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_36   := M.Instance;
         return Transform_Res_36;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_36;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_39 := Pos;

--  Start opt_code

--  Start row_code

      Row_Pos_40 := Row_Pos_39;

--  Start or_code

      Or_Pos_16 := No_Token_Index;
      Or_Res_16 := No_Bare_Ada_Node;

      Defer_Res_60 := Identifier_Transform_Parse_0 (Parser, Row_Pos_40);
      Defer_Pos_60 := Parser.Current_Pos;

      if Defer_Pos_60 /= No_Token_Index then
         Or_Pos_16 := Defer_Pos_60;
         Or_Res_16 := Defer_Res_60;
         goto Exit_Or_15;
      end if;

      Defer_Res_61 := Others_Designator_Transform_Parse_0 (Parser, Row_Pos_40);
      Defer_Pos_61 := Parser.Current_Pos;

      if Defer_Pos_61 /= No_Token_Index then
         Or_Pos_16 := Defer_Pos_61;
         Or_Res_16 := Defer_Res_61;
         goto Exit_Or_15;
      end if;

      Defer_Res_62 := String_Literal_Transform_Parse_0 (Parser, Row_Pos_40);
      Defer_Pos_62 := Parser.Current_Pos;

      if Defer_Pos_62 /= No_Token_Index then
         Or_Pos_16 := Defer_Pos_62;
         Or_Res_16 := Defer_Res_62;
         goto Exit_Or_15;
      end if;
      <<Exit_Or_15>>

--  End or_code

      if Or_Pos_16 /= No_Token_Index then

         Row_Pos_40 := Or_Pos_16;

      else
         Row_Pos_40 := No_Token_Index;
         goto Exit_Row_30_0;

      end if;

--  Start tok_code

      Token_Res_39 := Row_Pos_40;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_39));
      begin
         if T.Kind /= From_Token_Kind (Ada_Arrow) then
            Token_Pos_39 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_40 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_40,
                  Expected_Token_Id => Ada_Arrow,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_39 := Row_Pos_40 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_39 /= No_Token_Index then

         Row_Pos_40 := Token_Pos_39;

      else
         Row_Pos_40 := No_Token_Index;
         goto Exit_Row_30_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_30_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_40 = No_Token_Index then

         Or_Res_16 := No_Bare_Ada_Node;

         Row_Pos_40 := Row_Pos_39;

      end if;

--  End opt_code

      if Row_Pos_40 /= No_Token_Index then

         Row_Pos_39 := Row_Pos_40;

      else
         Row_Pos_39 := No_Token_Index;
         goto Exit_Row_29_0;

      end if;

--  Start or_code

      Or_Pos_17 := No_Token_Index;
      Or_Res_17 := No_Bare_Ada_Node;

      Defer_Res_63 := Expr_Or_Parse_0 (Parser, Row_Pos_39);
      Defer_Pos_63 := Parser.Current_Pos;

      if Defer_Pos_63 /= No_Token_Index then
         Or_Pos_17 := Defer_Pos_63;
         Or_Res_17 := Defer_Res_63;
         goto Exit_Or_16;
      end if;

      Defer_Res_64 := Box_Expr_Transform_Parse_0 (Parser, Row_Pos_39);
      Defer_Pos_64 := Parser.Current_Pos;

      if Defer_Pos_64 /= No_Token_Index then
         Or_Pos_17 := Defer_Pos_64;
         Or_Res_17 := Defer_Res_64;
         goto Exit_Or_16;
      end if;
      <<Exit_Or_16>>

--  End or_code

      if Or_Pos_17 /= No_Token_Index then

         Row_Pos_39 := Or_Pos_17;

      else
         Row_Pos_39 := No_Token_Index;
         goto Exit_Row_29_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_29_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_39 /= No_Token_Index then

         Transform_Res_36 := Allocate_Param_Assoc (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_36, Kind => Ada_Param_Assoc,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_39 = Pos then No_Token_Index else Row_Pos_39 - 1));

         Initialize_Fields_For_Param_Assoc
           (Self => Transform_Res_36, Param_Assoc_F_Designator => Or_Res_16,
            Param_Assoc_F_R_Expr => Or_Res_17);

         if Or_Res_16 /= null and then Is_Incomplete (Or_Res_16) then
            Transform_Res_36.Last_Attempted_Child := 0;
         elsif Or_Res_16 /= null and then not Is_Ghost (Or_Res_16) then
            Transform_Res_36.Last_Attempted_Child := -1;
         end if;
         if Or_Res_17 /= null and then Is_Incomplete (Or_Res_17) then
            Transform_Res_36.Last_Attempted_Child := 0;
         elsif Or_Res_17 /= null and then not Is_Ghost (Or_Res_17) then
            Transform_Res_36.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Param_Assoc_Transform_Parse_0_Memo,
         Row_Pos_39 /= No_Token_Index, Transform_Res_36, Pos, Row_Pos_39);

      Parser.Current_Pos := Row_Pos_39;

      return Transform_Res_36;
   end Param_Assoc_Transform_Parse_0;

   function Call_Suffix_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Defer_Pos_41 : Token_Index                      := No_Token_Index;
      Defer_Res_41 : Bare_Discrete_Subtype_Indication := No_Bare_Ada_Node;
      Defer_Pos_42 : Token_Index                      := No_Token_Index;
      Defer_Res_42 : Bare_Expr                        := No_Bare_Ada_Node;
      Lst_Cpos_0   : Token_Index                      := No_Token_Index;
      Tmp_List_0   : Free_Parse_List;
      Defer_Pos_43 : Token_Index                      := No_Token_Index;
      Defer_Res_43 : Bare_Param_Assoc                 := No_Bare_Ada_Node;
      Token_Pos_27 : Token_Index                      := No_Token_Index;
      Token_Res_27 : Token_Index                      := No_Token_Index;
      List_Pos_0   : Token_Index                      := No_Token_Index;
      List_Res_0   : Bare_Assoc_List                  := No_Bare_Ada_Node;
      Or_Pos_11    : Token_Index                      := No_Token_Index;
      Or_Res_11    : Bare_Ada_Node                    := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Call_Suffix_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_11          := M.Instance;
         return Or_Res_11;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_11;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_11 := No_Token_Index;
      Or_Res_11 := No_Bare_Ada_Node;

      Defer_Res_41 :=
        Discrete_Subtype_Indication_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_41 := Parser.Current_Pos;

      if Defer_Pos_41 /= No_Token_Index then
         Or_Pos_11 := Defer_Pos_41;
         Or_Res_11 := Defer_Res_41;
         goto Exit_Or_10;
      end if;

      Defer_Res_42 := Discrete_Range_Or_Parse_0 (Parser, Pos);
      Defer_Pos_42 := Parser.Current_Pos;

      if Defer_Pos_42 /= No_Token_Index then
         Or_Pos_11 := Defer_Pos_42;
         Or_Res_11 := Defer_Res_42;
         goto Exit_Or_10;
      end if;

--  Start list_code

      List_Pos_0 := No_Token_Index;

      Lst_Cpos_0 := Pos;
      Tmp_List_0 := Get_Parse_List (Parser);

      loop

         Defer_Res_43 := Param_Assoc_Transform_Parse_0 (Parser, Lst_Cpos_0);
         Defer_Pos_43 := Parser.Current_Pos;

         exit when Defer_Pos_43 = No_Token_Index;

         List_Pos_0 := Defer_Pos_43;
         Lst_Cpos_0 := List_Pos_0;

         Tmp_List_0.Nodes.Append (Defer_Res_43);

--  Start tok_code

         Token_Res_27 := Lst_Cpos_0;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_27));
         begin
            if T.Kind /= From_Token_Kind (Ada_Comma) then
               Token_Pos_27 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_0 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_0,
                     Expected_Token_Id => Ada_Comma,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_27 := Lst_Cpos_0 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_27 /= No_Token_Index then
            Lst_Cpos_0 := Token_Pos_27;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_0.Nodes.Length;
      begin
         List_Res_0 := Allocate_Assoc_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Pos;
            Token_End   := (if Lst_Cpos_0 = Pos then Pos else Lst_Cpos_0 - 1);

         else
            Token_Start := Token_Index'Max (Pos, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self => List_Res_0, Kind => Ada_Assoc_List, Unit => Parser.Unit,
            Token_Start_Index => Token_Start, Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_0, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_0.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_0.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_0);

--  End list_code

      if List_Pos_0 /= No_Token_Index then
         Or_Pos_11 := List_Pos_0;
         Or_Res_11 := List_Res_0;
         goto Exit_Or_10;
      end if;
      <<Exit_Or_10>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Call_Suffix_Or_Parse_0_Memo,
         Or_Pos_11 /= No_Token_Index, Or_Res_11, Pos, Or_Pos_11);

      Parser.Current_Pos := Or_Pos_11;

      return Or_Res_11;
   end Call_Suffix_Or_Parse_0;

   function Choice_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Defer_Pos_88 : Token_Index                      := No_Token_Index;
      Defer_Res_88 : Bare_Expr                        := No_Bare_Ada_Node;
      Defer_Pos_89 : Token_Index                      := No_Token_Index;
      Defer_Res_89 : Bare_Discrete_Subtype_Indication := No_Bare_Ada_Node;
      Defer_Pos_90 : Token_Index                      := No_Token_Index;
      Defer_Res_90 : Bare_Expr                        := No_Bare_Ada_Node;
      Defer_Pos_91 : Token_Index                      := No_Token_Index;
      Defer_Res_91 : Bare_Others_Designator           := No_Bare_Ada_Node;
      Or_Pos_27    : Token_Index                      := No_Token_Index;
      Or_Res_27    : Bare_Ada_Node                    := No_Bare_Ada_Node;

      M : Memo_Entry := Get (Parser.Private_Part.Choice_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_27          := M.Instance;
         return Or_Res_27;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_27;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_27 := No_Token_Index;
      Or_Res_27 := No_Bare_Ada_Node;

      Defer_Res_88 := Discrete_Range_Or_Parse_0 (Parser, Pos);
      Defer_Pos_88 := Parser.Current_Pos;

      if Defer_Pos_88 /= No_Token_Index then
         Or_Pos_27 := Defer_Pos_88;
         Or_Res_27 := Defer_Res_88;
         goto Exit_Or_25;
      end if;

      Defer_Res_89 :=
        Discrete_Subtype_Indication_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_89 := Parser.Current_Pos;

      if Defer_Pos_89 /= No_Token_Index then
         Or_Pos_27 := Defer_Pos_89;
         Or_Res_27 := Defer_Res_89;
         goto Exit_Or_25;
      end if;

      Defer_Res_90 := Expr_Or_Parse_0 (Parser, Pos);
      Defer_Pos_90 := Parser.Current_Pos;

      if Defer_Pos_90 /= No_Token_Index then
         Or_Pos_27 := Defer_Pos_90;
         Or_Res_27 := Defer_Res_90;
         goto Exit_Or_25;
      end if;

      Defer_Res_91 := Others_Designator_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_91 := Parser.Current_Pos;

      if Defer_Pos_91 /= No_Token_Index then
         Or_Pos_27 := Defer_Pos_91;
         Or_Res_27 := Defer_Res_91;
         goto Exit_Or_25;
      end if;
      <<Exit_Or_25>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Choice_Or_Parse_0_Memo,
         Or_Pos_27 /= No_Token_Index, Or_Res_27, Pos, Or_Pos_27);

      Parser.Current_Pos := Or_Pos_27;

      return Or_Res_27;
   end Choice_Or_Parse_0;

   function Choice_List_List_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Alternatives_List
   is
      use Bare_Alternatives_List_Memos;

      Lst_Cpos_3   : Token_Index            := No_Token_Index;
      Tmp_List_3   : Free_Parse_List;
      Defer_Pos_87 : Token_Index            := No_Token_Index;
      Defer_Res_87 : Bare_Ada_Node          := No_Bare_Ada_Node;
      Token_Pos_71 : Token_Index            := No_Token_Index;
      Token_Res_71 : Token_Index            := No_Token_Index;
      List_Pos_3   : Token_Index            := No_Token_Index;
      List_Res_3   : Bare_Alternatives_List := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Choice_List_List_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         List_Res_3         := M.Instance;
         return List_Res_3;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return List_Res_3;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start list_code

      List_Pos_3 := No_Token_Index;

      Lst_Cpos_3 := Pos;
      Tmp_List_3 := Get_Parse_List (Parser);

      loop

         Defer_Res_87 := Choice_Or_Parse_0 (Parser, Lst_Cpos_3);
         Defer_Pos_87 := Parser.Current_Pos;

         exit when Defer_Pos_87 = No_Token_Index;

         List_Pos_3 := Defer_Pos_87;
         Lst_Cpos_3 := List_Pos_3;

         Tmp_List_3.Nodes.Append (Defer_Res_87);

--  Start tok_code

         Token_Res_71 := Lst_Cpos_3;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_71));
         begin
            if T.Kind /= From_Token_Kind (Ada_Pipe) then
               Token_Pos_71 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_3 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_3,
                     Expected_Token_Id => Ada_Pipe,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_71 := Lst_Cpos_3 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_71 /= No_Token_Index then
            Lst_Cpos_3 := Token_Pos_71;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_3.Nodes.Length;
      begin
         List_Res_3 := Allocate_Alternatives_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Pos;
            Token_End   := (if Lst_Cpos_3 = Pos then Pos else Lst_Cpos_3 - 1);

         else
            Token_Start := Token_Index'Max (Pos, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self            => List_Res_3, Kind => Ada_Alternatives_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_3, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_3.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_3.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_3);

--  End list_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Choice_List_List_Parse_0_Memo,
         List_Pos_3 /= No_Token_Index, List_Res_3, Pos, List_Pos_3);

      Parser.Current_Pos := List_Pos_3;

      return List_Res_3;
   end Choice_List_List_Parse_0;

   function Aggregate_Assoc_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Aggregate_Assoc
   is
      use Bare_Aggregate_Assoc_Memos;

      Row_Pos_65       : Token_Index            := No_Token_Index;
      Row_Pos_66       : Token_Index            := No_Token_Index;
      Defer_Pos_84     : Token_Index            := No_Token_Index;
      Defer_Res_84     : Bare_Alternatives_List := No_Bare_Ada_Node;
      Token_Pos_70     : Token_Index            := No_Token_Index;
      Token_Res_70     : Token_Index            := No_Token_Index;
      Defer_Pos_85     : Token_Index            := No_Token_Index;
      Defer_Res_85     : Bare_Box_Expr          := No_Bare_Ada_Node;
      Defer_Pos_86     : Token_Index            := No_Token_Index;
      Defer_Res_86     : Bare_Expr              := No_Bare_Ada_Node;
      Or_Pos_26        : Token_Index            := No_Token_Index;
      Or_Res_26        : Bare_Expr              := No_Bare_Ada_Node;
      Transform_Res_59 : Bare_Aggregate_Assoc   := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Aggregate_Assoc_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_59   := M.Instance;
         return Transform_Res_59;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_59;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_65 := Pos;

--  Start opt_code

--  Start row_code

      Row_Pos_66 := Row_Pos_65;

      Defer_Res_84 := Choice_List_List_Parse_0 (Parser, Row_Pos_66);
      Defer_Pos_84 := Parser.Current_Pos;

      if Defer_Pos_84 /= No_Token_Index then

         Row_Pos_66 := Defer_Pos_84;

      else
         Row_Pos_66 := No_Token_Index;
         goto Exit_Row_59_0;

      end if;

--  Start tok_code

      Token_Res_70 := Row_Pos_66;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_70));
      begin
         if T.Kind /= From_Token_Kind (Ada_Arrow) then
            Token_Pos_70 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_66 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_66,
                  Expected_Token_Id => Ada_Arrow,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_70 := Row_Pos_66 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_70 /= No_Token_Index then

         Row_Pos_66 := Token_Pos_70;

      else
         Row_Pos_66 := No_Token_Index;
         goto Exit_Row_59_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_59_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_66 = No_Token_Index then

         Defer_Res_84 := Allocate_Alternatives_List (Parser.Mem_Pool);
         Initialize
           (Self            => Defer_Res_84, Kind => Ada_Alternatives_List,
            Unit => Parser.Unit, Token_Start_Index => Row_Pos_65 - 1,
            Token_End_Index => No_Token_Index);
         Initialize_List (Self => Defer_Res_84, Parser => Parser, Count => 0);

         Row_Pos_66 := Row_Pos_65;

      end if;

--  End opt_code

      if Row_Pos_66 /= No_Token_Index then

         Row_Pos_65 := Row_Pos_66;

      else
         Row_Pos_65 := No_Token_Index;
         goto Exit_Row_58_0;

      end if;

--  Start or_code

      Or_Pos_26 := No_Token_Index;
      Or_Res_26 := No_Bare_Ada_Node;

      Defer_Res_85 := Box_Expr_Transform_Parse_0 (Parser, Row_Pos_65);
      Defer_Pos_85 := Parser.Current_Pos;

      if Defer_Pos_85 /= No_Token_Index then
         Or_Pos_26 := Defer_Pos_85;
         Or_Res_26 := Defer_Res_85;
         goto Exit_Or_26;
      end if;

      Defer_Res_86 := Expr_Or_Parse_0 (Parser, Row_Pos_65);
      Defer_Pos_86 := Parser.Current_Pos;

      if Defer_Pos_86 /= No_Token_Index then
         Or_Pos_26 := Defer_Pos_86;
         Or_Res_26 := Defer_Res_86;
         goto Exit_Or_26;
      end if;
      <<Exit_Or_26>>

--  End or_code

      if Or_Pos_26 /= No_Token_Index then

         Row_Pos_65 := Or_Pos_26;

      else
         Row_Pos_65 := No_Token_Index;
         goto Exit_Row_58_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_58_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_65 /= No_Token_Index then

         Transform_Res_59 := Allocate_Aggregate_Assoc (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_59, Kind => Ada_Aggregate_Assoc,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_65 = Pos then No_Token_Index else Row_Pos_65 - 1));

         Initialize_Fields_For_Aggregate_Assoc
           (Self                          => Transform_Res_59,
            Aggregate_Assoc_F_Designators => Defer_Res_84,
            Aggregate_Assoc_F_R_Expr      => Or_Res_26);

         if Defer_Res_84 /= null and then Is_Incomplete (Defer_Res_84) then
            Transform_Res_59.Last_Attempted_Child := 0;
         elsif Defer_Res_84 /= null and then not Is_Ghost (Defer_Res_84) then
            Transform_Res_59.Last_Attempted_Child := -1;
         end if;
         if Or_Res_26 /= null and then Is_Incomplete (Or_Res_26) then
            Transform_Res_59.Last_Attempted_Child := 0;
         elsif Or_Res_26 /= null and then not Is_Ghost (Or_Res_26) then
            Transform_Res_59.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Aggregate_Assoc_Transform_Parse_0_Memo,
         Row_Pos_65 /= No_Token_Index, Transform_Res_59, Pos, Row_Pos_65);

      Parser.Current_Pos := Row_Pos_65;

      return Transform_Res_59;
   end Aggregate_Assoc_Transform_Parse_0;

   function Aggregate_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Base_Aggregate
   is
      use Bare_Base_Aggregate_Memos;

      Nobt_9                 : Boolean                    := False;
      Row_Pos_61             : Token_Index                := No_Token_Index;
      Token_Pos_61           : Token_Index                := No_Token_Index;
      Token_Res_61           : Token_Index                := No_Token_Index;
      Row_Pos_62             : Token_Index                := No_Token_Index;
      Defer_Pos_81           : Token_Index                := No_Token_Index;
      Defer_Res_81           : Bare_Expr                  := No_Bare_Ada_Node;
      Token_Pos_62           : Token_Index                := No_Token_Index;
      Token_Res_62           : Token_Index                := No_Token_Index;
      Token_Pos_63           : Token_Index                := No_Token_Index;
      Token_Res_63           : Token_Index                := No_Token_Index;
      Token_Pos_64           : Token_Index                := No_Token_Index;
      Token_Res_64           : Token_Index                := No_Token_Index;
      Null_Res_2             : Bare_Assoc_List            := No_Bare_Ada_Node;
      Token_Pos_65           : Token_Index                := No_Token_Index;
      Token_Res_65           : Token_Index                := No_Token_Index;
      Transform_Res_57       : Bare_Null_Record_Aggregate := No_Bare_Ada_Node;
      Row_Pos_63             : Token_Index                := No_Token_Index;
      Token_Pos_66           : Token_Index                := No_Token_Index;
      Token_Res_66           : Token_Index                := No_Token_Index;
      Row_Pos_64             : Token_Index                := No_Token_Index;
      Defer_Pos_82           : Token_Index                := No_Token_Index;
      Defer_Res_82           : Bare_Expr                  := No_Bare_Ada_Node;
      Token_Pos_67           : Token_Index                := No_Token_Index;
      Token_Res_67           : Token_Index                := No_Token_Index;
      Lst_Cpos_2             : Token_Index                := No_Token_Index;
      Tmp_List_2             : Free_Parse_List;
      Defer_Pos_83           : Token_Index                := No_Token_Index;
      Defer_Res_83           : Bare_Aggregate_Assoc       := No_Bare_Ada_Node;
      Token_Pos_68           : Token_Index                := No_Token_Index;
      Token_Res_68           : Token_Index                := No_Token_Index;
      List_Pos_2             : Token_Index                := No_Token_Index;
      List_Res_2             : Bare_Assoc_List            := No_Bare_Ada_Node;
      Token_Pos_69           : Token_Index                := No_Token_Index;
      Token_Res_69           : Token_Index                := No_Token_Index;
      Row_Progress_9         : Integer                    := 0;
      Transform_Res_58       : Bare_Aggregate             := No_Bare_Ada_Node;
      Transform_Has_Failed_9 : Boolean                    := False;
      Or_Pos_25              : Token_Index                := No_Token_Index;
      Or_Res_25              : Bare_Base_Aggregate        := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Aggregate_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_25          := M.Instance;
         return Or_Res_25;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_25;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_25 := No_Token_Index;
      Or_Res_25 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_61 := Pos;

--  Start tok_code

      Token_Res_61 := Row_Pos_61;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_61));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Open) then
            Token_Pos_61 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_61 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_61,
                  Expected_Token_Id => Ada_Par_Open,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_61 := Row_Pos_61 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_61 /= No_Token_Index then

         Row_Pos_61 := Token_Pos_61;

      else
         Row_Pos_61 := No_Token_Index;
         goto Exit_Row_54_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_62 := Row_Pos_61;

      Defer_Res_81 := Expr_Or_Parse_0 (Parser, Row_Pos_62);
      Defer_Pos_81 := Parser.Current_Pos;

      if Defer_Pos_81 /= No_Token_Index then

         Row_Pos_62 := Defer_Pos_81;

      else
         Row_Pos_62 := No_Token_Index;
         goto Exit_Row_55_0;

      end if;

--  Start tok_code

      Token_Res_62 := Row_Pos_62;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_62));
      begin
         if T.Kind /= From_Token_Kind (Ada_With) then
            Token_Pos_62 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_62 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_62,
                  Expected_Token_Id => Ada_With,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_62 := Row_Pos_62 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_62 /= No_Token_Index then

         Row_Pos_62 := Token_Pos_62;

      else
         Row_Pos_62 := No_Token_Index;
         goto Exit_Row_55_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_55_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_62 = No_Token_Index then

         Defer_Res_81 := No_Bare_Ada_Node;

         Row_Pos_62 := Row_Pos_61;

      end if;

--  End opt_code

      if Row_Pos_62 /= No_Token_Index then

         Row_Pos_61 := Row_Pos_62;

      else
         Row_Pos_61 := No_Token_Index;
         goto Exit_Row_54_0;

      end if;

--  Start tok_code

      Token_Res_63 := Row_Pos_61;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_63));
      begin
         if T.Kind /= From_Token_Kind (Ada_Null) then
            Token_Pos_63 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_61 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_61,
                  Expected_Token_Id => Ada_Null,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_63 := Row_Pos_61 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_63 /= No_Token_Index then

         Row_Pos_61 := Token_Pos_63;

      else
         Row_Pos_61 := No_Token_Index;
         goto Exit_Row_54_0;

      end if;

--  Start tok_code

      Token_Res_64 := Row_Pos_61;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_64));
      begin
         if T.Kind /= From_Token_Kind (Ada_Record) then
            Token_Pos_64 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_61 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_61,
                  Expected_Token_Id => Ada_Record,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_64 := Row_Pos_61 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_64 /= No_Token_Index then

         Row_Pos_61 := Token_Pos_64;

      else
         Row_Pos_61 := No_Token_Index;
         goto Exit_Row_54_0;

      end if;

      Null_Res_2 := Allocate_Assoc_List (Parser.Mem_Pool);
      Initialize
        (Self => Null_Res_2, Kind => Ada_Assoc_List, Unit => Parser.Unit,
         Token_Start_Index => Token_Index'Max (Row_Pos_61, 1),
         Token_End_Index   => No_Token_Index);
      Initialize_List (Self => Null_Res_2, Parser => Parser, Count => 0);

      if Row_Pos_61 /= No_Token_Index then

         Row_Pos_61 := Row_Pos_61;

      else
         Row_Pos_61 := No_Token_Index;
         goto Exit_Row_54_0;

      end if;

--  Start tok_code

      Token_Res_65 := Row_Pos_61;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_65));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Close) then
            Token_Pos_65 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_61 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_61,
                  Expected_Token_Id => Ada_Par_Close,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_65 := Row_Pos_61 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_65 /= No_Token_Index then

         Row_Pos_61 := Token_Pos_65;

      else
         Row_Pos_61 := No_Token_Index;
         goto Exit_Row_54_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_54_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_61 /= No_Token_Index then

         Transform_Res_57 := Allocate_Null_Record_Aggregate (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_57, Kind => Ada_Null_Record_Aggregate,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_61 = Pos then No_Token_Index else Row_Pos_61 - 1));

         Initialize_Fields_For_Null_Record_Aggregate
           (Self                           => Transform_Res_57,
            Base_Aggregate_F_Ancestor_Expr => Defer_Res_81,
            Base_Aggregate_F_Assocs        => Null_Res_2);

         if Defer_Res_81 /= null and then Is_Incomplete (Defer_Res_81) then
            Transform_Res_57.Last_Attempted_Child := 0;
         elsif Defer_Res_81 /= null and then not Is_Ghost (Defer_Res_81) then
            Transform_Res_57.Last_Attempted_Child := -1;
         end if;
         if Null_Res_2 /= null and then Is_Incomplete (Null_Res_2) then
            Transform_Res_57.Last_Attempted_Child := 0;
         elsif Null_Res_2 /= null and then not Is_Ghost (Null_Res_2) then
            Transform_Res_57.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_61 /= No_Token_Index then
         Or_Pos_25 := Row_Pos_61;
         Or_Res_25 := Transform_Res_57;
         goto Exit_Or_24;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_63 := Pos;

--  Start tok_code

      Token_Res_66 := Row_Pos_63;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_66));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Open) then
            Token_Pos_66 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_63 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_63,
                  Expected_Token_Id => Ada_Par_Open,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_66 := Row_Pos_63 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_9 := 1;

      if Token_Pos_66 /= No_Token_Index then

         Row_Pos_63 := Token_Pos_66;

      else
         Row_Pos_63 := No_Token_Index;
         goto Exit_Row_56_0;

      end if;

      Nobt_9 := True;

      Row_Progress_9 := 2;

      if Row_Pos_63 /= No_Token_Index then

         Row_Pos_63 := Row_Pos_63;

      else
         Row_Pos_63 := No_Token_Index;
         goto Exit_Row_56_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_64 := Row_Pos_63;

      Defer_Res_82 := Expr_Or_Parse_0 (Parser, Row_Pos_64);
      Defer_Pos_82 := Parser.Current_Pos;

      if Defer_Pos_82 /= No_Token_Index then

         Row_Pos_64 := Defer_Pos_82;

      else
         Row_Pos_64 := No_Token_Index;
         goto Exit_Row_57_0;

      end if;

--  Start tok_code

      Token_Res_67 := Row_Pos_64;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_67));
      begin
         if T.Kind /= From_Token_Kind (Ada_With) then
            Token_Pos_67 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_64 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_64,
                  Expected_Token_Id => Ada_With,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_67 := Row_Pos_64 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_67 /= No_Token_Index then

         Row_Pos_64 := Token_Pos_67;

      else
         Row_Pos_64 := No_Token_Index;
         goto Exit_Row_57_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_57_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_64 = No_Token_Index then

         Defer_Res_82 := No_Bare_Ada_Node;

         Row_Pos_64 := Row_Pos_63;

      end if;

--  End opt_code

      Row_Progress_9 := 3;

      if Row_Pos_64 /= No_Token_Index then

         Row_Pos_63 := Row_Pos_64;

      else
         Row_Pos_63 := No_Token_Index;
         goto Exit_Row_56_0;

      end if;

--  Start list_code

      List_Pos_2 := No_Token_Index;

      Lst_Cpos_2 := Row_Pos_63;
      Tmp_List_2 := Get_Parse_List (Parser);

      loop

         Defer_Res_83 :=
           Aggregate_Assoc_Transform_Parse_0 (Parser, Lst_Cpos_2);
         Defer_Pos_83 := Parser.Current_Pos;

         exit when Defer_Pos_83 = No_Token_Index;

         List_Pos_2 := Defer_Pos_83;
         Lst_Cpos_2 := List_Pos_2;

         Tmp_List_2.Nodes.Append (Defer_Res_83);

--  Start tok_code

         Token_Res_68 := Lst_Cpos_2;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_68));
         begin
            if T.Kind /= From_Token_Kind (Ada_Comma) then
               Token_Pos_68 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_2 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_2,
                     Expected_Token_Id => Ada_Comma,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_68 := Lst_Cpos_2 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_68 /= No_Token_Index then
            Lst_Cpos_2 := Token_Pos_68;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_2.Nodes.Length;
      begin
         List_Res_2 := Allocate_Assoc_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_63;
            Token_End   :=
              (if Lst_Cpos_2 = Row_Pos_63 then Row_Pos_63 else Lst_Cpos_2 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_63, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self => List_Res_2, Kind => Ada_Assoc_List, Unit => Parser.Unit,
            Token_Start_Index => Token_Start, Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_2, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_2.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_2.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_2);

--  End list_code

      Row_Progress_9 := 4;

      if List_Pos_2 /= No_Token_Index then

         Row_Pos_63 := List_Pos_2;

      else
         Row_Pos_63 := No_Token_Index;
         goto Exit_Row_56_0;

      end if;

--  Start tok_code

      Token_Res_69 := Row_Pos_63;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_69));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Close) then
            Token_Pos_69 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_63 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_63,
                  Expected_Token_Id => Ada_Par_Close,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_69 := Row_Pos_63 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_9 := 5;

      if Token_Pos_69 /= No_Token_Index then

         Row_Pos_63 := Token_Pos_69;

      else
         Row_Pos_63 := No_Token_Index;
         goto Exit_Row_56_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_56_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_63 = No_Token_Index and then Nobt_9 then
         Row_Pos_63             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_9 := True;
      end if;

      if Row_Pos_63 /= No_Token_Index then

         Transform_Res_58 := Allocate_Aggregate (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_58, Kind => Ada_Aggregate,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_63 = Pos then No_Token_Index else Row_Pos_63 - 1));

         Initialize_Fields_For_Aggregate
           (Self                           => Transform_Res_58,
            Base_Aggregate_F_Ancestor_Expr => Defer_Res_82,
            Base_Aggregate_F_Assocs        => List_Res_2);

         if Defer_Res_82 /= null and then Is_Incomplete (Defer_Res_82) then
            Transform_Res_58.Last_Attempted_Child := 0;
         elsif Defer_Res_82 /= null and then not Is_Ghost (Defer_Res_82) then
            Transform_Res_58.Last_Attempted_Child := -1;
         end if;
         if List_Res_2 /= null and then Is_Incomplete (List_Res_2) then
            Transform_Res_58.Last_Attempted_Child := 0;
         elsif List_Res_2 /= null and then not Is_Ghost (List_Res_2) then
            Transform_Res_58.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_9 then
            Transform_Res_58.Last_Attempted_Child := Row_Progress_9;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <aggregate>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      if Row_Pos_63 /= No_Token_Index then
         Or_Pos_25 := Row_Pos_63;
         Or_Res_25 := Transform_Res_58;
         goto Exit_Or_24;
      end if;
      <<Exit_Or_24>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Aggregate_Or_Parse_0_Memo,
         Or_Pos_25 /= No_Token_Index, Or_Res_25, Pos, Or_Pos_25);

      Parser.Current_Pos := Or_Pos_25;

      return Or_Res_25;
   end Aggregate_Or_Parse_0;

   function Multidim_Array_Assoc_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Multi_Dim_Array_Assoc
   is
      use Bare_Multi_Dim_Array_Assoc_Memos;

      Row_Pos_67       : Token_Index                := No_Token_Index;
      Lst_Cpos_5       : Token_Index                := No_Token_Index;
      Tmp_List_5       : Free_Parse_List;
      Defer_Pos_93     : Token_Index                := No_Token_Index;
      Defer_Res_93     : Bare_Base_Aggregate        := No_Bare_Ada_Node;
      Token_Pos_73     : Token_Index                := No_Token_Index;
      Token_Res_73     : Token_Index                := No_Token_Index;
      List_Pos_5       : Token_Index                := No_Token_Index;
      List_Res_5       : Bare_Alternatives_List     := No_Bare_Ada_Node;
      Token_Pos_74     : Token_Index                := No_Token_Index;
      Token_Res_74     : Token_Index                := No_Token_Index;
      Defer_Pos_94     : Token_Index                := No_Token_Index;
      Defer_Res_94     : Bare_Expr                  := No_Bare_Ada_Node;
      Transform_Res_60 : Bare_Multi_Dim_Array_Assoc := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Multidim_Array_Assoc_Transform_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_60   := M.Instance;
         return Transform_Res_60;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_60;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_67 := Pos;

--  Start list_code

      List_Pos_5 := No_Token_Index;

      Lst_Cpos_5 := Row_Pos_67;
      Tmp_List_5 := Get_Parse_List (Parser);

      loop

         Defer_Res_93 := Aggregate_Or_Parse_0 (Parser, Lst_Cpos_5);
         Defer_Pos_93 := Parser.Current_Pos;

         exit when Defer_Pos_93 = No_Token_Index;

         List_Pos_5 := Defer_Pos_93;
         Lst_Cpos_5 := List_Pos_5;

         Tmp_List_5.Nodes.Append (Defer_Res_93);

--  Start tok_code

         Token_Res_73 := Lst_Cpos_5;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_73));
         begin
            if T.Kind /= From_Token_Kind (Ada_Pipe) then
               Token_Pos_73 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_5 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_5,
                     Expected_Token_Id => Ada_Pipe,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_73 := Lst_Cpos_5 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_73 /= No_Token_Index then
            Lst_Cpos_5 := Token_Pos_73;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_5.Nodes.Length;
      begin
         List_Res_5 := Allocate_Alternatives_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_67;
            Token_End   :=
              (if Lst_Cpos_5 = Row_Pos_67 then Row_Pos_67 else Lst_Cpos_5 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_67, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self            => List_Res_5, Kind => Ada_Alternatives_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_5, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_5.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_5.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_5);

--  End list_code

      if List_Pos_5 /= No_Token_Index then

         Row_Pos_67 := List_Pos_5;

      else
         Row_Pos_67 := No_Token_Index;
         goto Exit_Row_61_0;

      end if;

--  Start tok_code

      Token_Res_74 := Row_Pos_67;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_74));
      begin
         if T.Kind /= From_Token_Kind (Ada_Arrow) then
            Token_Pos_74 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_67 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_67,
                  Expected_Token_Id => Ada_Arrow,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_74 := Row_Pos_67 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_74 /= No_Token_Index then

         Row_Pos_67 := Token_Pos_74;

      else
         Row_Pos_67 := No_Token_Index;
         goto Exit_Row_61_0;

      end if;

      Defer_Res_94 := Expr_Or_Parse_0 (Parser, Row_Pos_67);
      Defer_Pos_94 := Parser.Current_Pos;

      if Defer_Pos_94 /= No_Token_Index then

         Row_Pos_67 := Defer_Pos_94;

      else
         Row_Pos_67 := No_Token_Index;
         goto Exit_Row_61_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_61_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_67 /= No_Token_Index then

         Transform_Res_60 := Allocate_Multi_Dim_Array_Assoc (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_60, Kind => Ada_Multi_Dim_Array_Assoc,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_67 = Pos then No_Token_Index else Row_Pos_67 - 1));

         Initialize_Fields_For_Multi_Dim_Array_Assoc
           (Self                          => Transform_Res_60,
            Aggregate_Assoc_F_Designators => List_Res_5,
            Aggregate_Assoc_F_R_Expr      => Defer_Res_94);

         if List_Res_5 /= null and then Is_Incomplete (List_Res_5) then
            Transform_Res_60.Last_Attempted_Child := 0;
         elsif List_Res_5 /= null and then not Is_Ghost (List_Res_5) then
            Transform_Res_60.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_94 /= null and then Is_Incomplete (Defer_Res_94) then
            Transform_Res_60.Last_Attempted_Child := 0;
         elsif Defer_Res_94 /= null and then not Is_Ghost (Defer_Res_94) then
            Transform_Res_60.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Multidim_Array_Assoc_Transform_Parse_0_Memo,
         Row_Pos_67 /= No_Token_Index, Transform_Res_60, Pos, Row_Pos_67);

      Parser.Current_Pos := Row_Pos_67;

      return Transform_Res_60;
   end Multidim_Array_Assoc_Transform_Parse_0;

   function Update_Attr_Content_List_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Assoc_List
   is
      use Bare_Assoc_List_Memos;

      Lst_Cpos_4   : Token_Index                := No_Token_Index;
      Tmp_List_4   : Free_Parse_List;
      Defer_Pos_92 : Token_Index                := No_Token_Index;
      Defer_Res_92 : Bare_Multi_Dim_Array_Assoc := No_Bare_Ada_Node;
      Token_Pos_72 : Token_Index                := No_Token_Index;
      Token_Res_72 : Token_Index                := No_Token_Index;
      List_Pos_4   : Token_Index                := No_Token_Index;
      List_Res_4   : Bare_Assoc_List            := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Update_Attr_Content_List_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         List_Res_4         := M.Instance;
         return List_Res_4;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return List_Res_4;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start list_code

      List_Pos_4 := No_Token_Index;

      Lst_Cpos_4 := Pos;
      Tmp_List_4 := Get_Parse_List (Parser);

      loop

         Defer_Res_92 :=
           Multidim_Array_Assoc_Transform_Parse_0 (Parser, Lst_Cpos_4);
         Defer_Pos_92 := Parser.Current_Pos;

         exit when Defer_Pos_92 = No_Token_Index;

         List_Pos_4 := Defer_Pos_92;
         Lst_Cpos_4 := List_Pos_4;

         Tmp_List_4.Nodes.Append (Defer_Res_92);

--  Start tok_code

         Token_Res_72 := Lst_Cpos_4;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_72));
         begin
            if T.Kind /= From_Token_Kind (Ada_Comma) then
               Token_Pos_72 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_4 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_4,
                     Expected_Token_Id => Ada_Comma,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_72 := Lst_Cpos_4 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_72 /= No_Token_Index then
            Lst_Cpos_4 := Token_Pos_72;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_4.Nodes.Length;
      begin
         List_Res_4 := Allocate_Assoc_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Pos;
            Token_End   := (if Lst_Cpos_4 = Pos then Pos else Lst_Cpos_4 - 1);

         else
            Token_Start := Token_Index'Max (Pos, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self => List_Res_4, Kind => Ada_Assoc_List, Unit => Parser.Unit,
            Token_Start_Index => Token_Start, Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_4, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_4.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_4.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_4);

--  End list_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Update_Attr_Content_List_Parse_0_Memo,
         List_Pos_4 /= No_Token_Index, List_Res_4, Pos, List_Pos_4);

      Parser.Current_Pos := List_Pos_4;

      return List_Res_4;
   end Update_Attr_Content_List_Parse_0;

   function Update_Attr_Aggregate_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Base_Aggregate
   is
      use Bare_Base_Aggregate_Memos;

      Nobt_8                 : Boolean             := False;
      Defer_Pos_79           : Token_Index         := No_Token_Index;
      Defer_Res_79           : Bare_Base_Aggregate := No_Bare_Ada_Node;
      Row_Pos_60             : Token_Index         := No_Token_Index;
      Token_Pos_59           : Token_Index         := No_Token_Index;
      Token_Res_59           : Token_Index         := No_Token_Index;
      Null_Res_1             : Bare_Expr           := No_Bare_Ada_Node;
      Defer_Pos_80           : Token_Index         := No_Token_Index;
      Defer_Res_80           : Bare_Assoc_List     := No_Bare_Ada_Node;
      Token_Pos_60           : Token_Index         := No_Token_Index;
      Token_Res_60           : Token_Index         := No_Token_Index;
      Row_Progress_8         : Integer             := 0;
      Transform_Res_56       : Bare_Aggregate      := No_Bare_Ada_Node;
      Transform_Has_Failed_8 : Boolean             := False;
      Or_Pos_24              : Token_Index         := No_Token_Index;
      Or_Res_24              : Bare_Base_Aggregate := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Update_Attr_Aggregate_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_24          := M.Instance;
         return Or_Res_24;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_24;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_24 := No_Token_Index;
      Or_Res_24 := No_Bare_Ada_Node;

      Defer_Res_79 := Aggregate_Or_Parse_0 (Parser, Pos);
      Defer_Pos_79 := Parser.Current_Pos;

      if Defer_Pos_79 /= No_Token_Index then
         Or_Pos_24 := Defer_Pos_79;
         Or_Res_24 := Defer_Res_79;
         goto Exit_Or_23;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_60 := Pos;

--  Start tok_code

      Token_Res_59 := Row_Pos_60;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_59));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Open) then
            Token_Pos_59 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_60 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_60,
                  Expected_Token_Id => Ada_Par_Open,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_59 := Row_Pos_60 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_8 := 1;

      if Token_Pos_59 /= No_Token_Index then

         Row_Pos_60 := Token_Pos_59;

      else
         Row_Pos_60 := No_Token_Index;
         goto Exit_Row_60_0;

      end if;

      Nobt_8 := True;

      Row_Progress_8 := 2;

      if Row_Pos_60 /= No_Token_Index then

         Row_Pos_60 := Row_Pos_60;

      else
         Row_Pos_60 := No_Token_Index;
         goto Exit_Row_60_0;

      end if;

      Null_Res_1 := No_Bare_Ada_Node;

      Row_Progress_8 := 3;

      if Row_Pos_60 /= No_Token_Index then

         Row_Pos_60 := Row_Pos_60;

      else
         Row_Pos_60 := No_Token_Index;
         goto Exit_Row_60_0;

      end if;

      Defer_Res_80 := Update_Attr_Content_List_Parse_0 (Parser, Row_Pos_60);
      Defer_Pos_80 := Parser.Current_Pos;

      Row_Progress_8 := 4;

      if Defer_Pos_80 /= No_Token_Index then

         Row_Pos_60 := Defer_Pos_80;

      else
         Row_Pos_60 := No_Token_Index;
         goto Exit_Row_60_0;

      end if;

--  Start tok_code

      Token_Res_60 := Row_Pos_60;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_60));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Close) then
            Token_Pos_60 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_60 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_60,
                  Expected_Token_Id => Ada_Par_Close,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_60 := Row_Pos_60 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_8 := 5;

      if Token_Pos_60 /= No_Token_Index then

         Row_Pos_60 := Token_Pos_60;

      else
         Row_Pos_60 := No_Token_Index;
         goto Exit_Row_60_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_60_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_60 = No_Token_Index and then Nobt_8 then
         Row_Pos_60             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_8 := True;
      end if;

      if Row_Pos_60 /= No_Token_Index then

         Transform_Res_56 := Allocate_Aggregate (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_56, Kind => Ada_Aggregate,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_60 = Pos then No_Token_Index else Row_Pos_60 - 1));

         Initialize_Fields_For_Aggregate
           (Self                           => Transform_Res_56,
            Base_Aggregate_F_Ancestor_Expr => Null_Res_1,
            Base_Aggregate_F_Assocs        => Defer_Res_80);

         if Null_Res_1 /= null and then Is_Incomplete (Null_Res_1) then
            Transform_Res_56.Last_Attempted_Child := 0;
         elsif Null_Res_1 /= null and then not Is_Ghost (Null_Res_1) then
            Transform_Res_56.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_80 /= null and then Is_Incomplete (Defer_Res_80) then
            Transform_Res_56.Last_Attempted_Child := 0;
         elsif Defer_Res_80 /= null and then not Is_Ghost (Defer_Res_80) then
            Transform_Res_56.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_8 then
            Transform_Res_56.Last_Attempted_Child := Row_Progress_8;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <update_attr_aggregate>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      if Row_Pos_60 /= No_Token_Index then
         Or_Pos_24 := Row_Pos_60;
         Or_Res_24 := Transform_Res_56;
         goto Exit_Or_23;
      end if;
      <<Exit_Or_23>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Update_Attr_Aggregate_Or_Parse_0_Memo,
         Or_Pos_24 /= No_Token_Index, Or_Res_24, Pos, Or_Pos_24);

      Parser.Current_Pos := Or_Pos_24;

      return Or_Res_24;
   end Update_Attr_Aggregate_Or_Parse_0;

   function Paren_Expr_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Paren_Expr
   is
      use Bare_Paren_Expr_Memos;

      Row_Pos_68       : Token_Index     := No_Token_Index;
      Token_Pos_75     : Token_Index     := No_Token_Index;
      Token_Res_75     : Token_Index     := No_Token_Index;
      Defer_Pos_95     : Token_Index     := No_Token_Index;
      Defer_Res_95     : Bare_Expr       := No_Bare_Ada_Node;
      Token_Pos_76     : Token_Index     := No_Token_Index;
      Token_Res_76     : Token_Index     := No_Token_Index;
      Transform_Res_61 : Bare_Paren_Expr := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Paren_Expr_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_61   := M.Instance;
         return Transform_Res_61;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_61;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_68 := Pos;

--  Start tok_code

      Token_Res_75 := Row_Pos_68;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_75));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Open) then
            Token_Pos_75 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_68 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_68,
                  Expected_Token_Id => Ada_Par_Open,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_75 := Row_Pos_68 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_75 /= No_Token_Index then

         Row_Pos_68 := Token_Pos_75;

      else
         Row_Pos_68 := No_Token_Index;
         goto Exit_Row_66_0;

      end if;

      Defer_Res_95 := Expr_Or_Parse_0 (Parser, Row_Pos_68);
      Defer_Pos_95 := Parser.Current_Pos;

      if Defer_Pos_95 /= No_Token_Index then

         Row_Pos_68 := Defer_Pos_95;

      else
         Row_Pos_68 := No_Token_Index;
         goto Exit_Row_66_0;

      end if;

--  Start tok_code

      Token_Res_76 := Row_Pos_68;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_76));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Close) then
            Token_Pos_76 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_68 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_68,
                  Expected_Token_Id => Ada_Par_Close,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_76 := Row_Pos_68 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_76 /= No_Token_Index then

         Row_Pos_68 := Token_Pos_76;

      else
         Row_Pos_68 := No_Token_Index;
         goto Exit_Row_66_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_66_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_68 /= No_Token_Index then

         Transform_Res_61 := Allocate_Paren_Expr (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_61, Kind => Ada_Paren_Expr,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_68 = Pos then No_Token_Index else Row_Pos_68 - 1));

         Initialize_Fields_For_Paren_Expr
           (Self => Transform_Res_61, Paren_Expr_F_Expr => Defer_Res_95);

         if Defer_Res_95 /= null and then Is_Incomplete (Defer_Res_95) then
            Transform_Res_61.Last_Attempted_Child := 0;
         elsif Defer_Res_95 /= null and then not Is_Ghost (Defer_Res_95) then
            Transform_Res_61.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Paren_Expr_Transform_Parse_0_Memo,
         Row_Pos_68 /= No_Token_Index, Transform_Res_61, Pos, Row_Pos_68);

      Parser.Current_Pos := Row_Pos_68;

      return Transform_Res_61;
   end Paren_Expr_Transform_Parse_0;

   function Target_Name_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Target_Name
   is
      use Bare_Target_Name_Memos;

      Row_Pos_69       : Token_Index      := No_Token_Index;
      Token_Pos_77     : Token_Index      := No_Token_Index;
      Token_Res_77     : Token_Index      := No_Token_Index;
      Transform_Res_62 : Bare_Target_Name := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Target_Name_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_62   := M.Instance;
         return Transform_Res_62;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_62;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_69 := Pos;

--  Start tok_code

      Token_Res_77 := Row_Pos_69;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_77));
      begin
         if T.Kind /= From_Token_Kind (Ada_Target) then
            Token_Pos_77 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_69 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_69,
                  Expected_Token_Id => Ada_Target,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_77 := Row_Pos_69 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_77 /= No_Token_Index then

         Row_Pos_69 := Token_Pos_77;

      else
         Row_Pos_69 := No_Token_Index;
         goto Exit_Row_67_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_67_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_69 /= No_Token_Index then

         Transform_Res_62 := Allocate_Target_Name (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_62, Kind => Ada_Target_Name,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_69 = Pos then No_Token_Index else Row_Pos_69 - 1));

         Initialize_Fields_For_Target_Name (Self => Transform_Res_62);

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Target_Name_Transform_Parse_0_Memo,
         Row_Pos_69 /= No_Token_Index, Transform_Res_62, Pos, Row_Pos_69);

      Parser.Current_Pos := Row_Pos_69;

      return Transform_Res_62;
   end Target_Name_Transform_Parse_0;

   function Direct_Name_Or_Target_Name_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Name
   is
      use Bare_Name_Memos;

      Defer_Pos_96 : Token_Index      := No_Token_Index;
      Defer_Res_96 : Bare_Base_Id     := No_Bare_Ada_Node;
      Defer_Pos_97 : Token_Index      := No_Token_Index;
      Defer_Res_97 : Bare_Target_Name := No_Bare_Ada_Node;
      Or_Pos_28    : Token_Index      := No_Token_Index;
      Or_Res_28    : Bare_Name        := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Direct_Name_Or_Target_Name_Or_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_28          := M.Instance;
         return Or_Res_28;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_28;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_28 := No_Token_Index;
      Or_Res_28 := No_Bare_Ada_Node;

      Defer_Res_96 := Direct_Name_Or_Parse_0 (Parser, Pos);
      Defer_Pos_96 := Parser.Current_Pos;

      if Defer_Pos_96 /= No_Token_Index then
         Or_Pos_28 := Defer_Pos_96;
         Or_Res_28 := Defer_Res_96;
         goto Exit_Or_28;
      end if;

      Defer_Res_97 := Target_Name_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_97 := Parser.Current_Pos;

      if Defer_Pos_97 /= No_Token_Index then
         Or_Pos_28 := Defer_Pos_97;
         Or_Res_28 := Defer_Res_97;
         goto Exit_Or_28;
      end if;
      <<Exit_Or_28>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Direct_Name_Or_Target_Name_Or_Parse_0_Memo,
         Or_Pos_28 /= No_Token_Index, Or_Res_28, Pos, Or_Pos_28);

      Parser.Current_Pos := Or_Pos_28;

      return Or_Res_28;
   end Direct_Name_Or_Target_Name_Or_Parse_0;

   function Name_Or_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Name
   is
      use Bare_Name_Memos;

      Nobt_4                 : Boolean                   := False;
      Nobt_5                 : Boolean                   := False;
      Row_Pos_18             : Token_Index               := No_Token_Index;
      Defer_Pos_25           : Token_Index               := No_Token_Index;
      Defer_Res_25           : Bare_Name                 := No_Bare_Ada_Node;
      Token_Pos_15           : Token_Index               := No_Token_Index;
      Token_Res_15           : Token_Index               := No_Token_Index;
      Defer_Pos_26           : Token_Index               := No_Token_Index;
      Defer_Res_26           : Bare_Ada_Node             := No_Bare_Ada_Node;
      Token_Pos_16           : Token_Index               := No_Token_Index;
      Token_Res_16           : Token_Index               := No_Token_Index;
      Row_Progress_4         : Integer                   := 0;
      Transform_Res_18       : Bare_Call_Expr            := No_Bare_Ada_Node;
      Transform_Has_Failed_4 : Boolean                   := False;
      Row_Pos_19             : Token_Index               := No_Token_Index;
      Defer_Pos_27           : Token_Index               := No_Token_Index;
      Defer_Res_27           : Bare_Name                 := No_Bare_Ada_Node;
      Token_Pos_17           : Token_Index               := No_Token_Index;
      Token_Res_17           : Token_Index               := No_Token_Index;
      Token_Pos_18           : Token_Index               := No_Token_Index;
      Token_Res_18           : Token_Index               := No_Token_Index;
      Transform_Res_19       : Bare_Explicit_Deref       := No_Bare_Ada_Node;
      Row_Pos_20             : Token_Index               := No_Token_Index;
      Defer_Pos_28           : Token_Index               := No_Token_Index;
      Defer_Res_28           : Bare_Name                 := No_Bare_Ada_Node;
      Token_Pos_19           : Token_Index               := No_Token_Index;
      Token_Res_19           : Token_Index               := No_Token_Index;
      Defer_Pos_29           : Token_Index               := No_Token_Index;
      Defer_Res_29           : Bare_Base_Id              := No_Bare_Ada_Node;
      Row_Progress_5         : Integer                   := 0;
      Transform_Res_20       : Bare_Dotted_Name          := No_Bare_Ada_Node;
      Transform_Has_Failed_5 : Boolean                   := False;
      Row_Pos_21             : Token_Index               := No_Token_Index;
      Defer_Pos_30           : Token_Index               := No_Token_Index;
      Defer_Res_30           : Bare_Name                 := No_Bare_Ada_Node;
      Token_Pos_20           : Token_Index               := No_Token_Index;
      Token_Res_20           : Token_Index               := No_Token_Index;
      Row_Pos_22             : Token_Index               := No_Token_Index;
      Token_Pos_21           : Token_Index               := No_Token_Index;
      Token_Res_21           : Token_Index               := No_Token_Index;
      Transform_Res_21       : Bare_Identifier           := No_Bare_Ada_Node;
      Defer_Pos_31           : Token_Index               := No_Token_Index;
      Defer_Res_31           : Bare_Base_Aggregate       := No_Bare_Ada_Node;
      Transform_Res_22       : Bare_Update_Attribute_Ref := No_Bare_Ada_Node;
      Row_Pos_23             : Token_Index               := No_Token_Index;
      Defer_Pos_32           : Token_Index               := No_Token_Index;
      Defer_Res_32           : Bare_Name                 := No_Bare_Ada_Node;
      Token_Pos_22           : Token_Index               := No_Token_Index;
      Token_Res_22           : Token_Index               := No_Token_Index;
      Defer_Pos_33           : Token_Index               := No_Token_Index;
      Defer_Res_33           : Bare_Identifier           := No_Bare_Ada_Node;
      Predicate_Pos_0        : Token_Index               := No_Token_Index;
      Predicate_Res_0        : Bare_Identifier           := No_Bare_Ada_Node;
      Row_Pos_24             : Token_Index               := No_Token_Index;
      Token_Pos_23           : Token_Index               := No_Token_Index;
      Token_Res_23           : Token_Index               := No_Token_Index;
      Defer_Pos_34           : Token_Index               := No_Token_Index;
      Defer_Res_34           : Bare_Ada_Node             := No_Bare_Ada_Node;
      Token_Pos_24           : Token_Index               := No_Token_Index;
      Token_Res_24           : Token_Index               := No_Token_Index;
      Transform_Res_23       : Bare_Attribute_Ref        := No_Bare_Ada_Node;
      Row_Pos_25             : Token_Index               := No_Token_Index;
      Defer_Pos_35           : Token_Index               := No_Token_Index;
      Defer_Res_35           : Bare_Name                 := No_Bare_Ada_Node;
      Token_Pos_25           : Token_Index               := No_Token_Index;
      Token_Res_25           : Token_Index               := No_Token_Index;
      Defer_Pos_36           : Token_Index               := No_Token_Index;
      Defer_Res_36           : Bare_Identifier           := No_Bare_Ada_Node;
      Null_Res_0             : Bare_Ada_Node             := No_Bare_Ada_Node;
      Transform_Res_24       : Bare_Attribute_Ref        := No_Bare_Ada_Node;
      Row_Pos_26             : Token_Index               := No_Token_Index;
      Defer_Pos_37           : Token_Index               := No_Token_Index;
      Defer_Res_37           : Bare_Name                 := No_Bare_Ada_Node;
      Token_Pos_26           : Token_Index               := No_Token_Index;
      Token_Res_26           : Token_Index               := No_Token_Index;
      Defer_Pos_38           : Token_Index               := No_Token_Index;
      Defer_Res_38           : Bare_Paren_Expr           := No_Bare_Ada_Node;
      Defer_Pos_39           : Token_Index               := No_Token_Index;
      Defer_Res_39           : Bare_Base_Aggregate       := No_Bare_Ada_Node;
      Or_Pos_9               : Token_Index               := No_Token_Index;
      Or_Res_9               : Bare_Expr                 := No_Bare_Ada_Node;
      Transform_Res_25       : Bare_Qual_Expr            := No_Bare_Ada_Node;
      Defer_Pos_40           : Token_Index               := No_Token_Index;
      Defer_Res_40           : Bare_Name                 := No_Bare_Ada_Node;
      Or_Pos_10              : Token_Index               := No_Token_Index;
      Or_Res_10              : Bare_Name                 := No_Bare_Ada_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Name   := No_Bare_Ada_Node;

      M : Memo_Entry := Get (Parser.Private_Part.Name_Or_Parse_1_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_10          := M.Instance;
         return Or_Res_10;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_10;
      end if;

      Set
        (Parser.Private_Part.Name_Or_Parse_1_Memo, False, Or_Res_10, Pos,
         Mem_Pos);

      <<Try_Again>>

      Nobt_4 := False;
      Nobt_5 := False;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_10 := No_Token_Index;
      Or_Res_10 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_18 := Pos;

      Defer_Res_25 := Name_Or_Parse_1 (Parser, Row_Pos_18);
      Defer_Pos_25 := Parser.Current_Pos;

      Row_Progress_4 := 1;

      if Defer_Pos_25 /= No_Token_Index then

         Row_Pos_18 := Defer_Pos_25;

      else
         Row_Pos_18 := No_Token_Index;
         goto Exit_Row_16_0;

      end if;

--  Start tok_code

      Token_Res_15 := Row_Pos_18;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_15));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Open) then
            Token_Pos_15 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_18 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_18,
                  Expected_Token_Id => Ada_Par_Open,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_15 := Row_Pos_18 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_4 := 2;

      if Token_Pos_15 /= No_Token_Index then

         Row_Pos_18 := Token_Pos_15;

      else
         Row_Pos_18 := No_Token_Index;
         goto Exit_Row_16_0;

      end if;

      Nobt_4 := True;

      Row_Progress_4 := 3;

      if Row_Pos_18 /= No_Token_Index then

         Row_Pos_18 := Row_Pos_18;

      else
         Row_Pos_18 := No_Token_Index;
         goto Exit_Row_16_0;

      end if;

      Defer_Res_26 := Call_Suffix_Or_Parse_0 (Parser, Row_Pos_18);
      Defer_Pos_26 := Parser.Current_Pos;

      Row_Progress_4 := 4;

      if Defer_Pos_26 /= No_Token_Index then

         Row_Pos_18 := Defer_Pos_26;

      else
         Row_Pos_18 := No_Token_Index;
         goto Exit_Row_16_0;

      end if;

--  Start tok_code

      Token_Res_16 := Row_Pos_18;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_16));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Close) then
            Token_Pos_16 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_18 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_18,
                  Expected_Token_Id => Ada_Par_Close,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_16 := Row_Pos_18 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_4 := 5;

      if Token_Pos_16 /= No_Token_Index then

         Row_Pos_18 := Token_Pos_16;

      else
         Row_Pos_18 := No_Token_Index;
         goto Exit_Row_16_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_16_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_18 = No_Token_Index and then Nobt_4 then
         Row_Pos_18             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_4 := True;
      end if;

      if Row_Pos_18 /= No_Token_Index then

         Transform_Res_18 := Allocate_Call_Expr (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_18, Kind => Ada_Call_Expr,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_18 = Pos then No_Token_Index else Row_Pos_18 - 1));

         Initialize_Fields_For_Call_Expr
           (Self => Transform_Res_18, Call_Expr_F_Name => Defer_Res_25,
            Call_Expr_F_Suffix => Defer_Res_26);

         if Defer_Res_25 /= null and then Is_Incomplete (Defer_Res_25) then
            Transform_Res_18.Last_Attempted_Child := 0;
         elsif Defer_Res_25 /= null and then not Is_Ghost (Defer_Res_25) then
            Transform_Res_18.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_26 /= null and then Is_Incomplete (Defer_Res_26) then
            Transform_Res_18.Last_Attempted_Child := 0;
         elsif Defer_Res_26 /= null and then not Is_Ghost (Defer_Res_26) then
            Transform_Res_18.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_4 then
            Transform_Res_18.Last_Attempted_Child := Row_Progress_4;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <name>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      if Row_Pos_18 /= No_Token_Index then
         Or_Pos_10 := Row_Pos_18;
         Or_Res_10 := Transform_Res_18;
         goto Exit_Or_9;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_19 := Pos;

      Defer_Res_27 := Name_Or_Parse_1 (Parser, Row_Pos_19);
      Defer_Pos_27 := Parser.Current_Pos;

      if Defer_Pos_27 /= No_Token_Index then

         Row_Pos_19 := Defer_Pos_27;

      else
         Row_Pos_19 := No_Token_Index;
         goto Exit_Row_50_0;

      end if;

--  Start tok_code

      Token_Res_17 := Row_Pos_19;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_17));
      begin
         if T.Kind /= From_Token_Kind (Ada_Dot) then
            Token_Pos_17 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_19 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_19,
                  Expected_Token_Id => Ada_Dot,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_17 := Row_Pos_19 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_17 /= No_Token_Index then

         Row_Pos_19 := Token_Pos_17;

      else
         Row_Pos_19 := No_Token_Index;
         goto Exit_Row_50_0;

      end if;

--  Start tok_code

      Token_Res_18 := Row_Pos_19;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_18));
      begin
         if T.Kind /= From_Token_Kind (Ada_All) then
            Token_Pos_18 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_19 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_19,
                  Expected_Token_Id => Ada_All,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_18 := Row_Pos_19 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_18 /= No_Token_Index then

         Row_Pos_19 := Token_Pos_18;

      else
         Row_Pos_19 := No_Token_Index;
         goto Exit_Row_50_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_50_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_19 /= No_Token_Index then

         Transform_Res_19 := Allocate_Explicit_Deref (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_19, Kind => Ada_Explicit_Deref,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_19 = Pos then No_Token_Index else Row_Pos_19 - 1));

         Initialize_Fields_For_Explicit_Deref
           (Self => Transform_Res_19, Explicit_Deref_F_Prefix => Defer_Res_27);

         if Defer_Res_27 /= null and then Is_Incomplete (Defer_Res_27) then
            Transform_Res_19.Last_Attempted_Child := 0;
         elsif Defer_Res_27 /= null and then not Is_Ghost (Defer_Res_27) then
            Transform_Res_19.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_19 /= No_Token_Index then
         Or_Pos_10 := Row_Pos_19;
         Or_Res_10 := Transform_Res_19;
         goto Exit_Or_9;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_20 := Pos;

      Defer_Res_28 := Name_Or_Parse_1 (Parser, Row_Pos_20);
      Defer_Pos_28 := Parser.Current_Pos;

      Row_Progress_5 := 1;

      if Defer_Pos_28 /= No_Token_Index then

         Row_Pos_20 := Defer_Pos_28;

      else
         Row_Pos_20 := No_Token_Index;
         goto Exit_Row_51_0;

      end if;

--  Start tok_code

      Token_Res_19 := Row_Pos_20;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_19));
      begin
         if T.Kind /= From_Token_Kind (Ada_Dot) then
            Token_Pos_19 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_20 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_20,
                  Expected_Token_Id => Ada_Dot,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_19 := Row_Pos_20 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_5 := 2;

      if Token_Pos_19 /= No_Token_Index then

         Row_Pos_20 := Token_Pos_19;

      else
         Row_Pos_20 := No_Token_Index;
         goto Exit_Row_51_0;

      end if;

      Nobt_5 := True;

      Row_Progress_5 := 3;

      if Row_Pos_20 /= No_Token_Index then

         Row_Pos_20 := Row_Pos_20;

      else
         Row_Pos_20 := No_Token_Index;
         goto Exit_Row_51_0;

      end if;

      Defer_Res_29 := Direct_Name_Or_Parse_0 (Parser, Row_Pos_20);
      Defer_Pos_29 := Parser.Current_Pos;

      Row_Progress_5 := 4;

      if Defer_Pos_29 /= No_Token_Index then

         Row_Pos_20 := Defer_Pos_29;

      else
         Row_Pos_20 := No_Token_Index;
         goto Exit_Row_51_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_51_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_20 = No_Token_Index and then Nobt_5 then
         Row_Pos_20             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_5 := True;
      end if;

      if Row_Pos_20 /= No_Token_Index then

         Transform_Res_20 := Allocate_Dotted_Name (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_20, Kind => Ada_Dotted_Name,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_20 = Pos then No_Token_Index else Row_Pos_20 - 1));

         Initialize_Fields_For_Dotted_Name
           (Self => Transform_Res_20, Dotted_Name_F_Prefix => Defer_Res_28,
            Dotted_Name_F_Suffix => Defer_Res_29);

         if Defer_Res_28 /= null and then Is_Incomplete (Defer_Res_28) then
            Transform_Res_20.Last_Attempted_Child := 0;
         elsif Defer_Res_28 /= null and then not Is_Ghost (Defer_Res_28) then
            Transform_Res_20.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_29 /= null and then Is_Incomplete (Defer_Res_29) then
            Transform_Res_20.Last_Attempted_Child := 0;
         elsif Defer_Res_29 /= null and then not Is_Ghost (Defer_Res_29) then
            Transform_Res_20.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_5 then
            Transform_Res_20.Last_Attempted_Child := Row_Progress_5;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <name>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      if Row_Pos_20 /= No_Token_Index then
         Or_Pos_10 := Row_Pos_20;
         Or_Res_10 := Transform_Res_20;
         goto Exit_Or_9;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_21 := Pos;

      Defer_Res_30 := Name_Or_Parse_1 (Parser, Row_Pos_21);
      Defer_Pos_30 := Parser.Current_Pos;

      if Defer_Pos_30 /= No_Token_Index then

         Row_Pos_21 := Defer_Pos_30;

      else
         Row_Pos_21 := No_Token_Index;
         goto Exit_Row_52_0;

      end if;

--  Start tok_code

      Token_Res_20 := Row_Pos_21;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_20));
      begin
         if T.Kind /= From_Token_Kind (Ada_Tick) then
            Token_Pos_20 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_21 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_21,
                  Expected_Token_Id => Ada_Tick,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_20 := Row_Pos_21 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_20 /= No_Token_Index then

         Row_Pos_21 := Token_Pos_20;

      else
         Row_Pos_21 := No_Token_Index;
         goto Exit_Row_52_0;

      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_22 := Row_Pos_21;

--  Start tok_code

      Token_Res_21 := Row_Pos_22;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_21));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol (Parser.TDH.Symbols, Precomputed_Symbol_Update)
         then
            Token_Pos_21 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_22 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_22,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_21 := Row_Pos_22 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_21 /= No_Token_Index then

         Row_Pos_22 := Token_Pos_21;

      else
         Row_Pos_22 := No_Token_Index;
         goto Exit_Row_53_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_53_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_22 /= No_Token_Index then

         Transform_Res_21 := Allocate_Identifier (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_21, Kind => Ada_Identifier,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_21,
            Token_End_Index =>
              (if Row_Pos_22 = Row_Pos_21 then No_Token_Index
               else Row_Pos_22 - 1));

         Initialize_Fields_For_Identifier (Self => Transform_Res_21);

      end if;

--  End transform_code

      if Row_Pos_22 /= No_Token_Index then

         Row_Pos_21 := Row_Pos_22;

      else
         Row_Pos_21 := No_Token_Index;
         goto Exit_Row_52_0;

      end if;

      Defer_Res_31 := Update_Attr_Aggregate_Or_Parse_0 (Parser, Row_Pos_21);
      Defer_Pos_31 := Parser.Current_Pos;

      if Defer_Pos_31 /= No_Token_Index then

         Row_Pos_21 := Defer_Pos_31;

      else
         Row_Pos_21 := No_Token_Index;
         goto Exit_Row_52_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_52_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_21 /= No_Token_Index then

         Transform_Res_22 := Allocate_Update_Attribute_Ref (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_22, Kind => Ada_Update_Attribute_Ref,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_21 = Pos then No_Token_Index else Row_Pos_21 - 1));

         Initialize_Fields_For_Update_Attribute_Ref
           (Self => Transform_Res_22, Attribute_Ref_F_Prefix => Defer_Res_30,
            Attribute_Ref_F_Attribute => Transform_Res_21,
            Attribute_Ref_F_Args      => Defer_Res_31);

         if Defer_Res_30 /= null and then Is_Incomplete (Defer_Res_30) then
            Transform_Res_22.Last_Attempted_Child := 0;
         elsif Defer_Res_30 /= null and then not Is_Ghost (Defer_Res_30) then
            Transform_Res_22.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_21 /= null and then Is_Incomplete (Transform_Res_21)
         then
            Transform_Res_22.Last_Attempted_Child := 0;
         elsif Transform_Res_21 /= null
           and then not Is_Ghost (Transform_Res_21)
         then
            Transform_Res_22.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_31 /= null and then Is_Incomplete (Defer_Res_31) then
            Transform_Res_22.Last_Attempted_Child := 0;
         elsif Defer_Res_31 /= null and then not Is_Ghost (Defer_Res_31) then
            Transform_Res_22.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_21 /= No_Token_Index then
         Or_Pos_10 := Row_Pos_21;
         Or_Res_10 := Transform_Res_22;
         goto Exit_Or_9;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_23 := Pos;

      Defer_Res_32 := Name_Or_Parse_1 (Parser, Row_Pos_23);
      Defer_Pos_32 := Parser.Current_Pos;

      if Defer_Pos_32 /= No_Token_Index then

         Row_Pos_23 := Defer_Pos_32;

      else
         Row_Pos_23 := No_Token_Index;
         goto Exit_Row_62_0;

      end if;

--  Start tok_code

      Token_Res_22 := Row_Pos_23;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_22));
      begin
         if T.Kind /= From_Token_Kind (Ada_Tick) then
            Token_Pos_22 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_23 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_23,
                  Expected_Token_Id => Ada_Tick,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_22 := Row_Pos_23 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_22 /= No_Token_Index then

         Row_Pos_23 := Token_Pos_22;

      else
         Row_Pos_23 := No_Token_Index;
         goto Exit_Row_62_0;

      end if;

--  Start predicate_code

      Defer_Res_33 := Identifier_Transform_Parse_0 (Parser, Row_Pos_23);
      Defer_Pos_33 := Parser.Current_Pos;

      if Defer_Res_33 /= null
        and then Identifier_P_Is_Attr_With_Args (Defer_Res_33)
      then
         Predicate_Res_0 := Defer_Res_33;
         Predicate_Pos_0 := Defer_Pos_33;
      else
         Predicate_Pos_0 := No_Token_Index;
         Predicate_Res_0 := null;

         if Parser.Last_Fail.Pos <= Row_Pos_23 then
            Parser.Last_Fail :=
              (Kind           => Custom_Fail, Pos => Row_Pos_23,
               Custom_Message => Generic_Parsing_Error_Message_Access);
         end if;
      end if;

--  End predicate_code

      if Predicate_Pos_0 /= No_Token_Index then

         Row_Pos_23 := Predicate_Pos_0;

      else
         Row_Pos_23 := No_Token_Index;
         goto Exit_Row_62_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_24 := Row_Pos_23;

--  Start tok_code

      Token_Res_23 := Row_Pos_24;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_23));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Open) then
            Token_Pos_23 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_24 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_24,
                  Expected_Token_Id => Ada_Par_Open,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_23 := Row_Pos_24 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_23 /= No_Token_Index then

         Row_Pos_24 := Token_Pos_23;

      else
         Row_Pos_24 := No_Token_Index;
         goto Exit_Row_63_0;

      end if;

      Defer_Res_34 := Call_Suffix_Or_Parse_0 (Parser, Row_Pos_24);
      Defer_Pos_34 := Parser.Current_Pos;

      if Defer_Pos_34 /= No_Token_Index then

         Row_Pos_24 := Defer_Pos_34;

      else
         Row_Pos_24 := No_Token_Index;
         goto Exit_Row_63_0;

      end if;

--  Start tok_code

      Token_Res_24 := Row_Pos_24;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_24));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Close) then
            Token_Pos_24 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_24 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_24,
                  Expected_Token_Id => Ada_Par_Close,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_24 := Row_Pos_24 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_24 /= No_Token_Index then

         Row_Pos_24 := Token_Pos_24;

      else
         Row_Pos_24 := No_Token_Index;
         goto Exit_Row_63_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_63_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_24 = No_Token_Index then

         Defer_Res_34 := No_Bare_Ada_Node;

         Row_Pos_24 := Row_Pos_23;

      end if;

--  End opt_code

      if Row_Pos_24 /= No_Token_Index then

         Row_Pos_23 := Row_Pos_24;

      else
         Row_Pos_23 := No_Token_Index;
         goto Exit_Row_62_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_62_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_23 /= No_Token_Index then

         Transform_Res_23 := Allocate_Attribute_Ref (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_23, Kind => Ada_Attribute_Ref,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_23 = Pos then No_Token_Index else Row_Pos_23 - 1));

         Initialize_Fields_For_Attribute_Ref
           (Self => Transform_Res_23, Attribute_Ref_F_Prefix => Defer_Res_32,
            Attribute_Ref_F_Attribute => Predicate_Res_0,
            Attribute_Ref_F_Args      => Defer_Res_34);

         if Defer_Res_32 /= null and then Is_Incomplete (Defer_Res_32) then
            Transform_Res_23.Last_Attempted_Child := 0;
         elsif Defer_Res_32 /= null and then not Is_Ghost (Defer_Res_32) then
            Transform_Res_23.Last_Attempted_Child := -1;
         end if;
         if Predicate_Res_0 /= null and then Is_Incomplete (Predicate_Res_0)
         then
            Transform_Res_23.Last_Attempted_Child := 0;
         elsif Predicate_Res_0 /= null and then not Is_Ghost (Predicate_Res_0)
         then
            Transform_Res_23.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_34 /= null and then Is_Incomplete (Defer_Res_34) then
            Transform_Res_23.Last_Attempted_Child := 0;
         elsif Defer_Res_34 /= null and then not Is_Ghost (Defer_Res_34) then
            Transform_Res_23.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_23 /= No_Token_Index then
         Or_Pos_10 := Row_Pos_23;
         Or_Res_10 := Transform_Res_23;
         goto Exit_Or_9;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_25 := Pos;

      Defer_Res_35 := Name_Or_Parse_1 (Parser, Row_Pos_25);
      Defer_Pos_35 := Parser.Current_Pos;

      if Defer_Pos_35 /= No_Token_Index then

         Row_Pos_25 := Defer_Pos_35;

      else
         Row_Pos_25 := No_Token_Index;
         goto Exit_Row_64_0;

      end if;

--  Start tok_code

      Token_Res_25 := Row_Pos_25;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_25));
      begin
         if T.Kind /= From_Token_Kind (Ada_Tick) then
            Token_Pos_25 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_25 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_25,
                  Expected_Token_Id => Ada_Tick,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_25 := Row_Pos_25 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_25 /= No_Token_Index then

         Row_Pos_25 := Token_Pos_25;

      else
         Row_Pos_25 := No_Token_Index;
         goto Exit_Row_64_0;

      end if;

      Defer_Res_36 := Identifier_Transform_Parse_0 (Parser, Row_Pos_25);
      Defer_Pos_36 := Parser.Current_Pos;

      if Defer_Pos_36 /= No_Token_Index then

         Row_Pos_25 := Defer_Pos_36;

      else
         Row_Pos_25 := No_Token_Index;
         goto Exit_Row_64_0;

      end if;

      Null_Res_0 := No_Bare_Ada_Node;

      if Row_Pos_25 /= No_Token_Index then

         Row_Pos_25 := Row_Pos_25;

      else
         Row_Pos_25 := No_Token_Index;
         goto Exit_Row_64_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_64_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_25 /= No_Token_Index then

         Transform_Res_24 := Allocate_Attribute_Ref (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_24, Kind => Ada_Attribute_Ref,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_25 = Pos then No_Token_Index else Row_Pos_25 - 1));

         Initialize_Fields_For_Attribute_Ref
           (Self => Transform_Res_24, Attribute_Ref_F_Prefix => Defer_Res_35,
            Attribute_Ref_F_Attribute => Defer_Res_36,
            Attribute_Ref_F_Args      => Null_Res_0);

         if Defer_Res_35 /= null and then Is_Incomplete (Defer_Res_35) then
            Transform_Res_24.Last_Attempted_Child := 0;
         elsif Defer_Res_35 /= null and then not Is_Ghost (Defer_Res_35) then
            Transform_Res_24.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_36 /= null and then Is_Incomplete (Defer_Res_36) then
            Transform_Res_24.Last_Attempted_Child := 0;
         elsif Defer_Res_36 /= null and then not Is_Ghost (Defer_Res_36) then
            Transform_Res_24.Last_Attempted_Child := -1;
         end if;
         if Null_Res_0 /= null and then Is_Incomplete (Null_Res_0) then
            Transform_Res_24.Last_Attempted_Child := 0;
         elsif Null_Res_0 /= null and then not Is_Ghost (Null_Res_0) then
            Transform_Res_24.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_25 /= No_Token_Index then
         Or_Pos_10 := Row_Pos_25;
         Or_Res_10 := Transform_Res_24;
         goto Exit_Or_9;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_26 := Pos;

      Defer_Res_37 := Name_Or_Parse_1 (Parser, Row_Pos_26);
      Defer_Pos_37 := Parser.Current_Pos;

      if Defer_Pos_37 /= No_Token_Index then

         Row_Pos_26 := Defer_Pos_37;

      else
         Row_Pos_26 := No_Token_Index;
         goto Exit_Row_65_0;

      end if;

--  Start tok_code

      Token_Res_26 := Row_Pos_26;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_26));
      begin
         if T.Kind /= From_Token_Kind (Ada_Tick) then
            Token_Pos_26 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_26 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_26,
                  Expected_Token_Id => Ada_Tick,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_26 := Row_Pos_26 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_26 /= No_Token_Index then

         Row_Pos_26 := Token_Pos_26;

      else
         Row_Pos_26 := No_Token_Index;
         goto Exit_Row_65_0;

      end if;

--  Start or_code

      Or_Pos_9 := No_Token_Index;
      Or_Res_9 := No_Bare_Ada_Node;

      Defer_Res_38 := Paren_Expr_Transform_Parse_0 (Parser, Row_Pos_26);
      Defer_Pos_38 := Parser.Current_Pos;

      if Defer_Pos_38 /= No_Token_Index then
         Or_Pos_9 := Defer_Pos_38;
         Or_Res_9 := Defer_Res_38;
         goto Exit_Or_27;
      end if;

      Defer_Res_39 := Aggregate_Or_Parse_0 (Parser, Row_Pos_26);
      Defer_Pos_39 := Parser.Current_Pos;

      if Defer_Pos_39 /= No_Token_Index then
         Or_Pos_9 := Defer_Pos_39;
         Or_Res_9 := Defer_Res_39;
         goto Exit_Or_27;
      end if;
      <<Exit_Or_27>>

--  End or_code

      if Or_Pos_9 /= No_Token_Index then

         Row_Pos_26 := Or_Pos_9;

      else
         Row_Pos_26 := No_Token_Index;
         goto Exit_Row_65_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_65_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_26 /= No_Token_Index then

         Transform_Res_25 := Allocate_Qual_Expr (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_25, Kind => Ada_Qual_Expr,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_26 = Pos then No_Token_Index else Row_Pos_26 - 1));

         Initialize_Fields_For_Qual_Expr
           (Self => Transform_Res_25, Qual_Expr_F_Prefix => Defer_Res_37,
            Qual_Expr_F_Suffix => Or_Res_9);

         if Defer_Res_37 /= null and then Is_Incomplete (Defer_Res_37) then
            Transform_Res_25.Last_Attempted_Child := 0;
         elsif Defer_Res_37 /= null and then not Is_Ghost (Defer_Res_37) then
            Transform_Res_25.Last_Attempted_Child := -1;
         end if;
         if Or_Res_9 /= null and then Is_Incomplete (Or_Res_9) then
            Transform_Res_25.Last_Attempted_Child := 0;
         elsif Or_Res_9 /= null and then not Is_Ghost (Or_Res_9) then
            Transform_Res_25.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_26 /= No_Token_Index then
         Or_Pos_10 := Row_Pos_26;
         Or_Res_10 := Transform_Res_25;
         goto Exit_Or_9;
      end if;

      Defer_Res_40 := Direct_Name_Or_Target_Name_Or_Parse_0 (Parser, Pos);
      Defer_Pos_40 := Parser.Current_Pos;

      if Defer_Pos_40 /= No_Token_Index then
         Or_Pos_10 := Defer_Pos_40;
         Or_Res_10 := Defer_Res_40;
         goto Exit_Or_9;
      end if;
      <<Exit_Or_9>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      if Or_Pos_10 > Mem_Pos then
         Mem_Pos := Or_Pos_10;
         Mem_Res := Or_Res_10;
         Set
           (Parser.Private_Part.Name_Or_Parse_1_Memo,
            Or_Pos_10 /= No_Token_Index, Or_Res_10, Pos, Or_Pos_10);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res_10 := Mem_Res;
         Or_Pos_10 := Mem_Pos;
         goto No_Memo;
      end if;

      Set
        (Parser.Private_Part.Name_Or_Parse_1_Memo, Or_Pos_10 /= No_Token_Index,
         Or_Res_10, Pos, Or_Pos_10);

      <<No_Memo>>

      Parser.Current_Pos := Or_Pos_10;

      return Or_Res_10;
   end Name_Or_Parse_1;

   function Qual_Name_Internal_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Name
   is
      use Bare_Name_Memos;

      Row_Pos_73       : Token_Index        := No_Token_Index;
      Defer_Pos_104    : Token_Index        := No_Token_Index;
      Defer_Res_104    : Bare_Name          := No_Bare_Ada_Node;
      Token_Pos_82     : Token_Index        := No_Token_Index;
      Token_Res_82     : Token_Index        := No_Token_Index;
      Defer_Pos_105    : Token_Index        := No_Token_Index;
      Defer_Res_105    : Bare_Base_Id       := No_Bare_Ada_Node;
      Transform_Res_65 : Bare_Dotted_Name   := No_Bare_Ada_Node;
      Row_Pos_74       : Token_Index        := No_Token_Index;
      Defer_Pos_106    : Token_Index        := No_Token_Index;
      Defer_Res_106    : Bare_Name          := No_Bare_Ada_Node;
      Token_Pos_83     : Token_Index        := No_Token_Index;
      Token_Res_83     : Token_Index        := No_Token_Index;
      Defer_Pos_107    : Token_Index        := No_Token_Index;
      Defer_Res_107    : Bare_Identifier    := No_Bare_Ada_Node;
      Null_Res_3       : Bare_Ada_Node      := No_Bare_Ada_Node;
      Transform_Res_66 : Bare_Attribute_Ref := No_Bare_Ada_Node;
      Defer_Pos_108    : Token_Index        := No_Token_Index;
      Defer_Res_108    : Bare_Base_Id       := No_Bare_Ada_Node;
      Or_Pos_31        : Token_Index        := No_Token_Index;
      Or_Res_31        : Bare_Name          := No_Bare_Ada_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Name   := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Qual_Name_Internal_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_31          := M.Instance;
         return Or_Res_31;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_31;
      end if;

      Set
        (Parser.Private_Part.Qual_Name_Internal_Or_Parse_0_Memo, False,
         Or_Res_31, Pos, Mem_Pos);

      <<Try_Again>>

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_31 := No_Token_Index;
      Or_Res_31 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_73 := Pos;

      Defer_Res_104 := Qual_Name_Internal_Or_Parse_0 (Parser, Row_Pos_73);
      Defer_Pos_104 := Parser.Current_Pos;

      if Defer_Pos_104 /= No_Token_Index then

         Row_Pos_73 := Defer_Pos_104;

      else
         Row_Pos_73 := No_Token_Index;
         goto Exit_Row_71_0;

      end if;

--  Start tok_code

      Token_Res_82 := Row_Pos_73;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_82));
      begin
         if T.Kind /= From_Token_Kind (Ada_Dot) then
            Token_Pos_82 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_73 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_73,
                  Expected_Token_Id => Ada_Dot,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_82 := Row_Pos_73 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_82 /= No_Token_Index then

         Row_Pos_73 := Token_Pos_82;

      else
         Row_Pos_73 := No_Token_Index;
         goto Exit_Row_71_0;

      end if;

      Defer_Res_105 := Direct_Name_Or_Parse_0 (Parser, Row_Pos_73);
      Defer_Pos_105 := Parser.Current_Pos;

      if Defer_Pos_105 /= No_Token_Index then

         Row_Pos_73 := Defer_Pos_105;

      else
         Row_Pos_73 := No_Token_Index;
         goto Exit_Row_71_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_71_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_73 /= No_Token_Index then

         Transform_Res_65 := Allocate_Dotted_Name (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_65, Kind => Ada_Dotted_Name,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_73 = Pos then No_Token_Index else Row_Pos_73 - 1));

         Initialize_Fields_For_Dotted_Name
           (Self => Transform_Res_65, Dotted_Name_F_Prefix => Defer_Res_104,
            Dotted_Name_F_Suffix => Defer_Res_105);

         if Defer_Res_104 /= null and then Is_Incomplete (Defer_Res_104) then
            Transform_Res_65.Last_Attempted_Child := 0;
         elsif Defer_Res_104 /= null and then not Is_Ghost (Defer_Res_104) then
            Transform_Res_65.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_105 /= null and then Is_Incomplete (Defer_Res_105) then
            Transform_Res_65.Last_Attempted_Child := 0;
         elsif Defer_Res_105 /= null and then not Is_Ghost (Defer_Res_105) then
            Transform_Res_65.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_73 /= No_Token_Index then
         Or_Pos_31 := Row_Pos_73;
         Or_Res_31 := Transform_Res_65;
         goto Exit_Or_30;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_74 := Pos;

      Defer_Res_106 := Qual_Name_Internal_Or_Parse_0 (Parser, Row_Pos_74);
      Defer_Pos_106 := Parser.Current_Pos;

      if Defer_Pos_106 /= No_Token_Index then

         Row_Pos_74 := Defer_Pos_106;

      else
         Row_Pos_74 := No_Token_Index;
         goto Exit_Row_72_0;

      end if;

--  Start tok_code

      Token_Res_83 := Row_Pos_74;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_83));
      begin
         if T.Kind /= From_Token_Kind (Ada_Tick) then
            Token_Pos_83 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_74 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_74,
                  Expected_Token_Id => Ada_Tick,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_83 := Row_Pos_74 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_83 /= No_Token_Index then

         Row_Pos_74 := Token_Pos_83;

      else
         Row_Pos_74 := No_Token_Index;
         goto Exit_Row_72_0;

      end if;

      Defer_Res_107 := Identifier_Transform_Parse_0 (Parser, Row_Pos_74);
      Defer_Pos_107 := Parser.Current_Pos;

      if Defer_Pos_107 /= No_Token_Index then

         Row_Pos_74 := Defer_Pos_107;

      else
         Row_Pos_74 := No_Token_Index;
         goto Exit_Row_72_0;

      end if;

      Null_Res_3 := No_Bare_Ada_Node;

      if Row_Pos_74 /= No_Token_Index then

         Row_Pos_74 := Row_Pos_74;

      else
         Row_Pos_74 := No_Token_Index;
         goto Exit_Row_72_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_72_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_74 /= No_Token_Index then

         Transform_Res_66 := Allocate_Attribute_Ref (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_66, Kind => Ada_Attribute_Ref,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_74 = Pos then No_Token_Index else Row_Pos_74 - 1));

         Initialize_Fields_For_Attribute_Ref
           (Self => Transform_Res_66, Attribute_Ref_F_Prefix => Defer_Res_106,
            Attribute_Ref_F_Attribute => Defer_Res_107,
            Attribute_Ref_F_Args      => Null_Res_3);

         if Defer_Res_106 /= null and then Is_Incomplete (Defer_Res_106) then
            Transform_Res_66.Last_Attempted_Child := 0;
         elsif Defer_Res_106 /= null and then not Is_Ghost (Defer_Res_106) then
            Transform_Res_66.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_107 /= null and then Is_Incomplete (Defer_Res_107) then
            Transform_Res_66.Last_Attempted_Child := 0;
         elsif Defer_Res_107 /= null and then not Is_Ghost (Defer_Res_107) then
            Transform_Res_66.Last_Attempted_Child := -1;
         end if;
         if Null_Res_3 /= null and then Is_Incomplete (Null_Res_3) then
            Transform_Res_66.Last_Attempted_Child := 0;
         elsif Null_Res_3 /= null and then not Is_Ghost (Null_Res_3) then
            Transform_Res_66.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_74 /= No_Token_Index then
         Or_Pos_31 := Row_Pos_74;
         Or_Res_31 := Transform_Res_66;
         goto Exit_Or_30;
      end if;

      Defer_Res_108 := Direct_Name_Or_Parse_0 (Parser, Pos);
      Defer_Pos_108 := Parser.Current_Pos;

      if Defer_Pos_108 /= No_Token_Index then
         Or_Pos_31 := Defer_Pos_108;
         Or_Res_31 := Defer_Res_108;
         goto Exit_Or_30;
      end if;
      <<Exit_Or_30>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      if Or_Pos_31 > Mem_Pos then
         Mem_Pos := Or_Pos_31;
         Mem_Res := Or_Res_31;
         Set
           (Parser.Private_Part.Qual_Name_Internal_Or_Parse_0_Memo,
            Or_Pos_31 /= No_Token_Index, Or_Res_31, Pos, Or_Pos_31);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res_31 := Mem_Res;
         Or_Pos_31 := Mem_Pos;
         goto No_Memo;
      end if;

      Set
        (Parser.Private_Part.Qual_Name_Internal_Or_Parse_0_Memo,
         Or_Pos_31 /= No_Token_Index, Or_Res_31, Pos, Or_Pos_31);

      <<No_Memo>>

      Parser.Current_Pos := Or_Pos_31;

      return Or_Res_31;
   end Qual_Name_Internal_Or_Parse_0;

   function Qualified_Name_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Qual_Expr
   is
      use Bare_Qual_Expr_Memos;

      Row_Pos_72       : Token_Index         := No_Token_Index;
      Defer_Pos_101    : Token_Index         := No_Token_Index;
      Defer_Res_101    : Bare_Name           := No_Bare_Ada_Node;
      Token_Pos_81     : Token_Index         := No_Token_Index;
      Token_Res_81     : Token_Index         := No_Token_Index;
      Defer_Pos_102    : Token_Index         := No_Token_Index;
      Defer_Res_102    : Bare_Paren_Expr     := No_Bare_Ada_Node;
      Defer_Pos_103    : Token_Index         := No_Token_Index;
      Defer_Res_103    : Bare_Base_Aggregate := No_Bare_Ada_Node;
      Or_Pos_30        : Token_Index         := No_Token_Index;
      Or_Res_30        : Bare_Expr           := No_Bare_Ada_Node;
      Transform_Res_64 : Bare_Qual_Expr      := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Qualified_Name_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_64   := M.Instance;
         return Transform_Res_64;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_64;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_72 := Pos;

      Defer_Res_101 := Qual_Name_Internal_Or_Parse_0 (Parser, Row_Pos_72);
      Defer_Pos_101 := Parser.Current_Pos;

      if Defer_Pos_101 /= No_Token_Index then

         Row_Pos_72 := Defer_Pos_101;

      else
         Row_Pos_72 := No_Token_Index;
         goto Exit_Row_70_0;

      end if;

--  Start tok_code

      Token_Res_81 := Row_Pos_72;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_81));
      begin
         if T.Kind /= From_Token_Kind (Ada_Tick) then
            Token_Pos_81 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_72 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_72,
                  Expected_Token_Id => Ada_Tick,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_81 := Row_Pos_72 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_81 /= No_Token_Index then

         Row_Pos_72 := Token_Pos_81;

      else
         Row_Pos_72 := No_Token_Index;
         goto Exit_Row_70_0;

      end if;

--  Start or_code

      Or_Pos_30 := No_Token_Index;
      Or_Res_30 := No_Bare_Ada_Node;

      Defer_Res_102 := Paren_Expr_Transform_Parse_0 (Parser, Row_Pos_72);
      Defer_Pos_102 := Parser.Current_Pos;

      if Defer_Pos_102 /= No_Token_Index then
         Or_Pos_30 := Defer_Pos_102;
         Or_Res_30 := Defer_Res_102;
         goto Exit_Or_31;
      end if;

      Defer_Res_103 := Aggregate_Or_Parse_0 (Parser, Row_Pos_72);
      Defer_Pos_103 := Parser.Current_Pos;

      if Defer_Pos_103 /= No_Token_Index then
         Or_Pos_30 := Defer_Pos_103;
         Or_Res_30 := Defer_Res_103;
         goto Exit_Or_31;
      end if;
      <<Exit_Or_31>>

--  End or_code

      if Or_Pos_30 /= No_Token_Index then

         Row_Pos_72 := Or_Pos_30;

      else
         Row_Pos_72 := No_Token_Index;
         goto Exit_Row_70_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_70_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_72 /= No_Token_Index then

         Transform_Res_64 := Allocate_Qual_Expr (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_64, Kind => Ada_Qual_Expr,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_72 = Pos then No_Token_Index else Row_Pos_72 - 1));

         Initialize_Fields_For_Qual_Expr
           (Self => Transform_Res_64, Qual_Expr_F_Prefix => Defer_Res_101,
            Qual_Expr_F_Suffix => Or_Res_30);

         if Defer_Res_101 /= null and then Is_Incomplete (Defer_Res_101) then
            Transform_Res_64.Last_Attempted_Child := 0;
         elsif Defer_Res_101 /= null and then not Is_Ghost (Defer_Res_101) then
            Transform_Res_64.Last_Attempted_Child := -1;
         end if;
         if Or_Res_30 /= null and then Is_Incomplete (Or_Res_30) then
            Transform_Res_64.Last_Attempted_Child := 0;
         elsif Or_Res_30 /= null and then not Is_Ghost (Or_Res_30) then
            Transform_Res_64.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Qualified_Name_Transform_Parse_0_Memo,
         Row_Pos_72 /= No_Token_Index, Transform_Res_64, Pos, Row_Pos_72);

      Parser.Current_Pos := Row_Pos_72;

      return Transform_Res_64;
   end Qualified_Name_Transform_Parse_0;

   function Range_Spec_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Range_Spec
   is
      use Bare_Range_Spec_Memos;

      Row_Pos_78       : Token_Index     := No_Token_Index;
      Token_Pos_87     : Token_Index     := No_Token_Index;
      Token_Res_87     : Token_Index     := No_Token_Index;
      Defer_Pos_118    : Token_Index     := No_Token_Index;
      Defer_Res_118    : Bare_Expr       := No_Bare_Ada_Node;
      Defer_Pos_119    : Token_Index     := No_Token_Index;
      Defer_Res_119    : Bare_Name       := No_Bare_Ada_Node;
      Defer_Pos_120    : Token_Index     := No_Token_Index;
      Defer_Res_120    : Bare_Box_Expr   := No_Bare_Ada_Node;
      Or_Pos_33        : Token_Index     := No_Token_Index;
      Or_Res_33        : Bare_Expr       := No_Bare_Ada_Node;
      Transform_Res_69 : Bare_Range_Spec := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Range_Spec_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_69   := M.Instance;
         return Transform_Res_69;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_69;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_78 := Pos;

--  Start tok_code

      Token_Res_87 := Row_Pos_78;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_87));
      begin
         if T.Kind /= From_Token_Kind (Ada_Range) then
            Token_Pos_87 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_78 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_78,
                  Expected_Token_Id => Ada_Range,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_87 := Row_Pos_78 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_87 /= No_Token_Index then

         Row_Pos_78 := Token_Pos_87;

      else
         Row_Pos_78 := No_Token_Index;
         goto Exit_Row_76_0;

      end if;

--  Start or_code

      Or_Pos_33 := No_Token_Index;
      Or_Res_33 := No_Bare_Ada_Node;

      Defer_Res_118 := Discrete_Range_Or_Parse_0 (Parser, Row_Pos_78);
      Defer_Pos_118 := Parser.Current_Pos;

      if Defer_Pos_118 /= No_Token_Index then
         Or_Pos_33 := Defer_Pos_118;
         Or_Res_33 := Defer_Res_118;
         goto Exit_Or_33;
      end if;

      Defer_Res_119 := Name_Or_Parse_1 (Parser, Row_Pos_78);
      Defer_Pos_119 := Parser.Current_Pos;

      if Defer_Pos_119 /= No_Token_Index then
         Or_Pos_33 := Defer_Pos_119;
         Or_Res_33 := Defer_Res_119;
         goto Exit_Or_33;
      end if;

      Defer_Res_120 := Box_Expr_Transform_Parse_0 (Parser, Row_Pos_78);
      Defer_Pos_120 := Parser.Current_Pos;

      if Defer_Pos_120 /= No_Token_Index then
         Or_Pos_33 := Defer_Pos_120;
         Or_Res_33 := Defer_Res_120;
         goto Exit_Or_33;
      end if;
      <<Exit_Or_33>>

--  End or_code

      if Or_Pos_33 /= No_Token_Index then

         Row_Pos_78 := Or_Pos_33;

      else
         Row_Pos_78 := No_Token_Index;
         goto Exit_Row_76_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_76_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_78 /= No_Token_Index then

         Transform_Res_69 := Allocate_Range_Spec (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_69, Kind => Ada_Range_Spec,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_78 = Pos then No_Token_Index else Row_Pos_78 - 1));

         Initialize_Fields_For_Range_Spec
           (Self => Transform_Res_69, Range_Spec_F_Range => Or_Res_33);

         if Or_Res_33 /= null and then Is_Incomplete (Or_Res_33) then
            Transform_Res_69.Last_Attempted_Child := 0;
         elsif Or_Res_33 /= null and then not Is_Ghost (Or_Res_33) then
            Transform_Res_69.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Range_Spec_Transform_Parse_0_Memo,
         Row_Pos_78 /= No_Token_Index, Transform_Res_69, Pos, Row_Pos_78);

      Parser.Current_Pos := Row_Pos_78;

      return Transform_Res_69;
   end Range_Spec_Transform_Parse_0;

   function Digits_Constraint_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Digits_Constraint
   is
      use Bare_Digits_Constraint_Memos;

      Row_Pos_77       : Token_Index            := No_Token_Index;
      Token_Pos_86     : Token_Index            := No_Token_Index;
      Token_Res_86     : Token_Index            := No_Token_Index;
      Defer_Pos_116    : Token_Index            := No_Token_Index;
      Defer_Res_116    : Bare_Expr              := No_Bare_Ada_Node;
      Defer_Pos_117    : Token_Index            := No_Token_Index;
      Defer_Res_117    : Bare_Range_Spec        := No_Bare_Ada_Node;
      Transform_Res_68 : Bare_Digits_Constraint := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Digits_Constraint_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_68   := M.Instance;
         return Transform_Res_68;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_68;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_77 := Pos;

--  Start tok_code

      Token_Res_86 := Row_Pos_77;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_86));
      begin
         if T.Kind /= From_Token_Kind (Ada_Digits) then
            Token_Pos_86 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_77 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_77,
                  Expected_Token_Id => Ada_Digits,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_86 := Row_Pos_77 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_86 /= No_Token_Index then

         Row_Pos_77 := Token_Pos_86;

      else
         Row_Pos_77 := No_Token_Index;
         goto Exit_Row_75_0;

      end if;

      Defer_Res_116 := Simple_Expr_Or_Parse_1 (Parser, Row_Pos_77);
      Defer_Pos_116 := Parser.Current_Pos;

      if Defer_Pos_116 /= No_Token_Index then

         Row_Pos_77 := Defer_Pos_116;

      else
         Row_Pos_77 := No_Token_Index;
         goto Exit_Row_75_0;

      end if;

--  Start opt_code

      Defer_Res_117 := Range_Spec_Transform_Parse_0 (Parser, Row_Pos_77);
      Defer_Pos_117 := Parser.Current_Pos;

      if Defer_Pos_117 = No_Token_Index then

         Defer_Res_117 := No_Bare_Ada_Node;

         Defer_Pos_117 := Row_Pos_77;

      end if;

--  End opt_code

      if Defer_Pos_117 /= No_Token_Index then

         Row_Pos_77 := Defer_Pos_117;

      else
         Row_Pos_77 := No_Token_Index;
         goto Exit_Row_75_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_75_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_77 /= No_Token_Index then

         Transform_Res_68 := Allocate_Digits_Constraint (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_68, Kind => Ada_Digits_Constraint,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_77 = Pos then No_Token_Index else Row_Pos_77 - 1));

         Initialize_Fields_For_Digits_Constraint
           (Self                       => Transform_Res_68,
            Digits_Constraint_F_Digits => Defer_Res_116,
            Digits_Constraint_F_Range  => Defer_Res_117);

         if Defer_Res_116 /= null and then Is_Incomplete (Defer_Res_116) then
            Transform_Res_68.Last_Attempted_Child := 0;
         elsif Defer_Res_116 /= null and then not Is_Ghost (Defer_Res_116) then
            Transform_Res_68.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_117 /= null and then Is_Incomplete (Defer_Res_117) then
            Transform_Res_68.Last_Attempted_Child := 0;
         elsif Defer_Res_117 /= null and then not Is_Ghost (Defer_Res_117) then
            Transform_Res_68.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Digits_Constraint_Transform_Parse_0_Memo,
         Row_Pos_77 /= No_Token_Index, Transform_Res_68, Pos, Row_Pos_77);

      Parser.Current_Pos := Row_Pos_77;

      return Transform_Res_68;
   end Digits_Constraint_Transform_Parse_0;

   function Delta_Constraint_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Delta_Constraint
   is
      use Bare_Delta_Constraint_Memos;

      Row_Pos_79       : Token_Index           := No_Token_Index;
      Token_Pos_88     : Token_Index           := No_Token_Index;
      Token_Res_88     : Token_Index           := No_Token_Index;
      Defer_Pos_121    : Token_Index           := No_Token_Index;
      Defer_Res_121    : Bare_Expr             := No_Bare_Ada_Node;
      Defer_Pos_122    : Token_Index           := No_Token_Index;
      Defer_Res_122    : Bare_Range_Spec       := No_Bare_Ada_Node;
      Transform_Res_70 : Bare_Delta_Constraint := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Delta_Constraint_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_70   := M.Instance;
         return Transform_Res_70;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_70;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_79 := Pos;

--  Start tok_code

      Token_Res_88 := Row_Pos_79;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_88));
      begin
         if T.Kind /= From_Token_Kind (Ada_Delta) then
            Token_Pos_88 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_79 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_79,
                  Expected_Token_Id => Ada_Delta,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_88 := Row_Pos_79 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_88 /= No_Token_Index then

         Row_Pos_79 := Token_Pos_88;

      else
         Row_Pos_79 := No_Token_Index;
         goto Exit_Row_77_0;

      end if;

      Defer_Res_121 := Simple_Expr_Or_Parse_1 (Parser, Row_Pos_79);
      Defer_Pos_121 := Parser.Current_Pos;

      if Defer_Pos_121 /= No_Token_Index then

         Row_Pos_79 := Defer_Pos_121;

      else
         Row_Pos_79 := No_Token_Index;
         goto Exit_Row_77_0;

      end if;

--  Start opt_code

      Defer_Res_122 := Range_Spec_Transform_Parse_0 (Parser, Row_Pos_79);
      Defer_Pos_122 := Parser.Current_Pos;

      if Defer_Pos_122 = No_Token_Index then

         Defer_Res_122 := No_Bare_Ada_Node;

         Defer_Pos_122 := Row_Pos_79;

      end if;

--  End opt_code

      if Defer_Pos_122 /= No_Token_Index then

         Row_Pos_79 := Defer_Pos_122;

      else
         Row_Pos_79 := No_Token_Index;
         goto Exit_Row_77_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_77_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_79 /= No_Token_Index then

         Transform_Res_70 := Allocate_Delta_Constraint (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_70, Kind => Ada_Delta_Constraint,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_79 = Pos then No_Token_Index else Row_Pos_79 - 1));

         Initialize_Fields_For_Delta_Constraint
           (Self                      => Transform_Res_70,
            Delta_Constraint_F_Digits => Defer_Res_121,
            Delta_Constraint_F_Range  => Defer_Res_122);

         if Defer_Res_121 /= null and then Is_Incomplete (Defer_Res_121) then
            Transform_Res_70.Last_Attempted_Child := 0;
         elsif Defer_Res_121 /= null and then not Is_Ghost (Defer_Res_121) then
            Transform_Res_70.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_122 /= null and then Is_Incomplete (Defer_Res_122) then
            Transform_Res_70.Last_Attempted_Child := 0;
         elsif Defer_Res_122 /= null and then not Is_Ghost (Defer_Res_122) then
            Transform_Res_70.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Delta_Constraint_Transform_Parse_0_Memo,
         Row_Pos_79 /= No_Token_Index, Transform_Res_70, Pos, Row_Pos_79);

      Parser.Current_Pos := Row_Pos_79;

      return Transform_Res_70;
   end Delta_Constraint_Transform_Parse_0;

   function Discriminant_Assoc_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Discriminant_Assoc
   is
      use Bare_Discriminant_Assoc_Memos;

      Row_Pos_81       : Token_Index                   := No_Token_Index;
      Row_Pos_82       : Token_Index                   := No_Token_Index;
      Lst_Cpos_7       : Token_Index                   := No_Token_Index;
      Tmp_List_7       : Free_Parse_List;
      Defer_Pos_124    : Token_Index                   := No_Token_Index;
      Defer_Res_124    : Bare_Identifier               := No_Bare_Ada_Node;
      Token_Pos_92     : Token_Index                   := No_Token_Index;
      Token_Res_92     : Token_Index                   := No_Token_Index;
      List_Pos_7       : Token_Index                   := No_Token_Index;
      List_Res_7       : Bare_Discriminant_Choice_List := No_Bare_Ada_Node;
      Token_Pos_93     : Token_Index                   := No_Token_Index;
      Token_Res_93     : Token_Index                   := No_Token_Index;
      Defer_Pos_125    : Token_Index                   := No_Token_Index;
      Defer_Res_125    : Bare_Expr                     := No_Bare_Ada_Node;
      Transform_Res_72 : Bare_Discriminant_Assoc       := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Discriminant_Assoc_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_72   := M.Instance;
         return Transform_Res_72;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_72;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_81 := Pos;

--  Start opt_code

--  Start row_code

      Row_Pos_82 := Row_Pos_81;

--  Start list_code

      List_Pos_7 := No_Token_Index;

      Lst_Cpos_7 := Row_Pos_82;
      Tmp_List_7 := Get_Parse_List (Parser);

      loop

         Defer_Res_124 := Identifier_Transform_Parse_0 (Parser, Lst_Cpos_7);
         Defer_Pos_124 := Parser.Current_Pos;

         exit when Defer_Pos_124 = No_Token_Index;

         List_Pos_7 := Defer_Pos_124;
         Lst_Cpos_7 := List_Pos_7;

         Tmp_List_7.Nodes.Append (Defer_Res_124);

--  Start tok_code

         Token_Res_92 := Lst_Cpos_7;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_92));
         begin
            if T.Kind /= From_Token_Kind (Ada_Pipe) then
               Token_Pos_92 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_7 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_7,
                     Expected_Token_Id => Ada_Pipe,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_92 := Lst_Cpos_7 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_92 /= No_Token_Index then
            Lst_Cpos_7 := Token_Pos_92;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_7.Nodes.Length;
      begin
         List_Res_7 := Allocate_Discriminant_Choice_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_82;
            Token_End   :=
              (if Lst_Cpos_7 = Row_Pos_82 then Row_Pos_82 else Lst_Cpos_7 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_82, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self => List_Res_7, Kind => Ada_Discriminant_Choice_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_7, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_7.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_7.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_7);

--  End list_code

      if List_Pos_7 /= No_Token_Index then

         Row_Pos_82 := List_Pos_7;

      else
         Row_Pos_82 := No_Token_Index;
         goto Exit_Row_80_0;

      end if;

--  Start tok_code

      Token_Res_93 := Row_Pos_82;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_93));
      begin
         if T.Kind /= From_Token_Kind (Ada_Arrow) then
            Token_Pos_93 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_82 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_82,
                  Expected_Token_Id => Ada_Arrow,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_93 := Row_Pos_82 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_93 /= No_Token_Index then

         Row_Pos_82 := Token_Pos_93;

      else
         Row_Pos_82 := No_Token_Index;
         goto Exit_Row_80_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_80_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_82 = No_Token_Index then

         List_Res_7 := Allocate_Discriminant_Choice_List (Parser.Mem_Pool);
         Initialize
           (Self => List_Res_7, Kind => Ada_Discriminant_Choice_List,
            Unit => Parser.Unit, Token_Start_Index => Row_Pos_81 - 1,
            Token_End_Index => No_Token_Index);
         Initialize_List (Self => List_Res_7, Parser => Parser, Count => 0);

         Row_Pos_82 := Row_Pos_81;

      end if;

--  End opt_code

      if Row_Pos_82 /= No_Token_Index then

         Row_Pos_81 := Row_Pos_82;

      else
         Row_Pos_81 := No_Token_Index;
         goto Exit_Row_79_0;

      end if;

      Defer_Res_125 := Expr_Or_Parse_0 (Parser, Row_Pos_81);
      Defer_Pos_125 := Parser.Current_Pos;

      if Defer_Pos_125 /= No_Token_Index then

         Row_Pos_81 := Defer_Pos_125;

      else
         Row_Pos_81 := No_Token_Index;
         goto Exit_Row_79_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_79_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_81 /= No_Token_Index then

         Transform_Res_72 := Allocate_Discriminant_Assoc (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_72, Kind => Ada_Discriminant_Assoc,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_81 = Pos then No_Token_Index else Row_Pos_81 - 1));

         Initialize_Fields_For_Discriminant_Assoc
           (Self => Transform_Res_72, Discriminant_Assoc_F_Ids => List_Res_7,
            Discriminant_Assoc_F_Discr_Expr => Defer_Res_125);

         if List_Res_7 /= null and then Is_Incomplete (List_Res_7) then
            Transform_Res_72.Last_Attempted_Child := 0;
         elsif List_Res_7 /= null and then not Is_Ghost (List_Res_7) then
            Transform_Res_72.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_125 /= null and then Is_Incomplete (Defer_Res_125) then
            Transform_Res_72.Last_Attempted_Child := 0;
         elsif Defer_Res_125 /= null and then not Is_Ghost (Defer_Res_125) then
            Transform_Res_72.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Discriminant_Assoc_Transform_Parse_0_Memo,
         Row_Pos_81 /= No_Token_Index, Transform_Res_72, Pos, Row_Pos_81);

      Parser.Current_Pos := Row_Pos_81;

      return Transform_Res_72;
   end Discriminant_Assoc_Transform_Parse_0;

   function Discriminant_Constraint_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Discriminant_Constraint
   is
      use Bare_Discriminant_Constraint_Memos;

      Row_Pos_80       : Token_Index                  := No_Token_Index;
      Token_Pos_89     : Token_Index                  := No_Token_Index;
      Token_Res_89     : Token_Index                  := No_Token_Index;
      Lst_Cpos_6       : Token_Index                  := No_Token_Index;
      Tmp_List_6       : Free_Parse_List;
      Defer_Pos_123    : Token_Index                  := No_Token_Index;
      Defer_Res_123    : Bare_Discriminant_Assoc      := No_Bare_Ada_Node;
      Token_Pos_90     : Token_Index                  := No_Token_Index;
      Token_Res_90     : Token_Index                  := No_Token_Index;
      List_Pos_6       : Token_Index                  := No_Token_Index;
      List_Res_6       : Bare_Assoc_List              := No_Bare_Ada_Node;
      Token_Pos_91     : Token_Index                  := No_Token_Index;
      Token_Res_91     : Token_Index                  := No_Token_Index;
      Transform_Res_71 : Bare_Discriminant_Constraint := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Discriminant_Constraint_Transform_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_71   := M.Instance;
         return Transform_Res_71;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_71;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_80 := Pos;

--  Start tok_code

      Token_Res_89 := Row_Pos_80;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_89));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Open) then
            Token_Pos_89 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_80 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_80,
                  Expected_Token_Id => Ada_Par_Open,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_89 := Row_Pos_80 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_89 /= No_Token_Index then

         Row_Pos_80 := Token_Pos_89;

      else
         Row_Pos_80 := No_Token_Index;
         goto Exit_Row_78_0;

      end if;

--  Start list_code

      List_Pos_6 := No_Token_Index;

      Lst_Cpos_6 := Row_Pos_80;
      Tmp_List_6 := Get_Parse_List (Parser);

      loop

         Defer_Res_123 :=
           Discriminant_Assoc_Transform_Parse_0 (Parser, Lst_Cpos_6);
         Defer_Pos_123 := Parser.Current_Pos;

         exit when Defer_Pos_123 = No_Token_Index;

         List_Pos_6 := Defer_Pos_123;
         Lst_Cpos_6 := List_Pos_6;

         Tmp_List_6.Nodes.Append (Defer_Res_123);

--  Start tok_code

         Token_Res_90 := Lst_Cpos_6;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_90));
         begin
            if T.Kind /= From_Token_Kind (Ada_Comma) then
               Token_Pos_90 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_6 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_6,
                     Expected_Token_Id => Ada_Comma,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_90 := Lst_Cpos_6 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_90 /= No_Token_Index then
            Lst_Cpos_6 := Token_Pos_90;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_6.Nodes.Length;
      begin
         List_Res_6 := Allocate_Assoc_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_80;
            Token_End   :=
              (if Lst_Cpos_6 = Row_Pos_80 then Row_Pos_80 else Lst_Cpos_6 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_80, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self => List_Res_6, Kind => Ada_Assoc_List, Unit => Parser.Unit,
            Token_Start_Index => Token_Start, Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_6, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_6.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_6.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_6);

--  End list_code

      if List_Pos_6 /= No_Token_Index then

         Row_Pos_80 := List_Pos_6;

      else
         Row_Pos_80 := No_Token_Index;
         goto Exit_Row_78_0;

      end if;

--  Start tok_code

      Token_Res_91 := Row_Pos_80;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_91));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Close) then
            Token_Pos_91 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_80 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_80,
                  Expected_Token_Id => Ada_Par_Close,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_91 := Row_Pos_80 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_91 /= No_Token_Index then

         Row_Pos_80 := Token_Pos_91;

      else
         Row_Pos_80 := No_Token_Index;
         goto Exit_Row_78_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_78_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_80 /= No_Token_Index then

         Transform_Res_71 :=
           Allocate_Discriminant_Constraint (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_71, Kind => Ada_Discriminant_Constraint,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_80 = Pos then No_Token_Index else Row_Pos_80 - 1));

         Initialize_Fields_For_Discriminant_Constraint
           (Self                                  => Transform_Res_71,
            Discriminant_Constraint_F_Constraints => List_Res_6);

         if List_Res_6 /= null and then Is_Incomplete (List_Res_6) then
            Transform_Res_71.Last_Attempted_Child := 0;
         elsif List_Res_6 /= null and then not Is_Ghost (List_Res_6) then
            Transform_Res_71.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Discriminant_Constraint_Transform_Parse_0_Memo,
         Row_Pos_80 /= No_Token_Index, Transform_Res_71, Pos, Row_Pos_80);

      Parser.Current_Pos := Row_Pos_80;

      return Transform_Res_71;
   end Discriminant_Constraint_Transform_Parse_0;

   function Discrete_Subtype_Definition_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Defer_Pos_128 : Token_Index             := No_Token_Index;
      Defer_Res_128 : Bare_Expr               := No_Bare_Ada_Node;
      Defer_Pos_129 : Token_Index             := No_Token_Index;
      Defer_Res_129 : Bare_Subtype_Indication := No_Bare_Ada_Node;
      Or_Pos_34     : Token_Index             := No_Token_Index;
      Or_Res_34     : Bare_Ada_Node           := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Discrete_Subtype_Definition_Or_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_34          := M.Instance;
         return Or_Res_34;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_34;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_34 := No_Token_Index;
      Or_Res_34 := No_Bare_Ada_Node;

      Defer_Res_128 := Discrete_Range_Or_Parse_0 (Parser, Pos);
      Defer_Pos_128 := Parser.Current_Pos;

      if Defer_Pos_128 /= No_Token_Index then
         Or_Pos_34 := Defer_Pos_128;
         Or_Res_34 := Defer_Res_128;
         goto Exit_Or_34;
      end if;

      Defer_Res_129 := Subtype_Indication_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_129 := Parser.Current_Pos;

      if Defer_Pos_129 /= No_Token_Index then
         Or_Pos_34 := Defer_Pos_129;
         Or_Res_34 := Defer_Res_129;
         goto Exit_Or_34;
      end if;
      <<Exit_Or_34>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Discrete_Subtype_Definition_Or_Parse_0_Memo,
         Or_Pos_34 /= No_Token_Index, Or_Res_34, Pos, Or_Pos_34);

      Parser.Current_Pos := Or_Pos_34;

      return Or_Res_34;
   end Discrete_Subtype_Definition_Or_Parse_0;

   function Constraint_List_List_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Constraint_List
   is
      use Bare_Constraint_List_Memos;

      Lst_Cpos_8    : Token_Index          := No_Token_Index;
      Tmp_List_8    : Free_Parse_List;
      Defer_Pos_127 : Token_Index          := No_Token_Index;
      Defer_Res_127 : Bare_Ada_Node        := No_Bare_Ada_Node;
      Token_Pos_96  : Token_Index          := No_Token_Index;
      Token_Res_96  : Token_Index          := No_Token_Index;
      List_Pos_8    : Token_Index          := No_Token_Index;
      List_Res_8    : Bare_Constraint_List := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Constraint_List_List_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         List_Res_8         := M.Instance;
         return List_Res_8;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return List_Res_8;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start list_code

      List_Pos_8 := No_Token_Index;

      Lst_Cpos_8 := Pos;
      Tmp_List_8 := Get_Parse_List (Parser);

      loop

         Defer_Res_127 :=
           Discrete_Subtype_Definition_Or_Parse_0 (Parser, Lst_Cpos_8);
         Defer_Pos_127 := Parser.Current_Pos;

         exit when Defer_Pos_127 = No_Token_Index;

         List_Pos_8 := Defer_Pos_127;
         Lst_Cpos_8 := List_Pos_8;

         Tmp_List_8.Nodes.Append (Defer_Res_127);

--  Start tok_code

         Token_Res_96 := Lst_Cpos_8;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_96));
         begin
            if T.Kind /= From_Token_Kind (Ada_Comma) then
               Token_Pos_96 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_8 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_8,
                     Expected_Token_Id => Ada_Comma,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_96 := Lst_Cpos_8 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_96 /= No_Token_Index then
            Lst_Cpos_8 := Token_Pos_96;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_8.Nodes.Length;
      begin
         List_Res_8 := Allocate_Constraint_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Pos;
            Token_End   := (if Lst_Cpos_8 = Pos then Pos else Lst_Cpos_8 - 1);

         else
            Token_Start := Token_Index'Max (Pos, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self            => List_Res_8, Kind => Ada_Constraint_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_8, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_8.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_8.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_8);

--  End list_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Constraint_List_List_Parse_0_Memo,
         List_Pos_8 /= No_Token_Index, List_Res_8, Pos, List_Pos_8);

      Parser.Current_Pos := List_Pos_8;

      return List_Res_8;
   end Constraint_List_List_Parse_0;

   function Index_Constraint_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Index_Constraint
   is
      use Bare_Index_Constraint_Memos;

      Row_Pos_83       : Token_Index           := No_Token_Index;
      Token_Pos_94     : Token_Index           := No_Token_Index;
      Token_Res_94     : Token_Index           := No_Token_Index;
      Defer_Pos_126    : Token_Index           := No_Token_Index;
      Defer_Res_126    : Bare_Constraint_List  := No_Bare_Ada_Node;
      Token_Pos_95     : Token_Index           := No_Token_Index;
      Token_Res_95     : Token_Index           := No_Token_Index;
      Transform_Res_73 : Bare_Index_Constraint := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Index_Constraint_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_73   := M.Instance;
         return Transform_Res_73;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_73;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_83 := Pos;

--  Start tok_code

      Token_Res_94 := Row_Pos_83;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_94));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Open) then
            Token_Pos_94 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_83 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_83,
                  Expected_Token_Id => Ada_Par_Open,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_94 := Row_Pos_83 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_94 /= No_Token_Index then

         Row_Pos_83 := Token_Pos_94;

      else
         Row_Pos_83 := No_Token_Index;
         goto Exit_Row_81_0;

      end if;

      Defer_Res_126 := Constraint_List_List_Parse_0 (Parser, Row_Pos_83);
      Defer_Pos_126 := Parser.Current_Pos;

      if Defer_Pos_126 /= No_Token_Index then

         Row_Pos_83 := Defer_Pos_126;

      else
         Row_Pos_83 := No_Token_Index;
         goto Exit_Row_81_0;

      end if;

--  Start tok_code

      Token_Res_95 := Row_Pos_83;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_95));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Close) then
            Token_Pos_95 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_83 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_83,
                  Expected_Token_Id => Ada_Par_Close,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_95 := Row_Pos_83 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_95 /= No_Token_Index then

         Row_Pos_83 := Token_Pos_95;

      else
         Row_Pos_83 := No_Token_Index;
         goto Exit_Row_81_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_81_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_83 /= No_Token_Index then

         Transform_Res_73 := Allocate_Index_Constraint (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_73, Kind => Ada_Index_Constraint,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_83 = Pos then No_Token_Index else Row_Pos_83 - 1));

         Initialize_Fields_For_Index_Constraint
           (Self                           => Transform_Res_73,
            Index_Constraint_F_Constraints => Defer_Res_126);

         if Defer_Res_126 /= null and then Is_Incomplete (Defer_Res_126) then
            Transform_Res_73.Last_Attempted_Child := 0;
         elsif Defer_Res_126 /= null and then not Is_Ghost (Defer_Res_126) then
            Transform_Res_73.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Index_Constraint_Transform_Parse_0_Memo,
         Row_Pos_83 /= No_Token_Index, Transform_Res_73, Pos, Row_Pos_83);

      Parser.Current_Pos := Row_Pos_83;

      return Transform_Res_73;
   end Index_Constraint_Transform_Parse_0;

   function Constraint_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Constraint
   is
      use Bare_Constraint_Memos;

      Defer_Pos_111 : Token_Index                  := No_Token_Index;
      Defer_Res_111 : Bare_Digits_Constraint       := No_Bare_Ada_Node;
      Defer_Pos_112 : Token_Index                  := No_Token_Index;
      Defer_Res_112 : Bare_Delta_Constraint        := No_Bare_Ada_Node;
      Defer_Pos_113 : Token_Index                  := No_Token_Index;
      Defer_Res_113 : Bare_Range_Constraint        := No_Bare_Ada_Node;
      Defer_Pos_114 : Token_Index                  := No_Token_Index;
      Defer_Res_114 : Bare_Discriminant_Constraint := No_Bare_Ada_Node;
      Defer_Pos_115 : Token_Index                  := No_Token_Index;
      Defer_Res_115 : Bare_Index_Constraint        := No_Bare_Ada_Node;
      Or_Pos_32     : Token_Index                  := No_Token_Index;
      Or_Res_32     : Bare_Constraint              := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Constraint_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_32          := M.Instance;
         return Or_Res_32;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_32;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_32 := No_Token_Index;
      Or_Res_32 := No_Bare_Ada_Node;

      Defer_Res_111 := Digits_Constraint_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_111 := Parser.Current_Pos;

      if Defer_Pos_111 /= No_Token_Index then
         Or_Pos_32 := Defer_Pos_111;
         Or_Res_32 := Defer_Res_111;
         goto Exit_Or_32;
      end if;

      Defer_Res_112 := Delta_Constraint_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_112 := Parser.Current_Pos;

      if Defer_Pos_112 /= No_Token_Index then
         Or_Pos_32 := Defer_Pos_112;
         Or_Res_32 := Defer_Res_112;
         goto Exit_Or_32;
      end if;

      Defer_Res_113 := Range_Constraint_Transform_Parse_1 (Parser, Pos);
      Defer_Pos_113 := Parser.Current_Pos;

      if Defer_Pos_113 /= No_Token_Index then
         Or_Pos_32 := Defer_Pos_113;
         Or_Res_32 := Defer_Res_113;
         goto Exit_Or_32;
      end if;

      Defer_Res_114 := Discriminant_Constraint_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_114 := Parser.Current_Pos;

      if Defer_Pos_114 /= No_Token_Index then
         Or_Pos_32 := Defer_Pos_114;
         Or_Res_32 := Defer_Res_114;
         goto Exit_Or_32;
      end if;

      Defer_Res_115 := Index_Constraint_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_115 := Parser.Current_Pos;

      if Defer_Pos_115 /= No_Token_Index then
         Or_Pos_32 := Defer_Pos_115;
         Or_Res_32 := Defer_Res_115;
         goto Exit_Or_32;
      end if;
      <<Exit_Or_32>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Constraint_Or_Parse_0_Memo,
         Or_Pos_32 /= No_Token_Index, Or_Res_32, Pos, Or_Pos_32);

      Parser.Current_Pos := Or_Pos_32;

      return Or_Res_32;
   end Constraint_Or_Parse_0;

   function Subtype_Indication_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Subtype_Indication
   is
      use Bare_Subtype_Indication_Memos;

      Row_Pos_75       : Token_Index             := No_Token_Index;
      Row_Pos_76       : Token_Index             := No_Token_Index;
      Token_Pos_84     : Token_Index             := No_Token_Index;
      Token_Res_84     : Token_Index             := No_Token_Index;
      Token_Pos_85     : Token_Index             := No_Token_Index;
      Token_Res_85     : Token_Index             := No_Token_Index;
      Opt_Res_1        : Bare_Not_Null           := No_Bare_Ada_Node;
      Defer_Pos_109    : Token_Index             := No_Token_Index;
      Defer_Res_109    : Bare_Name               := No_Bare_Ada_Node;
      Defer_Pos_110    : Token_Index             := No_Token_Index;
      Defer_Res_110    : Bare_Constraint         := No_Bare_Ada_Node;
      Transform_Res_67 : Bare_Subtype_Indication := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Subtype_Indication_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_67   := M.Instance;
         return Transform_Res_67;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_67;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_75 := Pos;

--  Start opt_code

--  Start row_code

      Row_Pos_76 := Row_Pos_75;

--  Start tok_code

      Token_Res_84 := Row_Pos_76;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_84));
      begin
         if T.Kind /= From_Token_Kind (Ada_Not) then
            Token_Pos_84 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_76 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_76,
                  Expected_Token_Id => Ada_Not,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_84 := Row_Pos_76 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_84 /= No_Token_Index then

         Row_Pos_76 := Token_Pos_84;

      else
         Row_Pos_76 := No_Token_Index;
         goto Exit_Row_74_0;

      end if;

--  Start tok_code

      Token_Res_85 := Row_Pos_76;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_85));
      begin
         if T.Kind /= From_Token_Kind (Ada_Null) then
            Token_Pos_85 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_76 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_76,
                  Expected_Token_Id => Ada_Null,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_85 := Row_Pos_76 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_85 /= No_Token_Index then

         Row_Pos_76 := Token_Pos_85;

      else
         Row_Pos_76 := No_Token_Index;
         goto Exit_Row_74_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_74_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_76 = No_Token_Index then

         Opt_Res_1 := Allocate_Not_Null_Absent (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_1, Kind => Ada_Not_Null_Absent,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_75,
            Token_End_Index => No_Token_Index);

         Row_Pos_76 := Row_Pos_75;

      else

         Opt_Res_1 := Allocate_Not_Null_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_1, Kind => Ada_Not_Null_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_75,
            Token_End_Index => Row_Pos_76 - 1);

      end if;

--  End opt_code

      if Row_Pos_76 /= No_Token_Index then

         Row_Pos_75 := Row_Pos_76;

      else
         Row_Pos_75 := No_Token_Index;
         goto Exit_Row_73_0;

      end if;

      Defer_Res_109 := Subtype_Name_Or_Parse_0 (Parser, Row_Pos_75);
      Defer_Pos_109 := Parser.Current_Pos;

      if Defer_Pos_109 /= No_Token_Index then

         Row_Pos_75 := Defer_Pos_109;

      else
         Row_Pos_75 := No_Token_Index;
         goto Exit_Row_73_0;

      end if;

--  Start opt_code

      Defer_Res_110 := Constraint_Or_Parse_0 (Parser, Row_Pos_75);
      Defer_Pos_110 := Parser.Current_Pos;

      if Defer_Pos_110 = No_Token_Index then

         Defer_Res_110 := No_Bare_Ada_Node;

         Defer_Pos_110 := Row_Pos_75;

      end if;

--  End opt_code

      if Defer_Pos_110 /= No_Token_Index then

         Row_Pos_75 := Defer_Pos_110;

      else
         Row_Pos_75 := No_Token_Index;
         goto Exit_Row_73_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_73_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_75 /= No_Token_Index then

         Transform_Res_67 := Allocate_Subtype_Indication (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_67, Kind => Ada_Subtype_Indication,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_75 = Pos then No_Token_Index else Row_Pos_75 - 1));

         Initialize_Fields_For_Subtype_Indication
           (Self                              => Transform_Res_67,
            Subtype_Indication_F_Has_Not_Null => Opt_Res_1,
            Subtype_Indication_F_Name         => Defer_Res_109,
            Subtype_Indication_F_Constraint   => Defer_Res_110);

         if Opt_Res_1 /= null and then Is_Incomplete (Opt_Res_1) then
            Transform_Res_67.Last_Attempted_Child := 0;
         elsif Opt_Res_1 /= null and then not Is_Ghost (Opt_Res_1) then
            Transform_Res_67.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_109 /= null and then Is_Incomplete (Defer_Res_109) then
            Transform_Res_67.Last_Attempted_Child := 0;
         elsif Defer_Res_109 /= null and then not Is_Ghost (Defer_Res_109) then
            Transform_Res_67.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_110 /= null and then Is_Incomplete (Defer_Res_110) then
            Transform_Res_67.Last_Attempted_Child := 0;
         elsif Defer_Res_110 /= null and then not Is_Ghost (Defer_Res_110) then
            Transform_Res_67.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Subtype_Indication_Transform_Parse_0_Memo,
         Row_Pos_75 /= No_Token_Index, Transform_Res_67, Pos, Row_Pos_75);

      Parser.Current_Pos := Row_Pos_75;

      return Transform_Res_67;
   end Subtype_Indication_Transform_Parse_0;

   function Allocator_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Allocator
   is
      use Bare_Allocator_Memos;

      Nobt_10                 : Boolean                 := False;
      Row_Pos_70              : Token_Index             := No_Token_Index;
      Token_Pos_78            : Token_Index             := No_Token_Index;
      Token_Res_78            : Token_Index             := No_Token_Index;
      Row_Pos_71              : Token_Index             := No_Token_Index;
      Token_Pos_79            : Token_Index             := No_Token_Index;
      Token_Res_79            : Token_Index             := No_Token_Index;
      Defer_Pos_98            : Token_Index             := No_Token_Index;
      Defer_Res_98            : Bare_Name               := No_Bare_Ada_Node;
      Token_Pos_80            : Token_Index             := No_Token_Index;
      Token_Res_80            : Token_Index             := No_Token_Index;
      Defer_Pos_99            : Token_Index             := No_Token_Index;
      Defer_Res_99            : Bare_Qual_Expr          := No_Bare_Ada_Node;
      Defer_Pos_100           : Token_Index             := No_Token_Index;
      Defer_Res_100           : Bare_Subtype_Indication := No_Bare_Ada_Node;
      Or_Pos_29               : Token_Index             := No_Token_Index;
      Or_Res_29               : Bare_Ada_Node           := No_Bare_Ada_Node;
      Row_Progress_10         : Integer                 := 0;
      Transform_Res_63        : Bare_Allocator          := No_Bare_Ada_Node;
      Transform_Has_Failed_10 : Boolean                 := False;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Allocator_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_63   := M.Instance;
         return Transform_Res_63;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_63;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_70 := Pos;

--  Start tok_code

      Token_Res_78 := Row_Pos_70;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_78));
      begin
         if T.Kind /= From_Token_Kind (Ada_New) then
            Token_Pos_78 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_70 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_70,
                  Expected_Token_Id => Ada_New,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_78 := Row_Pos_70 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_10 := 1;

      if Token_Pos_78 /= No_Token_Index then

         Row_Pos_70 := Token_Pos_78;

      else
         Row_Pos_70 := No_Token_Index;
         goto Exit_Row_68_0;

      end if;

      Nobt_10 := True;

      Row_Progress_10 := 2;

      if Row_Pos_70 /= No_Token_Index then

         Row_Pos_70 := Row_Pos_70;

      else
         Row_Pos_70 := No_Token_Index;
         goto Exit_Row_68_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_71 := Row_Pos_70;

--  Start tok_code

      Token_Res_79 := Row_Pos_71;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_79));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Open) then
            Token_Pos_79 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_71 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_71,
                  Expected_Token_Id => Ada_Par_Open,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_79 := Row_Pos_71 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_79 /= No_Token_Index then

         Row_Pos_71 := Token_Pos_79;

      else
         Row_Pos_71 := No_Token_Index;
         goto Exit_Row_69_0;

      end if;

      Defer_Res_98 := Name_Or_Parse_1 (Parser, Row_Pos_71);
      Defer_Pos_98 := Parser.Current_Pos;

      if Defer_Pos_98 /= No_Token_Index then

         Row_Pos_71 := Defer_Pos_98;

      else
         Row_Pos_71 := No_Token_Index;
         goto Exit_Row_69_0;

      end if;

--  Start tok_code

      Token_Res_80 := Row_Pos_71;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_80));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Close) then
            Token_Pos_80 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_71 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_71,
                  Expected_Token_Id => Ada_Par_Close,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_80 := Row_Pos_71 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_80 /= No_Token_Index then

         Row_Pos_71 := Token_Pos_80;

      else
         Row_Pos_71 := No_Token_Index;
         goto Exit_Row_69_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_69_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_71 = No_Token_Index then

         Defer_Res_98 := No_Bare_Ada_Node;

         Row_Pos_71 := Row_Pos_70;

      end if;

--  End opt_code

      Row_Progress_10 := 3;

      if Row_Pos_71 /= No_Token_Index then

         Row_Pos_70 := Row_Pos_71;

      else
         Row_Pos_70 := No_Token_Index;
         goto Exit_Row_68_0;

      end if;

--  Start or_code

      Or_Pos_29 := No_Token_Index;
      Or_Res_29 := No_Bare_Ada_Node;

      Defer_Res_99 := Qualified_Name_Transform_Parse_0 (Parser, Row_Pos_70);
      Defer_Pos_99 := Parser.Current_Pos;

      if Defer_Pos_99 /= No_Token_Index then
         Or_Pos_29 := Defer_Pos_99;
         Or_Res_29 := Defer_Res_99;
         goto Exit_Or_29;
      end if;

      Defer_Res_100 :=
        Subtype_Indication_Transform_Parse_0 (Parser, Row_Pos_70);
      Defer_Pos_100 := Parser.Current_Pos;

      if Defer_Pos_100 /= No_Token_Index then
         Or_Pos_29 := Defer_Pos_100;
         Or_Res_29 := Defer_Res_100;
         goto Exit_Or_29;
      end if;
      <<Exit_Or_29>>

--  End or_code

      Row_Progress_10 := 4;

      if Or_Pos_29 /= No_Token_Index then

         Row_Pos_70 := Or_Pos_29;

      else
         Row_Pos_70 := No_Token_Index;
         goto Exit_Row_68_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_68_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_70 = No_Token_Index and then Nobt_10 then
         Row_Pos_70              := Parser.Last_Fail.Pos;
         Transform_Has_Failed_10 := True;
      end if;

      if Row_Pos_70 /= No_Token_Index then

         Transform_Res_63 := Allocate_Allocator (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_63, Kind => Ada_Allocator,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_70 = Pos then No_Token_Index else Row_Pos_70 - 1));

         Initialize_Fields_For_Allocator
           (Self => Transform_Res_63, Allocator_F_Subpool => Defer_Res_98,
            Allocator_F_Type_Or_Expr => Or_Res_29);

         if Defer_Res_98 /= null and then Is_Incomplete (Defer_Res_98) then
            Transform_Res_63.Last_Attempted_Child := 0;
         elsif Defer_Res_98 /= null and then not Is_Ghost (Defer_Res_98) then
            Transform_Res_63.Last_Attempted_Child := -1;
         end if;
         if Or_Res_29 /= null and then Is_Incomplete (Or_Res_29) then
            Transform_Res_63.Last_Attempted_Child := 0;
         elsif Or_Res_29 /= null and then not Is_Ghost (Or_Res_29) then
            Transform_Res_63.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_10 then
            Transform_Res_63.Last_Attempted_Child := Row_Progress_10;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <allocator>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Allocator_Transform_Parse_0_Memo,
         Row_Pos_70 /= No_Token_Index, Transform_Res_63, Pos, Row_Pos_70);

      Parser.Current_Pos := Row_Pos_70;

      return Transform_Res_63;
   end Allocator_Transform_Parse_0;

   function If_Expr_Transform_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_If_Expr
   is
      use Bare_If_Expr_Memos;

      Row_Pos_84       : Token_Index               := No_Token_Index;
      Token_Pos_97     : Token_Index               := No_Token_Index;
      Token_Res_97     : Token_Index               := No_Token_Index;
      Defer_Pos_133    : Token_Index               := No_Token_Index;
      Defer_Res_133    : Bare_Expr                 := No_Bare_Ada_Node;
      Token_Pos_98     : Token_Index               := No_Token_Index;
      Token_Res_98     : Token_Index               := No_Token_Index;
      Defer_Pos_134    : Token_Index               := No_Token_Index;
      Defer_Res_134    : Bare_Expr                 := No_Bare_Ada_Node;
      Lst_Cpos_9       : Token_Index               := No_Token_Index;
      Tmp_List_9       : Free_Parse_List;
      Row_Pos_85       : Token_Index               := No_Token_Index;
      Token_Pos_99     : Token_Index               := No_Token_Index;
      Token_Res_99     : Token_Index               := No_Token_Index;
      Defer_Pos_135    : Token_Index               := No_Token_Index;
      Defer_Res_135    : Bare_Expr                 := No_Bare_Ada_Node;
      Token_Pos_100    : Token_Index               := No_Token_Index;
      Token_Res_100    : Token_Index               := No_Token_Index;
      Defer_Pos_136    : Token_Index               := No_Token_Index;
      Defer_Res_136    : Bare_Expr                 := No_Bare_Ada_Node;
      Transform_Res_74 : Bare_Elsif_Expr_Part      := No_Bare_Ada_Node;
      List_Pos_9       : Token_Index               := No_Token_Index;
      List_Res_9       : Bare_Elsif_Expr_Part_List := No_Bare_Ada_Node;
      Row_Pos_86       : Token_Index               := No_Token_Index;
      Token_Pos_101    : Token_Index               := No_Token_Index;
      Token_Res_101    : Token_Index               := No_Token_Index;
      Defer_Pos_137    : Token_Index               := No_Token_Index;
      Defer_Res_137    : Bare_Expr                 := No_Bare_Ada_Node;
      Transform_Res_75 : Bare_If_Expr              := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.If_Expr_Transform_Parse_1_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_75   := M.Instance;
         return Transform_Res_75;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_75;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_84 := Pos;

--  Start tok_code

      Token_Res_97 := Row_Pos_84;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_97));
      begin
         if T.Kind /= From_Token_Kind (Ada_If) then
            Token_Pos_97 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_84 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_84,
                  Expected_Token_Id => Ada_If,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_97 := Row_Pos_84 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_97 /= No_Token_Index then

         Row_Pos_84 := Token_Pos_97;

      else
         Row_Pos_84 := No_Token_Index;
         goto Exit_Row_82_0;

      end if;

      Defer_Res_133 := Expr_Or_Parse_0 (Parser, Row_Pos_84);
      Defer_Pos_133 := Parser.Current_Pos;

      if Defer_Pos_133 /= No_Token_Index then

         Row_Pos_84 := Defer_Pos_133;

      else
         Row_Pos_84 := No_Token_Index;
         goto Exit_Row_82_0;

      end if;

--  Start tok_code

      Token_Res_98 := Row_Pos_84;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_98));
      begin
         if T.Kind /= From_Token_Kind (Ada_Then) then
            Token_Pos_98 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_84 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_84,
                  Expected_Token_Id => Ada_Then,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_98 := Row_Pos_84 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_98 /= No_Token_Index then

         Row_Pos_84 := Token_Pos_98;

      else
         Row_Pos_84 := No_Token_Index;
         goto Exit_Row_82_0;

      end if;

      Defer_Res_134 := Expr_Or_Parse_0 (Parser, Row_Pos_84);
      Defer_Pos_134 := Parser.Current_Pos;

      if Defer_Pos_134 /= No_Token_Index then

         Row_Pos_84 := Defer_Pos_134;

      else
         Row_Pos_84 := No_Token_Index;
         goto Exit_Row_82_0;

      end if;

--  Start list_code

      List_Pos_9 := Row_Pos_84;

      Lst_Cpos_9 := Row_Pos_84;
      Tmp_List_9 := Get_Parse_List (Parser);

      loop

--  Start transform_code

--  Start row_code

         Row_Pos_85 := Lst_Cpos_9;

--  Start tok_code

         Token_Res_99 := Row_Pos_85;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_99));
         begin
            if T.Kind /= From_Token_Kind (Ada_Elsif) then
               Token_Pos_99 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Row_Pos_85 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Row_Pos_85,
                     Expected_Token_Id => Ada_Elsif,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_99 := Row_Pos_85 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_99 /= No_Token_Index then

            Row_Pos_85 := Token_Pos_99;

         else
            Row_Pos_85 := No_Token_Index;
            goto Exit_Row_83_0;

         end if;

         Defer_Res_135 := Expr_Or_Parse_0 (Parser, Row_Pos_85);
         Defer_Pos_135 := Parser.Current_Pos;

         if Defer_Pos_135 /= No_Token_Index then

            Row_Pos_85 := Defer_Pos_135;

         else
            Row_Pos_85 := No_Token_Index;
            goto Exit_Row_83_0;

         end if;

--  Start tok_code

         Token_Res_100 := Row_Pos_85;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_100));
         begin
            if T.Kind /= From_Token_Kind (Ada_Then) then
               Token_Pos_100 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Row_Pos_85 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Row_Pos_85,
                     Expected_Token_Id => Ada_Then,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_100 := Row_Pos_85 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_100 /= No_Token_Index then

            Row_Pos_85 := Token_Pos_100;

         else
            Row_Pos_85 := No_Token_Index;
            goto Exit_Row_83_0;

         end if;

         Defer_Res_136 := Expr_Or_Parse_0 (Parser, Row_Pos_85);
         Defer_Pos_136 := Parser.Current_Pos;

         if Defer_Pos_136 /= No_Token_Index then

            Row_Pos_85 := Defer_Pos_136;

         else
            Row_Pos_85 := No_Token_Index;
            goto Exit_Row_83_0;

         end if;

         pragma Warnings (Off, "referenced");
         <<Exit_Row_83_0>>
         pragma Warnings (On, "referenced");

--  End row_code

         if Row_Pos_85 /= No_Token_Index then

            Transform_Res_74 := Allocate_Elsif_Expr_Part (Parser.Mem_Pool);

            Initialize
              (Self => Transform_Res_74, Kind => Ada_Elsif_Expr_Part,
               Unit            => Parser.Unit,
Token_Start_Index              => Lst_Cpos_9,
               Token_End_Index =>
                 (if Row_Pos_85 = Lst_Cpos_9 then No_Token_Index
                  else Row_Pos_85 - 1));

            Initialize_Fields_For_Elsif_Expr_Part
              (Self                        => Transform_Res_74,
               Elsif_Expr_Part_F_Cond_Expr => Defer_Res_135,
               Elsif_Expr_Part_F_Then_Expr => Defer_Res_136);

            if Defer_Res_135 /= null and then Is_Incomplete (Defer_Res_135)
            then
               Transform_Res_74.Last_Attempted_Child := 0;
            elsif Defer_Res_135 /= null and then not Is_Ghost (Defer_Res_135)
            then
               Transform_Res_74.Last_Attempted_Child := -1;
            end if;
            if Defer_Res_136 /= null and then Is_Incomplete (Defer_Res_136)
            then
               Transform_Res_74.Last_Attempted_Child := 0;
            elsif Defer_Res_136 /= null and then not Is_Ghost (Defer_Res_136)
            then
               Transform_Res_74.Last_Attempted_Child := -1;
            end if;

         end if;

--  End transform_code

         exit when Row_Pos_85 = No_Token_Index;

         List_Pos_9 := Row_Pos_85;
         Lst_Cpos_9 := List_Pos_9;

         Tmp_List_9.Nodes.Append (Transform_Res_74);

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_9.Nodes.Length;
      begin
         List_Res_9 := Allocate_Elsif_Expr_Part_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_84;
            Token_End   :=
              (if Lst_Cpos_9 = Row_Pos_84 then Row_Pos_84 else Lst_Cpos_9 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_84, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self            => List_Res_9, Kind => Ada_Elsif_Expr_Part_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_9, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_9.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_9.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_9);

--  End list_code

      if List_Pos_9 /= No_Token_Index then

         Row_Pos_84 := List_Pos_9;

      else
         Row_Pos_84 := No_Token_Index;
         goto Exit_Row_82_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_86 := Row_Pos_84;

--  Start tok_code

      Token_Res_101 := Row_Pos_86;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_101));
      begin
         if T.Kind /= From_Token_Kind (Ada_Else) then
            Token_Pos_101 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_86 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_86,
                  Expected_Token_Id => Ada_Else,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_101 := Row_Pos_86 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_101 /= No_Token_Index then

         Row_Pos_86 := Token_Pos_101;

      else
         Row_Pos_86 := No_Token_Index;
         goto Exit_Row_84_0;

      end if;

      Defer_Res_137 := Expr_Or_Parse_0 (Parser, Row_Pos_86);
      Defer_Pos_137 := Parser.Current_Pos;

      if Defer_Pos_137 /= No_Token_Index then

         Row_Pos_86 := Defer_Pos_137;

      else
         Row_Pos_86 := No_Token_Index;
         goto Exit_Row_84_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_84_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_86 = No_Token_Index then

         Defer_Res_137 := No_Bare_Ada_Node;

         Row_Pos_86 := Row_Pos_84;

      end if;

--  End opt_code

      if Row_Pos_86 /= No_Token_Index then

         Row_Pos_84 := Row_Pos_86;

      else
         Row_Pos_84 := No_Token_Index;
         goto Exit_Row_82_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_82_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_84 /= No_Token_Index then

         Transform_Res_75 := Allocate_If_Expr (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_75, Kind => Ada_If_Expr, Unit => Parser.Unit,

            Token_Start_Index => Pos,
            Token_End_Index   =>
              (if Row_Pos_84 = Pos then No_Token_Index else Row_Pos_84 - 1));

         Initialize_Fields_For_If_Expr
           (Self => Transform_Res_75, If_Expr_F_Cond_Expr => Defer_Res_133,
            If_Expr_F_Then_Expr    => Defer_Res_134,
            If_Expr_F_Alternatives => List_Res_9,
            If_Expr_F_Else_Expr    => Defer_Res_137);

         if Defer_Res_133 /= null and then Is_Incomplete (Defer_Res_133) then
            Transform_Res_75.Last_Attempted_Child := 0;
         elsif Defer_Res_133 /= null and then not Is_Ghost (Defer_Res_133) then
            Transform_Res_75.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_134 /= null and then Is_Incomplete (Defer_Res_134) then
            Transform_Res_75.Last_Attempted_Child := 0;
         elsif Defer_Res_134 /= null and then not Is_Ghost (Defer_Res_134) then
            Transform_Res_75.Last_Attempted_Child := -1;
         end if;
         if List_Res_9 /= null and then Is_Incomplete (List_Res_9) then
            Transform_Res_75.Last_Attempted_Child := 0;
         elsif List_Res_9 /= null and then not Is_Ghost (List_Res_9) then
            Transform_Res_75.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_137 /= null and then Is_Incomplete (Defer_Res_137) then
            Transform_Res_75.Last_Attempted_Child := 0;
         elsif Defer_Res_137 /= null and then not Is_Ghost (Defer_Res_137) then
            Transform_Res_75.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.If_Expr_Transform_Parse_1_Memo,
         Row_Pos_84 /= No_Token_Index, Transform_Res_75, Pos, Row_Pos_84);

      Parser.Current_Pos := Row_Pos_84;

      return Transform_Res_75;
   end If_Expr_Transform_Parse_1;

   function Case_Expr_Alt_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Case_Expr_Alternative
   is
      use Bare_Case_Expr_Alternative_Memos;

      Row_Pos_88       : Token_Index                := No_Token_Index;
      Token_Pos_105    : Token_Index                := No_Token_Index;
      Token_Res_105    : Token_Index                := No_Token_Index;
      Defer_Pos_140    : Token_Index                := No_Token_Index;
      Defer_Res_140    : Bare_Alternatives_List     := No_Bare_Ada_Node;
      Token_Pos_106    : Token_Index                := No_Token_Index;
      Token_Res_106    : Token_Index                := No_Token_Index;
      Defer_Pos_141    : Token_Index                := No_Token_Index;
      Defer_Res_141    : Bare_Expr                  := No_Bare_Ada_Node;
      Transform_Res_77 : Bare_Case_Expr_Alternative := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Case_Expr_Alt_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_77   := M.Instance;
         return Transform_Res_77;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_77;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_88 := Pos;

--  Start tok_code

      Token_Res_105 := Row_Pos_88;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_105));
      begin
         if T.Kind /= From_Token_Kind (Ada_When) then
            Token_Pos_105 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_88 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_88,
                  Expected_Token_Id => Ada_When,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_105 := Row_Pos_88 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_105 /= No_Token_Index then

         Row_Pos_88 := Token_Pos_105;

      else
         Row_Pos_88 := No_Token_Index;
         goto Exit_Row_86_0;

      end if;

      Defer_Res_140 := Choice_List_List_Parse_0 (Parser, Row_Pos_88);
      Defer_Pos_140 := Parser.Current_Pos;

      if Defer_Pos_140 /= No_Token_Index then

         Row_Pos_88 := Defer_Pos_140;

      else
         Row_Pos_88 := No_Token_Index;
         goto Exit_Row_86_0;

      end if;

--  Start tok_code

      Token_Res_106 := Row_Pos_88;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_106));
      begin
         if T.Kind /= From_Token_Kind (Ada_Arrow) then
            Token_Pos_106 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_88 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_88,
                  Expected_Token_Id => Ada_Arrow,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_106 := Row_Pos_88 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_106 /= No_Token_Index then

         Row_Pos_88 := Token_Pos_106;

      else
         Row_Pos_88 := No_Token_Index;
         goto Exit_Row_86_0;

      end if;

      Defer_Res_141 := Expr_Or_Parse_0 (Parser, Row_Pos_88);
      Defer_Pos_141 := Parser.Current_Pos;

      if Defer_Pos_141 /= No_Token_Index then

         Row_Pos_88 := Defer_Pos_141;

      else
         Row_Pos_88 := No_Token_Index;
         goto Exit_Row_86_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_86_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_88 /= No_Token_Index then

         Transform_Res_77 := Allocate_Case_Expr_Alternative (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_77, Kind => Ada_Case_Expr_Alternative,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_88 = Pos then No_Token_Index else Row_Pos_88 - 1));

         Initialize_Fields_For_Case_Expr_Alternative
           (Self                            => Transform_Res_77,
            Case_Expr_Alternative_F_Choices => Defer_Res_140,
            Case_Expr_Alternative_F_Expr    => Defer_Res_141);

         if Defer_Res_140 /= null and then Is_Incomplete (Defer_Res_140) then
            Transform_Res_77.Last_Attempted_Child := 0;
         elsif Defer_Res_140 /= null and then not Is_Ghost (Defer_Res_140) then
            Transform_Res_77.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_141 /= null and then Is_Incomplete (Defer_Res_141) then
            Transform_Res_77.Last_Attempted_Child := 0;
         elsif Defer_Res_141 /= null and then not Is_Ghost (Defer_Res_141) then
            Transform_Res_77.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Case_Expr_Alt_Transform_Parse_0_Memo,
         Row_Pos_88 /= No_Token_Index, Transform_Res_77, Pos, Row_Pos_88);

      Parser.Current_Pos := Row_Pos_88;

      return Transform_Res_77;
   end Case_Expr_Alt_Transform_Parse_0;

   function Case_Expr_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Case_Expr
   is
      use Bare_Case_Expr_Memos;

      Row_Pos_87       : Token_Index                     := No_Token_Index;
      Token_Pos_102    : Token_Index                     := No_Token_Index;
      Token_Res_102    : Token_Index                     := No_Token_Index;
      Defer_Pos_138    : Token_Index                     := No_Token_Index;
      Defer_Res_138    : Bare_Expr                       := No_Bare_Ada_Node;
      Token_Pos_103    : Token_Index                     := No_Token_Index;
      Token_Res_103    : Token_Index                     := No_Token_Index;
      Lst_Cpos_10      : Token_Index                     := No_Token_Index;
      Tmp_List_10      : Free_Parse_List;
      Defer_Pos_139    : Token_Index                     := No_Token_Index;
      Defer_Res_139    : Bare_Case_Expr_Alternative      := No_Bare_Ada_Node;
      Token_Pos_104    : Token_Index                     := No_Token_Index;
      Token_Res_104    : Token_Index                     := No_Token_Index;
      List_Pos_10      : Token_Index                     := No_Token_Index;
      List_Res_10      : Bare_Case_Expr_Alternative_List := No_Bare_Ada_Node;
      Transform_Res_76 : Bare_Case_Expr                  := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Case_Expr_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_76   := M.Instance;
         return Transform_Res_76;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_76;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_87 := Pos;

--  Start tok_code

      Token_Res_102 := Row_Pos_87;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_102));
      begin
         if T.Kind /= From_Token_Kind (Ada_Case) then
            Token_Pos_102 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_87 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_87,
                  Expected_Token_Id => Ada_Case,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_102 := Row_Pos_87 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_102 /= No_Token_Index then

         Row_Pos_87 := Token_Pos_102;

      else
         Row_Pos_87 := No_Token_Index;
         goto Exit_Row_85_0;

      end if;

      Defer_Res_138 := Expr_Or_Parse_0 (Parser, Row_Pos_87);
      Defer_Pos_138 := Parser.Current_Pos;

      if Defer_Pos_138 /= No_Token_Index then

         Row_Pos_87 := Defer_Pos_138;

      else
         Row_Pos_87 := No_Token_Index;
         goto Exit_Row_85_0;

      end if;

--  Start tok_code

      Token_Res_103 := Row_Pos_87;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_103));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_103 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_87 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_87,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_103 := Row_Pos_87 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_103 /= No_Token_Index then

         Row_Pos_87 := Token_Pos_103;

      else
         Row_Pos_87 := No_Token_Index;
         goto Exit_Row_85_0;

      end if;

--  Start list_code

      List_Pos_10 := No_Token_Index;

      Lst_Cpos_10 := Row_Pos_87;
      Tmp_List_10 := Get_Parse_List (Parser);

      loop

         Defer_Res_139 :=
           Case_Expr_Alt_Transform_Parse_0 (Parser, Lst_Cpos_10);
         Defer_Pos_139 := Parser.Current_Pos;

         exit when Defer_Pos_139 = No_Token_Index;

         List_Pos_10 := Defer_Pos_139;
         Lst_Cpos_10 := List_Pos_10;

         Tmp_List_10.Nodes.Append (Defer_Res_139);

--  Start tok_code

         Token_Res_104 := Lst_Cpos_10;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_104));
         begin
            if T.Kind /= From_Token_Kind (Ada_Comma) then
               Token_Pos_104 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_10 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_10,
                     Expected_Token_Id => Ada_Comma,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_104 := Lst_Cpos_10 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_104 /= No_Token_Index then
            Lst_Cpos_10 := Token_Pos_104;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_10.Nodes.Length;
      begin
         List_Res_10 := Allocate_Case_Expr_Alternative_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_87;
            Token_End   :=
              (if Lst_Cpos_10 = Row_Pos_87 then Row_Pos_87
               else Lst_Cpos_10 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_87, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self => List_Res_10, Kind => Ada_Case_Expr_Alternative_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_10, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_10.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_10.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_10);

--  End list_code

      if List_Pos_10 /= No_Token_Index then

         Row_Pos_87 := List_Pos_10;

      else
         Row_Pos_87 := No_Token_Index;
         goto Exit_Row_85_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_85_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_87 /= No_Token_Index then

         Transform_Res_76 := Allocate_Case_Expr (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_76, Kind => Ada_Case_Expr,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_87 = Pos then No_Token_Index else Row_Pos_87 - 1));

         Initialize_Fields_For_Case_Expr
           (Self => Transform_Res_76, Case_Expr_F_Expr => Defer_Res_138,
            Case_Expr_F_Cases => List_Res_10);

         if Defer_Res_138 /= null and then Is_Incomplete (Defer_Res_138) then
            Transform_Res_76.Last_Attempted_Child := 0;
         elsif Defer_Res_138 /= null and then not Is_Ghost (Defer_Res_138) then
            Transform_Res_76.Last_Attempted_Child := -1;
         end if;
         if List_Res_10 /= null and then Is_Incomplete (List_Res_10) then
            Transform_Res_76.Last_Attempted_Child := 0;
         elsif List_Res_10 /= null and then not Is_Ghost (List_Res_10) then
            Transform_Res_76.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Case_Expr_Transform_Parse_0_Memo,
         Row_Pos_87 /= No_Token_Index, Transform_Res_76, Pos, Row_Pos_87);

      Parser.Current_Pos := Row_Pos_87;

      return Transform_Res_76;
   end Case_Expr_Transform_Parse_0;

   function Defining_Id_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Defining_Name
   is
      use Bare_Defining_Name_Memos;

      Row_Pos_97       : Token_Index        := No_Token_Index;
      Defer_Pos_150    : Token_Index        := No_Token_Index;
      Defer_Res_150    : Bare_Identifier    := No_Bare_Ada_Node;
      Transform_Res_85 : Bare_Defining_Name := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Defining_Id_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_85   := M.Instance;
         return Transform_Res_85;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_85;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_97 := Pos;

      Defer_Res_150 := Identifier_Transform_Parse_0 (Parser, Row_Pos_97);
      Defer_Pos_150 := Parser.Current_Pos;

      if Defer_Pos_150 /= No_Token_Index then

         Row_Pos_97 := Defer_Pos_150;

      else
         Row_Pos_97 := No_Token_Index;
         goto Exit_Row_92_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_92_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_97 /= No_Token_Index then

         Transform_Res_85 := Allocate_Defining_Name (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_85, Kind => Ada_Defining_Name,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_97 = Pos then No_Token_Index else Row_Pos_97 - 1));

         Initialize_Fields_For_Defining_Name
           (Self => Transform_Res_85, Defining_Name_F_Name => Defer_Res_150);

         if Defer_Res_150 /= null and then Is_Incomplete (Defer_Res_150) then
            Transform_Res_85.Last_Attempted_Child := 0;
         elsif Defer_Res_150 /= null and then not Is_Ghost (Defer_Res_150) then
            Transform_Res_85.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Defining_Id_Transform_Parse_0_Memo,
         Row_Pos_97 /= No_Token_Index, Transform_Res_85, Pos, Row_Pos_97);

      Parser.Current_Pos := Row_Pos_97;

      return Transform_Res_85;
   end Defining_Id_Transform_Parse_0;

   function For_Loop_Param_Spec_Transform_Parse_3
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_For_Loop_Spec
   is
      use Bare_For_Loop_Spec_Memos;

      Row_Pos_92       : Token_Index                      := No_Token_Index;
      Row_Pos_93       : Token_Index                      := No_Token_Index;
      Defer_Pos_145    : Token_Index                      := No_Token_Index;
      Defer_Res_145    : Bare_Defining_Name               := No_Bare_Ada_Node;
      Row_Pos_94       : Token_Index                      := No_Token_Index;
      Token_Pos_111    : Token_Index                      := No_Token_Index;
      Token_Res_111    : Token_Index                      := No_Token_Index;
      Defer_Pos_146    : Token_Index                      := No_Token_Index;
      Defer_Res_146    : Bare_Subtype_Indication          := No_Bare_Ada_Node;
      Transform_Res_81 : Bare_For_Loop_Var_Decl           := No_Bare_Ada_Node;
      Row_Pos_95       : Token_Index                      := No_Token_Index;
      Token_Pos_112    : Token_Index                      := No_Token_Index;
      Token_Res_112    : Token_Index                      := No_Token_Index;
      Transform_Res_82 : Bare_Iter_Type_In                := No_Bare_Ada_Node;
      Row_Pos_96       : Token_Index                      := No_Token_Index;
      Token_Pos_113    : Token_Index                      := No_Token_Index;
      Token_Res_113    : Token_Index                      := No_Token_Index;
      Transform_Res_83 : Bare_Iter_Type_Of                := No_Bare_Ada_Node;
      Or_Pos_38        : Token_Index                      := No_Token_Index;
      Or_Res_38        : Bare_Iter_Type                   := No_Bare_Ada_Node;
      Token_Pos_114    : Token_Index                      := No_Token_Index;
      Token_Res_114    : Token_Index                      := No_Token_Index;
      Opt_Res_2        : Bare_Reverse_Node                := No_Bare_Ada_Node;
      Defer_Pos_147    : Token_Index                      := No_Token_Index;
      Defer_Res_147    : Bare_Expr                        := No_Bare_Ada_Node;
      Defer_Pos_148    : Token_Index                      := No_Token_Index;
      Defer_Res_148    : Bare_Discrete_Subtype_Indication := No_Bare_Ada_Node;
      Defer_Pos_149    : Token_Index                      := No_Token_Index;
      Defer_Res_149    : Bare_Name                        := No_Bare_Ada_Node;
      Or_Pos_39        : Token_Index                      := No_Token_Index;
      Or_Res_39        : Bare_Ada_Node                    := No_Bare_Ada_Node;
      Transform_Res_84 : Bare_For_Loop_Spec               := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.For_Loop_Param_Spec_Transform_Parse_3_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_84   := M.Instance;
         return Transform_Res_84;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_84;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_92 := Pos;

--  Start transform_code

--  Start row_code

      Row_Pos_93 := Row_Pos_92;

      Defer_Res_145 := Defining_Id_Transform_Parse_0 (Parser, Row_Pos_93);
      Defer_Pos_145 := Parser.Current_Pos;

      if Defer_Pos_145 /= No_Token_Index then

         Row_Pos_93 := Defer_Pos_145;

      else
         Row_Pos_93 := No_Token_Index;
         goto Exit_Row_91_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_94 := Row_Pos_93;

--  Start tok_code

      Token_Res_111 := Row_Pos_94;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_111));
      begin
         if T.Kind /= From_Token_Kind (Ada_Colon) then
            Token_Pos_111 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_94 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_94,
                  Expected_Token_Id => Ada_Colon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_111 := Row_Pos_94 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_111 /= No_Token_Index then

         Row_Pos_94 := Token_Pos_111;

      else
         Row_Pos_94 := No_Token_Index;
         goto Exit_Row_93_0;

      end if;

      Defer_Res_146 :=
        Subtype_Indication_Transform_Parse_0 (Parser, Row_Pos_94);
      Defer_Pos_146 := Parser.Current_Pos;

      if Defer_Pos_146 /= No_Token_Index then

         Row_Pos_94 := Defer_Pos_146;

      else
         Row_Pos_94 := No_Token_Index;
         goto Exit_Row_93_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_93_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_94 = No_Token_Index then

         Defer_Res_146 := No_Bare_Ada_Node;

         Row_Pos_94 := Row_Pos_93;

      end if;

--  End opt_code

      if Row_Pos_94 /= No_Token_Index then

         Row_Pos_93 := Row_Pos_94;

      else
         Row_Pos_93 := No_Token_Index;
         goto Exit_Row_91_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_91_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_93 /= No_Token_Index then

         Transform_Res_81 := Allocate_For_Loop_Var_Decl (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_81, Kind => Ada_For_Loop_Var_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_92,
            Token_End_Index =>
              (if Row_Pos_93 = Row_Pos_92 then No_Token_Index
               else Row_Pos_93 - 1));

         Initialize_Fields_For_For_Loop_Var_Decl
           (Self => Transform_Res_81, For_Loop_Var_Decl_F_Id => Defer_Res_145,
            For_Loop_Var_Decl_F_Id_Type => Defer_Res_146);

         if Defer_Res_145 /= null and then Is_Incomplete (Defer_Res_145) then
            Transform_Res_81.Last_Attempted_Child := 0;
         elsif Defer_Res_145 /= null and then not Is_Ghost (Defer_Res_145) then
            Transform_Res_81.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_146 /= null and then Is_Incomplete (Defer_Res_146) then
            Transform_Res_81.Last_Attempted_Child := 0;
         elsif Defer_Res_146 /= null and then not Is_Ghost (Defer_Res_146) then
            Transform_Res_81.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_93 /= No_Token_Index then

         Row_Pos_92 := Row_Pos_93;

      else
         Row_Pos_92 := No_Token_Index;
         goto Exit_Row_90_0;

      end if;

--  Start or_code

      Or_Pos_38 := No_Token_Index;
      Or_Res_38 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_95 := Row_Pos_92;

--  Start tok_code

      Token_Res_112 := Row_Pos_95;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_112));
      begin
         if T.Kind /= From_Token_Kind (Ada_In) then
            Token_Pos_112 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_95 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_95,
                  Expected_Token_Id => Ada_In,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_112 := Row_Pos_95 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_112 /= No_Token_Index then

         Row_Pos_95 := Token_Pos_112;

      else
         Row_Pos_95 := No_Token_Index;
         goto Exit_Row_94_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_94_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_95 /= No_Token_Index then

         Transform_Res_82 := Allocate_Iter_Type_In (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_82, Kind => Ada_Iter_Type_In,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_92,
            Token_End_Index =>
              (if Row_Pos_95 = Row_Pos_92 then No_Token_Index
               else Row_Pos_95 - 1));

      end if;

--  End transform_code

      if Row_Pos_95 /= No_Token_Index then
         Or_Pos_38 := Row_Pos_95;
         Or_Res_38 := Transform_Res_82;
         goto Exit_Or_37;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_96 := Row_Pos_92;

--  Start tok_code

      Token_Res_113 := Row_Pos_96;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_113));
      begin
         if T.Kind /= From_Token_Kind (Ada_Of) then
            Token_Pos_113 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_96 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_96,
                  Expected_Token_Id => Ada_Of,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_113 := Row_Pos_96 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_113 /= No_Token_Index then

         Row_Pos_96 := Token_Pos_113;

      else
         Row_Pos_96 := No_Token_Index;
         goto Exit_Row_95_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_95_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_96 /= No_Token_Index then

         Transform_Res_83 := Allocate_Iter_Type_Of (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_83, Kind => Ada_Iter_Type_Of,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_92,
            Token_End_Index =>
              (if Row_Pos_96 = Row_Pos_92 then No_Token_Index
               else Row_Pos_96 - 1));

      end if;

--  End transform_code

      if Row_Pos_96 /= No_Token_Index then
         Or_Pos_38 := Row_Pos_96;
         Or_Res_38 := Transform_Res_83;
         goto Exit_Or_37;
      end if;
      <<Exit_Or_37>>

--  End or_code

      if Or_Pos_38 /= No_Token_Index then

         Row_Pos_92 := Or_Pos_38;

      else
         Row_Pos_92 := No_Token_Index;
         goto Exit_Row_90_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_114 := Row_Pos_92;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_114));
      begin
         if T.Kind /= From_Token_Kind (Ada_Reverse) then
            Token_Pos_114 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_92 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_92,
                  Expected_Token_Id => Ada_Reverse,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_114 := Row_Pos_92 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_114 = No_Token_Index then

         Opt_Res_2 := Allocate_Reverse_Absent (Parser.Mem_Pool);
         Initialize
           (Self => Opt_Res_2, Kind => Ada_Reverse_Absent, Unit => Parser.Unit,
            Token_Start_Index => Row_Pos_92,
            Token_End_Index   => No_Token_Index);

         Token_Pos_114 := Row_Pos_92;

      else

         Opt_Res_2 := Allocate_Reverse_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_2, Kind => Ada_Reverse_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_92,
            Token_End_Index => Token_Pos_114 - 1);

      end if;

--  End opt_code

      if Token_Pos_114 /= No_Token_Index then

         Row_Pos_92 := Token_Pos_114;

      else
         Row_Pos_92 := No_Token_Index;
         goto Exit_Row_90_0;

      end if;

--  Start or_code

      Or_Pos_39 := No_Token_Index;
      Or_Res_39 := No_Bare_Ada_Node;

      Defer_Res_147 := Discrete_Range_Or_Parse_0 (Parser, Row_Pos_92);
      Defer_Pos_147 := Parser.Current_Pos;

      if Defer_Pos_147 /= No_Token_Index then
         Or_Pos_39 := Defer_Pos_147;
         Or_Res_39 := Defer_Res_147;
         goto Exit_Or_38;
      end if;

      Defer_Res_148 :=
        Discrete_Subtype_Indication_Transform_Parse_0 (Parser, Row_Pos_92);
      Defer_Pos_148 := Parser.Current_Pos;

      if Defer_Pos_148 /= No_Token_Index then
         Or_Pos_39 := Defer_Pos_148;
         Or_Res_39 := Defer_Res_148;
         goto Exit_Or_38;
      end if;

      Defer_Res_149 := Name_Or_Parse_1 (Parser, Row_Pos_92);
      Defer_Pos_149 := Parser.Current_Pos;

      if Defer_Pos_149 /= No_Token_Index then
         Or_Pos_39 := Defer_Pos_149;
         Or_Res_39 := Defer_Res_149;
         goto Exit_Or_38;
      end if;
      <<Exit_Or_38>>

--  End or_code

      if Or_Pos_39 /= No_Token_Index then

         Row_Pos_92 := Or_Pos_39;

      else
         Row_Pos_92 := No_Token_Index;
         goto Exit_Row_90_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_90_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_92 /= No_Token_Index then

         Transform_Res_84 := Allocate_For_Loop_Spec (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_84, Kind => Ada_For_Loop_Spec,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_92 = Pos then No_Token_Index else Row_Pos_92 - 1));

         Initialize_Fields_For_For_Loop_Spec
           (Self                        => Transform_Res_84,
            For_Loop_Spec_F_Var_Decl    => Transform_Res_81,
            For_Loop_Spec_F_Loop_Type   => Or_Res_38,
            For_Loop_Spec_F_Has_Reverse => Opt_Res_2,
            For_Loop_Spec_F_Iter_Expr   => Or_Res_39);

         if Transform_Res_81 /= null and then Is_Incomplete (Transform_Res_81)
         then
            Transform_Res_84.Last_Attempted_Child := 0;
         elsif Transform_Res_81 /= null
           and then not Is_Ghost (Transform_Res_81)
         then
            Transform_Res_84.Last_Attempted_Child := -1;
         end if;
         if Or_Res_38 /= null and then Is_Incomplete (Or_Res_38) then
            Transform_Res_84.Last_Attempted_Child := 0;
         elsif Or_Res_38 /= null and then not Is_Ghost (Or_Res_38) then
            Transform_Res_84.Last_Attempted_Child := -1;
         end if;
         if Opt_Res_2 /= null and then Is_Incomplete (Opt_Res_2) then
            Transform_Res_84.Last_Attempted_Child := 0;
         elsif Opt_Res_2 /= null and then not Is_Ghost (Opt_Res_2) then
            Transform_Res_84.Last_Attempted_Child := -1;
         end if;
         if Or_Res_39 /= null and then Is_Incomplete (Or_Res_39) then
            Transform_Res_84.Last_Attempted_Child := 0;
         elsif Or_Res_39 /= null and then not Is_Ghost (Or_Res_39) then
            Transform_Res_84.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.For_Loop_Param_Spec_Transform_Parse_3_Memo,
         Row_Pos_92 /= No_Token_Index, Transform_Res_84, Pos, Row_Pos_92);

      Parser.Current_Pos := Row_Pos_92;

      return Transform_Res_84;
   end For_Loop_Param_Spec_Transform_Parse_3;

   function Quantified_Expr_Transform_Parse_2
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Quantified_Expr
   is
      use Bare_Quantified_Expr_Memos;

      Row_Pos_89       : Token_Index          := No_Token_Index;
      Token_Pos_107    : Token_Index          := No_Token_Index;
      Token_Res_107    : Token_Index          := No_Token_Index;
      Row_Pos_90       : Token_Index          := No_Token_Index;
      Token_Pos_108    : Token_Index          := No_Token_Index;
      Token_Res_108    : Token_Index          := No_Token_Index;
      Transform_Res_78 : Bare_Quantifier_All  := No_Bare_Ada_Node;
      Row_Pos_91       : Token_Index          := No_Token_Index;
      Token_Pos_109    : Token_Index          := No_Token_Index;
      Token_Res_109    : Token_Index          := No_Token_Index;
      Transform_Res_79 : Bare_Quantifier_Some := No_Bare_Ada_Node;
      Or_Pos_36        : Token_Index          := No_Token_Index;
      Or_Res_36        : Bare_Quantifier      := No_Bare_Ada_Node;
      Defer_Pos_142    : Token_Index          := No_Token_Index;
      Defer_Res_142    : Bare_For_Loop_Spec   := No_Bare_Ada_Node;
      Token_Pos_110    : Token_Index          := No_Token_Index;
      Token_Res_110    : Token_Index          := No_Token_Index;
      Defer_Pos_143    : Token_Index          := No_Token_Index;
      Defer_Res_143    : Bare_Expr            := No_Bare_Ada_Node;
      Defer_Pos_144    : Token_Index          := No_Token_Index;
      Defer_Res_144    : Bare_Expr            := No_Bare_Ada_Node;
      Or_Pos_37        : Token_Index          := No_Token_Index;
      Or_Res_37        : Bare_Expr            := No_Bare_Ada_Node;
      Transform_Res_80 : Bare_Quantified_Expr := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Quantified_Expr_Transform_Parse_2_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_80   := M.Instance;
         return Transform_Res_80;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_80;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_89 := Pos;

--  Start tok_code

      Token_Res_107 := Row_Pos_89;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_107));
      begin
         if T.Kind /= From_Token_Kind (Ada_For) then
            Token_Pos_107 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_89 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_89,
                  Expected_Token_Id => Ada_For,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_107 := Row_Pos_89 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_107 /= No_Token_Index then

         Row_Pos_89 := Token_Pos_107;

      else
         Row_Pos_89 := No_Token_Index;
         goto Exit_Row_87_0;

      end if;

--  Start or_code

      Or_Pos_36 := No_Token_Index;
      Or_Res_36 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_90 := Row_Pos_89;

--  Start tok_code

      Token_Res_108 := Row_Pos_90;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_108));
      begin
         if T.Kind /= From_Token_Kind (Ada_All) then
            Token_Pos_108 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_90 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_90,
                  Expected_Token_Id => Ada_All,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_108 := Row_Pos_90 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_108 /= No_Token_Index then

         Row_Pos_90 := Token_Pos_108;

      else
         Row_Pos_90 := No_Token_Index;
         goto Exit_Row_88_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_88_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_90 /= No_Token_Index then

         Transform_Res_78 := Allocate_Quantifier_All (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_78, Kind => Ada_Quantifier_All,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_89,
            Token_End_Index =>
              (if Row_Pos_90 = Row_Pos_89 then No_Token_Index
               else Row_Pos_90 - 1));

      end if;

--  End transform_code

      if Row_Pos_90 /= No_Token_Index then
         Or_Pos_36 := Row_Pos_90;
         Or_Res_36 := Transform_Res_78;
         goto Exit_Or_36;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_91 := Row_Pos_89;

--  Start tok_code

      Token_Res_109 := Row_Pos_91;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_109));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol (Parser.TDH.Symbols, Precomputed_Symbol_Some)
         then
            Token_Pos_109 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_91 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_91,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_109 := Row_Pos_91 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_109 /= No_Token_Index then

         Row_Pos_91 := Token_Pos_109;

      else
         Row_Pos_91 := No_Token_Index;
         goto Exit_Row_89_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_89_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_91 /= No_Token_Index then

         Transform_Res_79 := Allocate_Quantifier_Some (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_79, Kind => Ada_Quantifier_Some,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_89,
            Token_End_Index =>
              (if Row_Pos_91 = Row_Pos_89 then No_Token_Index
               else Row_Pos_91 - 1));

      end if;

--  End transform_code

      if Row_Pos_91 /= No_Token_Index then
         Or_Pos_36 := Row_Pos_91;
         Or_Res_36 := Transform_Res_79;
         goto Exit_Or_36;
      end if;
      <<Exit_Or_36>>

--  End or_code

      if Or_Pos_36 /= No_Token_Index then

         Row_Pos_89 := Or_Pos_36;

      else
         Row_Pos_89 := No_Token_Index;
         goto Exit_Row_87_0;

      end if;

      Defer_Res_142 :=
        For_Loop_Param_Spec_Transform_Parse_3 (Parser, Row_Pos_89);
      Defer_Pos_142 := Parser.Current_Pos;

      if Defer_Pos_142 /= No_Token_Index then

         Row_Pos_89 := Defer_Pos_142;

      else
         Row_Pos_89 := No_Token_Index;
         goto Exit_Row_87_0;

      end if;

--  Start tok_code

      Token_Res_110 := Row_Pos_89;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_110));
      begin
         if T.Kind /= From_Token_Kind (Ada_Arrow) then
            Token_Pos_110 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_89 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_89,
                  Expected_Token_Id => Ada_Arrow,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_110 := Row_Pos_89 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_110 /= No_Token_Index then

         Row_Pos_89 := Token_Pos_110;

      else
         Row_Pos_89 := No_Token_Index;
         goto Exit_Row_87_0;

      end if;

--  Start or_code

      Or_Pos_37 := No_Token_Index;
      Or_Res_37 := No_Bare_Ada_Node;

      Defer_Res_143 := Expr_Or_Parse_0 (Parser, Row_Pos_89);
      Defer_Pos_143 := Parser.Current_Pos;

      if Defer_Pos_143 /= No_Token_Index then
         Or_Pos_37 := Defer_Pos_143;
         Or_Res_37 := Defer_Res_143;
         goto Exit_Or_39;
      end if;

      Defer_Res_144 := Discrete_Range_Or_Parse_0 (Parser, Row_Pos_89);
      Defer_Pos_144 := Parser.Current_Pos;

      if Defer_Pos_144 /= No_Token_Index then
         Or_Pos_37 := Defer_Pos_144;
         Or_Res_37 := Defer_Res_144;
         goto Exit_Or_39;
      end if;
      <<Exit_Or_39>>

--  End or_code

      if Or_Pos_37 /= No_Token_Index then

         Row_Pos_89 := Or_Pos_37;

      else
         Row_Pos_89 := No_Token_Index;
         goto Exit_Row_87_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_87_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_89 /= No_Token_Index then

         Transform_Res_80 := Allocate_Quantified_Expr (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_80, Kind => Ada_Quantified_Expr,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_89 = Pos then No_Token_Index else Row_Pos_89 - 1));

         Initialize_Fields_For_Quantified_Expr
           (Self                         => Transform_Res_80,
            Quantified_Expr_F_Quantifier => Or_Res_36,
            Quantified_Expr_F_Loop_Spec  => Defer_Res_142,
            Quantified_Expr_F_Expr       => Or_Res_37);

         if Or_Res_36 /= null and then Is_Incomplete (Or_Res_36) then
            Transform_Res_80.Last_Attempted_Child := 0;
         elsif Or_Res_36 /= null and then not Is_Ghost (Or_Res_36) then
            Transform_Res_80.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_142 /= null and then Is_Incomplete (Defer_Res_142) then
            Transform_Res_80.Last_Attempted_Child := 0;
         elsif Defer_Res_142 /= null and then not Is_Ghost (Defer_Res_142) then
            Transform_Res_80.Last_Attempted_Child := -1;
         end if;
         if Or_Res_37 /= null and then Is_Incomplete (Or_Res_37) then
            Transform_Res_80.Last_Attempted_Child := 0;
         elsif Or_Res_37 /= null and then not Is_Ghost (Or_Res_37) then
            Transform_Res_80.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Quantified_Expr_Transform_Parse_2_Memo,
         Row_Pos_89 /= No_Token_Index, Transform_Res_80, Pos, Row_Pos_89);

      Parser.Current_Pos := Row_Pos_89;

      return Transform_Res_80;
   end Quantified_Expr_Transform_Parse_2;

   function Conditional_Expr_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Expr
   is
      use Bare_Expr_Memos;

      Defer_Pos_130 : Token_Index          := No_Token_Index;
      Defer_Res_130 : Bare_If_Expr         := No_Bare_Ada_Node;
      Defer_Pos_131 : Token_Index          := No_Token_Index;
      Defer_Res_131 : Bare_Case_Expr       := No_Bare_Ada_Node;
      Defer_Pos_132 : Token_Index          := No_Token_Index;
      Defer_Res_132 : Bare_Quantified_Expr := No_Bare_Ada_Node;
      Or_Pos_35     : Token_Index          := No_Token_Index;
      Or_Res_35     : Bare_Expr            := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Conditional_Expr_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_35          := M.Instance;
         return Or_Res_35;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_35;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_35 := No_Token_Index;
      Or_Res_35 := No_Bare_Ada_Node;

      Defer_Res_130 := If_Expr_Transform_Parse_1 (Parser, Pos);
      Defer_Pos_130 := Parser.Current_Pos;

      if Defer_Pos_130 /= No_Token_Index then
         Or_Pos_35 := Defer_Pos_130;
         Or_Res_35 := Defer_Res_130;
         goto Exit_Or_35;
      end if;

      Defer_Res_131 := Case_Expr_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_131 := Parser.Current_Pos;

      if Defer_Pos_131 /= No_Token_Index then
         Or_Pos_35 := Defer_Pos_131;
         Or_Res_35 := Defer_Res_131;
         goto Exit_Or_35;
      end if;

      Defer_Res_132 := Quantified_Expr_Transform_Parse_2 (Parser, Pos);
      Defer_Pos_132 := Parser.Current_Pos;

      if Defer_Pos_132 /= No_Token_Index then
         Or_Pos_35 := Defer_Pos_132;
         Or_Res_35 := Defer_Res_132;
         goto Exit_Or_35;
      end if;
      <<Exit_Or_35>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Conditional_Expr_Or_Parse_0_Memo,
         Or_Pos_35 /= No_Token_Index, Or_Res_35, Pos, Or_Pos_35);

      Parser.Current_Pos := Or_Pos_35;

      return Or_Res_35;
   end Conditional_Expr_Or_Parse_0;

   function Raise_Expr_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Raise_Expr
   is
      use Bare_Raise_Expr_Memos;

      Row_Pos_98       : Token_Index     := No_Token_Index;
      Token_Pos_115    : Token_Index     := No_Token_Index;
      Token_Res_115    : Token_Index     := No_Token_Index;
      Defer_Pos_151    : Token_Index     := No_Token_Index;
      Defer_Res_151    : Bare_Name       := No_Bare_Ada_Node;
      Row_Pos_99       : Token_Index     := No_Token_Index;
      Token_Pos_116    : Token_Index     := No_Token_Index;
      Token_Res_116    : Token_Index     := No_Token_Index;
      Defer_Pos_152    : Token_Index     := No_Token_Index;
      Defer_Res_152    : Bare_Expr       := No_Bare_Ada_Node;
      Transform_Res_86 : Bare_Raise_Expr := No_Bare_Ada_Node;
      Row_Pos_100      : Token_Index     := No_Token_Index;
      Token_Pos_117    : Token_Index     := No_Token_Index;
      Token_Res_117    : Token_Index     := No_Token_Index;
      Null_Res_4       : Bare_Name       := No_Bare_Ada_Node;
      Null_Res_5       : Bare_Expr       := No_Bare_Ada_Node;
      Transform_Res_87 : Bare_Raise_Expr := No_Bare_Ada_Node;
      Or_Pos_40        : Token_Index     := No_Token_Index;
      Or_Res_40        : Bare_Raise_Expr := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Raise_Expr_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_40          := M.Instance;
         return Or_Res_40;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_40;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_40 := No_Token_Index;
      Or_Res_40 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_98 := Pos;

--  Start tok_code

      Token_Res_115 := Row_Pos_98;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_115));
      begin
         if T.Kind /= From_Token_Kind (Ada_Raise) then
            Token_Pos_115 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_98 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_98,
                  Expected_Token_Id => Ada_Raise,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_115 := Row_Pos_98 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_115 /= No_Token_Index then

         Row_Pos_98 := Token_Pos_115;

      else
         Row_Pos_98 := No_Token_Index;
         goto Exit_Row_96_0;

      end if;

      Defer_Res_151 := Name_Or_Parse_1 (Parser, Row_Pos_98);
      Defer_Pos_151 := Parser.Current_Pos;

      if Defer_Pos_151 /= No_Token_Index then

         Row_Pos_98 := Defer_Pos_151;

      else
         Row_Pos_98 := No_Token_Index;
         goto Exit_Row_96_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_99 := Row_Pos_98;

--  Start tok_code

      Token_Res_116 := Row_Pos_99;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_116));
      begin
         if T.Kind /= From_Token_Kind (Ada_With) then
            Token_Pos_116 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_99 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_99,
                  Expected_Token_Id => Ada_With,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_116 := Row_Pos_99 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_116 /= No_Token_Index then

         Row_Pos_99 := Token_Pos_116;

      else
         Row_Pos_99 := No_Token_Index;
         goto Exit_Row_97_0;

      end if;

      Defer_Res_152 := Expr_Or_Parse_0 (Parser, Row_Pos_99);
      Defer_Pos_152 := Parser.Current_Pos;

      if Defer_Pos_152 /= No_Token_Index then

         Row_Pos_99 := Defer_Pos_152;

      else
         Row_Pos_99 := No_Token_Index;
         goto Exit_Row_97_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_97_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_99 = No_Token_Index then

         Defer_Res_152 := No_Bare_Ada_Node;

         Row_Pos_99 := Row_Pos_98;

      end if;

--  End opt_code

      if Row_Pos_99 /= No_Token_Index then

         Row_Pos_98 := Row_Pos_99;

      else
         Row_Pos_98 := No_Token_Index;
         goto Exit_Row_96_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_96_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_98 /= No_Token_Index then

         Transform_Res_86 := Allocate_Raise_Expr (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_86, Kind => Ada_Raise_Expr,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_98 = Pos then No_Token_Index else Row_Pos_98 - 1));

         Initialize_Fields_For_Raise_Expr
           (Self                        => Transform_Res_86,
            Raise_Expr_F_Exception_Name => Defer_Res_151,
            Raise_Expr_F_Error_Message  => Defer_Res_152);

         if Defer_Res_151 /= null and then Is_Incomplete (Defer_Res_151) then
            Transform_Res_86.Last_Attempted_Child := 0;
         elsif Defer_Res_151 /= null and then not Is_Ghost (Defer_Res_151) then
            Transform_Res_86.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_152 /= null and then Is_Incomplete (Defer_Res_152) then
            Transform_Res_86.Last_Attempted_Child := 0;
         elsif Defer_Res_152 /= null and then not Is_Ghost (Defer_Res_152) then
            Transform_Res_86.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_98 /= No_Token_Index then
         Or_Pos_40 := Row_Pos_98;
         Or_Res_40 := Transform_Res_86;
         goto Exit_Or_40;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_100 := Pos;

--  Start tok_code

      Token_Res_117 := Row_Pos_100;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_117));
      begin
         if T.Kind /= From_Token_Kind (Ada_Raise) then
            Token_Pos_117 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_100 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_100,
                  Expected_Token_Id => Ada_Raise,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_117 := Row_Pos_100 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_117 /= No_Token_Index then

         Row_Pos_100 := Token_Pos_117;

      else
         Row_Pos_100 := No_Token_Index;
         goto Exit_Row_98_0;

      end if;

      Null_Res_4 := No_Bare_Ada_Node;

      if Row_Pos_100 /= No_Token_Index then

         Row_Pos_100 := Row_Pos_100;

      else
         Row_Pos_100 := No_Token_Index;
         goto Exit_Row_98_0;

      end if;

      Null_Res_5 := No_Bare_Ada_Node;

      if Row_Pos_100 /= No_Token_Index then

         Row_Pos_100 := Row_Pos_100;

      else
         Row_Pos_100 := No_Token_Index;
         goto Exit_Row_98_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_98_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_100 /= No_Token_Index then

         Transform_Res_87 := Allocate_Raise_Expr (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_87, Kind => Ada_Raise_Expr,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_100 = Pos then No_Token_Index else Row_Pos_100 - 1));

         Initialize_Fields_For_Raise_Expr
           (Self                        => Transform_Res_87,
            Raise_Expr_F_Exception_Name => Null_Res_4,
            Raise_Expr_F_Error_Message  => Null_Res_5);

         if Null_Res_4 /= null and then Is_Incomplete (Null_Res_4) then
            Transform_Res_87.Last_Attempted_Child := 0;
         elsif Null_Res_4 /= null and then not Is_Ghost (Null_Res_4) then
            Transform_Res_87.Last_Attempted_Child := -1;
         end if;
         if Null_Res_5 /= null and then Is_Incomplete (Null_Res_5) then
            Transform_Res_87.Last_Attempted_Child := 0;
         elsif Null_Res_5 /= null and then not Is_Ghost (Null_Res_5) then
            Transform_Res_87.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_100 /= No_Token_Index then
         Or_Pos_40 := Row_Pos_100;
         Or_Res_40 := Transform_Res_87;
         goto Exit_Or_40;
      end if;
      <<Exit_Or_40>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Raise_Expr_Or_Parse_0_Memo,
         Or_Pos_40 /= No_Token_Index, Or_Res_40, Pos, Or_Pos_40);

      Parser.Current_Pos := Or_Pos_40;

      return Or_Res_40;
   end Raise_Expr_Or_Parse_0;

   function Primary_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Expr
   is
      use Bare_Expr_Memos;

      Defer_Pos_15 : Token_Index         := No_Token_Index;
      Defer_Res_15 : Bare_Num_Literal    := No_Bare_Ada_Node;
      Defer_Pos_16 : Token_Index         := No_Token_Index;
      Defer_Res_16 : Bare_Null_Literal   := No_Bare_Ada_Node;
      Defer_Pos_17 : Token_Index         := No_Token_Index;
      Defer_Res_17 : Bare_Name           := No_Bare_Ada_Node;
      Defer_Pos_18 : Token_Index         := No_Token_Index;
      Defer_Res_18 : Bare_Allocator      := No_Bare_Ada_Node;
      Defer_Pos_19 : Token_Index         := No_Token_Index;
      Defer_Res_19 : Bare_Expr           := No_Bare_Ada_Node;
      Defer_Pos_20 : Token_Index         := No_Token_Index;
      Defer_Res_20 : Bare_Raise_Expr     := No_Bare_Ada_Node;
      Defer_Pos_21 : Token_Index         := No_Token_Index;
      Defer_Res_21 : Bare_Paren_Expr     := No_Bare_Ada_Node;
      Defer_Pos_22 : Token_Index         := No_Token_Index;
      Defer_Res_22 : Bare_Base_Aggregate := No_Bare_Ada_Node;
      Or_Pos_7     : Token_Index         := No_Token_Index;
      Or_Res_7     : Bare_Expr           := No_Bare_Ada_Node;

      M : Memo_Entry := Get (Parser.Private_Part.Primary_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_7           := M.Instance;
         return Or_Res_7;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_7;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_7 := No_Token_Index;
      Or_Res_7 := No_Bare_Ada_Node;

      Defer_Res_15 := Num_Literal_Or_Parse_0 (Parser, Pos);
      Defer_Pos_15 := Parser.Current_Pos;

      if Defer_Pos_15 /= No_Token_Index then
         Or_Pos_7 := Defer_Pos_15;
         Or_Res_7 := Defer_Res_15;
         goto Exit_Or_7;
      end if;

      Defer_Res_16 := Null_Literal_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_16 := Parser.Current_Pos;

      if Defer_Pos_16 /= No_Token_Index then
         Or_Pos_7 := Defer_Pos_16;
         Or_Res_7 := Defer_Res_16;
         goto Exit_Or_7;
      end if;

      Defer_Res_17 := Name_Or_Parse_1 (Parser, Pos);
      Defer_Pos_17 := Parser.Current_Pos;

      if Defer_Pos_17 /= No_Token_Index then
         Or_Pos_7 := Defer_Pos_17;
         Or_Res_7 := Defer_Res_17;
         goto Exit_Or_7;
      end if;

      Defer_Res_18 := Allocator_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_18 := Parser.Current_Pos;

      if Defer_Pos_18 /= No_Token_Index then
         Or_Pos_7 := Defer_Pos_18;
         Or_Res_7 := Defer_Res_18;
         goto Exit_Or_7;
      end if;

      Defer_Res_19 := Conditional_Expr_Or_Parse_0 (Parser, Pos);
      Defer_Pos_19 := Parser.Current_Pos;

      if Defer_Pos_19 /= No_Token_Index then
         Or_Pos_7 := Defer_Pos_19;
         Or_Res_7 := Defer_Res_19;
         goto Exit_Or_7;
      end if;

      Defer_Res_20 := Raise_Expr_Or_Parse_0 (Parser, Pos);
      Defer_Pos_20 := Parser.Current_Pos;

      if Defer_Pos_20 /= No_Token_Index then
         Or_Pos_7 := Defer_Pos_20;
         Or_Res_7 := Defer_Res_20;
         goto Exit_Or_7;
      end if;

      Defer_Res_21 := Paren_Expr_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_21 := Parser.Current_Pos;

      if Defer_Pos_21 /= No_Token_Index then
         Or_Pos_7 := Defer_Pos_21;
         Or_Res_7 := Defer_Res_21;
         goto Exit_Or_7;
      end if;

      Defer_Res_22 := Aggregate_Or_Parse_0 (Parser, Pos);
      Defer_Pos_22 := Parser.Current_Pos;

      if Defer_Pos_22 /= No_Token_Index then
         Or_Pos_7 := Defer_Pos_22;
         Or_Res_7 := Defer_Res_22;
         goto Exit_Or_7;
      end if;
      <<Exit_Or_7>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Primary_Or_Parse_0_Memo,
         Or_Pos_7 /= No_Token_Index, Or_Res_7, Pos, Or_Pos_7);

      Parser.Current_Pos := Or_Pos_7;

      return Or_Res_7;
   end Primary_Or_Parse_0;

   function Factor_Or_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Expr
   is
      use Bare_Expr_Memos;

      Nobt_2                 : Boolean     := False;
      Nobt_3                 : Boolean     := False;
      Row_Pos_10             : Token_Index := No_Token_Index;
      Row_Pos_11             : Token_Index := No_Token_Index;
      Token_Pos_9            : Token_Index := No_Token_Index;
      Token_Res_9            : Token_Index := No_Token_Index;
      Transform_Res_10       : Bare_Op_Abs := No_Bare_Ada_Node;
      Row_Pos_12             : Token_Index := No_Token_Index;
      Token_Pos_10           : Token_Index := No_Token_Index;
      Token_Res_10           : Token_Index := No_Token_Index;
      Transform_Res_11       : Bare_Op_Not := No_Bare_Ada_Node;
      Or_Pos_5               : Token_Index := No_Token_Index;
      Or_Res_5               : Bare_Op     := No_Bare_Ada_Node;
      Defer_Pos_11           : Token_Index := No_Token_Index;
      Defer_Res_11           : Bare_Expr   := No_Bare_Ada_Node;
      Row_Progress_2         : Integer     := 0;
      Transform_Res_12       : Bare_Un_Op  := No_Bare_Ada_Node;
      Transform_Has_Failed_2 : Boolean     := False;
      Row_Pos_13             : Token_Index := No_Token_Index;
      Defer_Pos_12           : Token_Index := No_Token_Index;
      Defer_Res_12           : Bare_Expr   := No_Bare_Ada_Node;
      Row_Pos_14             : Token_Index := No_Token_Index;
      Token_Pos_11           : Token_Index := No_Token_Index;
      Token_Res_11           : Token_Index := No_Token_Index;
      Transform_Res_13       : Bare_Op_Pow := No_Bare_Ada_Node;
      Defer_Pos_13           : Token_Index := No_Token_Index;
      Defer_Res_13           : Bare_Expr   := No_Bare_Ada_Node;
      Row_Progress_3         : Integer     := 0;
      Transform_Res_14       : Bare_Bin_Op := No_Bare_Ada_Node;
      Transform_Has_Failed_3 : Boolean     := False;
      Defer_Pos_14           : Token_Index := No_Token_Index;
      Defer_Res_14           : Bare_Expr   := No_Bare_Ada_Node;
      Or_Pos_6               : Token_Index := No_Token_Index;
      Or_Res_6               : Bare_Expr   := No_Bare_Ada_Node;

      M : Memo_Entry := Get (Parser.Private_Part.Factor_Or_Parse_1_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_6           := M.Instance;
         return Or_Res_6;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_6;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_6 := No_Token_Index;
      Or_Res_6 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_10 := Pos;

--  Start or_code

      Or_Pos_5 := No_Token_Index;
      Or_Res_5 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_11 := Row_Pos_10;

--  Start tok_code

      Token_Res_9 := Row_Pos_11;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_9));
      begin
         if T.Kind /= From_Token_Kind (Ada_Abs) then
            Token_Pos_9 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_11 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_11,
                  Expected_Token_Id => Ada_Abs,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_9 := Row_Pos_11 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_9 /= No_Token_Index then

         Row_Pos_11 := Token_Pos_9;

      else
         Row_Pos_11 := No_Token_Index;
         goto Exit_Row_11_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_11_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_11 /= No_Token_Index then

         Transform_Res_10 := Allocate_Op_Abs (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_10, Kind => Ada_Op_Abs, Unit => Parser.Unit,

            Token_Start_Index => Row_Pos_10,
            Token_End_Index   =>
              (if Row_Pos_11 = Row_Pos_10 then No_Token_Index
               else Row_Pos_11 - 1));

         Initialize_Fields_For_Op_Abs (Self => Transform_Res_10);

      end if;

--  End transform_code

      if Row_Pos_11 /= No_Token_Index then
         Or_Pos_5 := Row_Pos_11;
         Or_Res_5 := Transform_Res_10;
         goto Exit_Or_6;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_12 := Row_Pos_10;

--  Start tok_code

      Token_Res_10 := Row_Pos_12;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_10));
      begin
         if T.Kind /= From_Token_Kind (Ada_Not) then
            Token_Pos_10 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_12 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_12,
                  Expected_Token_Id => Ada_Not,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_10 := Row_Pos_12 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_10 /= No_Token_Index then

         Row_Pos_12 := Token_Pos_10;

      else
         Row_Pos_12 := No_Token_Index;
         goto Exit_Row_12_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_12_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_12 /= No_Token_Index then

         Transform_Res_11 := Allocate_Op_Not (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_11, Kind => Ada_Op_Not, Unit => Parser.Unit,

            Token_Start_Index => Row_Pos_10,
            Token_End_Index   =>
              (if Row_Pos_12 = Row_Pos_10 then No_Token_Index
               else Row_Pos_12 - 1));

         Initialize_Fields_For_Op_Not (Self => Transform_Res_11);

      end if;

--  End transform_code

      if Row_Pos_12 /= No_Token_Index then
         Or_Pos_5 := Row_Pos_12;
         Or_Res_5 := Transform_Res_11;
         goto Exit_Or_6;
      end if;
      <<Exit_Or_6>>

--  End or_code

      Row_Progress_2 := 1;

      if Or_Pos_5 /= No_Token_Index then

         Row_Pos_10 := Or_Pos_5;

      else
         Row_Pos_10 := No_Token_Index;
         goto Exit_Row_10_0;

      end if;

      Nobt_2 := True;

      Row_Progress_2 := 2;

      if Row_Pos_10 /= No_Token_Index then

         Row_Pos_10 := Row_Pos_10;

      else
         Row_Pos_10 := No_Token_Index;
         goto Exit_Row_10_0;

      end if;

      Defer_Res_11 := Primary_Or_Parse_0 (Parser, Row_Pos_10);
      Defer_Pos_11 := Parser.Current_Pos;

      Row_Progress_2 := 3;

      if Defer_Pos_11 /= No_Token_Index then

         Row_Pos_10 := Defer_Pos_11;

      else
         Row_Pos_10 := No_Token_Index;
         goto Exit_Row_10_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_10_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_10 = No_Token_Index and then Nobt_2 then
         Row_Pos_10             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_2 := True;
      end if;

      if Row_Pos_10 /= No_Token_Index then

         Transform_Res_12 := Allocate_Un_Op (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_12, Kind => Ada_Un_Op, Unit => Parser.Unit,

            Token_Start_Index => Pos,
            Token_End_Index   =>
              (if Row_Pos_10 = Pos then No_Token_Index else Row_Pos_10 - 1));

         Initialize_Fields_For_Un_Op
           (Self         => Transform_Res_12, Un_Op_F_Op => Or_Res_5,
            Un_Op_F_Expr => Defer_Res_11);

         if Or_Res_5 /= null and then Is_Incomplete (Or_Res_5) then
            Transform_Res_12.Last_Attempted_Child := 0;
         elsif Or_Res_5 /= null and then not Is_Ghost (Or_Res_5) then
            Transform_Res_12.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_11 /= null and then Is_Incomplete (Defer_Res_11) then
            Transform_Res_12.Last_Attempted_Child := 0;
         elsif Defer_Res_11 /= null and then not Is_Ghost (Defer_Res_11) then
            Transform_Res_12.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_2 then
            Transform_Res_12.Last_Attempted_Child := Row_Progress_2;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <factor>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      if Row_Pos_10 /= No_Token_Index then
         Or_Pos_6 := Row_Pos_10;
         Or_Res_6 := Transform_Res_12;
         goto Exit_Or_5;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_13 := Pos;

      Defer_Res_12 := Primary_Or_Parse_0 (Parser, Row_Pos_13);
      Defer_Pos_12 := Parser.Current_Pos;

      Row_Progress_3 := 1;

      if Defer_Pos_12 /= No_Token_Index then

         Row_Pos_13 := Defer_Pos_12;

      else
         Row_Pos_13 := No_Token_Index;
         goto Exit_Row_99_0;

      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_14 := Row_Pos_13;

--  Start tok_code

      Token_Res_11 := Row_Pos_14;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_11));
      begin
         if T.Kind /= From_Token_Kind (Ada_Power) then
            Token_Pos_11 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_14 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_14,
                  Expected_Token_Id => Ada_Power,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_11 := Row_Pos_14 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_11 /= No_Token_Index then

         Row_Pos_14 := Token_Pos_11;

      else
         Row_Pos_14 := No_Token_Index;
         goto Exit_Row_100_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_100_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_14 /= No_Token_Index then

         Transform_Res_13 := Allocate_Op_Pow (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_13, Kind => Ada_Op_Pow, Unit => Parser.Unit,

            Token_Start_Index => Row_Pos_13,
            Token_End_Index   =>
              (if Row_Pos_14 = Row_Pos_13 then No_Token_Index
               else Row_Pos_14 - 1));

         Initialize_Fields_For_Op_Pow (Self => Transform_Res_13);

      end if;

--  End transform_code

      Row_Progress_3 := 2;

      if Row_Pos_14 /= No_Token_Index then

         Row_Pos_13 := Row_Pos_14;

      else
         Row_Pos_13 := No_Token_Index;
         goto Exit_Row_99_0;

      end if;

      Nobt_3 := True;

      Row_Progress_3 := 3;

      if Row_Pos_13 /= No_Token_Index then

         Row_Pos_13 := Row_Pos_13;

      else
         Row_Pos_13 := No_Token_Index;
         goto Exit_Row_99_0;

      end if;

      Defer_Res_13 := Primary_Or_Parse_0 (Parser, Row_Pos_13);
      Defer_Pos_13 := Parser.Current_Pos;

      Row_Progress_3 := 4;

      if Defer_Pos_13 /= No_Token_Index then

         Row_Pos_13 := Defer_Pos_13;

      else
         Row_Pos_13 := No_Token_Index;
         goto Exit_Row_99_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_99_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_13 = No_Token_Index and then Nobt_3 then
         Row_Pos_13             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_3 := True;
      end if;

      if Row_Pos_13 /= No_Token_Index then

         Transform_Res_14 := Allocate_Bin_Op (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_14, Kind => Ada_Bin_Op, Unit => Parser.Unit,

            Token_Start_Index => Pos,
            Token_End_Index   =>
              (if Row_Pos_13 = Pos then No_Token_Index else Row_Pos_13 - 1));

         Initialize_Fields_For_Bin_Op
           (Self        => Transform_Res_14, Bin_Op_F_Left => Defer_Res_12,
            Bin_Op_F_Op => Transform_Res_13, Bin_Op_F_Right => Defer_Res_13);

         if Defer_Res_12 /= null and then Is_Incomplete (Defer_Res_12) then
            Transform_Res_14.Last_Attempted_Child := 0;
         elsif Defer_Res_12 /= null and then not Is_Ghost (Defer_Res_12) then
            Transform_Res_14.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_13 /= null and then Is_Incomplete (Transform_Res_13)
         then
            Transform_Res_14.Last_Attempted_Child := 0;
         elsif Transform_Res_13 /= null
           and then not Is_Ghost (Transform_Res_13)
         then
            Transform_Res_14.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_13 /= null and then Is_Incomplete (Defer_Res_13) then
            Transform_Res_14.Last_Attempted_Child := 0;
         elsif Defer_Res_13 /= null and then not Is_Ghost (Defer_Res_13) then
            Transform_Res_14.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_3 then
            Transform_Res_14.Last_Attempted_Child := Row_Progress_3;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <factor>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      if Row_Pos_13 /= No_Token_Index then
         Or_Pos_6 := Row_Pos_13;
         Or_Res_6 := Transform_Res_14;
         goto Exit_Or_5;
      end if;

      Defer_Res_14 := Primary_Or_Parse_0 (Parser, Pos);
      Defer_Pos_14 := Parser.Current_Pos;

      if Defer_Pos_14 /= No_Token_Index then
         Or_Pos_6 := Defer_Pos_14;
         Or_Res_6 := Defer_Res_14;
         goto Exit_Or_5;
      end if;
      <<Exit_Or_5>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Factor_Or_Parse_1_Memo,
         Or_Pos_6 /= No_Token_Index, Or_Res_6, Pos, Or_Pos_6);

      Parser.Current_Pos := Or_Pos_6;

      return Or_Res_6;
   end Factor_Or_Parse_1;

   function Term_Or_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Expr
   is
      use Bare_Expr_Memos;

      Nobt_1                 : Boolean      := False;
      Row_Pos_5              : Token_Index  := No_Token_Index;
      Defer_Pos_8            : Token_Index  := No_Token_Index;
      Defer_Res_8            : Bare_Expr    := No_Bare_Ada_Node;
      Row_Pos_6              : Token_Index  := No_Token_Index;
      Token_Pos_5            : Token_Index  := No_Token_Index;
      Token_Res_5            : Token_Index  := No_Token_Index;
      Transform_Res_5        : Bare_Op_Mult := No_Bare_Ada_Node;
      Row_Pos_7              : Token_Index  := No_Token_Index;
      Token_Pos_6            : Token_Index  := No_Token_Index;
      Token_Res_6            : Token_Index  := No_Token_Index;
      Transform_Res_6        : Bare_Op_Div  := No_Bare_Ada_Node;
      Row_Pos_8              : Token_Index  := No_Token_Index;
      Token_Pos_7            : Token_Index  := No_Token_Index;
      Token_Res_7            : Token_Index  := No_Token_Index;
      Transform_Res_7        : Bare_Op_Mod  := No_Bare_Ada_Node;
      Row_Pos_9              : Token_Index  := No_Token_Index;
      Token_Pos_8            : Token_Index  := No_Token_Index;
      Token_Res_8            : Token_Index  := No_Token_Index;
      Transform_Res_8        : Bare_Op_Rem  := No_Bare_Ada_Node;
      Or_Pos_3               : Token_Index  := No_Token_Index;
      Or_Res_3               : Bare_Op      := No_Bare_Ada_Node;
      Defer_Pos_9            : Token_Index  := No_Token_Index;
      Defer_Res_9            : Bare_Expr    := No_Bare_Ada_Node;
      Row_Progress_1         : Integer      := 0;
      Transform_Res_9        : Bare_Bin_Op  := No_Bare_Ada_Node;
      Transform_Has_Failed_1 : Boolean      := False;
      Defer_Pos_10           : Token_Index  := No_Token_Index;
      Defer_Res_10           : Bare_Expr    := No_Bare_Ada_Node;
      Or_Pos_4               : Token_Index  := No_Token_Index;
      Or_Res_4               : Bare_Expr    := No_Bare_Ada_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Expr   := No_Bare_Ada_Node;

      M : Memo_Entry := Get (Parser.Private_Part.Term_Or_Parse_1_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_4           := M.Instance;
         return Or_Res_4;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_4;
      end if;

      Set
        (Parser.Private_Part.Term_Or_Parse_1_Memo, False, Or_Res_4, Pos,
         Mem_Pos);

      <<Try_Again>>

      Nobt_1 := False;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_4 := No_Token_Index;
      Or_Res_4 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_5 := Pos;

      Defer_Res_8 := Term_Or_Parse_1 (Parser, Row_Pos_5);
      Defer_Pos_8 := Parser.Current_Pos;

      Row_Progress_1 := 1;

      if Defer_Pos_8 /= No_Token_Index then

         Row_Pos_5 := Defer_Pos_8;

      else
         Row_Pos_5 := No_Token_Index;
         goto Exit_Row_5_0;

      end if;

--  Start or_code

      Or_Pos_3 := No_Token_Index;
      Or_Res_3 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_6 := Row_Pos_5;

--  Start tok_code

      Token_Res_5 := Row_Pos_6;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_5));
      begin
         if T.Kind /= From_Token_Kind (Ada_Mult) then
            Token_Pos_5 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_6 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_6,
                  Expected_Token_Id => Ada_Mult,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_5 := Row_Pos_6 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_5 /= No_Token_Index then

         Row_Pos_6 := Token_Pos_5;

      else
         Row_Pos_6 := No_Token_Index;
         goto Exit_Row_6_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_6_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_6 /= No_Token_Index then

         Transform_Res_5 := Allocate_Op_Mult (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_5, Kind => Ada_Op_Mult, Unit => Parser.Unit,

            Token_Start_Index => Row_Pos_5,
            Token_End_Index   =>
              (if Row_Pos_6 = Row_Pos_5 then No_Token_Index
               else Row_Pos_6 - 1));

         Initialize_Fields_For_Op_Mult (Self => Transform_Res_5);

      end if;

--  End transform_code

      if Row_Pos_6 /= No_Token_Index then
         Or_Pos_3 := Row_Pos_6;
         Or_Res_3 := Transform_Res_5;
         goto Exit_Or_4;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_7 := Row_Pos_5;

--  Start tok_code

      Token_Res_6 := Row_Pos_7;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_6));
      begin
         if T.Kind /= From_Token_Kind (Ada_Divide) then
            Token_Pos_6 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_7 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_7,
                  Expected_Token_Id => Ada_Divide,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_6 := Row_Pos_7 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_6 /= No_Token_Index then

         Row_Pos_7 := Token_Pos_6;

      else
         Row_Pos_7 := No_Token_Index;
         goto Exit_Row_7_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_7_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_7 /= No_Token_Index then

         Transform_Res_6 := Allocate_Op_Div (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_6, Kind => Ada_Op_Div, Unit => Parser.Unit,

            Token_Start_Index => Row_Pos_5,
            Token_End_Index   =>
              (if Row_Pos_7 = Row_Pos_5 then No_Token_Index
               else Row_Pos_7 - 1));

         Initialize_Fields_For_Op_Div (Self => Transform_Res_6);

      end if;

--  End transform_code

      if Row_Pos_7 /= No_Token_Index then
         Or_Pos_3 := Row_Pos_7;
         Or_Res_3 := Transform_Res_6;
         goto Exit_Or_4;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_8 := Row_Pos_5;

--  Start tok_code

      Token_Res_7 := Row_Pos_8;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_7));
      begin
         if T.Kind /= From_Token_Kind (Ada_Mod) then
            Token_Pos_7 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_8 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_8,
                  Expected_Token_Id => Ada_Mod,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_7 := Row_Pos_8 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_7 /= No_Token_Index then

         Row_Pos_8 := Token_Pos_7;

      else
         Row_Pos_8 := No_Token_Index;
         goto Exit_Row_8_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_8_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_8 /= No_Token_Index then

         Transform_Res_7 := Allocate_Op_Mod (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_7, Kind => Ada_Op_Mod, Unit => Parser.Unit,

            Token_Start_Index => Row_Pos_5,
            Token_End_Index   =>
              (if Row_Pos_8 = Row_Pos_5 then No_Token_Index
               else Row_Pos_8 - 1));

         Initialize_Fields_For_Op_Mod (Self => Transform_Res_7);

      end if;

--  End transform_code

      if Row_Pos_8 /= No_Token_Index then
         Or_Pos_3 := Row_Pos_8;
         Or_Res_3 := Transform_Res_7;
         goto Exit_Or_4;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_9 := Row_Pos_5;

--  Start tok_code

      Token_Res_8 := Row_Pos_9;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_8));
      begin
         if T.Kind /= From_Token_Kind (Ada_Rem) then
            Token_Pos_8 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_9 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_9,
                  Expected_Token_Id => Ada_Rem,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_8 := Row_Pos_9 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_8 /= No_Token_Index then

         Row_Pos_9 := Token_Pos_8;

      else
         Row_Pos_9 := No_Token_Index;
         goto Exit_Row_9_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_9_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_9 /= No_Token_Index then

         Transform_Res_8 := Allocate_Op_Rem (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_8, Kind => Ada_Op_Rem, Unit => Parser.Unit,

            Token_Start_Index => Row_Pos_5,
            Token_End_Index   =>
              (if Row_Pos_9 = Row_Pos_5 then No_Token_Index
               else Row_Pos_9 - 1));

         Initialize_Fields_For_Op_Rem (Self => Transform_Res_8);

      end if;

--  End transform_code

      if Row_Pos_9 /= No_Token_Index then
         Or_Pos_3 := Row_Pos_9;
         Or_Res_3 := Transform_Res_8;
         goto Exit_Or_4;
      end if;
      <<Exit_Or_4>>

--  End or_code

      Row_Progress_1 := 2;

      if Or_Pos_3 /= No_Token_Index then

         Row_Pos_5 := Or_Pos_3;

      else
         Row_Pos_5 := No_Token_Index;
         goto Exit_Row_5_0;

      end if;

      Nobt_1 := True;

      Row_Progress_1 := 3;

      if Row_Pos_5 /= No_Token_Index then

         Row_Pos_5 := Row_Pos_5;

      else
         Row_Pos_5 := No_Token_Index;
         goto Exit_Row_5_0;

      end if;

      Defer_Res_9 := Factor_Or_Parse_1 (Parser, Row_Pos_5);
      Defer_Pos_9 := Parser.Current_Pos;

      Row_Progress_1 := 4;

      if Defer_Pos_9 /= No_Token_Index then

         Row_Pos_5 := Defer_Pos_9;

      else
         Row_Pos_5 := No_Token_Index;
         goto Exit_Row_5_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_5_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_5 = No_Token_Index and then Nobt_1 then
         Row_Pos_5              := Parser.Last_Fail.Pos;
         Transform_Has_Failed_1 := True;
      end if;

      if Row_Pos_5 /= No_Token_Index then

         Transform_Res_9 := Allocate_Bin_Op (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_9, Kind => Ada_Bin_Op, Unit => Parser.Unit,

            Token_Start_Index => Pos,
            Token_End_Index   =>
              (if Row_Pos_5 = Pos then No_Token_Index else Row_Pos_5 - 1));

         Initialize_Fields_For_Bin_Op
           (Self        => Transform_Res_9, Bin_Op_F_Left => Defer_Res_8,
            Bin_Op_F_Op => Or_Res_3, Bin_Op_F_Right => Defer_Res_9);

         if Defer_Res_8 /= null and then Is_Incomplete (Defer_Res_8) then
            Transform_Res_9.Last_Attempted_Child := 0;
         elsif Defer_Res_8 /= null and then not Is_Ghost (Defer_Res_8) then
            Transform_Res_9.Last_Attempted_Child := -1;
         end if;
         if Or_Res_3 /= null and then Is_Incomplete (Or_Res_3) then
            Transform_Res_9.Last_Attempted_Child := 0;
         elsif Or_Res_3 /= null and then not Is_Ghost (Or_Res_3) then
            Transform_Res_9.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_9 /= null and then Is_Incomplete (Defer_Res_9) then
            Transform_Res_9.Last_Attempted_Child := 0;
         elsif Defer_Res_9 /= null and then not Is_Ghost (Defer_Res_9) then
            Transform_Res_9.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_1 then
            Transform_Res_9.Last_Attempted_Child := Row_Progress_1;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <term>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      if Row_Pos_5 /= No_Token_Index then
         Or_Pos_4 := Row_Pos_5;
         Or_Res_4 := Transform_Res_9;
         goto Exit_Or_3;
      end if;

      Defer_Res_10 := Factor_Or_Parse_1 (Parser, Pos);
      Defer_Pos_10 := Parser.Current_Pos;

      if Defer_Pos_10 /= No_Token_Index then
         Or_Pos_4 := Defer_Pos_10;
         Or_Res_4 := Defer_Res_10;
         goto Exit_Or_3;
      end if;
      <<Exit_Or_3>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      if Or_Pos_4 > Mem_Pos then
         Mem_Pos := Or_Pos_4;
         Mem_Res := Or_Res_4;
         Set
           (Parser.Private_Part.Term_Or_Parse_1_Memo,
            Or_Pos_4 /= No_Token_Index, Or_Res_4, Pos, Or_Pos_4);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res_4 := Mem_Res;
         Or_Pos_4 := Mem_Pos;
         goto No_Memo;
      end if;

      Set
        (Parser.Private_Part.Term_Or_Parse_1_Memo, Or_Pos_4 /= No_Token_Index,
         Or_Res_4, Pos, Or_Pos_4);

      <<No_Memo>>

      Parser.Current_Pos := Or_Pos_4;

      return Or_Res_4;
   end Term_Or_Parse_1;

   function Unop_Term_Or_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Expr
   is
      use Bare_Expr_Memos;

      Nobt_11                 : Boolean       := False;
      Row_Pos_101             : Token_Index   := No_Token_Index;
      Row_Pos_102             : Token_Index   := No_Token_Index;
      Token_Pos_118           : Token_Index   := No_Token_Index;
      Token_Res_118           : Token_Index   := No_Token_Index;
      Transform_Res_88        : Bare_Op_Plus  := No_Bare_Ada_Node;
      Row_Pos_103             : Token_Index   := No_Token_Index;
      Token_Pos_119           : Token_Index   := No_Token_Index;
      Token_Res_119           : Token_Index   := No_Token_Index;
      Transform_Res_89        : Bare_Op_Minus := No_Bare_Ada_Node;
      Or_Pos_41               : Token_Index   := No_Token_Index;
      Or_Res_41               : Bare_Op       := No_Bare_Ada_Node;
      Defer_Pos_153           : Token_Index   := No_Token_Index;
      Defer_Res_153           : Bare_Expr     := No_Bare_Ada_Node;
      Row_Progress_11         : Integer       := 0;
      Transform_Res_90        : Bare_Un_Op    := No_Bare_Ada_Node;
      Transform_Has_Failed_11 : Boolean       := False;
      Defer_Pos_154           : Token_Index   := No_Token_Index;
      Defer_Res_154           : Bare_Expr     := No_Bare_Ada_Node;
      Or_Pos_42               : Token_Index   := No_Token_Index;
      Or_Res_42               : Bare_Expr     := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Unop_Term_Or_Parse_1_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_42          := M.Instance;
         return Or_Res_42;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_42;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_42 := No_Token_Index;
      Or_Res_42 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_101 := Pos;

--  Start or_code

      Or_Pos_41 := No_Token_Index;
      Or_Res_41 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_102 := Row_Pos_101;

--  Start tok_code

      Token_Res_118 := Row_Pos_102;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_118));
      begin
         if T.Kind /= From_Token_Kind (Ada_Plus) then
            Token_Pos_118 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_102 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_102,
                  Expected_Token_Id => Ada_Plus,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_118 := Row_Pos_102 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_118 /= No_Token_Index then

         Row_Pos_102 := Token_Pos_118;

      else
         Row_Pos_102 := No_Token_Index;
         goto Exit_Row_102_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_102_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_102 /= No_Token_Index then

         Transform_Res_88 := Allocate_Op_Plus (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_88, Kind => Ada_Op_Plus, Unit => Parser.Unit,

            Token_Start_Index => Row_Pos_101,
            Token_End_Index   =>
              (if Row_Pos_102 = Row_Pos_101 then No_Token_Index
               else Row_Pos_102 - 1));

         Initialize_Fields_For_Op_Plus (Self => Transform_Res_88);

      end if;

--  End transform_code

      if Row_Pos_102 /= No_Token_Index then
         Or_Pos_41 := Row_Pos_102;
         Or_Res_41 := Transform_Res_88;
         goto Exit_Or_42;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_103 := Row_Pos_101;

--  Start tok_code

      Token_Res_119 := Row_Pos_103;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_119));
      begin
         if T.Kind /= From_Token_Kind (Ada_Minus) then
            Token_Pos_119 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_103 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_103,
                  Expected_Token_Id => Ada_Minus,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_119 := Row_Pos_103 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_119 /= No_Token_Index then

         Row_Pos_103 := Token_Pos_119;

      else
         Row_Pos_103 := No_Token_Index;
         goto Exit_Row_103_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_103_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_103 /= No_Token_Index then

         Transform_Res_89 := Allocate_Op_Minus (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_89, Kind => Ada_Op_Minus,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_101,
            Token_End_Index =>
              (if Row_Pos_103 = Row_Pos_101 then No_Token_Index
               else Row_Pos_103 - 1));

         Initialize_Fields_For_Op_Minus (Self => Transform_Res_89);

      end if;

--  End transform_code

      if Row_Pos_103 /= No_Token_Index then
         Or_Pos_41 := Row_Pos_103;
         Or_Res_41 := Transform_Res_89;
         goto Exit_Or_42;
      end if;
      <<Exit_Or_42>>

--  End or_code

      Row_Progress_11 := 1;

      if Or_Pos_41 /= No_Token_Index then

         Row_Pos_101 := Or_Pos_41;

      else
         Row_Pos_101 := No_Token_Index;
         goto Exit_Row_101_0;

      end if;

      Nobt_11 := True;

      Row_Progress_11 := 2;

      if Row_Pos_101 /= No_Token_Index then

         Row_Pos_101 := Row_Pos_101;

      else
         Row_Pos_101 := No_Token_Index;
         goto Exit_Row_101_0;

      end if;

      Defer_Res_153 := Term_Or_Parse_1 (Parser, Row_Pos_101);
      Defer_Pos_153 := Parser.Current_Pos;

      Row_Progress_11 := 3;

      if Defer_Pos_153 /= No_Token_Index then

         Row_Pos_101 := Defer_Pos_153;

      else
         Row_Pos_101 := No_Token_Index;
         goto Exit_Row_101_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_101_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_101 = No_Token_Index and then Nobt_11 then
         Row_Pos_101             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_11 := True;
      end if;

      if Row_Pos_101 /= No_Token_Index then

         Transform_Res_90 := Allocate_Un_Op (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_90, Kind => Ada_Un_Op, Unit => Parser.Unit,

            Token_Start_Index => Pos,
            Token_End_Index   =>
              (if Row_Pos_101 = Pos then No_Token_Index else Row_Pos_101 - 1));

         Initialize_Fields_For_Un_Op
           (Self         => Transform_Res_90, Un_Op_F_Op => Or_Res_41,
            Un_Op_F_Expr => Defer_Res_153);

         if Or_Res_41 /= null and then Is_Incomplete (Or_Res_41) then
            Transform_Res_90.Last_Attempted_Child := 0;
         elsif Or_Res_41 /= null and then not Is_Ghost (Or_Res_41) then
            Transform_Res_90.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_153 /= null and then Is_Incomplete (Defer_Res_153) then
            Transform_Res_90.Last_Attempted_Child := 0;
         elsif Defer_Res_153 /= null and then not Is_Ghost (Defer_Res_153) then
            Transform_Res_90.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_11 then
            Transform_Res_90.Last_Attempted_Child := Row_Progress_11;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <unop_term>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      if Row_Pos_101 /= No_Token_Index then
         Or_Pos_42 := Row_Pos_101;
         Or_Res_42 := Transform_Res_90;
         goto Exit_Or_41;
      end if;

      Defer_Res_154 := Term_Or_Parse_1 (Parser, Pos);
      Defer_Pos_154 := Parser.Current_Pos;

      if Defer_Pos_154 /= No_Token_Index then
         Or_Pos_42 := Defer_Pos_154;
         Or_Res_42 := Defer_Res_154;
         goto Exit_Or_41;
      end if;
      <<Exit_Or_41>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Unop_Term_Or_Parse_1_Memo,
         Or_Pos_42 /= No_Token_Index, Or_Res_42, Pos, Or_Pos_42);

      Parser.Current_Pos := Or_Pos_42;

      return Or_Res_42;
   end Unop_Term_Or_Parse_1;

   function Simple_Expr_Or_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Expr
   is
      use Bare_Expr_Memos;

      Nobt_0                 : Boolean        := False;
      Row_Pos_1              : Token_Index    := No_Token_Index;
      Defer_Pos_5            : Token_Index    := No_Token_Index;
      Defer_Res_5            : Bare_Expr      := No_Bare_Ada_Node;
      Row_Pos_2              : Token_Index    := No_Token_Index;
      Token_Pos_2            : Token_Index    := No_Token_Index;
      Token_Res_2            : Token_Index    := No_Token_Index;
      Transform_Res_1        : Bare_Op_Plus   := No_Bare_Ada_Node;
      Row_Pos_3              : Token_Index    := No_Token_Index;
      Token_Pos_3            : Token_Index    := No_Token_Index;
      Token_Res_3            : Token_Index    := No_Token_Index;
      Transform_Res_2        : Bare_Op_Minus  := No_Bare_Ada_Node;
      Row_Pos_4              : Token_Index    := No_Token_Index;
      Token_Pos_4            : Token_Index    := No_Token_Index;
      Token_Res_4            : Token_Index    := No_Token_Index;
      Transform_Res_3        : Bare_Op_Concat := No_Bare_Ada_Node;
      Or_Pos_1               : Token_Index    := No_Token_Index;
      Or_Res_1               : Bare_Op        := No_Bare_Ada_Node;
      Defer_Pos_6            : Token_Index    := No_Token_Index;
      Defer_Res_6            : Bare_Expr      := No_Bare_Ada_Node;
      Row_Progress_0         : Integer        := 0;
      Transform_Res_4        : Bare_Bin_Op    := No_Bare_Ada_Node;
      Transform_Has_Failed_0 : Boolean        := False;
      Defer_Pos_7            : Token_Index    := No_Token_Index;
      Defer_Res_7            : Bare_Expr      := No_Bare_Ada_Node;
      Or_Pos_2               : Token_Index    := No_Token_Index;
      Or_Res_2               : Bare_Expr      := No_Bare_Ada_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Expr   := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Simple_Expr_Or_Parse_1_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_2           := M.Instance;
         return Or_Res_2;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_2;
      end if;

      Set
        (Parser.Private_Part.Simple_Expr_Or_Parse_1_Memo, False, Or_Res_2, Pos,
         Mem_Pos);

      <<Try_Again>>

      Nobt_0 := False;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_2 := No_Token_Index;
      Or_Res_2 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_1 := Pos;

      Defer_Res_5 := Simple_Expr_Or_Parse_1 (Parser, Row_Pos_1);
      Defer_Pos_5 := Parser.Current_Pos;

      Row_Progress_0 := 1;

      if Defer_Pos_5 /= No_Token_Index then

         Row_Pos_1 := Defer_Pos_5;

      else
         Row_Pos_1 := No_Token_Index;
         goto Exit_Row_1_0;

      end if;

--  Start or_code

      Or_Pos_1 := No_Token_Index;
      Or_Res_1 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_2 := Row_Pos_1;

--  Start tok_code

      Token_Res_2 := Row_Pos_2;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_2));
      begin
         if T.Kind /= From_Token_Kind (Ada_Plus) then
            Token_Pos_2 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_2 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_2,
                  Expected_Token_Id => Ada_Plus,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_2 := Row_Pos_2 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_2 /= No_Token_Index then

         Row_Pos_2 := Token_Pos_2;

      else
         Row_Pos_2 := No_Token_Index;
         goto Exit_Row_2_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_2_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_2 /= No_Token_Index then

         Transform_Res_1 := Allocate_Op_Plus (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_1, Kind => Ada_Op_Plus, Unit => Parser.Unit,

            Token_Start_Index => Row_Pos_1,
            Token_End_Index   =>
              (if Row_Pos_2 = Row_Pos_1 then No_Token_Index
               else Row_Pos_2 - 1));

         Initialize_Fields_For_Op_Plus (Self => Transform_Res_1);

      end if;

--  End transform_code

      if Row_Pos_2 /= No_Token_Index then
         Or_Pos_1 := Row_Pos_2;
         Or_Res_1 := Transform_Res_1;
         goto Exit_Or_2;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_3 := Row_Pos_1;

--  Start tok_code

      Token_Res_3 := Row_Pos_3;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_3));
      begin
         if T.Kind /= From_Token_Kind (Ada_Minus) then
            Token_Pos_3 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_3 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_3,
                  Expected_Token_Id => Ada_Minus,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_3 := Row_Pos_3 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_3 /= No_Token_Index then

         Row_Pos_3 := Token_Pos_3;

      else
         Row_Pos_3 := No_Token_Index;
         goto Exit_Row_3_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_3_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_3 /= No_Token_Index then

         Transform_Res_2 := Allocate_Op_Minus (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_2, Kind => Ada_Op_Minus, Unit => Parser.Unit,

            Token_Start_Index => Row_Pos_1,
            Token_End_Index   =>
              (if Row_Pos_3 = Row_Pos_1 then No_Token_Index
               else Row_Pos_3 - 1));

         Initialize_Fields_For_Op_Minus (Self => Transform_Res_2);

      end if;

--  End transform_code

      if Row_Pos_3 /= No_Token_Index then
         Or_Pos_1 := Row_Pos_3;
         Or_Res_1 := Transform_Res_2;
         goto Exit_Or_2;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_4 := Row_Pos_1;

--  Start tok_code

      Token_Res_4 := Row_Pos_4;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_4));
      begin
         if T.Kind /= From_Token_Kind (Ada_Amp) then
            Token_Pos_4 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_4 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_4,
                  Expected_Token_Id => Ada_Amp,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_4 := Row_Pos_4 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_4 /= No_Token_Index then

         Row_Pos_4 := Token_Pos_4;

      else
         Row_Pos_4 := No_Token_Index;
         goto Exit_Row_4_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_4_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_4 /= No_Token_Index then

         Transform_Res_3 := Allocate_Op_Concat (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_3, Kind => Ada_Op_Concat,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_1,
            Token_End_Index =>
              (if Row_Pos_4 = Row_Pos_1 then No_Token_Index
               else Row_Pos_4 - 1));

         Initialize_Fields_For_Op_Concat (Self => Transform_Res_3);

      end if;

--  End transform_code

      if Row_Pos_4 /= No_Token_Index then
         Or_Pos_1 := Row_Pos_4;
         Or_Res_1 := Transform_Res_3;
         goto Exit_Or_2;
      end if;
      <<Exit_Or_2>>

--  End or_code

      Row_Progress_0 := 2;

      if Or_Pos_1 /= No_Token_Index then

         Row_Pos_1 := Or_Pos_1;

      else
         Row_Pos_1 := No_Token_Index;
         goto Exit_Row_1_0;

      end if;

      Nobt_0 := True;

      Row_Progress_0 := 3;

      if Row_Pos_1 /= No_Token_Index then

         Row_Pos_1 := Row_Pos_1;

      else
         Row_Pos_1 := No_Token_Index;
         goto Exit_Row_1_0;

      end if;

      Defer_Res_6 := Term_Or_Parse_1 (Parser, Row_Pos_1);
      Defer_Pos_6 := Parser.Current_Pos;

      Row_Progress_0 := 4;

      if Defer_Pos_6 /= No_Token_Index then

         Row_Pos_1 := Defer_Pos_6;

      else
         Row_Pos_1 := No_Token_Index;
         goto Exit_Row_1_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_1_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_1 = No_Token_Index and then Nobt_0 then
         Row_Pos_1              := Parser.Last_Fail.Pos;
         Transform_Has_Failed_0 := True;
      end if;

      if Row_Pos_1 /= No_Token_Index then

         Transform_Res_4 := Allocate_Bin_Op (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_4, Kind => Ada_Bin_Op, Unit => Parser.Unit,

            Token_Start_Index => Pos,
            Token_End_Index   =>
              (if Row_Pos_1 = Pos then No_Token_Index else Row_Pos_1 - 1));

         Initialize_Fields_For_Bin_Op
           (Self        => Transform_Res_4, Bin_Op_F_Left => Defer_Res_5,
            Bin_Op_F_Op => Or_Res_1, Bin_Op_F_Right => Defer_Res_6);

         if Defer_Res_5 /= null and then Is_Incomplete (Defer_Res_5) then
            Transform_Res_4.Last_Attempted_Child := 0;
         elsif Defer_Res_5 /= null and then not Is_Ghost (Defer_Res_5) then
            Transform_Res_4.Last_Attempted_Child := -1;
         end if;
         if Or_Res_1 /= null and then Is_Incomplete (Or_Res_1) then
            Transform_Res_4.Last_Attempted_Child := 0;
         elsif Or_Res_1 /= null and then not Is_Ghost (Or_Res_1) then
            Transform_Res_4.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_6 /= null and then Is_Incomplete (Defer_Res_6) then
            Transform_Res_4.Last_Attempted_Child := 0;
         elsif Defer_Res_6 /= null and then not Is_Ghost (Defer_Res_6) then
            Transform_Res_4.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_0 then
            Transform_Res_4.Last_Attempted_Child := Row_Progress_0;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <simple_expr>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      if Row_Pos_1 /= No_Token_Index then
         Or_Pos_2 := Row_Pos_1;
         Or_Res_2 := Transform_Res_4;
         goto Exit_Or_1;
      end if;

      Defer_Res_7 := Unop_Term_Or_Parse_1 (Parser, Pos);
      Defer_Pos_7 := Parser.Current_Pos;

      if Defer_Pos_7 /= No_Token_Index then
         Or_Pos_2 := Defer_Pos_7;
         Or_Res_2 := Defer_Res_7;
         goto Exit_Or_1;
      end if;
      <<Exit_Or_1>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      if Or_Pos_2 > Mem_Pos then
         Mem_Pos := Or_Pos_2;
         Mem_Res := Or_Res_2;
         Set
           (Parser.Private_Part.Simple_Expr_Or_Parse_1_Memo,
            Or_Pos_2 /= No_Token_Index, Or_Res_2, Pos, Or_Pos_2);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res_2 := Mem_Res;
         Or_Pos_2 := Mem_Pos;
         goto No_Memo;
      end if;

      Set
        (Parser.Private_Part.Simple_Expr_Or_Parse_1_Memo,
         Or_Pos_2 /= No_Token_Index, Or_Res_2, Pos, Or_Pos_2);

      <<No_Memo>>

      Parser.Current_Pos := Or_Pos_2;

      return Or_Res_2;
   end Simple_Expr_Or_Parse_1;

   function Sexpr_Or_Box_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Expr
   is
      use Bare_Expr_Memos;

      Defer_Pos_3 : Token_Index   := No_Token_Index;
      Defer_Res_3 : Bare_Expr     := No_Bare_Ada_Node;
      Defer_Pos_4 : Token_Index   := No_Token_Index;
      Defer_Res_4 : Bare_Box_Expr := No_Bare_Ada_Node;
      Or_Pos_0    : Token_Index   := No_Token_Index;
      Or_Res_0    : Bare_Expr     := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Sexpr_Or_Box_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_0           := M.Instance;
         return Or_Res_0;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_0;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_0 := No_Token_Index;
      Or_Res_0 := No_Bare_Ada_Node;

      Defer_Res_3 := Simple_Expr_Or_Parse_1 (Parser, Pos);
      Defer_Pos_3 := Parser.Current_Pos;

      if Defer_Pos_3 /= No_Token_Index then
         Or_Pos_0 := Defer_Pos_3;
         Or_Res_0 := Defer_Res_3;
         goto Exit_Or_0;
      end if;

      Defer_Res_4 := Box_Expr_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_4 := Parser.Current_Pos;

      if Defer_Pos_4 /= No_Token_Index then
         Or_Pos_0 := Defer_Pos_4;
         Or_Res_0 := Defer_Res_4;
         goto Exit_Or_0;
      end if;
      <<Exit_Or_0>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Sexpr_Or_Box_Or_Parse_0_Memo,
         Or_Pos_0 /= No_Token_Index, Or_Res_0, Pos, Or_Pos_0);

      Parser.Current_Pos := Or_Pos_0;

      return Or_Res_0;
   end Sexpr_Or_Box_Or_Parse_0;

   function Decimal_Fixed_Point_Def_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Decimal_Fixed_Point_Def
   is
      use Bare_Decimal_Fixed_Point_Def_Memos;

      Row_Pos_0       : Token_Index                  := No_Token_Index;
      Token_Pos_0     : Token_Index                  := No_Token_Index;
      Token_Res_0     : Token_Index                  := No_Token_Index;
      Defer_Pos_0     : Token_Index                  := No_Token_Index;
      Defer_Res_0     : Bare_Expr                    := No_Bare_Ada_Node;
      Token_Pos_1     : Token_Index                  := No_Token_Index;
      Token_Res_1     : Token_Index                  := No_Token_Index;
      Defer_Pos_1     : Token_Index                  := No_Token_Index;
      Defer_Res_1     : Bare_Expr                    := No_Bare_Ada_Node;
      Defer_Pos_2     : Token_Index                  := No_Token_Index;
      Defer_Res_2     : Bare_Range_Spec              := No_Bare_Ada_Node;
      Transform_Res_0 : Bare_Decimal_Fixed_Point_Def := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Decimal_Fixed_Point_Def_Transform_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_0    := M.Instance;
         return Transform_Res_0;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_0;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_0 := Pos;

--  Start tok_code

      Token_Res_0 := Row_Pos_0;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_0));
      begin
         if T.Kind /= From_Token_Kind (Ada_Delta) then
            Token_Pos_0 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_0 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_0,
                  Expected_Token_Id => Ada_Delta,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_0 := Row_Pos_0 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_0 /= No_Token_Index then

         Row_Pos_0 := Token_Pos_0;

      else
         Row_Pos_0 := No_Token_Index;
         goto Exit_Row_0_0;

      end if;

      Defer_Res_0 := Sexpr_Or_Box_Or_Parse_0 (Parser, Row_Pos_0);
      Defer_Pos_0 := Parser.Current_Pos;

      if Defer_Pos_0 /= No_Token_Index then

         Row_Pos_0 := Defer_Pos_0;

      else
         Row_Pos_0 := No_Token_Index;
         goto Exit_Row_0_0;

      end if;

--  Start tok_code

      Token_Res_1 := Row_Pos_0;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_1));
      begin
         if T.Kind /= From_Token_Kind (Ada_Digits) then
            Token_Pos_1 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_0 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_0,
                  Expected_Token_Id => Ada_Digits,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_1 := Row_Pos_0 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_1 /= No_Token_Index then

         Row_Pos_0 := Token_Pos_1;

      else
         Row_Pos_0 := No_Token_Index;
         goto Exit_Row_0_0;

      end if;

      Defer_Res_1 := Sexpr_Or_Box_Or_Parse_0 (Parser, Row_Pos_0);
      Defer_Pos_1 := Parser.Current_Pos;

      if Defer_Pos_1 /= No_Token_Index then

         Row_Pos_0 := Defer_Pos_1;

      else
         Row_Pos_0 := No_Token_Index;
         goto Exit_Row_0_0;

      end if;

--  Start opt_code

      Defer_Res_2 := Range_Spec_Transform_Parse_0 (Parser, Row_Pos_0);
      Defer_Pos_2 := Parser.Current_Pos;

      if Defer_Pos_2 = No_Token_Index then

         Defer_Res_2 := No_Bare_Ada_Node;

         Defer_Pos_2 := Row_Pos_0;

      end if;

--  End opt_code

      if Defer_Pos_2 /= No_Token_Index then

         Row_Pos_0 := Defer_Pos_2;

      else
         Row_Pos_0 := No_Token_Index;
         goto Exit_Row_0_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_0_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_0 /= No_Token_Index then

         Transform_Res_0 := Allocate_Decimal_Fixed_Point_Def (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_0, Kind => Ada_Decimal_Fixed_Point_Def,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_0 = Pos then No_Token_Index else Row_Pos_0 - 1));

         Initialize_Fields_For_Decimal_Fixed_Point_Def
           (Self                             => Transform_Res_0,
            Decimal_Fixed_Point_Def_F_Delta  => Defer_Res_0,
            Decimal_Fixed_Point_Def_F_Digits => Defer_Res_1,
            Decimal_Fixed_Point_Def_F_Range  => Defer_Res_2);

         if Defer_Res_0 /= null and then Is_Incomplete (Defer_Res_0) then
            Transform_Res_0.Last_Attempted_Child := 0;
         elsif Defer_Res_0 /= null and then not Is_Ghost (Defer_Res_0) then
            Transform_Res_0.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_1 /= null and then Is_Incomplete (Defer_Res_1) then
            Transform_Res_0.Last_Attempted_Child := 0;
         elsif Defer_Res_1 /= null and then not Is_Ghost (Defer_Res_1) then
            Transform_Res_0.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_2 /= null and then Is_Incomplete (Defer_Res_2) then
            Transform_Res_0.Last_Attempted_Child := 0;
         elsif Defer_Res_2 /= null and then not Is_Ghost (Defer_Res_2) then
            Transform_Res_0.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Decimal_Fixed_Point_Def_Transform_Parse_0_Memo,
         Row_Pos_0 /= No_Token_Index, Transform_Res_0, Pos, Row_Pos_0);

      Parser.Current_Pos := Row_Pos_0;

      return Transform_Res_0;
   end Decimal_Fixed_Point_Def_Transform_Parse_0;

   function Dontskip_Generic_Decl_0_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Row_Pos_104   : Token_Index   := No_Token_Index;
      Null_Res_6    : Bare_Ada_Node := No_Bare_Ada_Node;
      Token_Pos_120 : Token_Index   := No_Token_Index;
      Token_Res_120 : Token_Index   := No_Token_Index;
      Token_Pos_121 : Token_Index   := No_Token_Index;
      Token_Res_121 : Token_Index   := No_Token_Index;
      Or_Pos_43     : Token_Index   := No_Token_Index;
      Or_Res_43     : Token_Index   := No_Token_Index;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Dontskip_Generic_Decl_0_Extract_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Null_Res_6         := M.Instance;
         return Null_Res_6;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Null_Res_6;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start row_code

      Row_Pos_104 := Pos;

      Null_Res_6 := No_Bare_Ada_Node;

      if Row_Pos_104 /= No_Token_Index then

         Row_Pos_104 := Row_Pos_104;

      else
         Row_Pos_104 := No_Token_Index;
         goto Exit_Row_104_0;

      end if;

--  Start or_code

      Or_Pos_43 := No_Token_Index;
      Or_Res_43 := No_Token_Index;

--  Start tok_code

      Token_Res_120 := Row_Pos_104;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_120));
      begin
         if T.Kind /= From_Token_Kind (Ada_Private) then
            Token_Pos_120 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_104 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_104,
                  Expected_Token_Id => Ada_Private,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_120 := Row_Pos_104 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_120 /= No_Token_Index then
         Or_Pos_43 := Token_Pos_120;
         Or_Res_43 := Token_Res_120;
         goto Exit_Or_43;
      end if;

--  Start tok_code

      Token_Res_121 := Row_Pos_104;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_121));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_121 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_104 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_104,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_121 := Row_Pos_104 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_121 /= No_Token_Index then
         Or_Pos_43 := Token_Pos_121;
         Or_Res_43 := Token_Res_121;
         goto Exit_Or_43;
      end if;
      <<Exit_Or_43>>

--  End or_code

      if Or_Pos_43 /= No_Token_Index then

         Row_Pos_104 := Or_Pos_43;

      else
         Row_Pos_104 := No_Token_Index;
         goto Exit_Row_104_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_104_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Dontskip_Generic_Decl_0_Extract_Parse_0_Memo,
         Row_Pos_104 /= No_Token_Index, Null_Res_6, Pos, Row_Pos_104);

      Parser.Current_Pos := Row_Pos_104;

      return Null_Res_6;
   end Dontskip_Generic_Decl_0_Extract_Parse_0;

   function Contract_Case_Assoc_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Contract_Case_Assoc
   is
      use Bare_Contract_Case_Assoc_Memos;

      Row_Pos_109      : Token_Index              := No_Token_Index;
      Defer_Pos_160    : Token_Index              := No_Token_Index;
      Defer_Res_160    : Bare_Expr                := No_Bare_Ada_Node;
      Defer_Pos_161    : Token_Index              := No_Token_Index;
      Defer_Res_161    : Bare_Others_Designator   := No_Bare_Ada_Node;
      Or_Pos_45        : Token_Index              := No_Token_Index;
      Or_Res_45        : Bare_Ada_Node            := No_Bare_Ada_Node;
      Token_Pos_128    : Token_Index              := No_Token_Index;
      Token_Res_128    : Token_Index              := No_Token_Index;
      Defer_Pos_162    : Token_Index              := No_Token_Index;
      Defer_Res_162    : Bare_Expr                := No_Bare_Ada_Node;
      Transform_Res_94 : Bare_Contract_Case_Assoc := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Contract_Case_Assoc_Transform_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_94   := M.Instance;
         return Transform_Res_94;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_94;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_109 := Pos;

--  Start or_code

      Or_Pos_45 := No_Token_Index;
      Or_Res_45 := No_Bare_Ada_Node;

      Defer_Res_160 := Expr_Or_Parse_0 (Parser, Row_Pos_109);
      Defer_Pos_160 := Parser.Current_Pos;

      if Defer_Pos_160 /= No_Token_Index then
         Or_Pos_45 := Defer_Pos_160;
         Or_Res_45 := Defer_Res_160;
         goto Exit_Or_45;
      end if;

      Defer_Res_161 :=
        Others_Designator_Transform_Parse_0 (Parser, Row_Pos_109);
      Defer_Pos_161 := Parser.Current_Pos;

      if Defer_Pos_161 /= No_Token_Index then
         Or_Pos_45 := Defer_Pos_161;
         Or_Res_45 := Defer_Res_161;
         goto Exit_Or_45;
      end if;
      <<Exit_Or_45>>

--  End or_code

      if Or_Pos_45 /= No_Token_Index then

         Row_Pos_109 := Or_Pos_45;

      else
         Row_Pos_109 := No_Token_Index;
         goto Exit_Row_109_0;

      end if;

--  Start tok_code

      Token_Res_128 := Row_Pos_109;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_128));
      begin
         if T.Kind /= From_Token_Kind (Ada_Arrow) then
            Token_Pos_128 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_109 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_109,
                  Expected_Token_Id => Ada_Arrow,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_128 := Row_Pos_109 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_128 /= No_Token_Index then

         Row_Pos_109 := Token_Pos_128;

      else
         Row_Pos_109 := No_Token_Index;
         goto Exit_Row_109_0;

      end if;

      Defer_Res_162 := Expr_Or_Parse_0 (Parser, Row_Pos_109);
      Defer_Pos_162 := Parser.Current_Pos;

      if Defer_Pos_162 /= No_Token_Index then

         Row_Pos_109 := Defer_Pos_162;

      else
         Row_Pos_109 := No_Token_Index;
         goto Exit_Row_109_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_109_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_109 /= No_Token_Index then

         Transform_Res_94 := Allocate_Contract_Case_Assoc (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_94, Kind => Ada_Contract_Case_Assoc,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_109 = Pos then No_Token_Index else Row_Pos_109 - 1));

         Initialize_Fields_For_Contract_Case_Assoc
           (Self => Transform_Res_94, Contract_Case_Assoc_F_Guard => Or_Res_45,
            Contract_Case_Assoc_F_Consequence => Defer_Res_162);

         if Or_Res_45 /= null and then Is_Incomplete (Or_Res_45) then
            Transform_Res_94.Last_Attempted_Child := 0;
         elsif Or_Res_45 /= null and then not Is_Ghost (Or_Res_45) then
            Transform_Res_94.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_162 /= null and then Is_Incomplete (Defer_Res_162) then
            Transform_Res_94.Last_Attempted_Child := 0;
         elsif Defer_Res_162 /= null and then not Is_Ghost (Defer_Res_162) then
            Transform_Res_94.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Contract_Case_Assoc_Transform_Parse_0_Memo,
         Row_Pos_109 /= No_Token_Index, Transform_Res_94, Pos, Row_Pos_109);

      Parser.Current_Pos := Row_Pos_109;

      return Transform_Res_94;
   end Contract_Case_Assoc_Transform_Parse_0;

   function Contract_Cases_Expr_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Contract_Cases
   is
      use Bare_Contract_Cases_Memos;

      Row_Pos_108      : Token_Index                   := No_Token_Index;
      Token_Pos_125    : Token_Index                   := No_Token_Index;
      Token_Res_125    : Token_Index                   := No_Token_Index;
      Lst_Cpos_12      : Token_Index                   := No_Token_Index;
      Tmp_List_12      : Free_Parse_List;
      Defer_Pos_159    : Token_Index                   := No_Token_Index;
      Defer_Res_159    : Bare_Contract_Case_Assoc      := No_Bare_Ada_Node;
      Token_Pos_126    : Token_Index                   := No_Token_Index;
      Token_Res_126    : Token_Index                   := No_Token_Index;
      List_Pos_12      : Token_Index                   := No_Token_Index;
      List_Res_12      : Bare_Contract_Case_Assoc_List := No_Bare_Ada_Node;
      Token_Pos_127    : Token_Index                   := No_Token_Index;
      Token_Res_127    : Token_Index                   := No_Token_Index;
      Transform_Res_93 : Bare_Contract_Cases           := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Contract_Cases_Expr_Transform_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_93   := M.Instance;
         return Transform_Res_93;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_93;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_108 := Pos;

--  Start tok_code

      Token_Res_125 := Row_Pos_108;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_125));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Open) then
            Token_Pos_125 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_108 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_108,
                  Expected_Token_Id => Ada_Par_Open,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_125 := Row_Pos_108 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_125 /= No_Token_Index then

         Row_Pos_108 := Token_Pos_125;

      else
         Row_Pos_108 := No_Token_Index;
         goto Exit_Row_108_0;

      end if;

--  Start list_code

      List_Pos_12 := No_Token_Index;

      Lst_Cpos_12 := Row_Pos_108;
      Tmp_List_12 := Get_Parse_List (Parser);

      loop

         Defer_Res_159 :=
           Contract_Case_Assoc_Transform_Parse_0 (Parser, Lst_Cpos_12);
         Defer_Pos_159 := Parser.Current_Pos;

         exit when Defer_Pos_159 = No_Token_Index;

         List_Pos_12 := Defer_Pos_159;
         Lst_Cpos_12 := List_Pos_12;

         Tmp_List_12.Nodes.Append (Defer_Res_159);

--  Start tok_code

         Token_Res_126 := Lst_Cpos_12;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_126));
         begin
            if T.Kind /= From_Token_Kind (Ada_Comma) then
               Token_Pos_126 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_12 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_12,
                     Expected_Token_Id => Ada_Comma,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_126 := Lst_Cpos_12 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_126 /= No_Token_Index then
            Lst_Cpos_12 := Token_Pos_126;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_12.Nodes.Length;
      begin
         List_Res_12 := Allocate_Contract_Case_Assoc_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_108;
            Token_End   :=
              (if Lst_Cpos_12 = Row_Pos_108 then Row_Pos_108
               else Lst_Cpos_12 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_108, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self => List_Res_12, Kind => Ada_Contract_Case_Assoc_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_12, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_12.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_12.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_12);

--  End list_code

      if List_Pos_12 /= No_Token_Index then

         Row_Pos_108 := List_Pos_12;

      else
         Row_Pos_108 := No_Token_Index;
         goto Exit_Row_108_0;

      end if;

--  Start tok_code

      Token_Res_127 := Row_Pos_108;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_127));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Close) then
            Token_Pos_127 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_108 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_108,
                  Expected_Token_Id => Ada_Par_Close,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_127 := Row_Pos_108 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_127 /= No_Token_Index then

         Row_Pos_108 := Token_Pos_127;

      else
         Row_Pos_108 := No_Token_Index;
         goto Exit_Row_108_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_108_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_108 /= No_Token_Index then

         Transform_Res_93 := Allocate_Contract_Cases (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_93, Kind => Ada_Contract_Cases,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_108 = Pos then No_Token_Index else Row_Pos_108 - 1));

         Initialize_Fields_For_Contract_Cases
           (Self                            => Transform_Res_93,
            Contract_Cases_F_Contract_Cases => List_Res_12);

         if List_Res_12 /= null and then Is_Incomplete (List_Res_12) then
            Transform_Res_93.Last_Attempted_Child := 0;
         elsif List_Res_12 /= null and then not Is_Ghost (List_Res_12) then
            Transform_Res_93.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Contract_Cases_Expr_Transform_Parse_0_Memo,
         Row_Pos_108 /= No_Token_Index, Transform_Res_93, Pos, Row_Pos_108);

      Parser.Current_Pos := Row_Pos_108;

      return Transform_Res_93;
   end Contract_Cases_Expr_Transform_Parse_0;

   function Aspect_Assoc_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Aspect_Assoc
   is
      use Bare_Aspect_Assoc_Memos;

      Row_Pos_106      : Token_Index         := No_Token_Index;
      Defer_Pos_156    : Token_Index         := No_Token_Index;
      Defer_Res_156    : Bare_Name           := No_Bare_Ada_Node;
      Row_Pos_107      : Token_Index         := No_Token_Index;
      Token_Pos_124    : Token_Index         := No_Token_Index;
      Token_Res_124    : Token_Index         := No_Token_Index;
      Defer_Pos_157    : Token_Index         := No_Token_Index;
      Defer_Res_157    : Bare_Expr           := No_Bare_Ada_Node;
      Defer_Pos_158    : Token_Index         := No_Token_Index;
      Defer_Res_158    : Bare_Contract_Cases := No_Bare_Ada_Node;
      Or_Pos_44        : Token_Index         := No_Token_Index;
      Or_Res_44        : Bare_Expr           := No_Bare_Ada_Node;
      Transform_Res_92 : Bare_Aspect_Assoc   := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Aspect_Assoc_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_92   := M.Instance;
         return Transform_Res_92;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_92;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_106 := Pos;

      Defer_Res_156 := Name_Or_Parse_1 (Parser, Row_Pos_106);
      Defer_Pos_156 := Parser.Current_Pos;

      if Defer_Pos_156 /= No_Token_Index then

         Row_Pos_106 := Defer_Pos_156;

      else
         Row_Pos_106 := No_Token_Index;
         goto Exit_Row_106_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_107 := Row_Pos_106;

--  Start tok_code

      Token_Res_124 := Row_Pos_107;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_124));
      begin
         if T.Kind /= From_Token_Kind (Ada_Arrow) then
            Token_Pos_124 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_107 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_107,
                  Expected_Token_Id => Ada_Arrow,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_124 := Row_Pos_107 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_124 /= No_Token_Index then

         Row_Pos_107 := Token_Pos_124;

      else
         Row_Pos_107 := No_Token_Index;
         goto Exit_Row_107_0;

      end if;

--  Start or_code

      Or_Pos_44 := No_Token_Index;
      Or_Res_44 := No_Bare_Ada_Node;

      Defer_Res_157 := Expr_Or_Parse_0 (Parser, Row_Pos_107);
      Defer_Pos_157 := Parser.Current_Pos;

      if Defer_Pos_157 /= No_Token_Index then
         Or_Pos_44 := Defer_Pos_157;
         Or_Res_44 := Defer_Res_157;
         goto Exit_Or_44;
      end if;

      Defer_Res_158 :=
        Contract_Cases_Expr_Transform_Parse_0 (Parser, Row_Pos_107);
      Defer_Pos_158 := Parser.Current_Pos;

      if Defer_Pos_158 /= No_Token_Index then
         Or_Pos_44 := Defer_Pos_158;
         Or_Res_44 := Defer_Res_158;
         goto Exit_Or_44;
      end if;
      <<Exit_Or_44>>

--  End or_code

      if Or_Pos_44 /= No_Token_Index then

         Row_Pos_107 := Or_Pos_44;

      else
         Row_Pos_107 := No_Token_Index;
         goto Exit_Row_107_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_107_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_107 = No_Token_Index then

         Or_Res_44 := No_Bare_Ada_Node;

         Row_Pos_107 := Row_Pos_106;

      end if;

--  End opt_code

      if Row_Pos_107 /= No_Token_Index then

         Row_Pos_106 := Row_Pos_107;

      else
         Row_Pos_106 := No_Token_Index;
         goto Exit_Row_106_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_106_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_106 /= No_Token_Index then

         Transform_Res_92 := Allocate_Aspect_Assoc (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_92, Kind => Ada_Aspect_Assoc,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_106 = Pos then No_Token_Index else Row_Pos_106 - 1));

         Initialize_Fields_For_Aspect_Assoc
           (Self => Transform_Res_92, Aspect_Assoc_F_Id => Defer_Res_156,
            Aspect_Assoc_F_Expr => Or_Res_44);

         if Defer_Res_156 /= null and then Is_Incomplete (Defer_Res_156) then
            Transform_Res_92.Last_Attempted_Child := 0;
         elsif Defer_Res_156 /= null and then not Is_Ghost (Defer_Res_156) then
            Transform_Res_92.Last_Attempted_Child := -1;
         end if;
         if Or_Res_44 /= null and then Is_Incomplete (Or_Res_44) then
            Transform_Res_92.Last_Attempted_Child := 0;
         elsif Or_Res_44 /= null and then not Is_Ghost (Or_Res_44) then
            Transform_Res_92.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Aspect_Assoc_Transform_Parse_0_Memo,
         Row_Pos_106 /= No_Token_Index, Transform_Res_92, Pos, Row_Pos_106);

      Parser.Current_Pos := Row_Pos_106;

      return Transform_Res_92;
   end Aspect_Assoc_Transform_Parse_0;

   function Aspect_Spec_Opt_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Aspect_Spec
   is
      use Bare_Aspect_Spec_Memos;

      Row_Pos_105      : Token_Index            := No_Token_Index;
      Token_Pos_122    : Token_Index            := No_Token_Index;
      Token_Res_122    : Token_Index            := No_Token_Index;
      Lst_Cpos_11      : Token_Index            := No_Token_Index;
      Tmp_List_11      : Free_Parse_List;
      Defer_Pos_155    : Token_Index            := No_Token_Index;
      Defer_Res_155    : Bare_Aspect_Assoc      := No_Bare_Ada_Node;
      Token_Pos_123    : Token_Index            := No_Token_Index;
      Token_Res_123    : Token_Index            := No_Token_Index;
      List_Pos_11      : Token_Index            := No_Token_Index;
      List_Res_11      : Bare_Aspect_Assoc_List := No_Bare_Ada_Node;
      Transform_Res_91 : Bare_Aspect_Spec       := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Aspect_Spec_Opt_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_91   := M.Instance;
         return Transform_Res_91;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_91;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start opt_code

--  Start transform_code

--  Start row_code

      Row_Pos_105 := Pos;

--  Start tok_code

      Token_Res_122 := Row_Pos_105;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_122));
      begin
         if T.Kind /= From_Token_Kind (Ada_With) then
            Token_Pos_122 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_105 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_105,
                  Expected_Token_Id => Ada_With,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_122 := Row_Pos_105 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_122 /= No_Token_Index then

         Row_Pos_105 := Token_Pos_122;

      else
         Row_Pos_105 := No_Token_Index;
         goto Exit_Row_105_0;

      end if;

--  Start list_code

      List_Pos_11 := No_Token_Index;

      Lst_Cpos_11 := Row_Pos_105;
      Tmp_List_11 := Get_Parse_List (Parser);

      loop

         Defer_Res_155 := Aspect_Assoc_Transform_Parse_0 (Parser, Lst_Cpos_11);
         Defer_Pos_155 := Parser.Current_Pos;

         exit when Defer_Pos_155 = No_Token_Index;

         List_Pos_11 := Defer_Pos_155;
         Lst_Cpos_11 := List_Pos_11;

         Tmp_List_11.Nodes.Append (Defer_Res_155);

--  Start tok_code

         Token_Res_123 := Lst_Cpos_11;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_123));
         begin
            if T.Kind /= From_Token_Kind (Ada_Comma) then
               Token_Pos_123 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_11 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_11,
                     Expected_Token_Id => Ada_Comma,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_123 := Lst_Cpos_11 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_123 /= No_Token_Index then
            Lst_Cpos_11 := Token_Pos_123;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_11.Nodes.Length;
      begin
         List_Res_11 := Allocate_Aspect_Assoc_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_105;
            Token_End   :=
              (if Lst_Cpos_11 = Row_Pos_105 then Row_Pos_105
               else Lst_Cpos_11 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_105, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self            => List_Res_11, Kind => Ada_Aspect_Assoc_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_11, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_11.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_11.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_11);

--  End list_code

      if List_Pos_11 /= No_Token_Index then

         Row_Pos_105 := List_Pos_11;

      else
         Row_Pos_105 := No_Token_Index;
         goto Exit_Row_105_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_105_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_105 /= No_Token_Index then

         Transform_Res_91 := Allocate_Aspect_Spec (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_91, Kind => Ada_Aspect_Spec,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_105 = Pos then No_Token_Index else Row_Pos_105 - 1));

         Initialize_Fields_For_Aspect_Spec
           (Self                        => Transform_Res_91,
            Aspect_Spec_F_Aspect_Assocs => List_Res_11);

         if List_Res_11 /= null and then Is_Incomplete (List_Res_11) then
            Transform_Res_91.Last_Attempted_Child := 0;
         elsif List_Res_11 /= null and then not Is_Ghost (List_Res_11) then
            Transform_Res_91.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_105 = No_Token_Index then

         Transform_Res_91 := No_Bare_Ada_Node;

         Row_Pos_105 := Pos;

      end if;

--  End opt_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Aspect_Spec_Opt_Parse_0_Memo,
         Row_Pos_105 /= No_Token_Index, Transform_Res_91, Pos, Row_Pos_105);

      Parser.Current_Pos := Row_Pos_105;

      return Transform_Res_91;
   end Aspect_Spec_Opt_Parse_0;

   function Overriding_Indicator_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Overriding_Node
   is
      use Bare_Overriding_Node_Memos;

      Row_Pos_111      : Token_Index                    := No_Token_Index;
      Token_Pos_130    : Token_Index                    := No_Token_Index;
      Token_Res_130    : Token_Index                    := No_Token_Index;
      Transform_Res_96 : Bare_Overriding_Overriding     := No_Bare_Ada_Node;
      Row_Pos_112      : Token_Index                    := No_Token_Index;
      Token_Pos_131    : Token_Index                    := No_Token_Index;
      Token_Res_131    : Token_Index                    := No_Token_Index;
      Token_Pos_132    : Token_Index                    := No_Token_Index;
      Token_Res_132    : Token_Index                    := No_Token_Index;
      Transform_Res_97 : Bare_Overriding_Not_Overriding := No_Bare_Ada_Node;
      Row_Pos_113      : Token_Index                    := No_Token_Index;
      Transform_Res_98 : Bare_Overriding_Unspecified    := No_Bare_Ada_Node;
      Or_Pos_46        : Token_Index                    := No_Token_Index;
      Or_Res_46        : Bare_Overriding_Node           := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Overriding_Indicator_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_46          := M.Instance;
         return Or_Res_46;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_46;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_46 := No_Token_Index;
      Or_Res_46 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_111 := Pos;

--  Start tok_code

      Token_Res_130 := Row_Pos_111;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_130));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol
               (Parser.TDH.Symbols, Precomputed_Symbol_Overriding)
         then
            Token_Pos_130 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_111 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_111,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_130 := Row_Pos_111 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_130 /= No_Token_Index then

         Row_Pos_111 := Token_Pos_130;

      else
         Row_Pos_111 := No_Token_Index;
         goto Exit_Row_111_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_111_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_111 /= No_Token_Index then

         Transform_Res_96 := Allocate_Overriding_Overriding (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_96, Kind => Ada_Overriding_Overriding,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_111 = Pos then No_Token_Index else Row_Pos_111 - 1));

      end if;

--  End transform_code

      if Row_Pos_111 /= No_Token_Index then
         Or_Pos_46 := Row_Pos_111;
         Or_Res_46 := Transform_Res_96;
         goto Exit_Or_46;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_112 := Pos;

--  Start tok_code

      Token_Res_131 := Row_Pos_112;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_131));
      begin
         if T.Kind /= From_Token_Kind (Ada_Not) then
            Token_Pos_131 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_112 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_112,
                  Expected_Token_Id => Ada_Not,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_131 := Row_Pos_112 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_131 /= No_Token_Index then

         Row_Pos_112 := Token_Pos_131;

      else
         Row_Pos_112 := No_Token_Index;
         goto Exit_Row_112_0;

      end if;

--  Start tok_code

      Token_Res_132 := Row_Pos_112;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_132));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol
               (Parser.TDH.Symbols, Precomputed_Symbol_Overriding)
         then
            Token_Pos_132 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_112 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_112,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_132 := Row_Pos_112 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_132 /= No_Token_Index then

         Row_Pos_112 := Token_Pos_132;

      else
         Row_Pos_112 := No_Token_Index;
         goto Exit_Row_112_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_112_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_112 /= No_Token_Index then

         Transform_Res_97 :=
           Allocate_Overriding_Not_Overriding (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_97, Kind => Ada_Overriding_Not_Overriding,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_112 = Pos then No_Token_Index else Row_Pos_112 - 1));

      end if;

--  End transform_code

      if Row_Pos_112 /= No_Token_Index then
         Or_Pos_46 := Row_Pos_112;
         Or_Res_46 := Transform_Res_97;
         goto Exit_Or_46;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_113 := Pos;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_113_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_113 /= No_Token_Index then

         Transform_Res_98 := Allocate_Overriding_Unspecified (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_98, Kind => Ada_Overriding_Unspecified,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_113 = Pos then No_Token_Index else Row_Pos_113 - 1));

      end if;

--  End transform_code

      if Row_Pos_113 /= No_Token_Index then
         Or_Pos_46 := Row_Pos_113;
         Or_Res_46 := Transform_Res_98;
         goto Exit_Or_46;
      end if;
      <<Exit_Or_46>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Overriding_Indicator_Or_Parse_0_Memo,
         Or_Pos_46 /= No_Token_Index, Or_Res_46, Pos, Or_Pos_46);

      Parser.Current_Pos := Or_Pos_46;

      return Or_Res_46;
   end Overriding_Indicator_Or_Parse_0;

   function Static_Name_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Name
   is
      use Bare_Name_Memos;

      Nobt_12                 : Boolean          := False;
      Row_Pos_119             : Token_Index      := No_Token_Index;
      Defer_Pos_170           : Token_Index      := No_Token_Index;
      Defer_Res_170           : Bare_Name        := No_Bare_Ada_Node;
      Token_Pos_136           : Token_Index      := No_Token_Index;
      Token_Res_136           : Token_Index      := No_Token_Index;
      Defer_Pos_171           : Token_Index      := No_Token_Index;
      Defer_Res_171           : Bare_Base_Id     := No_Bare_Ada_Node;
      Row_Progress_12         : Integer          := 0;
      Transform_Res_103       : Bare_Dotted_Name := No_Bare_Ada_Node;
      Transform_Has_Failed_12 : Boolean          := False;
      Defer_Pos_172           : Token_Index      := No_Token_Index;
      Defer_Res_172           : Bare_Base_Id     := No_Bare_Ada_Node;
      Or_Pos_48               : Token_Index      := No_Token_Index;
      Or_Res_48               : Bare_Name        := No_Bare_Ada_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Name   := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Static_Name_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_48          := M.Instance;
         return Or_Res_48;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_48;
      end if;

      Set
        (Parser.Private_Part.Static_Name_Or_Parse_0_Memo, False, Or_Res_48,
         Pos, Mem_Pos);

      <<Try_Again>>

      Nobt_12 := False;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_48 := No_Token_Index;
      Or_Res_48 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_119 := Pos;

      Defer_Res_170 := Static_Name_Or_Parse_0 (Parser, Row_Pos_119);
      Defer_Pos_170 := Parser.Current_Pos;

      Row_Progress_12 := 1;

      if Defer_Pos_170 /= No_Token_Index then

         Row_Pos_119 := Defer_Pos_170;

      else
         Row_Pos_119 := No_Token_Index;
         goto Exit_Row_118_0;

      end if;

--  Start tok_code

      Token_Res_136 := Row_Pos_119;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_136));
      begin
         if T.Kind /= From_Token_Kind (Ada_Dot) then
            Token_Pos_136 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_119 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_119,
                  Expected_Token_Id => Ada_Dot,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_136 := Row_Pos_119 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_12 := 2;

      if Token_Pos_136 /= No_Token_Index then

         Row_Pos_119 := Token_Pos_136;

      else
         Row_Pos_119 := No_Token_Index;
         goto Exit_Row_118_0;

      end if;

      Nobt_12 := True;

      Row_Progress_12 := 3;

      if Row_Pos_119 /= No_Token_Index then

         Row_Pos_119 := Row_Pos_119;

      else
         Row_Pos_119 := No_Token_Index;
         goto Exit_Row_118_0;

      end if;

      Defer_Res_171 := Direct_Name_Or_Parse_0 (Parser, Row_Pos_119);
      Defer_Pos_171 := Parser.Current_Pos;

      Row_Progress_12 := 4;

      if Defer_Pos_171 /= No_Token_Index then

         Row_Pos_119 := Defer_Pos_171;

      else
         Row_Pos_119 := No_Token_Index;
         goto Exit_Row_118_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_118_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_119 = No_Token_Index and then Nobt_12 then
         Row_Pos_119             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_12 := True;
      end if;

      if Row_Pos_119 /= No_Token_Index then

         Transform_Res_103 := Allocate_Dotted_Name (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_103, Kind => Ada_Dotted_Name,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_119 = Pos then No_Token_Index else Row_Pos_119 - 1));

         Initialize_Fields_For_Dotted_Name
           (Self => Transform_Res_103, Dotted_Name_F_Prefix => Defer_Res_170,
            Dotted_Name_F_Suffix => Defer_Res_171);

         if Defer_Res_170 /= null and then Is_Incomplete (Defer_Res_170) then
            Transform_Res_103.Last_Attempted_Child := 0;
         elsif Defer_Res_170 /= null and then not Is_Ghost (Defer_Res_170) then
            Transform_Res_103.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_171 /= null and then Is_Incomplete (Defer_Res_171) then
            Transform_Res_103.Last_Attempted_Child := 0;
         elsif Defer_Res_171 /= null and then not Is_Ghost (Defer_Res_171) then
            Transform_Res_103.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_12 then
            Transform_Res_103.Last_Attempted_Child := Row_Progress_12;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <static_name>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      if Row_Pos_119 /= No_Token_Index then
         Or_Pos_48 := Row_Pos_119;
         Or_Res_48 := Transform_Res_103;
         goto Exit_Or_48;
      end if;

      Defer_Res_172 := Direct_Name_Or_Parse_0 (Parser, Pos);
      Defer_Pos_172 := Parser.Current_Pos;

      if Defer_Pos_172 /= No_Token_Index then
         Or_Pos_48 := Defer_Pos_172;
         Or_Res_48 := Defer_Res_172;
         goto Exit_Or_48;
      end if;
      <<Exit_Or_48>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      if Or_Pos_48 > Mem_Pos then
         Mem_Pos := Or_Pos_48;
         Mem_Res := Or_Res_48;
         Set
           (Parser.Private_Part.Static_Name_Or_Parse_0_Memo,
            Or_Pos_48 /= No_Token_Index, Or_Res_48, Pos, Or_Pos_48);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res_48 := Mem_Res;
         Or_Pos_48 := Mem_Pos;
         goto No_Memo;
      end if;

      Set
        (Parser.Private_Part.Static_Name_Or_Parse_0_Memo,
         Or_Pos_48 /= No_Token_Index, Or_Res_48, Pos, Or_Pos_48);

      <<No_Memo>>

      Parser.Current_Pos := Or_Pos_48;

      return Or_Res_48;
   end Static_Name_Or_Parse_0;

   function Defining_Name_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Defining_Name
   is
      use Bare_Defining_Name_Memos;

      Row_Pos_118       : Token_Index        := No_Token_Index;
      Defer_Pos_169     : Token_Index        := No_Token_Index;
      Defer_Res_169     : Bare_Name          := No_Bare_Ada_Node;
      Transform_Res_102 : Bare_Defining_Name := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Defining_Name_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_102  := M.Instance;
         return Transform_Res_102;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_102;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_118 := Pos;

      Defer_Res_169 := Static_Name_Or_Parse_0 (Parser, Row_Pos_118);
      Defer_Pos_169 := Parser.Current_Pos;

      if Defer_Pos_169 /= No_Token_Index then

         Row_Pos_118 := Defer_Pos_169;

      else
         Row_Pos_118 := No_Token_Index;
         goto Exit_Row_117_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_117_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_118 /= No_Token_Index then

         Transform_Res_102 := Allocate_Defining_Name (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_102, Kind => Ada_Defining_Name,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_118 = Pos then No_Token_Index else Row_Pos_118 - 1));

         Initialize_Fields_For_Defining_Name
           (Self => Transform_Res_102, Defining_Name_F_Name => Defer_Res_169);

         if Defer_Res_169 /= null and then Is_Incomplete (Defer_Res_169) then
            Transform_Res_102.Last_Attempted_Child := 0;
         elsif Defer_Res_169 /= null and then not Is_Ghost (Defer_Res_169) then
            Transform_Res_102.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Defining_Name_Transform_Parse_0_Memo,
         Row_Pos_118 /= No_Token_Index, Transform_Res_102, Pos, Row_Pos_118);

      Parser.Current_Pos := Row_Pos_118;

      return Transform_Res_102;
   end Defining_Name_Transform_Parse_0;

   function Mode_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Mode
   is
      use Bare_Mode_Memos;

      Row_Pos_123       : Token_Index       := No_Token_Index;
      Token_Pos_144     : Token_Index       := No_Token_Index;
      Token_Res_144     : Token_Index       := No_Token_Index;
      Token_Pos_145     : Token_Index       := No_Token_Index;
      Token_Res_145     : Token_Index       := No_Token_Index;
      Transform_Res_106 : Bare_Mode_In_Out  := No_Bare_Ada_Node;
      Row_Pos_124       : Token_Index       := No_Token_Index;
      Token_Pos_146     : Token_Index       := No_Token_Index;
      Token_Res_146     : Token_Index       := No_Token_Index;
      Transform_Res_107 : Bare_Mode_In      := No_Bare_Ada_Node;
      Row_Pos_125       : Token_Index       := No_Token_Index;
      Token_Pos_147     : Token_Index       := No_Token_Index;
      Token_Res_147     : Token_Index       := No_Token_Index;
      Transform_Res_108 : Bare_Mode_Out     := No_Bare_Ada_Node;
      Row_Pos_126       : Token_Index       := No_Token_Index;
      Transform_Res_109 : Bare_Mode_Default := No_Bare_Ada_Node;
      Or_Pos_49         : Token_Index       := No_Token_Index;
      Or_Res_49         : Bare_Mode         := No_Bare_Ada_Node;

      M : Memo_Entry := Get (Parser.Private_Part.Mode_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_49          := M.Instance;
         return Or_Res_49;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_49;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_49 := No_Token_Index;
      Or_Res_49 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_123 := Pos;

--  Start tok_code

      Token_Res_144 := Row_Pos_123;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_144));
      begin
         if T.Kind /= From_Token_Kind (Ada_In) then
            Token_Pos_144 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_123 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_123,
                  Expected_Token_Id => Ada_In,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_144 := Row_Pos_123 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_144 /= No_Token_Index then

         Row_Pos_123 := Token_Pos_144;

      else
         Row_Pos_123 := No_Token_Index;
         goto Exit_Row_121_0;

      end if;

--  Start tok_code

      Token_Res_145 := Row_Pos_123;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_145));
      begin
         if T.Kind /= From_Token_Kind (Ada_Out) then
            Token_Pos_145 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_123 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_123,
                  Expected_Token_Id => Ada_Out,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_145 := Row_Pos_123 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_145 /= No_Token_Index then

         Row_Pos_123 := Token_Pos_145;

      else
         Row_Pos_123 := No_Token_Index;
         goto Exit_Row_121_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_121_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_123 /= No_Token_Index then

         Transform_Res_106 := Allocate_Mode_In_Out (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_106, Kind => Ada_Mode_In_Out,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_123 = Pos then No_Token_Index else Row_Pos_123 - 1));

      end if;

--  End transform_code

      if Row_Pos_123 /= No_Token_Index then
         Or_Pos_49 := Row_Pos_123;
         Or_Res_49 := Transform_Res_106;
         goto Exit_Or_49;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_124 := Pos;

--  Start tok_code

      Token_Res_146 := Row_Pos_124;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_146));
      begin
         if T.Kind /= From_Token_Kind (Ada_In) then
            Token_Pos_146 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_124 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_124,
                  Expected_Token_Id => Ada_In,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_146 := Row_Pos_124 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_146 /= No_Token_Index then

         Row_Pos_124 := Token_Pos_146;

      else
         Row_Pos_124 := No_Token_Index;
         goto Exit_Row_122_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_122_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_124 /= No_Token_Index then

         Transform_Res_107 := Allocate_Mode_In (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_107, Kind => Ada_Mode_In,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_124 = Pos then No_Token_Index else Row_Pos_124 - 1));

      end if;

--  End transform_code

      if Row_Pos_124 /= No_Token_Index then
         Or_Pos_49 := Row_Pos_124;
         Or_Res_49 := Transform_Res_107;
         goto Exit_Or_49;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_125 := Pos;

--  Start tok_code

      Token_Res_147 := Row_Pos_125;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_147));
      begin
         if T.Kind /= From_Token_Kind (Ada_Out) then
            Token_Pos_147 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_125 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_125,
                  Expected_Token_Id => Ada_Out,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_147 := Row_Pos_125 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_147 /= No_Token_Index then

         Row_Pos_125 := Token_Pos_147;

      else
         Row_Pos_125 := No_Token_Index;
         goto Exit_Row_123_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_123_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_125 /= No_Token_Index then

         Transform_Res_108 := Allocate_Mode_Out (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_108, Kind => Ada_Mode_Out,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_125 = Pos then No_Token_Index else Row_Pos_125 - 1));

      end if;

--  End transform_code

      if Row_Pos_125 /= No_Token_Index then
         Or_Pos_49 := Row_Pos_125;
         Or_Res_49 := Transform_Res_108;
         goto Exit_Or_49;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_126 := Pos;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_124_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_126 /= No_Token_Index then

         Transform_Res_109 := Allocate_Mode_Default (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_109, Kind => Ada_Mode_Default,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_126 = Pos then No_Token_Index else Row_Pos_126 - 1));

      end if;

--  End transform_code

      if Row_Pos_126 /= No_Token_Index then
         Or_Pos_49 := Row_Pos_126;
         Or_Res_49 := Transform_Res_109;
         goto Exit_Or_49;
      end if;
      <<Exit_Or_49>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Mode_Or_Parse_0_Memo, Or_Pos_49 /= No_Token_Index,
         Or_Res_49, Pos, Or_Pos_49);

      Parser.Current_Pos := Or_Pos_49;

      return Or_Res_49;
   end Mode_Or_Parse_0;

   function Unconstrained_Index_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Unconstrained_Array_Index
   is
      use Bare_Unconstrained_Array_Index_Memos;

      Row_Pos_132       : Token_Index                    := No_Token_Index;
      Defer_Pos_187     : Token_Index                    := No_Token_Index;
      Defer_Res_187     : Bare_Subtype_Indication        := No_Bare_Ada_Node;
      Token_Pos_153     : Token_Index                    := No_Token_Index;
      Token_Res_153     : Token_Index                    := No_Token_Index;
      Token_Pos_154     : Token_Index                    := No_Token_Index;
      Token_Res_154     : Token_Index                    := No_Token_Index;
      Transform_Res_115 : Bare_Unconstrained_Array_Index := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Unconstrained_Index_Transform_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_115  := M.Instance;
         return Transform_Res_115;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_115;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_132 := Pos;

      Defer_Res_187 :=
        Subtype_Indication_Transform_Parse_0 (Parser, Row_Pos_132);
      Defer_Pos_187 := Parser.Current_Pos;

      if Defer_Pos_187 /= No_Token_Index then

         Row_Pos_132 := Defer_Pos_187;

      else
         Row_Pos_132 := No_Token_Index;
         goto Exit_Row_129_0;

      end if;

--  Start tok_code

      Token_Res_153 := Row_Pos_132;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_153));
      begin
         if T.Kind /= From_Token_Kind (Ada_Range) then
            Token_Pos_153 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_132 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_132,
                  Expected_Token_Id => Ada_Range,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_153 := Row_Pos_132 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_153 /= No_Token_Index then

         Row_Pos_132 := Token_Pos_153;

      else
         Row_Pos_132 := No_Token_Index;
         goto Exit_Row_129_0;

      end if;

--  Start tok_code

      Token_Res_154 := Row_Pos_132;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_154));
      begin
         if T.Kind /= From_Token_Kind (Ada_Diamond) then
            Token_Pos_154 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_132 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_132,
                  Expected_Token_Id => Ada_Diamond,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_154 := Row_Pos_132 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_154 /= No_Token_Index then

         Row_Pos_132 := Token_Pos_154;

      else
         Row_Pos_132 := No_Token_Index;
         goto Exit_Row_129_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_129_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_132 /= No_Token_Index then

         Transform_Res_115 :=
           Allocate_Unconstrained_Array_Index (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_115, Kind => Ada_Unconstrained_Array_Index,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_132 = Pos then No_Token_Index else Row_Pos_132 - 1));

         Initialize_Fields_For_Unconstrained_Array_Index
           (Self => Transform_Res_115,
            Unconstrained_Array_Index_F_Subtype_Indication => Defer_Res_187);

         if Defer_Res_187 /= null and then Is_Incomplete (Defer_Res_187) then
            Transform_Res_115.Last_Attempted_Child := 0;
         elsif Defer_Res_187 /= null and then not Is_Ghost (Defer_Res_187) then
            Transform_Res_115.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Unconstrained_Index_Transform_Parse_0_Memo,
         Row_Pos_132 /= No_Token_Index, Transform_Res_115, Pos, Row_Pos_132);

      Parser.Current_Pos := Row_Pos_132;

      return Transform_Res_115;
   end Unconstrained_Index_Transform_Parse_0;

   function Component_Def_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Component_Def
   is
      use Bare_Component_Def_Memos;

      Row_Pos_133       : Token_Index        := No_Token_Index;
      Token_Pos_155     : Token_Index        := No_Token_Index;
      Token_Res_155     : Token_Index        := No_Token_Index;
      Opt_Res_4         : Bare_Aliased_Node  := No_Bare_Ada_Node;
      Token_Pos_156     : Token_Index        := No_Token_Index;
      Token_Res_156     : Token_Index        := No_Token_Index;
      Opt_Res_5         : Bare_Constant_Node := No_Bare_Ada_Node;
      Defer_Pos_188     : Token_Index        := No_Token_Index;
      Defer_Res_188     : Bare_Type_Expr     := No_Bare_Ada_Node;
      Transform_Res_116 : Bare_Component_Def := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Component_Def_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_116  := M.Instance;
         return Transform_Res_116;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_116;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_133 := Pos;

--  Start opt_code

--  Start tok_code

      Token_Res_155 := Row_Pos_133;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_155));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol
               (Parser.TDH.Symbols, Precomputed_Symbol_Aliased)
         then
            Token_Pos_155 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_133 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_133,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_155 := Row_Pos_133 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_155 = No_Token_Index then

         Opt_Res_4 := Allocate_Aliased_Absent (Parser.Mem_Pool);
         Initialize
           (Self => Opt_Res_4, Kind => Ada_Aliased_Absent, Unit => Parser.Unit,
            Token_Start_Index => Row_Pos_133,
            Token_End_Index   => No_Token_Index);

         Token_Pos_155 := Row_Pos_133;

      else

         Opt_Res_4 := Allocate_Aliased_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_4, Kind => Ada_Aliased_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_133,
            Token_End_Index => Token_Pos_155 - 1);

      end if;

--  End opt_code

      if Token_Pos_155 /= No_Token_Index then

         Row_Pos_133 := Token_Pos_155;

      else
         Row_Pos_133 := No_Token_Index;
         goto Exit_Row_131_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_156 := Row_Pos_133;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_156));
      begin
         if T.Kind /= From_Token_Kind (Ada_Constant) then
            Token_Pos_156 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_133 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_133,
                  Expected_Token_Id => Ada_Constant,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_156 := Row_Pos_133 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_156 = No_Token_Index then

         Opt_Res_5 := Allocate_Constant_Absent (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_5, Kind => Ada_Constant_Absent,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_133,
            Token_End_Index => No_Token_Index);

         Token_Pos_156 := Row_Pos_133;

      else

         Opt_Res_5 := Allocate_Constant_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_5, Kind => Ada_Constant_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_133,
            Token_End_Index => Token_Pos_156 - 1);

      end if;

--  End opt_code

      if Token_Pos_156 /= No_Token_Index then

         Row_Pos_133 := Token_Pos_156;

      else
         Row_Pos_133 := No_Token_Index;
         goto Exit_Row_131_0;

      end if;

      Defer_Res_188 := Type_Expr_Or_Parse_0 (Parser, Row_Pos_133);
      Defer_Pos_188 := Parser.Current_Pos;

      if Defer_Pos_188 /= No_Token_Index then

         Row_Pos_133 := Defer_Pos_188;

      else
         Row_Pos_133 := No_Token_Index;
         goto Exit_Row_131_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_131_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_133 /= No_Token_Index then

         Transform_Res_116 := Allocate_Component_Def (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_116, Kind => Ada_Component_Def,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_133 = Pos then No_Token_Index else Row_Pos_133 - 1));

         Initialize_Fields_For_Component_Def
           (Self                         => Transform_Res_116,
            Component_Def_F_Has_Aliased  => Opt_Res_4,
            Component_Def_F_Has_Constant => Opt_Res_5,
            Component_Def_F_Type_Expr    => Defer_Res_188);

         if Opt_Res_4 /= null and then Is_Incomplete (Opt_Res_4) then
            Transform_Res_116.Last_Attempted_Child := 0;
         elsif Opt_Res_4 /= null and then not Is_Ghost (Opt_Res_4) then
            Transform_Res_116.Last_Attempted_Child := -1;
         end if;
         if Opt_Res_5 /= null and then Is_Incomplete (Opt_Res_5) then
            Transform_Res_116.Last_Attempted_Child := 0;
         elsif Opt_Res_5 /= null and then not Is_Ghost (Opt_Res_5) then
            Transform_Res_116.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_188 /= null and then Is_Incomplete (Defer_Res_188) then
            Transform_Res_116.Last_Attempted_Child := 0;
         elsif Defer_Res_188 /= null and then not Is_Ghost (Defer_Res_188) then
            Transform_Res_116.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Component_Def_Transform_Parse_0_Memo,
         Row_Pos_133 /= No_Token_Index, Transform_Res_116, Pos, Row_Pos_133);

      Parser.Current_Pos := Row_Pos_133;

      return Transform_Res_116;
   end Component_Def_Transform_Parse_0;

   function Array_Type_Def_Transform_Parse_2
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Array_Type_Def
   is
      use Bare_Array_Type_Def_Memos;

      Row_Pos_129       : Token_Index := No_Token_Index;
      Token_Pos_148     : Token_Index := No_Token_Index;
      Token_Res_148     : Token_Index := No_Token_Index;
      Token_Pos_149     : Token_Index := No_Token_Index;
      Token_Res_149     : Token_Index := No_Token_Index;
      Row_Pos_130       : Token_Index := No_Token_Index;
      Lst_Cpos_15       : Token_Index := No_Token_Index;
      Tmp_List_15       : Free_Parse_List;
      Defer_Pos_184     : Token_Index := No_Token_Index;
      Defer_Res_184     : Bare_Unconstrained_Array_Index := No_Bare_Ada_Node;
      Token_Pos_150     : Token_Index := No_Token_Index;
      Token_Res_150     : Token_Index := No_Token_Index;
      List_Pos_15       : Token_Index := No_Token_Index;
      List_Res_15 : Bare_Unconstrained_Array_Index_List := No_Bare_Ada_Node;
      Transform_Res_112 : Bare_Unconstrained_Array_Indices := No_Bare_Ada_Node;
      Row_Pos_131       : Token_Index := No_Token_Index;
      Defer_Pos_185     : Token_Index := No_Token_Index;
      Defer_Res_185     : Bare_Constraint_List := No_Bare_Ada_Node;
      Transform_Res_113 : Bare_Constrained_Array_Indices := No_Bare_Ada_Node;
      Or_Pos_52         : Token_Index := No_Token_Index;
      Or_Res_52         : Bare_Array_Indices := No_Bare_Ada_Node;
      Token_Pos_151     : Token_Index := No_Token_Index;
      Token_Res_151     : Token_Index := No_Token_Index;
      Token_Pos_152     : Token_Index := No_Token_Index;
      Token_Res_152     : Token_Index := No_Token_Index;
      Defer_Pos_186     : Token_Index := No_Token_Index;
      Defer_Res_186     : Bare_Component_Def := No_Bare_Ada_Node;
      Transform_Res_114 : Bare_Array_Type_Def := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Array_Type_Def_Transform_Parse_2_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_114  := M.Instance;
         return Transform_Res_114;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_114;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_129 := Pos;

--  Start tok_code

      Token_Res_148 := Row_Pos_129;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_148));
      begin
         if T.Kind /= From_Token_Kind (Ada_Array) then
            Token_Pos_148 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_129 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_129,
                  Expected_Token_Id => Ada_Array,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_148 := Row_Pos_129 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_148 /= No_Token_Index then

         Row_Pos_129 := Token_Pos_148;

      else
         Row_Pos_129 := No_Token_Index;
         goto Exit_Row_127_0;

      end if;

--  Start tok_code

      Token_Res_149 := Row_Pos_129;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_149));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Open) then
            Token_Pos_149 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_129 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_129,
                  Expected_Token_Id => Ada_Par_Open,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_149 := Row_Pos_129 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_149 /= No_Token_Index then

         Row_Pos_129 := Token_Pos_149;

      else
         Row_Pos_129 := No_Token_Index;
         goto Exit_Row_127_0;

      end if;

--  Start or_code

      Or_Pos_52 := No_Token_Index;
      Or_Res_52 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_130 := Row_Pos_129;

--  Start list_code

      List_Pos_15 := No_Token_Index;

      Lst_Cpos_15 := Row_Pos_130;
      Tmp_List_15 := Get_Parse_List (Parser);

      loop

         Defer_Res_184 :=
           Unconstrained_Index_Transform_Parse_0 (Parser, Lst_Cpos_15);
         Defer_Pos_184 := Parser.Current_Pos;

         exit when Defer_Pos_184 = No_Token_Index;

         List_Pos_15 := Defer_Pos_184;
         Lst_Cpos_15 := List_Pos_15;

         Tmp_List_15.Nodes.Append (Defer_Res_184);

--  Start tok_code

         Token_Res_150 := Lst_Cpos_15;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_150));
         begin
            if T.Kind /= From_Token_Kind (Ada_Comma) then
               Token_Pos_150 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_15 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_15,
                     Expected_Token_Id => Ada_Comma,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_150 := Lst_Cpos_15 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_150 /= No_Token_Index then
            Lst_Cpos_15 := Token_Pos_150;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_15.Nodes.Length;
      begin
         List_Res_15 :=
           Allocate_Unconstrained_Array_Index_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_130;
            Token_End   :=
              (if Lst_Cpos_15 = Row_Pos_130 then Row_Pos_130
               else Lst_Cpos_15 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_130, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self => List_Res_15, Kind => Ada_Unconstrained_Array_Index_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_15, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_15.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_15.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_15);

--  End list_code

      if List_Pos_15 /= No_Token_Index then

         Row_Pos_130 := List_Pos_15;

      else
         Row_Pos_130 := No_Token_Index;
         goto Exit_Row_128_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_128_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_130 /= No_Token_Index then

         Transform_Res_112 :=
           Allocate_Unconstrained_Array_Indices (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_112, Kind => Ada_Unconstrained_Array_Indices,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_129,
            Token_End_Index =>
              (if Row_Pos_130 = Row_Pos_129 then No_Token_Index
               else Row_Pos_130 - 1));

         Initialize_Fields_For_Unconstrained_Array_Indices
           (Self                                => Transform_Res_112,
            Unconstrained_Array_Indices_F_Types => List_Res_15);

         if List_Res_15 /= null and then Is_Incomplete (List_Res_15) then
            Transform_Res_112.Last_Attempted_Child := 0;
         elsif List_Res_15 /= null and then not Is_Ghost (List_Res_15) then
            Transform_Res_112.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_130 /= No_Token_Index then
         Or_Pos_52 := Row_Pos_130;
         Or_Res_52 := Transform_Res_112;
         goto Exit_Or_52;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_131 := Row_Pos_129;

      Defer_Res_185 := Constraint_List_List_Parse_0 (Parser, Row_Pos_131);
      Defer_Pos_185 := Parser.Current_Pos;

      if Defer_Pos_185 /= No_Token_Index then

         Row_Pos_131 := Defer_Pos_185;

      else
         Row_Pos_131 := No_Token_Index;
         goto Exit_Row_130_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_130_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_131 /= No_Token_Index then

         Transform_Res_113 :=
           Allocate_Constrained_Array_Indices (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_113, Kind => Ada_Constrained_Array_Indices,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_129,
            Token_End_Index =>
              (if Row_Pos_131 = Row_Pos_129 then No_Token_Index
               else Row_Pos_131 - 1));

         Initialize_Fields_For_Constrained_Array_Indices
           (Self                             => Transform_Res_113,
            Constrained_Array_Indices_F_List => Defer_Res_185);

         if Defer_Res_185 /= null and then Is_Incomplete (Defer_Res_185) then
            Transform_Res_113.Last_Attempted_Child := 0;
         elsif Defer_Res_185 /= null and then not Is_Ghost (Defer_Res_185) then
            Transform_Res_113.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_131 /= No_Token_Index then
         Or_Pos_52 := Row_Pos_131;
         Or_Res_52 := Transform_Res_113;
         goto Exit_Or_52;
      end if;
      <<Exit_Or_52>>

--  End or_code

      if Or_Pos_52 /= No_Token_Index then

         Row_Pos_129 := Or_Pos_52;

      else
         Row_Pos_129 := No_Token_Index;
         goto Exit_Row_127_0;

      end if;

--  Start tok_code

      Token_Res_151 := Row_Pos_129;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_151));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Close) then
            Token_Pos_151 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_129 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_129,
                  Expected_Token_Id => Ada_Par_Close,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_151 := Row_Pos_129 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_151 /= No_Token_Index then

         Row_Pos_129 := Token_Pos_151;

      else
         Row_Pos_129 := No_Token_Index;
         goto Exit_Row_127_0;

      end if;

--  Start tok_code

      Token_Res_152 := Row_Pos_129;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_152));
      begin
         if T.Kind /= From_Token_Kind (Ada_Of) then
            Token_Pos_152 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_129 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_129,
                  Expected_Token_Id => Ada_Of,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_152 := Row_Pos_129 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_152 /= No_Token_Index then

         Row_Pos_129 := Token_Pos_152;

      else
         Row_Pos_129 := No_Token_Index;
         goto Exit_Row_127_0;

      end if;

      Defer_Res_186 := Component_Def_Transform_Parse_0 (Parser, Row_Pos_129);
      Defer_Pos_186 := Parser.Current_Pos;

      if Defer_Pos_186 /= No_Token_Index then

         Row_Pos_129 := Defer_Pos_186;

      else
         Row_Pos_129 := No_Token_Index;
         goto Exit_Row_127_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_127_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_129 /= No_Token_Index then

         Transform_Res_114 := Allocate_Array_Type_Def (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_114, Kind => Ada_Array_Type_Def,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_129 = Pos then No_Token_Index else Row_Pos_129 - 1));

         Initialize_Fields_For_Array_Type_Def
           (Self => Transform_Res_114, Array_Type_Def_F_Indices => Or_Res_52,
            Array_Type_Def_F_Component_Type => Defer_Res_186);

         if Or_Res_52 /= null and then Is_Incomplete (Or_Res_52) then
            Transform_Res_114.Last_Attempted_Child := 0;
         elsif Or_Res_52 /= null and then not Is_Ghost (Or_Res_52) then
            Transform_Res_114.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_186 /= null and then Is_Incomplete (Defer_Res_186) then
            Transform_Res_114.Last_Attempted_Child := 0;
         elsif Defer_Res_186 /= null and then not Is_Ghost (Defer_Res_186) then
            Transform_Res_114.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Array_Type_Def_Transform_Parse_2_Memo,
         Row_Pos_129 /= No_Token_Index, Transform_Res_114, Pos, Row_Pos_129);

      Parser.Current_Pos := Row_Pos_129;

      return Transform_Res_114;
   end Array_Type_Def_Transform_Parse_2;

   function Access_Def_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Access_Def
   is
      use Bare_Access_Def_Memos;

      Row_Pos_134       : Token_Index             := No_Token_Index;
      Row_Pos_135       : Token_Index             := No_Token_Index;
      Token_Pos_157     : Token_Index             := No_Token_Index;
      Token_Res_157     : Token_Index             := No_Token_Index;
      Token_Pos_158     : Token_Index             := No_Token_Index;
      Token_Res_158     : Token_Index             := No_Token_Index;
      Opt_Res_6         : Bare_Not_Null           := No_Bare_Ada_Node;
      Token_Pos_159     : Token_Index             := No_Token_Index;
      Token_Res_159     : Token_Index             := No_Token_Index;
      Token_Pos_160     : Token_Index             := No_Token_Index;
      Token_Res_160     : Token_Index             := No_Token_Index;
      Opt_Res_7         : Bare_Protected_Node     := No_Bare_Ada_Node;
      Defer_Pos_189     : Token_Index             := No_Token_Index;
      Defer_Res_189     : Bare_Subp_Spec          := No_Bare_Ada_Node;
      Transform_Res_117 : Bare_Access_To_Subp_Def := No_Bare_Ada_Node;
      Row_Pos_136       : Token_Index             := No_Token_Index;
      Row_Pos_137       : Token_Index             := No_Token_Index;
      Token_Pos_161     : Token_Index             := No_Token_Index;
      Token_Res_161     : Token_Index             := No_Token_Index;
      Token_Pos_162     : Token_Index             := No_Token_Index;
      Token_Res_162     : Token_Index             := No_Token_Index;
      Opt_Res_8         : Bare_Not_Null           := No_Bare_Ada_Node;
      Token_Pos_163     : Token_Index             := No_Token_Index;
      Token_Res_163     : Token_Index             := No_Token_Index;
      Token_Pos_164     : Token_Index             := No_Token_Index;
      Token_Res_164     : Token_Index             := No_Token_Index;
      Opt_Res_9         : Bare_All_Node           := No_Bare_Ada_Node;
      Token_Pos_165     : Token_Index             := No_Token_Index;
      Token_Res_165     : Token_Index             := No_Token_Index;
      Opt_Res_10        : Bare_Constant_Node      := No_Bare_Ada_Node;
      Defer_Pos_190     : Token_Index             := No_Token_Index;
      Defer_Res_190     : Bare_Subtype_Indication := No_Bare_Ada_Node;
      Transform_Res_118 : Bare_Type_Access_Def    := No_Bare_Ada_Node;
      Or_Pos_53         : Token_Index             := No_Token_Index;
      Or_Res_53         : Bare_Access_Def         := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Access_Def_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_53          := M.Instance;
         return Or_Res_53;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_53;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_53 := No_Token_Index;
      Or_Res_53 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_134 := Pos;

--  Start opt_code

--  Start row_code

      Row_Pos_135 := Row_Pos_134;

--  Start tok_code

      Token_Res_157 := Row_Pos_135;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_157));
      begin
         if T.Kind /= From_Token_Kind (Ada_Not) then
            Token_Pos_157 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_135 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_135,
                  Expected_Token_Id => Ada_Not,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_157 := Row_Pos_135 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_157 /= No_Token_Index then

         Row_Pos_135 := Token_Pos_157;

      else
         Row_Pos_135 := No_Token_Index;
         goto Exit_Row_133_0;

      end if;

--  Start tok_code

      Token_Res_158 := Row_Pos_135;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_158));
      begin
         if T.Kind /= From_Token_Kind (Ada_Null) then
            Token_Pos_158 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_135 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_135,
                  Expected_Token_Id => Ada_Null,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_158 := Row_Pos_135 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_158 /= No_Token_Index then

         Row_Pos_135 := Token_Pos_158;

      else
         Row_Pos_135 := No_Token_Index;
         goto Exit_Row_133_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_133_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_135 = No_Token_Index then

         Opt_Res_6 := Allocate_Not_Null_Absent (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_6, Kind => Ada_Not_Null_Absent,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_134,
            Token_End_Index => No_Token_Index);

         Row_Pos_135 := Row_Pos_134;

      else

         Opt_Res_6 := Allocate_Not_Null_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_6, Kind => Ada_Not_Null_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_134,
            Token_End_Index => Row_Pos_135 - 1);

      end if;

--  End opt_code

      if Row_Pos_135 /= No_Token_Index then

         Row_Pos_134 := Row_Pos_135;

      else
         Row_Pos_134 := No_Token_Index;
         goto Exit_Row_132_0;

      end if;

--  Start tok_code

      Token_Res_159 := Row_Pos_134;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_159));
      begin
         if T.Kind /= From_Token_Kind (Ada_Access) then
            Token_Pos_159 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_134 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_134,
                  Expected_Token_Id => Ada_Access,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_159 := Row_Pos_134 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_159 /= No_Token_Index then

         Row_Pos_134 := Token_Pos_159;

      else
         Row_Pos_134 := No_Token_Index;
         goto Exit_Row_132_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_160 := Row_Pos_134;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_160));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol
               (Parser.TDH.Symbols, Precomputed_Symbol_Protected)
         then
            Token_Pos_160 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_134 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_134,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_160 := Row_Pos_134 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_160 = No_Token_Index then

         Opt_Res_7 := Allocate_Protected_Absent (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_7, Kind => Ada_Protected_Absent,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_134,
            Token_End_Index => No_Token_Index);

         Token_Pos_160 := Row_Pos_134;

      else

         Opt_Res_7 := Allocate_Protected_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_7, Kind => Ada_Protected_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_134,
            Token_End_Index => Token_Pos_160 - 1);

      end if;

--  End opt_code

      if Token_Pos_160 /= No_Token_Index then

         Row_Pos_134 := Token_Pos_160;

      else
         Row_Pos_134 := No_Token_Index;
         goto Exit_Row_132_0;

      end if;

      Defer_Res_189 := Subp_Spec_Transform_Parse_2 (Parser, Row_Pos_134);
      Defer_Pos_189 := Parser.Current_Pos;

      if Defer_Pos_189 /= No_Token_Index then

         Row_Pos_134 := Defer_Pos_189;

      else
         Row_Pos_134 := No_Token_Index;
         goto Exit_Row_132_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_132_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_134 /= No_Token_Index then

         Transform_Res_117 := Allocate_Access_To_Subp_Def (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_117, Kind => Ada_Access_To_Subp_Def,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_134 = Pos then No_Token_Index else Row_Pos_134 - 1));

         Initialize_Fields_For_Access_To_Subp_Def
           (Self => Transform_Res_117, Access_Def_F_Has_Not_Null => Opt_Res_6,
            Access_To_Subp_Def_F_Has_Protected => Opt_Res_7,
            Access_To_Subp_Def_F_Subp_Spec     => Defer_Res_189);

         if Opt_Res_6 /= null and then Is_Incomplete (Opt_Res_6) then
            Transform_Res_117.Last_Attempted_Child := 0;
         elsif Opt_Res_6 /= null and then not Is_Ghost (Opt_Res_6) then
            Transform_Res_117.Last_Attempted_Child := -1;
         end if;
         if Opt_Res_7 /= null and then Is_Incomplete (Opt_Res_7) then
            Transform_Res_117.Last_Attempted_Child := 0;
         elsif Opt_Res_7 /= null and then not Is_Ghost (Opt_Res_7) then
            Transform_Res_117.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_189 /= null and then Is_Incomplete (Defer_Res_189) then
            Transform_Res_117.Last_Attempted_Child := 0;
         elsif Defer_Res_189 /= null and then not Is_Ghost (Defer_Res_189) then
            Transform_Res_117.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_134 /= No_Token_Index then
         Or_Pos_53 := Row_Pos_134;
         Or_Res_53 := Transform_Res_117;
         goto Exit_Or_53;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_136 := Pos;

--  Start opt_code

--  Start row_code

      Row_Pos_137 := Row_Pos_136;

--  Start tok_code

      Token_Res_161 := Row_Pos_137;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_161));
      begin
         if T.Kind /= From_Token_Kind (Ada_Not) then
            Token_Pos_161 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_137 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_137,
                  Expected_Token_Id => Ada_Not,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_161 := Row_Pos_137 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_161 /= No_Token_Index then

         Row_Pos_137 := Token_Pos_161;

      else
         Row_Pos_137 := No_Token_Index;
         goto Exit_Row_135_0;

      end if;

--  Start tok_code

      Token_Res_162 := Row_Pos_137;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_162));
      begin
         if T.Kind /= From_Token_Kind (Ada_Null) then
            Token_Pos_162 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_137 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_137,
                  Expected_Token_Id => Ada_Null,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_162 := Row_Pos_137 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_162 /= No_Token_Index then

         Row_Pos_137 := Token_Pos_162;

      else
         Row_Pos_137 := No_Token_Index;
         goto Exit_Row_135_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_135_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_137 = No_Token_Index then

         Opt_Res_8 := Allocate_Not_Null_Absent (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_8, Kind => Ada_Not_Null_Absent,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_136,
            Token_End_Index => No_Token_Index);

         Row_Pos_137 := Row_Pos_136;

      else

         Opt_Res_8 := Allocate_Not_Null_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_8, Kind => Ada_Not_Null_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_136,
            Token_End_Index => Row_Pos_137 - 1);

      end if;

--  End opt_code

      if Row_Pos_137 /= No_Token_Index then

         Row_Pos_136 := Row_Pos_137;

      else
         Row_Pos_136 := No_Token_Index;
         goto Exit_Row_134_0;

      end if;

--  Start tok_code

      Token_Res_163 := Row_Pos_136;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_163));
      begin
         if T.Kind /= From_Token_Kind (Ada_Access) then
            Token_Pos_163 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_136 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_136,
                  Expected_Token_Id => Ada_Access,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_163 := Row_Pos_136 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_163 /= No_Token_Index then

         Row_Pos_136 := Token_Pos_163;

      else
         Row_Pos_136 := No_Token_Index;
         goto Exit_Row_134_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_164 := Row_Pos_136;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_164));
      begin
         if T.Kind /= From_Token_Kind (Ada_All) then
            Token_Pos_164 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_136 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_136,
                  Expected_Token_Id => Ada_All,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_164 := Row_Pos_136 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_164 = No_Token_Index then

         Opt_Res_9 := Allocate_All_Absent (Parser.Mem_Pool);
         Initialize
           (Self => Opt_Res_9, Kind => Ada_All_Absent, Unit => Parser.Unit,
            Token_Start_Index => Row_Pos_136,
            Token_End_Index   => No_Token_Index);

         Token_Pos_164 := Row_Pos_136;

      else

         Opt_Res_9 := Allocate_All_Present (Parser.Mem_Pool);
         Initialize
           (Self => Opt_Res_9, Kind => Ada_All_Present, Unit => Parser.Unit,
            Token_Start_Index => Row_Pos_136,
            Token_End_Index   => Token_Pos_164 - 1);

      end if;

--  End opt_code

      if Token_Pos_164 /= No_Token_Index then

         Row_Pos_136 := Token_Pos_164;

      else
         Row_Pos_136 := No_Token_Index;
         goto Exit_Row_134_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_165 := Row_Pos_136;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_165));
      begin
         if T.Kind /= From_Token_Kind (Ada_Constant) then
            Token_Pos_165 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_136 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_136,
                  Expected_Token_Id => Ada_Constant,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_165 := Row_Pos_136 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_165 = No_Token_Index then

         Opt_Res_10 := Allocate_Constant_Absent (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_10, Kind => Ada_Constant_Absent,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_136,
            Token_End_Index => No_Token_Index);

         Token_Pos_165 := Row_Pos_136;

      else

         Opt_Res_10 := Allocate_Constant_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_10, Kind => Ada_Constant_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_136,
            Token_End_Index => Token_Pos_165 - 1);

      end if;

--  End opt_code

      if Token_Pos_165 /= No_Token_Index then

         Row_Pos_136 := Token_Pos_165;

      else
         Row_Pos_136 := No_Token_Index;
         goto Exit_Row_134_0;

      end if;

      Defer_Res_190 :=
        Subtype_Indication_Transform_Parse_0 (Parser, Row_Pos_136);
      Defer_Pos_190 := Parser.Current_Pos;

      if Defer_Pos_190 /= No_Token_Index then

         Row_Pos_136 := Defer_Pos_190;

      else
         Row_Pos_136 := No_Token_Index;
         goto Exit_Row_134_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_134_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_136 /= No_Token_Index then

         Transform_Res_118 := Allocate_Type_Access_Def (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_118, Kind => Ada_Type_Access_Def,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_136 = Pos then No_Token_Index else Row_Pos_136 - 1));

         Initialize_Fields_For_Type_Access_Def
           (Self => Transform_Res_118, Access_Def_F_Has_Not_Null => Opt_Res_8,
            Type_Access_Def_F_Has_All            => Opt_Res_9,
            Type_Access_Def_F_Has_Constant       => Opt_Res_10,
            Type_Access_Def_F_Subtype_Indication => Defer_Res_190);

         if Opt_Res_8 /= null and then Is_Incomplete (Opt_Res_8) then
            Transform_Res_118.Last_Attempted_Child := 0;
         elsif Opt_Res_8 /= null and then not Is_Ghost (Opt_Res_8) then
            Transform_Res_118.Last_Attempted_Child := -1;
         end if;
         if Opt_Res_9 /= null and then Is_Incomplete (Opt_Res_9) then
            Transform_Res_118.Last_Attempted_Child := 0;
         elsif Opt_Res_9 /= null and then not Is_Ghost (Opt_Res_9) then
            Transform_Res_118.Last_Attempted_Child := -1;
         end if;
         if Opt_Res_10 /= null and then Is_Incomplete (Opt_Res_10) then
            Transform_Res_118.Last_Attempted_Child := 0;
         elsif Opt_Res_10 /= null and then not Is_Ghost (Opt_Res_10) then
            Transform_Res_118.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_190 /= null and then Is_Incomplete (Defer_Res_190) then
            Transform_Res_118.Last_Attempted_Child := 0;
         elsif Defer_Res_190 /= null and then not Is_Ghost (Defer_Res_190) then
            Transform_Res_118.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_136 /= No_Token_Index then
         Or_Pos_53 := Row_Pos_136;
         Or_Res_53 := Transform_Res_118;
         goto Exit_Or_53;
      end if;
      <<Exit_Or_53>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Access_Def_Or_Parse_0_Memo,
         Or_Pos_53 /= No_Token_Index, Or_Res_53, Pos, Or_Pos_53);

      Parser.Current_Pos := Or_Pos_53;

      return Or_Res_53;
   end Access_Def_Or_Parse_0;

   function Anonymous_Type_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Anonymous_Type_Decl
   is
      use Bare_Anonymous_Type_Decl_Memos;

      Row_Pos_128       : Token_Index              := No_Token_Index;
      Null_Res_7        : Bare_Defining_Name       := No_Bare_Ada_Node;
      Null_Res_8        : Bare_Discriminant_Part   := No_Bare_Ada_Node;
      Defer_Pos_181     : Token_Index              := No_Token_Index;
      Defer_Res_181     : Bare_Array_Type_Def      := No_Bare_Ada_Node;
      Defer_Pos_182     : Token_Index              := No_Token_Index;
      Defer_Res_182     : Bare_Access_Def          := No_Bare_Ada_Node;
      Or_Pos_51         : Token_Index              := No_Token_Index;
      Or_Res_51         : Bare_Type_Def            := No_Bare_Ada_Node;
      Defer_Pos_183     : Token_Index              := No_Token_Index;
      Defer_Res_183     : Bare_Aspect_Spec         := No_Bare_Ada_Node;
      Transform_Res_111 : Bare_Anonymous_Type_Decl := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Anonymous_Type_Decl_Transform_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_111  := M.Instance;
         return Transform_Res_111;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_111;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_128 := Pos;

      Null_Res_7 := No_Bare_Ada_Node;

      if Row_Pos_128 /= No_Token_Index then

         Row_Pos_128 := Row_Pos_128;

      else
         Row_Pos_128 := No_Token_Index;
         goto Exit_Row_126_0;

      end if;

      Null_Res_8 := No_Bare_Ada_Node;

      if Row_Pos_128 /= No_Token_Index then

         Row_Pos_128 := Row_Pos_128;

      else
         Row_Pos_128 := No_Token_Index;
         goto Exit_Row_126_0;

      end if;

--  Start or_code

      Or_Pos_51 := No_Token_Index;
      Or_Res_51 := No_Bare_Ada_Node;

      Defer_Res_181 := Array_Type_Def_Transform_Parse_2 (Parser, Row_Pos_128);
      Defer_Pos_181 := Parser.Current_Pos;

      if Defer_Pos_181 /= No_Token_Index then
         Or_Pos_51 := Defer_Pos_181;
         Or_Res_51 := Defer_Res_181;
         goto Exit_Or_51;
      end if;

      Defer_Res_182 := Access_Def_Or_Parse_0 (Parser, Row_Pos_128);
      Defer_Pos_182 := Parser.Current_Pos;

      if Defer_Pos_182 /= No_Token_Index then
         Or_Pos_51 := Defer_Pos_182;
         Or_Res_51 := Defer_Res_182;
         goto Exit_Or_51;
      end if;
      <<Exit_Or_51>>

--  End or_code

      if Or_Pos_51 /= No_Token_Index then

         Row_Pos_128 := Or_Pos_51;

      else
         Row_Pos_128 := No_Token_Index;
         goto Exit_Row_126_0;

      end if;

      Defer_Res_183 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_128);
      Defer_Pos_183 := Parser.Current_Pos;

      if Defer_Pos_183 /= No_Token_Index then

         Row_Pos_128 := Defer_Pos_183;

      else
         Row_Pos_128 := No_Token_Index;
         goto Exit_Row_126_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_126_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_128 /= No_Token_Index then

         Transform_Res_111 := Allocate_Anonymous_Type_Decl (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_111, Kind => Ada_Anonymous_Type_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_128 = Pos then No_Token_Index else Row_Pos_128 - 1));

         Initialize_Fields_For_Anonymous_Type_Decl
           (Self => Transform_Res_111, Base_Type_Decl_F_Name => Null_Res_7,
            Type_Decl_F_Discriminants => Null_Res_8,
            Type_Decl_F_Type_Def      => Or_Res_51,
            Type_Decl_F_Aspects       => Defer_Res_183);

         if Null_Res_7 /= null and then Is_Incomplete (Null_Res_7) then
            Transform_Res_111.Last_Attempted_Child := 0;
         elsif Null_Res_7 /= null and then not Is_Ghost (Null_Res_7) then
            Transform_Res_111.Last_Attempted_Child := -1;
         end if;
         if Null_Res_8 /= null and then Is_Incomplete (Null_Res_8) then
            Transform_Res_111.Last_Attempted_Child := 0;
         elsif Null_Res_8 /= null and then not Is_Ghost (Null_Res_8) then
            Transform_Res_111.Last_Attempted_Child := -1;
         end if;
         if Or_Res_51 /= null and then Is_Incomplete (Or_Res_51) then
            Transform_Res_111.Last_Attempted_Child := 0;
         elsif Or_Res_51 /= null and then not Is_Ghost (Or_Res_51) then
            Transform_Res_111.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_183 /= null and then Is_Incomplete (Defer_Res_183) then
            Transform_Res_111.Last_Attempted_Child := 0;
         elsif Defer_Res_183 /= null and then not Is_Ghost (Defer_Res_183) then
            Transform_Res_111.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Anonymous_Type_Decl_Transform_Parse_0_Memo,
         Row_Pos_128 /= No_Token_Index, Transform_Res_111, Pos, Row_Pos_128);

      Parser.Current_Pos := Row_Pos_128;

      return Transform_Res_111;
   end Anonymous_Type_Decl_Transform_Parse_0;

   function Anonymous_Type_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Anonymous_Type
   is
      use Bare_Anonymous_Type_Memos;

      Row_Pos_127       : Token_Index              := No_Token_Index;
      Defer_Pos_180     : Token_Index              := No_Token_Index;
      Defer_Res_180     : Bare_Anonymous_Type_Decl := No_Bare_Ada_Node;
      Transform_Res_110 : Bare_Anonymous_Type      := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Anonymous_Type_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_110  := M.Instance;
         return Transform_Res_110;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_110;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_127 := Pos;

      Defer_Res_180 :=
        Anonymous_Type_Decl_Transform_Parse_0 (Parser, Row_Pos_127);
      Defer_Pos_180 := Parser.Current_Pos;

      if Defer_Pos_180 /= No_Token_Index then

         Row_Pos_127 := Defer_Pos_180;

      else
         Row_Pos_127 := No_Token_Index;
         goto Exit_Row_125_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_125_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_127 /= No_Token_Index then

         Transform_Res_110 := Allocate_Anonymous_Type (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_110, Kind => Ada_Anonymous_Type,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_127 = Pos then No_Token_Index else Row_Pos_127 - 1));

         Initialize_Fields_For_Anonymous_Type
           (Self                       => Transform_Res_110,
            Anonymous_Type_F_Type_Decl => Defer_Res_180);

         if Defer_Res_180 /= null and then Is_Incomplete (Defer_Res_180) then
            Transform_Res_110.Last_Attempted_Child := 0;
         elsif Defer_Res_180 /= null and then not Is_Ghost (Defer_Res_180) then
            Transform_Res_110.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Anonymous_Type_Transform_Parse_0_Memo,
         Row_Pos_127 /= No_Token_Index, Transform_Res_110, Pos, Row_Pos_127);

      Parser.Current_Pos := Row_Pos_127;

      return Transform_Res_110;
   end Anonymous_Type_Transform_Parse_0;

   function Type_Expr_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Type_Expr
   is
      use Bare_Type_Expr_Memos;

      Defer_Pos_178 : Token_Index             := No_Token_Index;
      Defer_Res_178 : Bare_Anonymous_Type     := No_Bare_Ada_Node;
      Defer_Pos_179 : Token_Index             := No_Token_Index;
      Defer_Res_179 : Bare_Subtype_Indication := No_Bare_Ada_Node;
      Or_Pos_50     : Token_Index             := No_Token_Index;
      Or_Res_50     : Bare_Type_Expr          := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Type_Expr_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_50          := M.Instance;
         return Or_Res_50;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_50;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_50 := No_Token_Index;
      Or_Res_50 := No_Bare_Ada_Node;

      Defer_Res_178 := Anonymous_Type_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_178 := Parser.Current_Pos;

      if Defer_Pos_178 /= No_Token_Index then
         Or_Pos_50 := Defer_Pos_178;
         Or_Res_50 := Defer_Res_178;
         goto Exit_Or_50;
      end if;

      Defer_Res_179 := Subtype_Indication_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_179 := Parser.Current_Pos;

      if Defer_Pos_179 /= No_Token_Index then
         Or_Pos_50 := Defer_Pos_179;
         Or_Res_50 := Defer_Res_179;
         goto Exit_Or_50;
      end if;
      <<Exit_Or_50>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Type_Expr_Or_Parse_0_Memo,
         Or_Pos_50 /= No_Token_Index, Or_Res_50, Pos, Or_Pos_50);

      Parser.Current_Pos := Or_Pos_50;

      return Or_Res_50;
   end Type_Expr_Or_Parse_0;

   function Param_Spec_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Param_Spec
   is
      use Bare_Param_Spec_Memos;

      Row_Pos_121       : Token_Index             := No_Token_Index;
      Lst_Cpos_14       : Token_Index             := No_Token_Index;
      Tmp_List_14       : Free_Parse_List;
      Defer_Pos_174     : Token_Index             := No_Token_Index;
      Defer_Res_174     : Bare_Defining_Name      := No_Bare_Ada_Node;
      Token_Pos_140     : Token_Index             := No_Token_Index;
      Token_Res_140     : Token_Index             := No_Token_Index;
      List_Pos_14       : Token_Index             := No_Token_Index;
      List_Res_14       : Bare_Defining_Name_List := No_Bare_Ada_Node;
      Token_Pos_141     : Token_Index             := No_Token_Index;
      Token_Res_141     : Token_Index             := No_Token_Index;
      Token_Pos_142     : Token_Index             := No_Token_Index;
      Token_Res_142     : Token_Index             := No_Token_Index;
      Opt_Res_3         : Bare_Aliased_Node       := No_Bare_Ada_Node;
      Defer_Pos_175     : Token_Index             := No_Token_Index;
      Defer_Res_175     : Bare_Mode               := No_Bare_Ada_Node;
      Defer_Pos_176     : Token_Index             := No_Token_Index;
      Defer_Res_176     : Bare_Type_Expr          := No_Bare_Ada_Node;
      Row_Pos_122       : Token_Index             := No_Token_Index;
      Token_Pos_143     : Token_Index             := No_Token_Index;
      Token_Res_143     : Token_Index             := No_Token_Index;
      Defer_Pos_177     : Token_Index             := No_Token_Index;
      Defer_Res_177     : Bare_Expr               := No_Bare_Ada_Node;
      Transform_Res_105 : Bare_Param_Spec         := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Param_Spec_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_105  := M.Instance;
         return Transform_Res_105;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_105;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_121 := Pos;

--  Start list_code

      List_Pos_14 := No_Token_Index;

      Lst_Cpos_14 := Row_Pos_121;
      Tmp_List_14 := Get_Parse_List (Parser);

      loop

         Defer_Res_174 := Defining_Id_Transform_Parse_0 (Parser, Lst_Cpos_14);
         Defer_Pos_174 := Parser.Current_Pos;

         exit when Defer_Pos_174 = No_Token_Index;

         List_Pos_14 := Defer_Pos_174;
         Lst_Cpos_14 := List_Pos_14;

         Tmp_List_14.Nodes.Append (Defer_Res_174);

--  Start tok_code

         Token_Res_140 := Lst_Cpos_14;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_140));
         begin
            if T.Kind /= From_Token_Kind (Ada_Comma) then
               Token_Pos_140 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_14 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_14,
                     Expected_Token_Id => Ada_Comma,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_140 := Lst_Cpos_14 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_140 /= No_Token_Index then
            Lst_Cpos_14 := Token_Pos_140;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_14.Nodes.Length;
      begin
         List_Res_14 := Allocate_Defining_Name_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_121;
            Token_End   :=
              (if Lst_Cpos_14 = Row_Pos_121 then Row_Pos_121
               else Lst_Cpos_14 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_121, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self            => List_Res_14, Kind => Ada_Defining_Name_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_14, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_14.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_14.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_14);

--  End list_code

      if List_Pos_14 /= No_Token_Index then

         Row_Pos_121 := List_Pos_14;

      else
         Row_Pos_121 := No_Token_Index;
         goto Exit_Row_120_0;

      end if;

--  Start tok_code

      Token_Res_141 := Row_Pos_121;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_141));
      begin
         if T.Kind /= From_Token_Kind (Ada_Colon) then
            Token_Pos_141 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_121 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_121,
                  Expected_Token_Id => Ada_Colon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_141 := Row_Pos_121 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_141 /= No_Token_Index then

         Row_Pos_121 := Token_Pos_141;

      else
         Row_Pos_121 := No_Token_Index;
         goto Exit_Row_120_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_142 := Row_Pos_121;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_142));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol
               (Parser.TDH.Symbols, Precomputed_Symbol_Aliased)
         then
            Token_Pos_142 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_121 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_121,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_142 := Row_Pos_121 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_142 = No_Token_Index then

         Opt_Res_3 := Allocate_Aliased_Absent (Parser.Mem_Pool);
         Initialize
           (Self => Opt_Res_3, Kind => Ada_Aliased_Absent, Unit => Parser.Unit,
            Token_Start_Index => Row_Pos_121,
            Token_End_Index   => No_Token_Index);

         Token_Pos_142 := Row_Pos_121;

      else

         Opt_Res_3 := Allocate_Aliased_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_3, Kind => Ada_Aliased_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_121,
            Token_End_Index => Token_Pos_142 - 1);

      end if;

--  End opt_code

      if Token_Pos_142 /= No_Token_Index then

         Row_Pos_121 := Token_Pos_142;

      else
         Row_Pos_121 := No_Token_Index;
         goto Exit_Row_120_0;

      end if;

--  Start opt_code

      Defer_Res_175 := Mode_Or_Parse_0 (Parser, Row_Pos_121);
      Defer_Pos_175 := Parser.Current_Pos;

      if Defer_Pos_175 = No_Token_Index then

         Defer_Res_175 := No_Bare_Ada_Node;

         Defer_Pos_175 := Row_Pos_121;

      end if;

--  End opt_code

      if Defer_Pos_175 /= No_Token_Index then

         Row_Pos_121 := Defer_Pos_175;

      else
         Row_Pos_121 := No_Token_Index;
         goto Exit_Row_120_0;

      end if;

      Defer_Res_176 := Type_Expr_Or_Parse_0 (Parser, Row_Pos_121);
      Defer_Pos_176 := Parser.Current_Pos;

      if Defer_Pos_176 /= No_Token_Index then

         Row_Pos_121 := Defer_Pos_176;

      else
         Row_Pos_121 := No_Token_Index;
         goto Exit_Row_120_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_122 := Row_Pos_121;

--  Start tok_code

      Token_Res_143 := Row_Pos_122;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_143));
      begin
         if T.Kind /= From_Token_Kind (Ada_Assign) then
            Token_Pos_143 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_122 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_122,
                  Expected_Token_Id => Ada_Assign,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_143 := Row_Pos_122 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_143 /= No_Token_Index then

         Row_Pos_122 := Token_Pos_143;

      else
         Row_Pos_122 := No_Token_Index;
         goto Exit_Row_136_0;

      end if;

      Defer_Res_177 := Expr_Or_Parse_0 (Parser, Row_Pos_122);
      Defer_Pos_177 := Parser.Current_Pos;

      if Defer_Pos_177 /= No_Token_Index then

         Row_Pos_122 := Defer_Pos_177;

      else
         Row_Pos_122 := No_Token_Index;
         goto Exit_Row_136_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_136_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_122 = No_Token_Index then

         Defer_Res_177 := No_Bare_Ada_Node;

         Row_Pos_122 := Row_Pos_121;

      end if;

--  End opt_code

      if Row_Pos_122 /= No_Token_Index then

         Row_Pos_121 := Row_Pos_122;

      else
         Row_Pos_121 := No_Token_Index;
         goto Exit_Row_120_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_120_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_121 /= No_Token_Index then

         Transform_Res_105 := Allocate_Param_Spec (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_105, Kind => Ada_Param_Spec,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_121 = Pos then No_Token_Index else Row_Pos_121 - 1));

         Initialize_Fields_For_Param_Spec
           (Self => Transform_Res_105, Param_Spec_F_Ids => List_Res_14,
            Param_Spec_F_Has_Aliased  => Opt_Res_3,
            Param_Spec_F_Mode         => Defer_Res_175,
            Param_Spec_F_Type_Expr    => Defer_Res_176,
            Param_Spec_F_Default_Expr => Defer_Res_177);

         if List_Res_14 /= null and then Is_Incomplete (List_Res_14) then
            Transform_Res_105.Last_Attempted_Child := 0;
         elsif List_Res_14 /= null and then not Is_Ghost (List_Res_14) then
            Transform_Res_105.Last_Attempted_Child := -1;
         end if;
         if Opt_Res_3 /= null and then Is_Incomplete (Opt_Res_3) then
            Transform_Res_105.Last_Attempted_Child := 0;
         elsif Opt_Res_3 /= null and then not Is_Ghost (Opt_Res_3) then
            Transform_Res_105.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_175 /= null and then Is_Incomplete (Defer_Res_175) then
            Transform_Res_105.Last_Attempted_Child := 0;
         elsif Defer_Res_175 /= null and then not Is_Ghost (Defer_Res_175) then
            Transform_Res_105.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_176 /= null and then Is_Incomplete (Defer_Res_176) then
            Transform_Res_105.Last_Attempted_Child := 0;
         elsif Defer_Res_176 /= null and then not Is_Ghost (Defer_Res_176) then
            Transform_Res_105.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_177 /= null and then Is_Incomplete (Defer_Res_177) then
            Transform_Res_105.Last_Attempted_Child := 0;
         elsif Defer_Res_177 /= null and then not Is_Ghost (Defer_Res_177) then
            Transform_Res_105.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Param_Spec_Transform_Parse_0_Memo,
         Row_Pos_121 /= No_Token_Index, Transform_Res_105, Pos, Row_Pos_121);

      Parser.Current_Pos := Row_Pos_121;

      return Transform_Res_105;
   end Param_Spec_Transform_Parse_0;

   function Param_Specs_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Params
   is
      use Bare_Params_Memos;

      Nobt_13                 : Boolean              := False;
      Row_Pos_120             : Token_Index          := No_Token_Index;
      Token_Pos_137           : Token_Index          := No_Token_Index;
      Token_Res_137           : Token_Index          := No_Token_Index;
      Lst_Cpos_13             : Token_Index          := No_Token_Index;
      Tmp_List_13             : Free_Parse_List;
      Defer_Pos_173           : Token_Index          := No_Token_Index;
      Defer_Res_173           : Bare_Param_Spec      := No_Bare_Ada_Node;
      Token_Pos_138           : Token_Index          := No_Token_Index;
      Token_Res_138           : Token_Index          := No_Token_Index;
      List_Pos_13             : Token_Index          := No_Token_Index;
      List_Res_13             : Bare_Param_Spec_List := No_Bare_Ada_Node;
      Token_Pos_139           : Token_Index          := No_Token_Index;
      Token_Res_139           : Token_Index          := No_Token_Index;
      Row_Progress_13         : Integer              := 0;
      Transform_Res_104       : Bare_Params          := No_Bare_Ada_Node;
      Transform_Has_Failed_13 : Boolean              := False;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Param_Specs_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_104  := M.Instance;
         return Transform_Res_104;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_104;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_120 := Pos;

--  Start tok_code

      Token_Res_137 := Row_Pos_120;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_137));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Open) then
            Token_Pos_137 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_120 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_120,
                  Expected_Token_Id => Ada_Par_Open,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_137 := Row_Pos_120 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_13 := 1;

      if Token_Pos_137 /= No_Token_Index then

         Row_Pos_120 := Token_Pos_137;

      else
         Row_Pos_120 := No_Token_Index;
         goto Exit_Row_119_0;

      end if;

      Nobt_13 := True;

      Row_Progress_13 := 2;

      if Row_Pos_120 /= No_Token_Index then

         Row_Pos_120 := Row_Pos_120;

      else
         Row_Pos_120 := No_Token_Index;
         goto Exit_Row_119_0;

      end if;

--  Start list_code

      List_Pos_13 := No_Token_Index;

      Lst_Cpos_13 := Row_Pos_120;
      Tmp_List_13 := Get_Parse_List (Parser);

      loop

         Defer_Res_173 := Param_Spec_Transform_Parse_0 (Parser, Lst_Cpos_13);
         Defer_Pos_173 := Parser.Current_Pos;

         exit when Defer_Pos_173 = No_Token_Index;

         List_Pos_13 := Defer_Pos_173;
         Lst_Cpos_13 := List_Pos_13;

         Tmp_List_13.Nodes.Append (Defer_Res_173);

--  Start tok_code

         Token_Res_138 := Lst_Cpos_13;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_138));
         begin
            if T.Kind /= From_Token_Kind (Ada_Semicolon) then
               Token_Pos_138 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_13 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_13,
                     Expected_Token_Id => Ada_Semicolon,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_138 := Lst_Cpos_13 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_138 /= No_Token_Index then
            Lst_Cpos_13 := Token_Pos_138;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_13.Nodes.Length;
      begin
         List_Res_13 := Allocate_Param_Spec_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_120;
            Token_End   :=
              (if Lst_Cpos_13 = Row_Pos_120 then Row_Pos_120
               else Lst_Cpos_13 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_120, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self            => List_Res_13, Kind => Ada_Param_Spec_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_13, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_13.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_13.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_13);

--  End list_code

      Row_Progress_13 := 3;

      if List_Pos_13 /= No_Token_Index then

         Row_Pos_120 := List_Pos_13;

      else
         Row_Pos_120 := No_Token_Index;
         goto Exit_Row_119_0;

      end if;

--  Start tok_code

      Token_Res_139 := Row_Pos_120;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_139));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Close) then
            Token_Pos_139 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_120 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_120,
                  Expected_Token_Id => Ada_Par_Close,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_139 := Row_Pos_120 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_13 := 4;

      if Token_Pos_139 /= No_Token_Index then

         Row_Pos_120 := Token_Pos_139;

      else
         Row_Pos_120 := No_Token_Index;
         goto Exit_Row_119_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_119_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_120 = No_Token_Index and then Nobt_13 then
         Row_Pos_120             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_13 := True;
      end if;

      if Row_Pos_120 /= No_Token_Index then

         Transform_Res_104 := Allocate_Params (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_104, Kind => Ada_Params, Unit => Parser.Unit,

            Token_Start_Index => Pos,
            Token_End_Index   =>
              (if Row_Pos_120 = Pos then No_Token_Index else Row_Pos_120 - 1));

         Initialize_Fields_For_Params
           (Self => Transform_Res_104, Params_F_Params => List_Res_13);

         if List_Res_13 /= null and then Is_Incomplete (List_Res_13) then
            Transform_Res_104.Last_Attempted_Child := 0;
         elsif List_Res_13 /= null and then not Is_Ghost (List_Res_13) then
            Transform_Res_104.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_13 then
            Transform_Res_104.Last_Attempted_Child := Row_Progress_13;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <param_specs>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Param_Specs_Transform_Parse_0_Memo,
         Row_Pos_120 /= No_Token_Index, Transform_Res_104, Pos, Row_Pos_120);

      Parser.Current_Pos := Row_Pos_120;

      return Transform_Res_104;
   end Param_Specs_Transform_Parse_0;

   function Subp_Spec_Transform_Parse_2
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Subp_Spec
   is
      use Bare_Subp_Spec_Memos;

      Row_Pos_114       : Token_Index              := No_Token_Index;
      Row_Pos_115       : Token_Index              := No_Token_Index;
      Token_Pos_133     : Token_Index              := No_Token_Index;
      Token_Res_133     : Token_Index              := No_Token_Index;
      Transform_Res_99  : Bare_Subp_Kind_Procedure := No_Bare_Ada_Node;
      Row_Pos_116       : Token_Index              := No_Token_Index;
      Token_Pos_134     : Token_Index              := No_Token_Index;
      Token_Res_134     : Token_Index              := No_Token_Index;
      Transform_Res_100 : Bare_Subp_Kind_Function  := No_Bare_Ada_Node;
      Or_Pos_47         : Token_Index              := No_Token_Index;
      Or_Res_47         : Bare_Subp_Kind           := No_Bare_Ada_Node;
      Defer_Pos_166     : Token_Index              := No_Token_Index;
      Defer_Res_166     : Bare_Defining_Name       := No_Bare_Ada_Node;
      Defer_Pos_167     : Token_Index              := No_Token_Index;
      Defer_Res_167     : Bare_Params              := No_Bare_Ada_Node;
      Row_Pos_117       : Token_Index              := No_Token_Index;
      Token_Pos_135     : Token_Index              := No_Token_Index;
      Token_Res_135     : Token_Index              := No_Token_Index;
      Defer_Pos_168     : Token_Index              := No_Token_Index;
      Defer_Res_168     : Bare_Type_Expr           := No_Bare_Ada_Node;
      Transform_Res_101 : Bare_Subp_Spec           := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Subp_Spec_Transform_Parse_2_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_101  := M.Instance;
         return Transform_Res_101;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_101;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_114 := Pos;

--  Start or_code

      Or_Pos_47 := No_Token_Index;
      Or_Res_47 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_115 := Row_Pos_114;

--  Start tok_code

      Token_Res_133 := Row_Pos_115;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_133));
      begin
         if T.Kind /= From_Token_Kind (Ada_Procedure) then
            Token_Pos_133 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_115 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_115,
                  Expected_Token_Id => Ada_Procedure,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_133 := Row_Pos_115 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_133 /= No_Token_Index then

         Row_Pos_115 := Token_Pos_133;

      else
         Row_Pos_115 := No_Token_Index;
         goto Exit_Row_115_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_115_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_115 /= No_Token_Index then

         Transform_Res_99 := Allocate_Subp_Kind_Procedure (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_99, Kind => Ada_Subp_Kind_Procedure,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_114,
            Token_End_Index =>
              (if Row_Pos_115 = Row_Pos_114 then No_Token_Index
               else Row_Pos_115 - 1));

      end if;

--  End transform_code

      if Row_Pos_115 /= No_Token_Index then
         Or_Pos_47 := Row_Pos_115;
         Or_Res_47 := Transform_Res_99;
         goto Exit_Or_47;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_116 := Row_Pos_114;

--  Start tok_code

      Token_Res_134 := Row_Pos_116;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_134));
      begin
         if T.Kind /= From_Token_Kind (Ada_Function) then
            Token_Pos_134 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_116 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_116,
                  Expected_Token_Id => Ada_Function,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_134 := Row_Pos_116 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_134 /= No_Token_Index then

         Row_Pos_116 := Token_Pos_134;

      else
         Row_Pos_116 := No_Token_Index;
         goto Exit_Row_116_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_116_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_116 /= No_Token_Index then

         Transform_Res_100 := Allocate_Subp_Kind_Function (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_100, Kind => Ada_Subp_Kind_Function,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_114,
            Token_End_Index =>
              (if Row_Pos_116 = Row_Pos_114 then No_Token_Index
               else Row_Pos_116 - 1));

      end if;

--  End transform_code

      if Row_Pos_116 /= No_Token_Index then
         Or_Pos_47 := Row_Pos_116;
         Or_Res_47 := Transform_Res_100;
         goto Exit_Or_47;
      end if;
      <<Exit_Or_47>>

--  End or_code

      if Or_Pos_47 /= No_Token_Index then

         Row_Pos_114 := Or_Pos_47;

      else
         Row_Pos_114 := No_Token_Index;
         goto Exit_Row_114_0;

      end if;

--  Start opt_code

      Defer_Res_166 := Defining_Name_Transform_Parse_0 (Parser, Row_Pos_114);
      Defer_Pos_166 := Parser.Current_Pos;

      if Defer_Pos_166 = No_Token_Index then

         Defer_Res_166 := No_Bare_Ada_Node;

         Defer_Pos_166 := Row_Pos_114;

      end if;

--  End opt_code

      if Defer_Pos_166 /= No_Token_Index then

         Row_Pos_114 := Defer_Pos_166;

      else
         Row_Pos_114 := No_Token_Index;
         goto Exit_Row_114_0;

      end if;

--  Start opt_code

      Defer_Res_167 := Param_Specs_Transform_Parse_0 (Parser, Row_Pos_114);
      Defer_Pos_167 := Parser.Current_Pos;

      if Defer_Pos_167 = No_Token_Index then

         Defer_Res_167 := No_Bare_Ada_Node;

         Defer_Pos_167 := Row_Pos_114;

      end if;

--  End opt_code

      if Defer_Pos_167 /= No_Token_Index then

         Row_Pos_114 := Defer_Pos_167;

      else
         Row_Pos_114 := No_Token_Index;
         goto Exit_Row_114_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_117 := Row_Pos_114;

--  Start tok_code

      Token_Res_135 := Row_Pos_117;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_135));
      begin
         if T.Kind /= From_Token_Kind (Ada_Return) then
            Token_Pos_135 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_117 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_117,
                  Expected_Token_Id => Ada_Return,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_135 := Row_Pos_117 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_135 /= No_Token_Index then

         Row_Pos_117 := Token_Pos_135;

      else
         Row_Pos_117 := No_Token_Index;
         goto Exit_Row_137_0;

      end if;

      Defer_Res_168 := Type_Expr_Or_Parse_0 (Parser, Row_Pos_117);
      Defer_Pos_168 := Parser.Current_Pos;

      if Defer_Pos_168 /= No_Token_Index then

         Row_Pos_117 := Defer_Pos_168;

      else
         Row_Pos_117 := No_Token_Index;
         goto Exit_Row_137_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_137_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_117 = No_Token_Index then

         Defer_Res_168 := No_Bare_Ada_Node;

         Row_Pos_117 := Row_Pos_114;

      end if;

--  End opt_code

      if Row_Pos_117 /= No_Token_Index then

         Row_Pos_114 := Row_Pos_117;

      else
         Row_Pos_114 := No_Token_Index;
         goto Exit_Row_114_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_114_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_114 /= No_Token_Index then

         Transform_Res_101 := Allocate_Subp_Spec (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_101, Kind => Ada_Subp_Spec,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_114 = Pos then No_Token_Index else Row_Pos_114 - 1));

         Initialize_Fields_For_Subp_Spec
           (Self => Transform_Res_101, Subp_Spec_F_Subp_Kind => Or_Res_47,
            Subp_Spec_F_Subp_Name    => Defer_Res_166,
            Subp_Spec_F_Subp_Params  => Defer_Res_167,
            Subp_Spec_F_Subp_Returns => Defer_Res_168);

         if Or_Res_47 /= null and then Is_Incomplete (Or_Res_47) then
            Transform_Res_101.Last_Attempted_Child := 0;
         elsif Or_Res_47 /= null and then not Is_Ghost (Or_Res_47) then
            Transform_Res_101.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_166 /= null and then Is_Incomplete (Defer_Res_166) then
            Transform_Res_101.Last_Attempted_Child := 0;
         elsif Defer_Res_166 /= null and then not Is_Ghost (Defer_Res_166) then
            Transform_Res_101.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_167 /= null and then Is_Incomplete (Defer_Res_167) then
            Transform_Res_101.Last_Attempted_Child := 0;
         elsif Defer_Res_167 /= null and then not Is_Ghost (Defer_Res_167) then
            Transform_Res_101.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_168 /= null and then Is_Incomplete (Defer_Res_168) then
            Transform_Res_101.Last_Attempted_Child := 0;
         elsif Defer_Res_168 /= null and then not Is_Ghost (Defer_Res_168) then
            Transform_Res_101.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Subp_Spec_Transform_Parse_2_Memo,
         Row_Pos_114 /= No_Token_Index, Transform_Res_101, Pos, Row_Pos_114);

      Parser.Current_Pos := Row_Pos_114;

      return Transform_Res_101;
   end Subp_Spec_Transform_Parse_2;

   function Simple_Subp_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Subp_Decl
   is
      use Bare_Subp_Decl_Memos;

      Row_Pos_110      : Token_Index          := No_Token_Index;
      Defer_Pos_163    : Token_Index          := No_Token_Index;
      Defer_Res_163    : Bare_Overriding_Node := No_Bare_Ada_Node;
      Defer_Pos_164    : Token_Index          := No_Token_Index;
      Defer_Res_164    : Bare_Subp_Spec       := No_Bare_Ada_Node;
      Defer_Pos_165    : Token_Index          := No_Token_Index;
      Defer_Res_165    : Bare_Aspect_Spec     := No_Bare_Ada_Node;
      Token_Pos_129    : Token_Index          := No_Token_Index;
      Token_Res_129    : Token_Index          := No_Token_Index;
      Transform_Res_95 : Bare_Subp_Decl       := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Simple_Subp_Decl_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_95   := M.Instance;
         return Transform_Res_95;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_95;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_110 := Pos;

      Defer_Res_163 := Overriding_Indicator_Or_Parse_0 (Parser, Row_Pos_110);
      Defer_Pos_163 := Parser.Current_Pos;

      if Defer_Pos_163 /= No_Token_Index then

         Row_Pos_110 := Defer_Pos_163;

      else
         Row_Pos_110 := No_Token_Index;
         goto Exit_Row_110_0;

      end if;

      Defer_Res_164 := Subp_Spec_Transform_Parse_2 (Parser, Row_Pos_110);
      Defer_Pos_164 := Parser.Current_Pos;

      if Defer_Pos_164 /= No_Token_Index then

         Row_Pos_110 := Defer_Pos_164;

      else
         Row_Pos_110 := No_Token_Index;
         goto Exit_Row_110_0;

      end if;

      Defer_Res_165 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_110);
      Defer_Pos_165 := Parser.Current_Pos;

      if Defer_Pos_165 /= No_Token_Index then

         Row_Pos_110 := Defer_Pos_165;

      else
         Row_Pos_110 := No_Token_Index;
         goto Exit_Row_110_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_129 := Row_Pos_110;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_129));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_129 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_110 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_110,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_129 := Row_Pos_110 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_129 = No_Token_Index then

         Token_Res_129 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_110).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_129 := Row_Pos_110;

      end if;

--  End opt_code

      if Token_Pos_129 /= No_Token_Index then

         Row_Pos_110 := Token_Pos_129;

      else
         Row_Pos_110 := No_Token_Index;
         goto Exit_Row_110_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_110_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_110 /= No_Token_Index then

         Transform_Res_95 := Allocate_Subp_Decl (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_95, Kind => Ada_Subp_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_110 = Pos then No_Token_Index else Row_Pos_110 - 1));

         Initialize_Fields_For_Subp_Decl
           (Self                           => Transform_Res_95,
            Classic_Subp_Decl_F_Overriding => Defer_Res_163,
            Classic_Subp_Decl_F_Subp_Spec  => Defer_Res_164,
            Subp_Decl_F_Aspects            => Defer_Res_165);

         if Defer_Res_163 /= null and then Is_Incomplete (Defer_Res_163) then
            Transform_Res_95.Last_Attempted_Child := 0;
         elsif Defer_Res_163 /= null and then not Is_Ghost (Defer_Res_163) then
            Transform_Res_95.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_164 /= null and then Is_Incomplete (Defer_Res_164) then
            Transform_Res_95.Last_Attempted_Child := 0;
         elsif Defer_Res_164 /= null and then not Is_Ghost (Defer_Res_164) then
            Transform_Res_95.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_165 /= null and then Is_Incomplete (Defer_Res_165) then
            Transform_Res_95.Last_Attempted_Child := 0;
         elsif Defer_Res_165 /= null and then not Is_Ghost (Defer_Res_165) then
            Transform_Res_95.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Simple_Subp_Decl_Transform_Parse_0_Memo,
         Row_Pos_110 /= No_Token_Index, Transform_Res_95, Pos, Row_Pos_110);

      Parser.Current_Pos := Row_Pos_110;

      return Transform_Res_95;
   end Simple_Subp_Decl_Transform_Parse_0;

   function Formal_Subp_Decl_Or_Parse_2
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Formal_Subp_Decl
   is
      use Bare_Formal_Subp_Decl_Memos;

      Row_Pos_138       : Token_Index                    := No_Token_Index;
      Token_Pos_166     : Token_Index                    := No_Token_Index;
      Token_Res_166     : Token_Index                    := No_Token_Index;
      Row_Pos_139       : Token_Index                    := No_Token_Index;
      Transform_Res_119 : Bare_Overriding_Unspecified    := No_Bare_Ada_Node;
      Defer_Pos_191     : Token_Index                    := No_Token_Index;
      Defer_Res_191     : Bare_Subp_Spec                 := No_Bare_Ada_Node;
      Token_Pos_167     : Token_Index                    := No_Token_Index;
      Token_Res_167     : Token_Index                    := No_Token_Index;
      Token_Pos_168     : Token_Index                    := No_Token_Index;
      Token_Res_168     : Token_Index                    := No_Token_Index;
      Defer_Pos_192     : Token_Index                    := No_Token_Index;
      Defer_Res_192     : Bare_Box_Expr                  := No_Bare_Ada_Node;
      Defer_Pos_193     : Token_Index                    := No_Token_Index;
      Defer_Res_193     : Bare_Name                      := No_Bare_Ada_Node;
      Defer_Pos_194     : Token_Index                    := No_Token_Index;
      Defer_Res_194     : Bare_Null_Literal              := No_Bare_Ada_Node;
      Or_Pos_54         : Token_Index                    := No_Token_Index;
      Or_Res_54         : Bare_Expr                      := No_Bare_Ada_Node;
      Defer_Pos_195     : Token_Index                    := No_Token_Index;
      Defer_Res_195     : Bare_Aspect_Spec               := No_Bare_Ada_Node;
      Token_Pos_169     : Token_Index                    := No_Token_Index;
      Token_Res_169     : Token_Index                    := No_Token_Index;
      Transform_Res_120 : Bare_Abstract_Formal_Subp_Decl := No_Bare_Ada_Node;
      Row_Pos_140       : Token_Index                    := No_Token_Index;
      Token_Pos_170     : Token_Index                    := No_Token_Index;
      Token_Res_170     : Token_Index                    := No_Token_Index;
      Row_Pos_141       : Token_Index                    := No_Token_Index;
      Transform_Res_121 : Bare_Overriding_Unspecified    := No_Bare_Ada_Node;
      Defer_Pos_196     : Token_Index                    := No_Token_Index;
      Defer_Res_196     : Bare_Subp_Spec                 := No_Bare_Ada_Node;
      Row_Pos_142       : Token_Index                    := No_Token_Index;
      Token_Pos_171     : Token_Index                    := No_Token_Index;
      Token_Res_171     : Token_Index                    := No_Token_Index;
      Defer_Pos_197     : Token_Index                    := No_Token_Index;
      Defer_Res_197     : Bare_Box_Expr                  := No_Bare_Ada_Node;
      Defer_Pos_198     : Token_Index                    := No_Token_Index;
      Defer_Res_198     : Bare_Name                      := No_Bare_Ada_Node;
      Defer_Pos_199     : Token_Index                    := No_Token_Index;
      Defer_Res_199     : Bare_Null_Literal              := No_Bare_Ada_Node;
      Or_Pos_55         : Token_Index                    := No_Token_Index;
      Or_Res_55         : Bare_Expr                      := No_Bare_Ada_Node;
      Defer_Pos_200     : Token_Index                    := No_Token_Index;
      Defer_Res_200     : Bare_Aspect_Spec               := No_Bare_Ada_Node;
      Token_Pos_172     : Token_Index                    := No_Token_Index;
      Token_Res_172     : Token_Index                    := No_Token_Index;
      Transform_Res_122 : Bare_Concrete_Formal_Subp_Decl := No_Bare_Ada_Node;
      Or_Pos_56         : Token_Index                    := No_Token_Index;
      Or_Res_56         : Bare_Formal_Subp_Decl          := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Formal_Subp_Decl_Or_Parse_2_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_56          := M.Instance;
         return Or_Res_56;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_56;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_56 := No_Token_Index;
      Or_Res_56 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_138 := Pos;

--  Start tok_code

      Token_Res_166 := Row_Pos_138;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_166));
      begin
         if T.Kind /= From_Token_Kind (Ada_With) then
            Token_Pos_166 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_138 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_138,
                  Expected_Token_Id => Ada_With,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_166 := Row_Pos_138 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_166 /= No_Token_Index then

         Row_Pos_138 := Token_Pos_166;

      else
         Row_Pos_138 := No_Token_Index;
         goto Exit_Row_138_0;

      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_139 := Row_Pos_138;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_139_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_139 /= No_Token_Index then

         Transform_Res_119 :=
           Allocate_Overriding_Unspecified (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_119, Kind => Ada_Overriding_Unspecified,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_138,
            Token_End_Index =>
              (if Row_Pos_139 = Row_Pos_138 then No_Token_Index
               else Row_Pos_139 - 1));

      end if;

--  End transform_code

      if Row_Pos_139 /= No_Token_Index then

         Row_Pos_138 := Row_Pos_139;

      else
         Row_Pos_138 := No_Token_Index;
         goto Exit_Row_138_0;

      end if;

      Defer_Res_191 := Subp_Spec_Transform_Parse_2 (Parser, Row_Pos_138);
      Defer_Pos_191 := Parser.Current_Pos;

      if Defer_Pos_191 /= No_Token_Index then

         Row_Pos_138 := Defer_Pos_191;

      else
         Row_Pos_138 := No_Token_Index;
         goto Exit_Row_138_0;

      end if;

--  Start tok_code

      Token_Res_167 := Row_Pos_138;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_167));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_167 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_138 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_138,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_167 := Row_Pos_138 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_167 /= No_Token_Index then

         Row_Pos_138 := Token_Pos_167;

      else
         Row_Pos_138 := No_Token_Index;
         goto Exit_Row_138_0;

      end if;

--  Start tok_code

      Token_Res_168 := Row_Pos_138;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_168));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol
               (Parser.TDH.Symbols, Precomputed_Symbol_Abstract)
         then
            Token_Pos_168 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_138 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_138,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_168 := Row_Pos_138 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_168 /= No_Token_Index then

         Row_Pos_138 := Token_Pos_168;

      else
         Row_Pos_138 := No_Token_Index;
         goto Exit_Row_138_0;

      end if;

--  Start opt_code

--  Start or_code

      Or_Pos_54 := No_Token_Index;
      Or_Res_54 := No_Bare_Ada_Node;

      Defer_Res_192 := Box_Expr_Transform_Parse_0 (Parser, Row_Pos_138);
      Defer_Pos_192 := Parser.Current_Pos;

      if Defer_Pos_192 /= No_Token_Index then
         Or_Pos_54 := Defer_Pos_192;
         Or_Res_54 := Defer_Res_192;
         goto Exit_Or_55;
      end if;

      Defer_Res_193 := Name_Or_Parse_1 (Parser, Row_Pos_138);
      Defer_Pos_193 := Parser.Current_Pos;

      if Defer_Pos_193 /= No_Token_Index then
         Or_Pos_54 := Defer_Pos_193;
         Or_Res_54 := Defer_Res_193;
         goto Exit_Or_55;
      end if;

      Defer_Res_194 := Null_Literal_Transform_Parse_0 (Parser, Row_Pos_138);
      Defer_Pos_194 := Parser.Current_Pos;

      if Defer_Pos_194 /= No_Token_Index then
         Or_Pos_54 := Defer_Pos_194;
         Or_Res_54 := Defer_Res_194;
         goto Exit_Or_55;
      end if;
      <<Exit_Or_55>>

--  End or_code

      if Or_Pos_54 = No_Token_Index then

         Or_Res_54 := No_Bare_Ada_Node;

         Or_Pos_54 := Row_Pos_138;

      end if;

--  End opt_code

      if Or_Pos_54 /= No_Token_Index then

         Row_Pos_138 := Or_Pos_54;

      else
         Row_Pos_138 := No_Token_Index;
         goto Exit_Row_138_0;

      end if;

      Defer_Res_195 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_138);
      Defer_Pos_195 := Parser.Current_Pos;

      if Defer_Pos_195 /= No_Token_Index then

         Row_Pos_138 := Defer_Pos_195;

      else
         Row_Pos_138 := No_Token_Index;
         goto Exit_Row_138_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_169 := Row_Pos_138;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_169));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_169 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_138 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_138,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_169 := Row_Pos_138 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_169 = No_Token_Index then

         Token_Res_169 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_138).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_169 := Row_Pos_138;

      end if;

--  End opt_code

      if Token_Pos_169 /= No_Token_Index then

         Row_Pos_138 := Token_Pos_169;

      else
         Row_Pos_138 := No_Token_Index;
         goto Exit_Row_138_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_138_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_138 /= No_Token_Index then

         Transform_Res_120 :=
           Allocate_Abstract_Formal_Subp_Decl (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_120, Kind => Ada_Abstract_Formal_Subp_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_138 = Pos then No_Token_Index else Row_Pos_138 - 1));

         Initialize_Fields_For_Abstract_Formal_Subp_Decl
           (Self                            => Transform_Res_120,
            Classic_Subp_Decl_F_Overriding  => Transform_Res_119,
            Classic_Subp_Decl_F_Subp_Spec   => Defer_Res_191,
            Formal_Subp_Decl_F_Default_Expr => Or_Res_54,
            Formal_Subp_Decl_F_Aspects      => Defer_Res_195);

         if Transform_Res_119 /= null
           and then Is_Incomplete (Transform_Res_119)
         then
            Transform_Res_120.Last_Attempted_Child := 0;
         elsif Transform_Res_119 /= null
           and then not Is_Ghost (Transform_Res_119)
         then
            Transform_Res_120.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_191 /= null and then Is_Incomplete (Defer_Res_191) then
            Transform_Res_120.Last_Attempted_Child := 0;
         elsif Defer_Res_191 /= null and then not Is_Ghost (Defer_Res_191) then
            Transform_Res_120.Last_Attempted_Child := -1;
         end if;
         if Or_Res_54 /= null and then Is_Incomplete (Or_Res_54) then
            Transform_Res_120.Last_Attempted_Child := 0;
         elsif Or_Res_54 /= null and then not Is_Ghost (Or_Res_54) then
            Transform_Res_120.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_195 /= null and then Is_Incomplete (Defer_Res_195) then
            Transform_Res_120.Last_Attempted_Child := 0;
         elsif Defer_Res_195 /= null and then not Is_Ghost (Defer_Res_195) then
            Transform_Res_120.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_138 /= No_Token_Index then
         Or_Pos_56 := Row_Pos_138;
         Or_Res_56 := Transform_Res_120;
         goto Exit_Or_54;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_140 := Pos;

--  Start tok_code

      Token_Res_170 := Row_Pos_140;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_170));
      begin
         if T.Kind /= From_Token_Kind (Ada_With) then
            Token_Pos_170 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_140 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_140,
                  Expected_Token_Id => Ada_With,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_170 := Row_Pos_140 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_170 /= No_Token_Index then

         Row_Pos_140 := Token_Pos_170;

      else
         Row_Pos_140 := No_Token_Index;
         goto Exit_Row_140_0;

      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_141 := Row_Pos_140;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_141_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_141 /= No_Token_Index then

         Transform_Res_121 :=
           Allocate_Overriding_Unspecified (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_121, Kind => Ada_Overriding_Unspecified,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_140,
            Token_End_Index =>
              (if Row_Pos_141 = Row_Pos_140 then No_Token_Index
               else Row_Pos_141 - 1));

      end if;

--  End transform_code

      if Row_Pos_141 /= No_Token_Index then

         Row_Pos_140 := Row_Pos_141;

      else
         Row_Pos_140 := No_Token_Index;
         goto Exit_Row_140_0;

      end if;

      Defer_Res_196 := Subp_Spec_Transform_Parse_2 (Parser, Row_Pos_140);
      Defer_Pos_196 := Parser.Current_Pos;

      if Defer_Pos_196 /= No_Token_Index then

         Row_Pos_140 := Defer_Pos_196;

      else
         Row_Pos_140 := No_Token_Index;
         goto Exit_Row_140_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_142 := Row_Pos_140;

--  Start tok_code

      Token_Res_171 := Row_Pos_142;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_171));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_171 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_142 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_142,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_171 := Row_Pos_142 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_171 /= No_Token_Index then

         Row_Pos_142 := Token_Pos_171;

      else
         Row_Pos_142 := No_Token_Index;
         goto Exit_Row_142_0;

      end if;

--  Start or_code

      Or_Pos_55 := No_Token_Index;
      Or_Res_55 := No_Bare_Ada_Node;

      Defer_Res_197 := Box_Expr_Transform_Parse_0 (Parser, Row_Pos_142);
      Defer_Pos_197 := Parser.Current_Pos;

      if Defer_Pos_197 /= No_Token_Index then
         Or_Pos_55 := Defer_Pos_197;
         Or_Res_55 := Defer_Res_197;
         goto Exit_Or_56;
      end if;

      Defer_Res_198 := Name_Or_Parse_1 (Parser, Row_Pos_142);
      Defer_Pos_198 := Parser.Current_Pos;

      if Defer_Pos_198 /= No_Token_Index then
         Or_Pos_55 := Defer_Pos_198;
         Or_Res_55 := Defer_Res_198;
         goto Exit_Or_56;
      end if;

      Defer_Res_199 := Null_Literal_Transform_Parse_0 (Parser, Row_Pos_142);
      Defer_Pos_199 := Parser.Current_Pos;

      if Defer_Pos_199 /= No_Token_Index then
         Or_Pos_55 := Defer_Pos_199;
         Or_Res_55 := Defer_Res_199;
         goto Exit_Or_56;
      end if;
      <<Exit_Or_56>>

--  End or_code

      if Or_Pos_55 /= No_Token_Index then

         Row_Pos_142 := Or_Pos_55;

      else
         Row_Pos_142 := No_Token_Index;
         goto Exit_Row_142_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_142_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_142 = No_Token_Index then

         Or_Res_55 := No_Bare_Ada_Node;

         Row_Pos_142 := Row_Pos_140;

      end if;

--  End opt_code

      if Row_Pos_142 /= No_Token_Index then

         Row_Pos_140 := Row_Pos_142;

      else
         Row_Pos_140 := No_Token_Index;
         goto Exit_Row_140_0;

      end if;

      Defer_Res_200 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_140);
      Defer_Pos_200 := Parser.Current_Pos;

      if Defer_Pos_200 /= No_Token_Index then

         Row_Pos_140 := Defer_Pos_200;

      else
         Row_Pos_140 := No_Token_Index;
         goto Exit_Row_140_0;

      end if;

--  Start tok_code

      Token_Res_172 := Row_Pos_140;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_172));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_172 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_140 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_140,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_172 := Row_Pos_140 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_172 /= No_Token_Index then

         Row_Pos_140 := Token_Pos_172;

      else
         Row_Pos_140 := No_Token_Index;
         goto Exit_Row_140_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_140_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_140 /= No_Token_Index then

         Transform_Res_122 :=
           Allocate_Concrete_Formal_Subp_Decl (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_122, Kind => Ada_Concrete_Formal_Subp_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_140 = Pos then No_Token_Index else Row_Pos_140 - 1));

         Initialize_Fields_For_Concrete_Formal_Subp_Decl
           (Self                            => Transform_Res_122,
            Classic_Subp_Decl_F_Overriding  => Transform_Res_121,
            Classic_Subp_Decl_F_Subp_Spec   => Defer_Res_196,
            Formal_Subp_Decl_F_Default_Expr => Or_Res_55,
            Formal_Subp_Decl_F_Aspects      => Defer_Res_200);

         if Transform_Res_121 /= null
           and then Is_Incomplete (Transform_Res_121)
         then
            Transform_Res_122.Last_Attempted_Child := 0;
         elsif Transform_Res_121 /= null
           and then not Is_Ghost (Transform_Res_121)
         then
            Transform_Res_122.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_196 /= null and then Is_Incomplete (Defer_Res_196) then
            Transform_Res_122.Last_Attempted_Child := 0;
         elsif Defer_Res_196 /= null and then not Is_Ghost (Defer_Res_196) then
            Transform_Res_122.Last_Attempted_Child := -1;
         end if;
         if Or_Res_55 /= null and then Is_Incomplete (Or_Res_55) then
            Transform_Res_122.Last_Attempted_Child := 0;
         elsif Or_Res_55 /= null and then not Is_Ghost (Or_Res_55) then
            Transform_Res_122.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_200 /= null and then Is_Incomplete (Defer_Res_200) then
            Transform_Res_122.Last_Attempted_Child := 0;
         elsif Defer_Res_200 /= null and then not Is_Ghost (Defer_Res_200) then
            Transform_Res_122.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_140 /= No_Token_Index then
         Or_Pos_56 := Row_Pos_140;
         Or_Res_56 := Transform_Res_122;
         goto Exit_Or_54;
      end if;
      <<Exit_Or_54>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Formal_Subp_Decl_Or_Parse_2_Memo,
         Or_Pos_56 /= No_Token_Index, Or_Res_56, Pos, Or_Pos_56);

      Parser.Current_Pos := Or_Pos_56;

      return Or_Res_56;
   end Formal_Subp_Decl_Or_Parse_2;

   function Null_Subp_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Null_Subp_Decl
   is
      use Bare_Null_Subp_Decl_Memos;

      Row_Pos_145       : Token_Index          := No_Token_Index;
      Defer_Pos_224     : Token_Index          := No_Token_Index;
      Defer_Res_224     : Bare_Overriding_Node := No_Bare_Ada_Node;
      Defer_Pos_225     : Token_Index          := No_Token_Index;
      Defer_Res_225     : Bare_Subp_Spec       := No_Bare_Ada_Node;
      Token_Pos_173     : Token_Index          := No_Token_Index;
      Token_Res_173     : Token_Index          := No_Token_Index;
      Token_Pos_174     : Token_Index          := No_Token_Index;
      Token_Res_174     : Token_Index          := No_Token_Index;
      Defer_Pos_226     : Token_Index          := No_Token_Index;
      Defer_Res_226     : Bare_Aspect_Spec     := No_Bare_Ada_Node;
      Token_Pos_175     : Token_Index          := No_Token_Index;
      Token_Res_175     : Token_Index          := No_Token_Index;
      Transform_Res_125 : Bare_Null_Subp_Decl  := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Null_Subp_Decl_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_125  := M.Instance;
         return Transform_Res_125;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_125;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_145 := Pos;

      Defer_Res_224 := Overriding_Indicator_Or_Parse_0 (Parser, Row_Pos_145);
      Defer_Pos_224 := Parser.Current_Pos;

      if Defer_Pos_224 /= No_Token_Index then

         Row_Pos_145 := Defer_Pos_224;

      else
         Row_Pos_145 := No_Token_Index;
         goto Exit_Row_144_0;

      end if;

      Defer_Res_225 := Subp_Spec_Transform_Parse_2 (Parser, Row_Pos_145);
      Defer_Pos_225 := Parser.Current_Pos;

      if Defer_Pos_225 /= No_Token_Index then

         Row_Pos_145 := Defer_Pos_225;

      else
         Row_Pos_145 := No_Token_Index;
         goto Exit_Row_144_0;

      end if;

--  Start tok_code

      Token_Res_173 := Row_Pos_145;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_173));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_173 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_145 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_145,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_173 := Row_Pos_145 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_173 /= No_Token_Index then

         Row_Pos_145 := Token_Pos_173;

      else
         Row_Pos_145 := No_Token_Index;
         goto Exit_Row_144_0;

      end if;

--  Start tok_code

      Token_Res_174 := Row_Pos_145;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_174));
      begin
         if T.Kind /= From_Token_Kind (Ada_Null) then
            Token_Pos_174 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_145 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_145,
                  Expected_Token_Id => Ada_Null,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_174 := Row_Pos_145 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_174 /= No_Token_Index then

         Row_Pos_145 := Token_Pos_174;

      else
         Row_Pos_145 := No_Token_Index;
         goto Exit_Row_144_0;

      end if;

      Defer_Res_226 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_145);
      Defer_Pos_226 := Parser.Current_Pos;

      if Defer_Pos_226 /= No_Token_Index then

         Row_Pos_145 := Defer_Pos_226;

      else
         Row_Pos_145 := No_Token_Index;
         goto Exit_Row_144_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_175 := Row_Pos_145;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_175));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_175 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_145 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_145,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_175 := Row_Pos_145 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_175 = No_Token_Index then

         Token_Res_175 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_145).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_175 := Row_Pos_145;

      end if;

--  End opt_code

      if Token_Pos_175 /= No_Token_Index then

         Row_Pos_145 := Token_Pos_175;

      else
         Row_Pos_145 := No_Token_Index;
         goto Exit_Row_144_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_144_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_145 /= No_Token_Index then

         Transform_Res_125 := Allocate_Null_Subp_Decl (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_125, Kind => Ada_Null_Subp_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_145 = Pos then No_Token_Index else Row_Pos_145 - 1));

         Initialize_Fields_For_Null_Subp_Decl
           (Self                        => Transform_Res_125,
            Base_Subp_Body_F_Overriding => Defer_Res_224,
            Base_Subp_Body_F_Subp_Spec  => Defer_Res_225,
            Null_Subp_Decl_F_Aspects    => Defer_Res_226);

         if Defer_Res_224 /= null and then Is_Incomplete (Defer_Res_224) then
            Transform_Res_125.Last_Attempted_Child := 0;
         elsif Defer_Res_224 /= null and then not Is_Ghost (Defer_Res_224) then
            Transform_Res_125.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_225 /= null and then Is_Incomplete (Defer_Res_225) then
            Transform_Res_125.Last_Attempted_Child := 0;
         elsif Defer_Res_225 /= null and then not Is_Ghost (Defer_Res_225) then
            Transform_Res_125.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_226 /= null and then Is_Incomplete (Defer_Res_226) then
            Transform_Res_125.Last_Attempted_Child := 0;
         elsif Defer_Res_226 /= null and then not Is_Ghost (Defer_Res_226) then
            Transform_Res_125.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Null_Subp_Decl_Transform_Parse_0_Memo,
         Row_Pos_145 /= No_Token_Index, Transform_Res_125, Pos, Row_Pos_145);

      Parser.Current_Pos := Row_Pos_145;

      return Transform_Res_125;
   end Null_Subp_Decl_Transform_Parse_0;

   function Abstract_Subp_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Abstract_Subp_Decl
   is
      use Bare_Abstract_Subp_Decl_Memos;

      Row_Pos_146       : Token_Index             := No_Token_Index;
      Defer_Pos_227     : Token_Index             := No_Token_Index;
      Defer_Res_227     : Bare_Overriding_Node    := No_Bare_Ada_Node;
      Defer_Pos_228     : Token_Index             := No_Token_Index;
      Defer_Res_228     : Bare_Subp_Spec          := No_Bare_Ada_Node;
      Token_Pos_176     : Token_Index             := No_Token_Index;
      Token_Res_176     : Token_Index             := No_Token_Index;
      Token_Pos_177     : Token_Index             := No_Token_Index;
      Token_Res_177     : Token_Index             := No_Token_Index;
      Defer_Pos_229     : Token_Index             := No_Token_Index;
      Defer_Res_229     : Bare_Aspect_Spec        := No_Bare_Ada_Node;
      Token_Pos_178     : Token_Index             := No_Token_Index;
      Token_Res_178     : Token_Index             := No_Token_Index;
      Transform_Res_126 : Bare_Abstract_Subp_Decl := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Abstract_Subp_Decl_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_126  := M.Instance;
         return Transform_Res_126;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_126;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_146 := Pos;

      Defer_Res_227 := Overriding_Indicator_Or_Parse_0 (Parser, Row_Pos_146);
      Defer_Pos_227 := Parser.Current_Pos;

      if Defer_Pos_227 /= No_Token_Index then

         Row_Pos_146 := Defer_Pos_227;

      else
         Row_Pos_146 := No_Token_Index;
         goto Exit_Row_145_0;

      end if;

      Defer_Res_228 := Subp_Spec_Transform_Parse_2 (Parser, Row_Pos_146);
      Defer_Pos_228 := Parser.Current_Pos;

      if Defer_Pos_228 /= No_Token_Index then

         Row_Pos_146 := Defer_Pos_228;

      else
         Row_Pos_146 := No_Token_Index;
         goto Exit_Row_145_0;

      end if;

--  Start tok_code

      Token_Res_176 := Row_Pos_146;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_176));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_176 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_146 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_146,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_176 := Row_Pos_146 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_176 /= No_Token_Index then

         Row_Pos_146 := Token_Pos_176;

      else
         Row_Pos_146 := No_Token_Index;
         goto Exit_Row_145_0;

      end if;

--  Start tok_code

      Token_Res_177 := Row_Pos_146;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_177));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol
               (Parser.TDH.Symbols, Precomputed_Symbol_Abstract)
         then
            Token_Pos_177 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_146 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_146,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_177 := Row_Pos_146 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_177 /= No_Token_Index then

         Row_Pos_146 := Token_Pos_177;

      else
         Row_Pos_146 := No_Token_Index;
         goto Exit_Row_145_0;

      end if;

      Defer_Res_229 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_146);
      Defer_Pos_229 := Parser.Current_Pos;

      if Defer_Pos_229 /= No_Token_Index then

         Row_Pos_146 := Defer_Pos_229;

      else
         Row_Pos_146 := No_Token_Index;
         goto Exit_Row_145_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_178 := Row_Pos_146;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_178));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_178 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_146 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_146,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_178 := Row_Pos_146 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_178 = No_Token_Index then

         Token_Res_178 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_146).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_178 := Row_Pos_146;

      end if;

--  End opt_code

      if Token_Pos_178 /= No_Token_Index then

         Row_Pos_146 := Token_Pos_178;

      else
         Row_Pos_146 := No_Token_Index;
         goto Exit_Row_145_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_145_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_146 /= No_Token_Index then

         Transform_Res_126 := Allocate_Abstract_Subp_Decl (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_126, Kind => Ada_Abstract_Subp_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_146 = Pos then No_Token_Index else Row_Pos_146 - 1));

         Initialize_Fields_For_Abstract_Subp_Decl
           (Self                           => Transform_Res_126,
            Classic_Subp_Decl_F_Overriding => Defer_Res_227,
            Classic_Subp_Decl_F_Subp_Spec  => Defer_Res_228,
            Abstract_Subp_Decl_F_Aspects   => Defer_Res_229);

         if Defer_Res_227 /= null and then Is_Incomplete (Defer_Res_227) then
            Transform_Res_126.Last_Attempted_Child := 0;
         elsif Defer_Res_227 /= null and then not Is_Ghost (Defer_Res_227) then
            Transform_Res_126.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_228 /= null and then Is_Incomplete (Defer_Res_228) then
            Transform_Res_126.Last_Attempted_Child := 0;
         elsif Defer_Res_228 /= null and then not Is_Ghost (Defer_Res_228) then
            Transform_Res_126.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_229 /= null and then Is_Incomplete (Defer_Res_229) then
            Transform_Res_126.Last_Attempted_Child := 0;
         elsif Defer_Res_229 /= null and then not Is_Ghost (Defer_Res_229) then
            Transform_Res_126.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Abstract_Subp_Decl_Transform_Parse_0_Memo,
         Row_Pos_146 /= No_Token_Index, Transform_Res_126, Pos, Row_Pos_146);

      Parser.Current_Pos := Row_Pos_146;

      return Transform_Res_126;
   end Abstract_Subp_Decl_Transform_Parse_0;

   function Expr_Fn_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Expr_Function
   is
      use Bare_Expr_Function_Memos;

      Row_Pos_147       : Token_Index          := No_Token_Index;
      Defer_Pos_230     : Token_Index          := No_Token_Index;
      Defer_Res_230     : Bare_Overriding_Node := No_Bare_Ada_Node;
      Defer_Pos_231     : Token_Index          := No_Token_Index;
      Defer_Res_231     : Bare_Subp_Spec       := No_Bare_Ada_Node;
      Token_Pos_179     : Token_Index          := No_Token_Index;
      Token_Res_179     : Token_Index          := No_Token_Index;
      Defer_Pos_232     : Token_Index          := No_Token_Index;
      Defer_Res_232     : Bare_Paren_Expr      := No_Bare_Ada_Node;
      Defer_Pos_233     : Token_Index          := No_Token_Index;
      Defer_Res_233     : Bare_Base_Aggregate  := No_Bare_Ada_Node;
      Or_Pos_59         : Token_Index          := No_Token_Index;
      Or_Res_59         : Bare_Expr            := No_Bare_Ada_Node;
      Defer_Pos_234     : Token_Index          := No_Token_Index;
      Defer_Res_234     : Bare_Aspect_Spec     := No_Bare_Ada_Node;
      Token_Pos_180     : Token_Index          := No_Token_Index;
      Token_Res_180     : Token_Index          := No_Token_Index;
      Transform_Res_127 : Bare_Expr_Function   := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Expr_Fn_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_127  := M.Instance;
         return Transform_Res_127;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_127;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_147 := Pos;

      Defer_Res_230 := Overriding_Indicator_Or_Parse_0 (Parser, Row_Pos_147);
      Defer_Pos_230 := Parser.Current_Pos;

      if Defer_Pos_230 /= No_Token_Index then

         Row_Pos_147 := Defer_Pos_230;

      else
         Row_Pos_147 := No_Token_Index;
         goto Exit_Row_146_0;

      end if;

      Defer_Res_231 := Subp_Spec_Transform_Parse_2 (Parser, Row_Pos_147);
      Defer_Pos_231 := Parser.Current_Pos;

      if Defer_Pos_231 /= No_Token_Index then

         Row_Pos_147 := Defer_Pos_231;

      else
         Row_Pos_147 := No_Token_Index;
         goto Exit_Row_146_0;

      end if;

--  Start tok_code

      Token_Res_179 := Row_Pos_147;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_179));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_179 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_147 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_147,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_179 := Row_Pos_147 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_179 /= No_Token_Index then

         Row_Pos_147 := Token_Pos_179;

      else
         Row_Pos_147 := No_Token_Index;
         goto Exit_Row_146_0;

      end if;

--  Start or_code

      Or_Pos_59 := No_Token_Index;
      Or_Res_59 := No_Bare_Ada_Node;

      Defer_Res_232 := Paren_Expr_Transform_Parse_0 (Parser, Row_Pos_147);
      Defer_Pos_232 := Parser.Current_Pos;

      if Defer_Pos_232 /= No_Token_Index then
         Or_Pos_59 := Defer_Pos_232;
         Or_Res_59 := Defer_Res_232;
         goto Exit_Or_59;
      end if;

      Defer_Res_233 := Aggregate_Or_Parse_0 (Parser, Row_Pos_147);
      Defer_Pos_233 := Parser.Current_Pos;

      if Defer_Pos_233 /= No_Token_Index then
         Or_Pos_59 := Defer_Pos_233;
         Or_Res_59 := Defer_Res_233;
         goto Exit_Or_59;
      end if;
      <<Exit_Or_59>>

--  End or_code

      if Or_Pos_59 /= No_Token_Index then

         Row_Pos_147 := Or_Pos_59;

      else
         Row_Pos_147 := No_Token_Index;
         goto Exit_Row_146_0;

      end if;

      Defer_Res_234 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_147);
      Defer_Pos_234 := Parser.Current_Pos;

      if Defer_Pos_234 /= No_Token_Index then

         Row_Pos_147 := Defer_Pos_234;

      else
         Row_Pos_147 := No_Token_Index;
         goto Exit_Row_146_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_180 := Row_Pos_147;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_180));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_180 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_147 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_147,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_180 := Row_Pos_147 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_180 = No_Token_Index then

         Token_Res_180 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_147).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_180 := Row_Pos_147;

      end if;

--  End opt_code

      if Token_Pos_180 /= No_Token_Index then

         Row_Pos_147 := Token_Pos_180;

      else
         Row_Pos_147 := No_Token_Index;
         goto Exit_Row_146_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_146_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_147 /= No_Token_Index then

         Transform_Res_127 := Allocate_Expr_Function (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_127, Kind => Ada_Expr_Function,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_147 = Pos then No_Token_Index else Row_Pos_147 - 1));

         Initialize_Fields_For_Expr_Function
           (Self                        => Transform_Res_127,
            Base_Subp_Body_F_Overriding => Defer_Res_230,
            Base_Subp_Body_F_Subp_Spec  => Defer_Res_231,
            Expr_Function_F_Expr        => Or_Res_59,
            Expr_Function_F_Aspects     => Defer_Res_234);

         if Defer_Res_230 /= null and then Is_Incomplete (Defer_Res_230) then
            Transform_Res_127.Last_Attempted_Child := 0;
         elsif Defer_Res_230 /= null and then not Is_Ghost (Defer_Res_230) then
            Transform_Res_127.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_231 /= null and then Is_Incomplete (Defer_Res_231) then
            Transform_Res_127.Last_Attempted_Child := 0;
         elsif Defer_Res_231 /= null and then not Is_Ghost (Defer_Res_231) then
            Transform_Res_127.Last_Attempted_Child := -1;
         end if;
         if Or_Res_59 /= null and then Is_Incomplete (Or_Res_59) then
            Transform_Res_127.Last_Attempted_Child := 0;
         elsif Or_Res_59 /= null and then not Is_Ghost (Or_Res_59) then
            Transform_Res_127.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_234 /= null and then Is_Incomplete (Defer_Res_234) then
            Transform_Res_127.Last_Attempted_Child := 0;
         elsif Defer_Res_234 /= null and then not Is_Ghost (Defer_Res_234) then
            Transform_Res_127.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Expr_Fn_Transform_Parse_0_Memo,
         Row_Pos_147 /= No_Token_Index, Transform_Res_127, Pos, Row_Pos_147);

      Parser.Current_Pos := Row_Pos_147;

      return Transform_Res_127;
   end Expr_Fn_Transform_Parse_0;

   function Renaming_Clause_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Renaming_Clause
   is
      use Bare_Renaming_Clause_Memos;

      Row_Pos_149       : Token_Index          := No_Token_Index;
      Token_Pos_182     : Token_Index          := No_Token_Index;
      Token_Res_182     : Token_Index          := No_Token_Index;
      Defer_Pos_239     : Token_Index          := No_Token_Index;
      Defer_Res_239     : Bare_Name            := No_Bare_Ada_Node;
      Transform_Res_129 : Bare_Renaming_Clause := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Renaming_Clause_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_129  := M.Instance;
         return Transform_Res_129;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_129;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_149 := Pos;

--  Start tok_code

      Token_Res_182 := Row_Pos_149;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_182));
      begin
         if T.Kind /= From_Token_Kind (Ada_Renames) then
            Token_Pos_182 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_149 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_149,
                  Expected_Token_Id => Ada_Renames,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_182 := Row_Pos_149 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_182 /= No_Token_Index then

         Row_Pos_149 := Token_Pos_182;

      else
         Row_Pos_149 := No_Token_Index;
         goto Exit_Row_148_0;

      end if;

      Defer_Res_239 := Name_Or_Parse_1 (Parser, Row_Pos_149);
      Defer_Pos_239 := Parser.Current_Pos;

      if Defer_Pos_239 /= No_Token_Index then

         Row_Pos_149 := Defer_Pos_239;

      else
         Row_Pos_149 := No_Token_Index;
         goto Exit_Row_148_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_148_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_149 /= No_Token_Index then

         Transform_Res_129 := Allocate_Renaming_Clause (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_129, Kind => Ada_Renaming_Clause,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_149 = Pos then No_Token_Index else Row_Pos_149 - 1));

         Initialize_Fields_For_Renaming_Clause
           (Self                             => Transform_Res_129,
            Renaming_Clause_F_Renamed_Object => Defer_Res_239);

         if Defer_Res_239 /= null and then Is_Incomplete (Defer_Res_239) then
            Transform_Res_129.Last_Attempted_Child := 0;
         elsif Defer_Res_239 /= null and then not Is_Ghost (Defer_Res_239) then
            Transform_Res_129.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Renaming_Clause_Transform_Parse_0_Memo,
         Row_Pos_149 /= No_Token_Index, Transform_Res_129, Pos, Row_Pos_149);

      Parser.Current_Pos := Row_Pos_149;

      return Transform_Res_129;
   end Renaming_Clause_Transform_Parse_0;

   function Subp_Renaming_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Subp_Renaming_Decl
   is
      use Bare_Subp_Renaming_Decl_Memos;

      Row_Pos_148       : Token_Index             := No_Token_Index;
      Defer_Pos_235     : Token_Index             := No_Token_Index;
      Defer_Res_235     : Bare_Overriding_Node    := No_Bare_Ada_Node;
      Defer_Pos_236     : Token_Index             := No_Token_Index;
      Defer_Res_236     : Bare_Subp_Spec          := No_Bare_Ada_Node;
      Defer_Pos_237     : Token_Index             := No_Token_Index;
      Defer_Res_237     : Bare_Renaming_Clause    := No_Bare_Ada_Node;
      Defer_Pos_238     : Token_Index             := No_Token_Index;
      Defer_Res_238     : Bare_Aspect_Spec        := No_Bare_Ada_Node;
      Token_Pos_181     : Token_Index             := No_Token_Index;
      Token_Res_181     : Token_Index             := No_Token_Index;
      Transform_Res_128 : Bare_Subp_Renaming_Decl := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Subp_Renaming_Decl_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_128  := M.Instance;
         return Transform_Res_128;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_128;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_148 := Pos;

      Defer_Res_235 := Overriding_Indicator_Or_Parse_0 (Parser, Row_Pos_148);
      Defer_Pos_235 := Parser.Current_Pos;

      if Defer_Pos_235 /= No_Token_Index then

         Row_Pos_148 := Defer_Pos_235;

      else
         Row_Pos_148 := No_Token_Index;
         goto Exit_Row_147_0;

      end if;

      Defer_Res_236 := Subp_Spec_Transform_Parse_2 (Parser, Row_Pos_148);
      Defer_Pos_236 := Parser.Current_Pos;

      if Defer_Pos_236 /= No_Token_Index then

         Row_Pos_148 := Defer_Pos_236;

      else
         Row_Pos_148 := No_Token_Index;
         goto Exit_Row_147_0;

      end if;

      Defer_Res_237 := Renaming_Clause_Transform_Parse_0 (Parser, Row_Pos_148);
      Defer_Pos_237 := Parser.Current_Pos;

      if Defer_Pos_237 /= No_Token_Index then

         Row_Pos_148 := Defer_Pos_237;

      else
         Row_Pos_148 := No_Token_Index;
         goto Exit_Row_147_0;

      end if;

      Defer_Res_238 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_148);
      Defer_Pos_238 := Parser.Current_Pos;

      if Defer_Pos_238 /= No_Token_Index then

         Row_Pos_148 := Defer_Pos_238;

      else
         Row_Pos_148 := No_Token_Index;
         goto Exit_Row_147_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_181 := Row_Pos_148;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_181));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_181 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_148 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_148,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_181 := Row_Pos_148 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_181 = No_Token_Index then

         Token_Res_181 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_148).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_181 := Row_Pos_148;

      end if;

--  End opt_code

      if Token_Pos_181 /= No_Token_Index then

         Row_Pos_148 := Token_Pos_181;

      else
         Row_Pos_148 := No_Token_Index;
         goto Exit_Row_147_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_147_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_148 /= No_Token_Index then

         Transform_Res_128 := Allocate_Subp_Renaming_Decl (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_128, Kind => Ada_Subp_Renaming_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_148 = Pos then No_Token_Index else Row_Pos_148 - 1));

         Initialize_Fields_For_Subp_Renaming_Decl
           (Self                         => Transform_Res_128,
            Base_Subp_Body_F_Overriding  => Defer_Res_235,
            Base_Subp_Body_F_Subp_Spec   => Defer_Res_236,
            Subp_Renaming_Decl_F_Renames => Defer_Res_237,
            Subp_Renaming_Decl_F_Aspects => Defer_Res_238);

         if Defer_Res_235 /= null and then Is_Incomplete (Defer_Res_235) then
            Transform_Res_128.Last_Attempted_Child := 0;
         elsif Defer_Res_235 /= null and then not Is_Ghost (Defer_Res_235) then
            Transform_Res_128.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_236 /= null and then Is_Incomplete (Defer_Res_236) then
            Transform_Res_128.Last_Attempted_Child := 0;
         elsif Defer_Res_236 /= null and then not Is_Ghost (Defer_Res_236) then
            Transform_Res_128.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_237 /= null and then Is_Incomplete (Defer_Res_237) then
            Transform_Res_128.Last_Attempted_Child := 0;
         elsif Defer_Res_237 /= null and then not Is_Ghost (Defer_Res_237) then
            Transform_Res_128.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_238 /= null and then Is_Incomplete (Defer_Res_238) then
            Transform_Res_128.Last_Attempted_Child := 0;
         elsif Defer_Res_238 /= null and then not Is_Ghost (Defer_Res_238) then
            Transform_Res_128.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Subp_Renaming_Decl_Transform_Parse_0_Memo,
         Row_Pos_148 /= No_Token_Index, Transform_Res_128, Pos, Row_Pos_148);

      Parser.Current_Pos := Row_Pos_148;

      return Transform_Res_128;
   end Subp_Renaming_Decl_Transform_Parse_0;

   function Subp_Body_Stub_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Subp_Body_Stub
   is
      use Bare_Subp_Body_Stub_Memos;

      Row_Pos_150       : Token_Index          := No_Token_Index;
      Defer_Pos_244     : Token_Index          := No_Token_Index;
      Defer_Res_244     : Bare_Overriding_Node := No_Bare_Ada_Node;
      Defer_Pos_245     : Token_Index          := No_Token_Index;
      Defer_Res_245     : Bare_Subp_Spec       := No_Bare_Ada_Node;
      Token_Pos_183     : Token_Index          := No_Token_Index;
      Token_Res_183     : Token_Index          := No_Token_Index;
      Token_Pos_184     : Token_Index          := No_Token_Index;
      Token_Res_184     : Token_Index          := No_Token_Index;
      Defer_Pos_246     : Token_Index          := No_Token_Index;
      Defer_Res_246     : Bare_Aspect_Spec     := No_Bare_Ada_Node;
      Token_Pos_185     : Token_Index          := No_Token_Index;
      Token_Res_185     : Token_Index          := No_Token_Index;
      Transform_Res_130 : Bare_Subp_Body_Stub  := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Subp_Body_Stub_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_130  := M.Instance;
         return Transform_Res_130;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_130;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_150 := Pos;

      Defer_Res_244 := Overriding_Indicator_Or_Parse_0 (Parser, Row_Pos_150);
      Defer_Pos_244 := Parser.Current_Pos;

      if Defer_Pos_244 /= No_Token_Index then

         Row_Pos_150 := Defer_Pos_244;

      else
         Row_Pos_150 := No_Token_Index;
         goto Exit_Row_149_0;

      end if;

      Defer_Res_245 := Subp_Spec_Transform_Parse_2 (Parser, Row_Pos_150);
      Defer_Pos_245 := Parser.Current_Pos;

      if Defer_Pos_245 /= No_Token_Index then

         Row_Pos_150 := Defer_Pos_245;

      else
         Row_Pos_150 := No_Token_Index;
         goto Exit_Row_149_0;

      end if;

--  Start tok_code

      Token_Res_183 := Row_Pos_150;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_183));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_183 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_150 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_150,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_183 := Row_Pos_150 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_183 /= No_Token_Index then

         Row_Pos_150 := Token_Pos_183;

      else
         Row_Pos_150 := No_Token_Index;
         goto Exit_Row_149_0;

      end if;

--  Start tok_code

      Token_Res_184 := Row_Pos_150;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_184));
      begin
         if T.Kind /= From_Token_Kind (Ada_Separate) then
            Token_Pos_184 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_150 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_150,
                  Expected_Token_Id => Ada_Separate,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_184 := Row_Pos_150 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_184 /= No_Token_Index then

         Row_Pos_150 := Token_Pos_184;

      else
         Row_Pos_150 := No_Token_Index;
         goto Exit_Row_149_0;

      end if;

      Defer_Res_246 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_150);
      Defer_Pos_246 := Parser.Current_Pos;

      if Defer_Pos_246 /= No_Token_Index then

         Row_Pos_150 := Defer_Pos_246;

      else
         Row_Pos_150 := No_Token_Index;
         goto Exit_Row_149_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_185 := Row_Pos_150;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_185));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_185 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_150 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_150,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_185 := Row_Pos_150 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_185 = No_Token_Index then

         Token_Res_185 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_150).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_185 := Row_Pos_150;

      end if;

--  End opt_code

      if Token_Pos_185 /= No_Token_Index then

         Row_Pos_150 := Token_Pos_185;

      else
         Row_Pos_150 := No_Token_Index;
         goto Exit_Row_149_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_149_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_150 /= No_Token_Index then

         Transform_Res_130 := Allocate_Subp_Body_Stub (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_130, Kind => Ada_Subp_Body_Stub,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_150 = Pos then No_Token_Index else Row_Pos_150 - 1));

         Initialize_Fields_For_Subp_Body_Stub
           (Self                        => Transform_Res_130,
            Subp_Body_Stub_F_Overriding => Defer_Res_244,
            Subp_Body_Stub_F_Subp_Spec  => Defer_Res_245,
            Subp_Body_Stub_F_Aspects    => Defer_Res_246);

         if Defer_Res_244 /= null and then Is_Incomplete (Defer_Res_244) then
            Transform_Res_130.Last_Attempted_Child := 0;
         elsif Defer_Res_244 /= null and then not Is_Ghost (Defer_Res_244) then
            Transform_Res_130.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_245 /= null and then Is_Incomplete (Defer_Res_245) then
            Transform_Res_130.Last_Attempted_Child := 0;
         elsif Defer_Res_245 /= null and then not Is_Ghost (Defer_Res_245) then
            Transform_Res_130.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_246 /= null and then Is_Incomplete (Defer_Res_246) then
            Transform_Res_130.Last_Attempted_Child := 0;
         elsif Defer_Res_246 /= null and then not Is_Ghost (Defer_Res_246) then
            Transform_Res_130.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Subp_Body_Stub_Transform_Parse_0_Memo,
         Row_Pos_150 /= No_Token_Index, Transform_Res_130, Pos, Row_Pos_150);

      Parser.Current_Pos := Row_Pos_150;

      return Transform_Res_130;
   end Subp_Body_Stub_Transform_Parse_0;

   function Package_Body_Stub_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Package_Body_Stub
   is
      use Bare_Package_Body_Stub_Memos;

      Row_Pos_151       : Token_Index            := No_Token_Index;
      Token_Pos_186     : Token_Index            := No_Token_Index;
      Token_Res_186     : Token_Index            := No_Token_Index;
      Token_Pos_187     : Token_Index            := No_Token_Index;
      Token_Res_187     : Token_Index            := No_Token_Index;
      Defer_Pos_247     : Token_Index            := No_Token_Index;
      Defer_Res_247     : Bare_Defining_Name     := No_Bare_Ada_Node;
      Token_Pos_188     : Token_Index            := No_Token_Index;
      Token_Res_188     : Token_Index            := No_Token_Index;
      Token_Pos_189     : Token_Index            := No_Token_Index;
      Token_Res_189     : Token_Index            := No_Token_Index;
      Defer_Pos_248     : Token_Index            := No_Token_Index;
      Defer_Res_248     : Bare_Aspect_Spec       := No_Bare_Ada_Node;
      Token_Pos_190     : Token_Index            := No_Token_Index;
      Token_Res_190     : Token_Index            := No_Token_Index;
      Transform_Res_131 : Bare_Package_Body_Stub := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Package_Body_Stub_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_131  := M.Instance;
         return Transform_Res_131;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_131;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_151 := Pos;

--  Start tok_code

      Token_Res_186 := Row_Pos_151;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_186));
      begin
         if T.Kind /= From_Token_Kind (Ada_Package) then
            Token_Pos_186 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_151 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_151,
                  Expected_Token_Id => Ada_Package,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_186 := Row_Pos_151 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_186 /= No_Token_Index then

         Row_Pos_151 := Token_Pos_186;

      else
         Row_Pos_151 := No_Token_Index;
         goto Exit_Row_150_0;

      end if;

--  Start tok_code

      Token_Res_187 := Row_Pos_151;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_187));
      begin
         if T.Kind /= From_Token_Kind (Ada_Body) then
            Token_Pos_187 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_151 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_151,
                  Expected_Token_Id => Ada_Body,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_187 := Row_Pos_151 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_187 /= No_Token_Index then

         Row_Pos_151 := Token_Pos_187;

      else
         Row_Pos_151 := No_Token_Index;
         goto Exit_Row_150_0;

      end if;

      Defer_Res_247 := Defining_Name_Transform_Parse_0 (Parser, Row_Pos_151);
      Defer_Pos_247 := Parser.Current_Pos;

      if Defer_Pos_247 /= No_Token_Index then

         Row_Pos_151 := Defer_Pos_247;

      else
         Row_Pos_151 := No_Token_Index;
         goto Exit_Row_150_0;

      end if;

--  Start tok_code

      Token_Res_188 := Row_Pos_151;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_188));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_188 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_151 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_151,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_188 := Row_Pos_151 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_188 /= No_Token_Index then

         Row_Pos_151 := Token_Pos_188;

      else
         Row_Pos_151 := No_Token_Index;
         goto Exit_Row_150_0;

      end if;

--  Start tok_code

      Token_Res_189 := Row_Pos_151;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_189));
      begin
         if T.Kind /= From_Token_Kind (Ada_Separate) then
            Token_Pos_189 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_151 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_151,
                  Expected_Token_Id => Ada_Separate,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_189 := Row_Pos_151 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_189 /= No_Token_Index then

         Row_Pos_151 := Token_Pos_189;

      else
         Row_Pos_151 := No_Token_Index;
         goto Exit_Row_150_0;

      end if;

      Defer_Res_248 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_151);
      Defer_Pos_248 := Parser.Current_Pos;

      if Defer_Pos_248 /= No_Token_Index then

         Row_Pos_151 := Defer_Pos_248;

      else
         Row_Pos_151 := No_Token_Index;
         goto Exit_Row_150_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_190 := Row_Pos_151;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_190));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_190 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_151 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_151,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_190 := Row_Pos_151 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_190 = No_Token_Index then

         Token_Res_190 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_151).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_190 := Row_Pos_151;

      end if;

--  End opt_code

      if Token_Pos_190 /= No_Token_Index then

         Row_Pos_151 := Token_Pos_190;

      else
         Row_Pos_151 := No_Token_Index;
         goto Exit_Row_150_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_150_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_151 /= No_Token_Index then

         Transform_Res_131 := Allocate_Package_Body_Stub (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_131, Kind => Ada_Package_Body_Stub,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_151 = Pos then No_Token_Index else Row_Pos_151 - 1));

         Initialize_Fields_For_Package_Body_Stub
           (Self                        => Transform_Res_131,
            Package_Body_Stub_F_Name    => Defer_Res_247,
            Package_Body_Stub_F_Aspects => Defer_Res_248);

         if Defer_Res_247 /= null and then Is_Incomplete (Defer_Res_247) then
            Transform_Res_131.Last_Attempted_Child := 0;
         elsif Defer_Res_247 /= null and then not Is_Ghost (Defer_Res_247) then
            Transform_Res_131.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_248 /= null and then Is_Incomplete (Defer_Res_248) then
            Transform_Res_131.Last_Attempted_Child := 0;
         elsif Defer_Res_248 /= null and then not Is_Ghost (Defer_Res_248) then
            Transform_Res_131.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Package_Body_Stub_Transform_Parse_0_Memo,
         Row_Pos_151 /= No_Token_Index, Transform_Res_131, Pos, Row_Pos_151);

      Parser.Current_Pos := Row_Pos_151;

      return Transform_Res_131;
   end Package_Body_Stub_Transform_Parse_0;

   function Task_Body_Stub_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Task_Body_Stub
   is
      use Bare_Task_Body_Stub_Memos;

      Row_Pos_152       : Token_Index         := No_Token_Index;
      Token_Pos_191     : Token_Index         := No_Token_Index;
      Token_Res_191     : Token_Index         := No_Token_Index;
      Token_Pos_192     : Token_Index         := No_Token_Index;
      Token_Res_192     : Token_Index         := No_Token_Index;
      Defer_Pos_249     : Token_Index         := No_Token_Index;
      Defer_Res_249     : Bare_Defining_Name  := No_Bare_Ada_Node;
      Token_Pos_193     : Token_Index         := No_Token_Index;
      Token_Res_193     : Token_Index         := No_Token_Index;
      Token_Pos_194     : Token_Index         := No_Token_Index;
      Token_Res_194     : Token_Index         := No_Token_Index;
      Defer_Pos_250     : Token_Index         := No_Token_Index;
      Defer_Res_250     : Bare_Aspect_Spec    := No_Bare_Ada_Node;
      Token_Pos_195     : Token_Index         := No_Token_Index;
      Token_Res_195     : Token_Index         := No_Token_Index;
      Transform_Res_132 : Bare_Task_Body_Stub := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Task_Body_Stub_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_132  := M.Instance;
         return Transform_Res_132;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_132;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_152 := Pos;

--  Start tok_code

      Token_Res_191 := Row_Pos_152;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_191));
      begin
         if T.Kind /= From_Token_Kind (Ada_Task) then
            Token_Pos_191 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_152 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_152,
                  Expected_Token_Id => Ada_Task,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_191 := Row_Pos_152 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_191 /= No_Token_Index then

         Row_Pos_152 := Token_Pos_191;

      else
         Row_Pos_152 := No_Token_Index;
         goto Exit_Row_151_0;

      end if;

--  Start tok_code

      Token_Res_192 := Row_Pos_152;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_192));
      begin
         if T.Kind /= From_Token_Kind (Ada_Body) then
            Token_Pos_192 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_152 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_152,
                  Expected_Token_Id => Ada_Body,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_192 := Row_Pos_152 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_192 /= No_Token_Index then

         Row_Pos_152 := Token_Pos_192;

      else
         Row_Pos_152 := No_Token_Index;
         goto Exit_Row_151_0;

      end if;

      Defer_Res_249 := Defining_Name_Transform_Parse_0 (Parser, Row_Pos_152);
      Defer_Pos_249 := Parser.Current_Pos;

      if Defer_Pos_249 /= No_Token_Index then

         Row_Pos_152 := Defer_Pos_249;

      else
         Row_Pos_152 := No_Token_Index;
         goto Exit_Row_151_0;

      end if;

--  Start tok_code

      Token_Res_193 := Row_Pos_152;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_193));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_193 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_152 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_152,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_193 := Row_Pos_152 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_193 /= No_Token_Index then

         Row_Pos_152 := Token_Pos_193;

      else
         Row_Pos_152 := No_Token_Index;
         goto Exit_Row_151_0;

      end if;

--  Start tok_code

      Token_Res_194 := Row_Pos_152;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_194));
      begin
         if T.Kind /= From_Token_Kind (Ada_Separate) then
            Token_Pos_194 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_152 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_152,
                  Expected_Token_Id => Ada_Separate,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_194 := Row_Pos_152 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_194 /= No_Token_Index then

         Row_Pos_152 := Token_Pos_194;

      else
         Row_Pos_152 := No_Token_Index;
         goto Exit_Row_151_0;

      end if;

      Defer_Res_250 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_152);
      Defer_Pos_250 := Parser.Current_Pos;

      if Defer_Pos_250 /= No_Token_Index then

         Row_Pos_152 := Defer_Pos_250;

      else
         Row_Pos_152 := No_Token_Index;
         goto Exit_Row_151_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_195 := Row_Pos_152;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_195));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_195 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_152 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_152,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_195 := Row_Pos_152 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_195 = No_Token_Index then

         Token_Res_195 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_152).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_195 := Row_Pos_152;

      end if;

--  End opt_code

      if Token_Pos_195 /= No_Token_Index then

         Row_Pos_152 := Token_Pos_195;

      else
         Row_Pos_152 := No_Token_Index;
         goto Exit_Row_151_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_151_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_152 /= No_Token_Index then

         Transform_Res_132 := Allocate_Task_Body_Stub (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_132, Kind => Ada_Task_Body_Stub,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_152 = Pos then No_Token_Index else Row_Pos_152 - 1));

         Initialize_Fields_For_Task_Body_Stub
           (Self => Transform_Res_132, Task_Body_Stub_F_Name => Defer_Res_249,
            Task_Body_Stub_F_Aspects => Defer_Res_250);

         if Defer_Res_249 /= null and then Is_Incomplete (Defer_Res_249) then
            Transform_Res_132.Last_Attempted_Child := 0;
         elsif Defer_Res_249 /= null and then not Is_Ghost (Defer_Res_249) then
            Transform_Res_132.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_250 /= null and then Is_Incomplete (Defer_Res_250) then
            Transform_Res_132.Last_Attempted_Child := 0;
         elsif Defer_Res_250 /= null and then not Is_Ghost (Defer_Res_250) then
            Transform_Res_132.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Task_Body_Stub_Transform_Parse_0_Memo,
         Row_Pos_152 /= No_Token_Index, Transform_Res_132, Pos, Row_Pos_152);

      Parser.Current_Pos := Row_Pos_152;

      return Transform_Res_132;
   end Task_Body_Stub_Transform_Parse_0;

   function Protected_Body_Stub_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Protected_Body_Stub
   is
      use Bare_Protected_Body_Stub_Memos;

      Row_Pos_153       : Token_Index              := No_Token_Index;
      Token_Pos_196     : Token_Index              := No_Token_Index;
      Token_Res_196     : Token_Index              := No_Token_Index;
      Token_Pos_197     : Token_Index              := No_Token_Index;
      Token_Res_197     : Token_Index              := No_Token_Index;
      Defer_Pos_251     : Token_Index              := No_Token_Index;
      Defer_Res_251     : Bare_Defining_Name       := No_Bare_Ada_Node;
      Token_Pos_198     : Token_Index              := No_Token_Index;
      Token_Res_198     : Token_Index              := No_Token_Index;
      Token_Pos_199     : Token_Index              := No_Token_Index;
      Token_Res_199     : Token_Index              := No_Token_Index;
      Defer_Pos_252     : Token_Index              := No_Token_Index;
      Defer_Res_252     : Bare_Aspect_Spec         := No_Bare_Ada_Node;
      Token_Pos_200     : Token_Index              := No_Token_Index;
      Token_Res_200     : Token_Index              := No_Token_Index;
      Transform_Res_133 : Bare_Protected_Body_Stub := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Protected_Body_Stub_Transform_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_133  := M.Instance;
         return Transform_Res_133;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_133;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_153 := Pos;

--  Start tok_code

      Token_Res_196 := Row_Pos_153;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_196));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol
               (Parser.TDH.Symbols, Precomputed_Symbol_Protected)
         then
            Token_Pos_196 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_153 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_153,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_196 := Row_Pos_153 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_196 /= No_Token_Index then

         Row_Pos_153 := Token_Pos_196;

      else
         Row_Pos_153 := No_Token_Index;
         goto Exit_Row_152_0;

      end if;

--  Start tok_code

      Token_Res_197 := Row_Pos_153;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_197));
      begin
         if T.Kind /= From_Token_Kind (Ada_Body) then
            Token_Pos_197 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_153 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_153,
                  Expected_Token_Id => Ada_Body,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_197 := Row_Pos_153 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_197 /= No_Token_Index then

         Row_Pos_153 := Token_Pos_197;

      else
         Row_Pos_153 := No_Token_Index;
         goto Exit_Row_152_0;

      end if;

      Defer_Res_251 := Defining_Name_Transform_Parse_0 (Parser, Row_Pos_153);
      Defer_Pos_251 := Parser.Current_Pos;

      if Defer_Pos_251 /= No_Token_Index then

         Row_Pos_153 := Defer_Pos_251;

      else
         Row_Pos_153 := No_Token_Index;
         goto Exit_Row_152_0;

      end if;

--  Start tok_code

      Token_Res_198 := Row_Pos_153;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_198));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_198 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_153 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_153,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_198 := Row_Pos_153 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_198 /= No_Token_Index then

         Row_Pos_153 := Token_Pos_198;

      else
         Row_Pos_153 := No_Token_Index;
         goto Exit_Row_152_0;

      end if;

--  Start tok_code

      Token_Res_199 := Row_Pos_153;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_199));
      begin
         if T.Kind /= From_Token_Kind (Ada_Separate) then
            Token_Pos_199 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_153 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_153,
                  Expected_Token_Id => Ada_Separate,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_199 := Row_Pos_153 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_199 /= No_Token_Index then

         Row_Pos_153 := Token_Pos_199;

      else
         Row_Pos_153 := No_Token_Index;
         goto Exit_Row_152_0;

      end if;

      Defer_Res_252 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_153);
      Defer_Pos_252 := Parser.Current_Pos;

      if Defer_Pos_252 /= No_Token_Index then

         Row_Pos_153 := Defer_Pos_252;

      else
         Row_Pos_153 := No_Token_Index;
         goto Exit_Row_152_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_200 := Row_Pos_153;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_200));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_200 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_153 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_153,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_200 := Row_Pos_153 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_200 = No_Token_Index then

         Token_Res_200 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_153).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_200 := Row_Pos_153;

      end if;

--  End opt_code

      if Token_Pos_200 /= No_Token_Index then

         Row_Pos_153 := Token_Pos_200;

      else
         Row_Pos_153 := No_Token_Index;
         goto Exit_Row_152_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_152_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_153 /= No_Token_Index then

         Transform_Res_133 := Allocate_Protected_Body_Stub (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_133, Kind => Ada_Protected_Body_Stub,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_153 = Pos then No_Token_Index else Row_Pos_153 - 1));

         Initialize_Fields_For_Protected_Body_Stub
           (Self                          => Transform_Res_133,
            Protected_Body_Stub_F_Name    => Defer_Res_251,
            Protected_Body_Stub_F_Aspects => Defer_Res_252);

         if Defer_Res_251 /= null and then Is_Incomplete (Defer_Res_251) then
            Transform_Res_133.Last_Attempted_Child := 0;
         elsif Defer_Res_251 /= null and then not Is_Ghost (Defer_Res_251) then
            Transform_Res_133.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_252 /= null and then Is_Incomplete (Defer_Res_252) then
            Transform_Res_133.Last_Attempted_Child := 0;
         elsif Defer_Res_252 /= null and then not Is_Ghost (Defer_Res_252) then
            Transform_Res_133.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Protected_Body_Stub_Transform_Parse_0_Memo,
         Row_Pos_153 /= No_Token_Index, Transform_Res_133, Pos, Row_Pos_153);

      Parser.Current_Pos := Row_Pos_153;

      return Transform_Res_133;
   end Protected_Body_Stub_Transform_Parse_0;

   function Body_Stub_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Body_Stub
   is
      use Bare_Body_Stub_Memos;

      Defer_Pos_240 : Token_Index              := No_Token_Index;
      Defer_Res_240 : Bare_Subp_Body_Stub      := No_Bare_Ada_Node;
      Defer_Pos_241 : Token_Index              := No_Token_Index;
      Defer_Res_241 : Bare_Package_Body_Stub   := No_Bare_Ada_Node;
      Defer_Pos_242 : Token_Index              := No_Token_Index;
      Defer_Res_242 : Bare_Task_Body_Stub      := No_Bare_Ada_Node;
      Defer_Pos_243 : Token_Index              := No_Token_Index;
      Defer_Res_243 : Bare_Protected_Body_Stub := No_Bare_Ada_Node;
      Or_Pos_60     : Token_Index              := No_Token_Index;
      Or_Res_60     : Bare_Body_Stub           := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Body_Stub_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_60          := M.Instance;
         return Or_Res_60;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_60;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_60 := No_Token_Index;
      Or_Res_60 := No_Bare_Ada_Node;

      Defer_Res_240 := Subp_Body_Stub_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_240 := Parser.Current_Pos;

      if Defer_Pos_240 /= No_Token_Index then
         Or_Pos_60 := Defer_Pos_240;
         Or_Res_60 := Defer_Res_240;
         goto Exit_Or_60;
      end if;

      Defer_Res_241 := Package_Body_Stub_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_241 := Parser.Current_Pos;

      if Defer_Pos_241 /= No_Token_Index then
         Or_Pos_60 := Defer_Pos_241;
         Or_Res_60 := Defer_Res_241;
         goto Exit_Or_60;
      end if;

      Defer_Res_242 := Task_Body_Stub_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_242 := Parser.Current_Pos;

      if Defer_Pos_242 /= No_Token_Index then
         Or_Pos_60 := Defer_Pos_242;
         Or_Res_60 := Defer_Res_242;
         goto Exit_Or_60;
      end if;

      Defer_Res_243 := Protected_Body_Stub_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_243 := Parser.Current_Pos;

      if Defer_Pos_243 /= No_Token_Index then
         Or_Pos_60 := Defer_Pos_243;
         Or_Res_60 := Defer_Res_243;
         goto Exit_Or_60;
      end if;
      <<Exit_Or_60>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Body_Stub_Or_Parse_0_Memo,
         Or_Pos_60 /= No_Token_Index, Or_Res_60, Pos, Or_Pos_60);

      Parser.Current_Pos := Or_Pos_60;

      return Or_Res_60;
   end Body_Stub_Or_Parse_0;

   function Generic_Instantiation_Or_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Generic_Instantiation
   is
      use Bare_Generic_Instantiation_Memos;

      Row_Pos_154       : Token_Index                        := No_Token_Index;
      Token_Pos_201     : Token_Index                        := No_Token_Index;
      Token_Res_201     : Token_Index                        := No_Token_Index;
      Defer_Pos_253     : Token_Index                        := No_Token_Index;
      Defer_Res_253     : Bare_Defining_Name := No_Bare_Ada_Node;
      Token_Pos_202     : Token_Index                        := No_Token_Index;
      Token_Res_202     : Token_Index                        := No_Token_Index;
      Token_Pos_203     : Token_Index                        := No_Token_Index;
      Token_Res_203     : Token_Index                        := No_Token_Index;
      Defer_Pos_254     : Token_Index                        := No_Token_Index;
      Defer_Res_254     : Bare_Name := No_Bare_Ada_Node;
      Row_Pos_155       : Token_Index                        := No_Token_Index;
      Token_Pos_204     : Token_Index                        := No_Token_Index;
      Token_Res_204     : Token_Index                        := No_Token_Index;
      Lst_Cpos_17       : Token_Index                        := No_Token_Index;
      Tmp_List_17       : Free_Parse_List;
      Defer_Pos_255     : Token_Index                        := No_Token_Index;
      Defer_Res_255     : Bare_Param_Assoc := No_Bare_Ada_Node;
      Token_Pos_205     : Token_Index                        := No_Token_Index;
      Token_Res_205     : Token_Index                        := No_Token_Index;
      List_Pos_17       : Token_Index                        := No_Token_Index;
      List_Res_17       : Bare_Assoc_List := No_Bare_Ada_Node;
      Token_Pos_206     : Token_Index                        := No_Token_Index;
      Token_Res_206     : Token_Index                        := No_Token_Index;
      Defer_Pos_256     : Token_Index                        := No_Token_Index;
      Defer_Res_256     : Bare_Aspect_Spec := No_Bare_Ada_Node;
      Token_Pos_207     : Token_Index                        := No_Token_Index;
      Token_Res_207     : Token_Index                        := No_Token_Index;
      Transform_Res_134 : Bare_Generic_Package_Instantiation :=
        No_Bare_Ada_Node;
      Row_Pos_156       : Token_Index                     := No_Token_Index;
      Defer_Pos_257     : Token_Index                     := No_Token_Index;
      Defer_Res_257     : Bare_Overriding_Node            := No_Bare_Ada_Node;
      Row_Pos_157       : Token_Index                     := No_Token_Index;
      Token_Pos_208     : Token_Index                     := No_Token_Index;
      Token_Res_208     : Token_Index                     := No_Token_Index;
      Transform_Res_135 : Bare_Subp_Kind_Procedure        := No_Bare_Ada_Node;
      Row_Pos_158       : Token_Index                     := No_Token_Index;
      Token_Pos_209     : Token_Index                     := No_Token_Index;
      Token_Res_209     : Token_Index                     := No_Token_Index;
      Transform_Res_136 : Bare_Subp_Kind_Function         := No_Bare_Ada_Node;
      Or_Pos_61         : Token_Index                     := No_Token_Index;
      Or_Res_61         : Bare_Subp_Kind                  := No_Bare_Ada_Node;
      Defer_Pos_258     : Token_Index                     := No_Token_Index;
      Defer_Res_258     : Bare_Defining_Name              := No_Bare_Ada_Node;
      Token_Pos_210     : Token_Index                     := No_Token_Index;
      Token_Res_210     : Token_Index                     := No_Token_Index;
      Token_Pos_211     : Token_Index                     := No_Token_Index;
      Token_Res_211     : Token_Index                     := No_Token_Index;
      Defer_Pos_259     : Token_Index                     := No_Token_Index;
      Defer_Res_259     : Bare_Name                       := No_Bare_Ada_Node;
      Row_Pos_159       : Token_Index                     := No_Token_Index;
      Token_Pos_212     : Token_Index                     := No_Token_Index;
      Token_Res_212     : Token_Index                     := No_Token_Index;
      Lst_Cpos_18       : Token_Index                     := No_Token_Index;
      Tmp_List_18       : Free_Parse_List;
      Defer_Pos_260     : Token_Index                     := No_Token_Index;
      Defer_Res_260     : Bare_Param_Assoc                := No_Bare_Ada_Node;
      Token_Pos_213     : Token_Index                     := No_Token_Index;
      Token_Res_213     : Token_Index                     := No_Token_Index;
      List_Pos_18       : Token_Index                     := No_Token_Index;
      List_Res_18       : Bare_Assoc_List                 := No_Bare_Ada_Node;
      Token_Pos_214     : Token_Index                     := No_Token_Index;
      Token_Res_214     : Token_Index                     := No_Token_Index;
      Defer_Pos_261     : Token_Index                     := No_Token_Index;
      Defer_Res_261     : Bare_Aspect_Spec                := No_Bare_Ada_Node;
      Token_Pos_215     : Token_Index                     := No_Token_Index;
      Token_Res_215     : Token_Index                     := No_Token_Index;
      Transform_Res_137 : Bare_Generic_Subp_Instantiation := No_Bare_Ada_Node;
      Or_Pos_62         : Token_Index                     := No_Token_Index;
      Or_Res_62         : Bare_Generic_Instantiation      := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Generic_Instantiation_Or_Parse_1_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_62          := M.Instance;
         return Or_Res_62;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_62;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_62 := No_Token_Index;
      Or_Res_62 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_154 := Pos;

--  Start tok_code

      Token_Res_201 := Row_Pos_154;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_201));
      begin
         if T.Kind /= From_Token_Kind (Ada_Package) then
            Token_Pos_201 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_154 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_154,
                  Expected_Token_Id => Ada_Package,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_201 := Row_Pos_154 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_201 /= No_Token_Index then

         Row_Pos_154 := Token_Pos_201;

      else
         Row_Pos_154 := No_Token_Index;
         goto Exit_Row_153_0;

      end if;

      Defer_Res_253 := Defining_Name_Transform_Parse_0 (Parser, Row_Pos_154);
      Defer_Pos_253 := Parser.Current_Pos;

      if Defer_Pos_253 /= No_Token_Index then

         Row_Pos_154 := Defer_Pos_253;

      else
         Row_Pos_154 := No_Token_Index;
         goto Exit_Row_153_0;

      end if;

--  Start tok_code

      Token_Res_202 := Row_Pos_154;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_202));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_202 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_154 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_154,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_202 := Row_Pos_154 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_202 /= No_Token_Index then

         Row_Pos_154 := Token_Pos_202;

      else
         Row_Pos_154 := No_Token_Index;
         goto Exit_Row_153_0;

      end if;

--  Start tok_code

      Token_Res_203 := Row_Pos_154;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_203));
      begin
         if T.Kind /= From_Token_Kind (Ada_New) then
            Token_Pos_203 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_154 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_154,
                  Expected_Token_Id => Ada_New,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_203 := Row_Pos_154 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_203 /= No_Token_Index then

         Row_Pos_154 := Token_Pos_203;

      else
         Row_Pos_154 := No_Token_Index;
         goto Exit_Row_153_0;

      end if;

      Defer_Res_254 := Static_Name_Or_Parse_0 (Parser, Row_Pos_154);
      Defer_Pos_254 := Parser.Current_Pos;

      if Defer_Pos_254 /= No_Token_Index then

         Row_Pos_154 := Defer_Pos_254;

      else
         Row_Pos_154 := No_Token_Index;
         goto Exit_Row_153_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_155 := Row_Pos_154;

--  Start tok_code

      Token_Res_204 := Row_Pos_155;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_204));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Open) then
            Token_Pos_204 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_155 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_155,
                  Expected_Token_Id => Ada_Par_Open,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_204 := Row_Pos_155 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_204 /= No_Token_Index then

         Row_Pos_155 := Token_Pos_204;

      else
         Row_Pos_155 := No_Token_Index;
         goto Exit_Row_154_0;

      end if;

--  Start list_code

      List_Pos_17 := No_Token_Index;

      Lst_Cpos_17 := Row_Pos_155;
      Tmp_List_17 := Get_Parse_List (Parser);

      loop

         Defer_Res_255 := Param_Assoc_Transform_Parse_0 (Parser, Lst_Cpos_17);
         Defer_Pos_255 := Parser.Current_Pos;

         exit when Defer_Pos_255 = No_Token_Index;

         List_Pos_17 := Defer_Pos_255;
         Lst_Cpos_17 := List_Pos_17;

         Tmp_List_17.Nodes.Append (Defer_Res_255);

--  Start tok_code

         Token_Res_205 := Lst_Cpos_17;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_205));
         begin
            if T.Kind /= From_Token_Kind (Ada_Comma) then
               Token_Pos_205 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_17 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_17,
                     Expected_Token_Id => Ada_Comma,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_205 := Lst_Cpos_17 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_205 /= No_Token_Index then
            Lst_Cpos_17 := Token_Pos_205;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_17.Nodes.Length;
      begin
         List_Res_17 := Allocate_Assoc_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_155;
            Token_End   :=
              (if Lst_Cpos_17 = Row_Pos_155 then Row_Pos_155
               else Lst_Cpos_17 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_155, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self => List_Res_17, Kind => Ada_Assoc_List, Unit => Parser.Unit,
            Token_Start_Index => Token_Start, Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_17, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_17.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_17.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_17);

--  End list_code

      if List_Pos_17 /= No_Token_Index then

         Row_Pos_155 := List_Pos_17;

      else
         Row_Pos_155 := No_Token_Index;
         goto Exit_Row_154_0;

      end if;

--  Start tok_code

      Token_Res_206 := Row_Pos_155;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_206));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Close) then
            Token_Pos_206 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_155 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_155,
                  Expected_Token_Id => Ada_Par_Close,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_206 := Row_Pos_155 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_206 /= No_Token_Index then

         Row_Pos_155 := Token_Pos_206;

      else
         Row_Pos_155 := No_Token_Index;
         goto Exit_Row_154_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_154_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_155 = No_Token_Index then

         List_Res_17 := Allocate_Assoc_List (Parser.Mem_Pool);
         Initialize
           (Self => List_Res_17, Kind => Ada_Assoc_List, Unit => Parser.Unit,
            Token_Start_Index => Row_Pos_154 - 1,
            Token_End_Index   => No_Token_Index);
         Initialize_List (Self => List_Res_17, Parser => Parser, Count => 0);

         Row_Pos_155 := Row_Pos_154;

      end if;

--  End opt_code

      if Row_Pos_155 /= No_Token_Index then

         Row_Pos_154 := Row_Pos_155;

      else
         Row_Pos_154 := No_Token_Index;
         goto Exit_Row_153_0;

      end if;

      Defer_Res_256 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_154);
      Defer_Pos_256 := Parser.Current_Pos;

      if Defer_Pos_256 /= No_Token_Index then

         Row_Pos_154 := Defer_Pos_256;

      else
         Row_Pos_154 := No_Token_Index;
         goto Exit_Row_153_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_207 := Row_Pos_154;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_207));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_207 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_154 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_154,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_207 := Row_Pos_154 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_207 = No_Token_Index then

         Token_Res_207 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_154).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_207 := Row_Pos_154;

      end if;

--  End opt_code

      if Token_Pos_207 /= No_Token_Index then

         Row_Pos_154 := Token_Pos_207;

      else
         Row_Pos_154 := No_Token_Index;
         goto Exit_Row_153_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_153_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_154 /= No_Token_Index then

         Transform_Res_134 :=
           Allocate_Generic_Package_Instantiation (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_134,
            Kind => Ada_Generic_Package_Instantiation, Unit => Parser.Unit,

            Token_Start_Index => Pos,
            Token_End_Index   =>
              (if Row_Pos_154 = Pos then No_Token_Index else Row_Pos_154 - 1));

         Initialize_Fields_For_Generic_Package_Instantiation
           (Self => Transform_Res_134,
            Generic_Package_Instantiation_F_Name             => Defer_Res_253,
            Generic_Package_Instantiation_F_Generic_Pkg_Name => Defer_Res_254,
            Generic_Package_Instantiation_F_Params           => List_Res_17,
            Generic_Package_Instantiation_F_Aspects          => Defer_Res_256);

         if Defer_Res_253 /= null and then Is_Incomplete (Defer_Res_253) then
            Transform_Res_134.Last_Attempted_Child := 0;
         elsif Defer_Res_253 /= null and then not Is_Ghost (Defer_Res_253) then
            Transform_Res_134.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_254 /= null and then Is_Incomplete (Defer_Res_254) then
            Transform_Res_134.Last_Attempted_Child := 0;
         elsif Defer_Res_254 /= null and then not Is_Ghost (Defer_Res_254) then
            Transform_Res_134.Last_Attempted_Child := -1;
         end if;
         if List_Res_17 /= null and then Is_Incomplete (List_Res_17) then
            Transform_Res_134.Last_Attempted_Child := 0;
         elsif List_Res_17 /= null and then not Is_Ghost (List_Res_17) then
            Transform_Res_134.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_256 /= null and then Is_Incomplete (Defer_Res_256) then
            Transform_Res_134.Last_Attempted_Child := 0;
         elsif Defer_Res_256 /= null and then not Is_Ghost (Defer_Res_256) then
            Transform_Res_134.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_154 /= No_Token_Index then
         Or_Pos_62 := Row_Pos_154;
         Or_Res_62 := Transform_Res_134;
         goto Exit_Or_61;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_156 := Pos;

      Defer_Res_257 := Overriding_Indicator_Or_Parse_0 (Parser, Row_Pos_156);
      Defer_Pos_257 := Parser.Current_Pos;

      if Defer_Pos_257 /= No_Token_Index then

         Row_Pos_156 := Defer_Pos_257;

      else
         Row_Pos_156 := No_Token_Index;
         goto Exit_Row_155_0;

      end if;

--  Start or_code

      Or_Pos_61 := No_Token_Index;
      Or_Res_61 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_157 := Row_Pos_156;

--  Start tok_code

      Token_Res_208 := Row_Pos_157;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_208));
      begin
         if T.Kind /= From_Token_Kind (Ada_Procedure) then
            Token_Pos_208 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_157 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_157,
                  Expected_Token_Id => Ada_Procedure,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_208 := Row_Pos_157 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_208 /= No_Token_Index then

         Row_Pos_157 := Token_Pos_208;

      else
         Row_Pos_157 := No_Token_Index;
         goto Exit_Row_156_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_156_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_157 /= No_Token_Index then

         Transform_Res_135 := Allocate_Subp_Kind_Procedure (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_135, Kind => Ada_Subp_Kind_Procedure,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_156,
            Token_End_Index =>
              (if Row_Pos_157 = Row_Pos_156 then No_Token_Index
               else Row_Pos_157 - 1));

      end if;

--  End transform_code

      if Row_Pos_157 /= No_Token_Index then
         Or_Pos_61 := Row_Pos_157;
         Or_Res_61 := Transform_Res_135;
         goto Exit_Or_62;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_158 := Row_Pos_156;

--  Start tok_code

      Token_Res_209 := Row_Pos_158;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_209));
      begin
         if T.Kind /= From_Token_Kind (Ada_Function) then
            Token_Pos_209 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_158 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_158,
                  Expected_Token_Id => Ada_Function,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_209 := Row_Pos_158 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_209 /= No_Token_Index then

         Row_Pos_158 := Token_Pos_209;

      else
         Row_Pos_158 := No_Token_Index;
         goto Exit_Row_157_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_157_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_158 /= No_Token_Index then

         Transform_Res_136 := Allocate_Subp_Kind_Function (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_136, Kind => Ada_Subp_Kind_Function,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_156,
            Token_End_Index =>
              (if Row_Pos_158 = Row_Pos_156 then No_Token_Index
               else Row_Pos_158 - 1));

      end if;

--  End transform_code

      if Row_Pos_158 /= No_Token_Index then
         Or_Pos_61 := Row_Pos_158;
         Or_Res_61 := Transform_Res_136;
         goto Exit_Or_62;
      end if;
      <<Exit_Or_62>>

--  End or_code

      if Or_Pos_61 /= No_Token_Index then

         Row_Pos_156 := Or_Pos_61;

      else
         Row_Pos_156 := No_Token_Index;
         goto Exit_Row_155_0;

      end if;

      Defer_Res_258 := Defining_Name_Transform_Parse_0 (Parser, Row_Pos_156);
      Defer_Pos_258 := Parser.Current_Pos;

      if Defer_Pos_258 /= No_Token_Index then

         Row_Pos_156 := Defer_Pos_258;

      else
         Row_Pos_156 := No_Token_Index;
         goto Exit_Row_155_0;

      end if;

--  Start tok_code

      Token_Res_210 := Row_Pos_156;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_210));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_210 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_156 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_156,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_210 := Row_Pos_156 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_210 /= No_Token_Index then

         Row_Pos_156 := Token_Pos_210;

      else
         Row_Pos_156 := No_Token_Index;
         goto Exit_Row_155_0;

      end if;

--  Start tok_code

      Token_Res_211 := Row_Pos_156;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_211));
      begin
         if T.Kind /= From_Token_Kind (Ada_New) then
            Token_Pos_211 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_156 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_156,
                  Expected_Token_Id => Ada_New,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_211 := Row_Pos_156 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_211 /= No_Token_Index then

         Row_Pos_156 := Token_Pos_211;

      else
         Row_Pos_156 := No_Token_Index;
         goto Exit_Row_155_0;

      end if;

      Defer_Res_259 := Static_Name_Or_Parse_0 (Parser, Row_Pos_156);
      Defer_Pos_259 := Parser.Current_Pos;

      if Defer_Pos_259 /= No_Token_Index then

         Row_Pos_156 := Defer_Pos_259;

      else
         Row_Pos_156 := No_Token_Index;
         goto Exit_Row_155_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_159 := Row_Pos_156;

--  Start tok_code

      Token_Res_212 := Row_Pos_159;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_212));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Open) then
            Token_Pos_212 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_159 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_159,
                  Expected_Token_Id => Ada_Par_Open,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_212 := Row_Pos_159 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_212 /= No_Token_Index then

         Row_Pos_159 := Token_Pos_212;

      else
         Row_Pos_159 := No_Token_Index;
         goto Exit_Row_158_0;

      end if;

--  Start list_code

      List_Pos_18 := No_Token_Index;

      Lst_Cpos_18 := Row_Pos_159;
      Tmp_List_18 := Get_Parse_List (Parser);

      loop

         Defer_Res_260 := Param_Assoc_Transform_Parse_0 (Parser, Lst_Cpos_18);
         Defer_Pos_260 := Parser.Current_Pos;

         exit when Defer_Pos_260 = No_Token_Index;

         List_Pos_18 := Defer_Pos_260;
         Lst_Cpos_18 := List_Pos_18;

         Tmp_List_18.Nodes.Append (Defer_Res_260);

--  Start tok_code

         Token_Res_213 := Lst_Cpos_18;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_213));
         begin
            if T.Kind /= From_Token_Kind (Ada_Comma) then
               Token_Pos_213 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_18 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_18,
                     Expected_Token_Id => Ada_Comma,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_213 := Lst_Cpos_18 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_213 /= No_Token_Index then
            Lst_Cpos_18 := Token_Pos_213;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_18.Nodes.Length;
      begin
         List_Res_18 := Allocate_Assoc_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_159;
            Token_End   :=
              (if Lst_Cpos_18 = Row_Pos_159 then Row_Pos_159
               else Lst_Cpos_18 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_159, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self => List_Res_18, Kind => Ada_Assoc_List, Unit => Parser.Unit,
            Token_Start_Index => Token_Start, Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_18, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_18.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_18.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_18);

--  End list_code

      if List_Pos_18 /= No_Token_Index then

         Row_Pos_159 := List_Pos_18;

      else
         Row_Pos_159 := No_Token_Index;
         goto Exit_Row_158_0;

      end if;

--  Start tok_code

      Token_Res_214 := Row_Pos_159;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_214));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Close) then
            Token_Pos_214 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_159 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_159,
                  Expected_Token_Id => Ada_Par_Close,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_214 := Row_Pos_159 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_214 /= No_Token_Index then

         Row_Pos_159 := Token_Pos_214;

      else
         Row_Pos_159 := No_Token_Index;
         goto Exit_Row_158_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_158_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_159 = No_Token_Index then

         List_Res_18 := Allocate_Assoc_List (Parser.Mem_Pool);
         Initialize
           (Self => List_Res_18, Kind => Ada_Assoc_List, Unit => Parser.Unit,
            Token_Start_Index => Row_Pos_156 - 1,
            Token_End_Index   => No_Token_Index);
         Initialize_List (Self => List_Res_18, Parser => Parser, Count => 0);

         Row_Pos_159 := Row_Pos_156;

      end if;

--  End opt_code

      if Row_Pos_159 /= No_Token_Index then

         Row_Pos_156 := Row_Pos_159;

      else
         Row_Pos_156 := No_Token_Index;
         goto Exit_Row_155_0;

      end if;

      Defer_Res_261 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_156);
      Defer_Pos_261 := Parser.Current_Pos;

      if Defer_Pos_261 /= No_Token_Index then

         Row_Pos_156 := Defer_Pos_261;

      else
         Row_Pos_156 := No_Token_Index;
         goto Exit_Row_155_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_215 := Row_Pos_156;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_215));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_215 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_156 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_156,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_215 := Row_Pos_156 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_215 = No_Token_Index then

         Token_Res_215 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_156).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_215 := Row_Pos_156;

      end if;

--  End opt_code

      if Token_Pos_215 /= No_Token_Index then

         Row_Pos_156 := Token_Pos_215;

      else
         Row_Pos_156 := No_Token_Index;
         goto Exit_Row_155_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_155_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_156 /= No_Token_Index then

         Transform_Res_137 :=
           Allocate_Generic_Subp_Instantiation (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_137, Kind => Ada_Generic_Subp_Instantiation,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_156 = Pos then No_Token_Index else Row_Pos_156 - 1));

         Initialize_Fields_For_Generic_Subp_Instantiation
           (Self => Transform_Res_137,
            Generic_Subp_Instantiation_F_Overriding        => Defer_Res_257,
            Generic_Subp_Instantiation_F_Kind              => Or_Res_61,
            Generic_Subp_Instantiation_F_Subp_Name         => Defer_Res_258,
            Generic_Subp_Instantiation_F_Generic_Subp_Name => Defer_Res_259,
            Generic_Subp_Instantiation_F_Params            => List_Res_18,
            Generic_Subp_Instantiation_F_Aspects           => Defer_Res_261);

         if Defer_Res_257 /= null and then Is_Incomplete (Defer_Res_257) then
            Transform_Res_137.Last_Attempted_Child := 0;
         elsif Defer_Res_257 /= null and then not Is_Ghost (Defer_Res_257) then
            Transform_Res_137.Last_Attempted_Child := -1;
         end if;
         if Or_Res_61 /= null and then Is_Incomplete (Or_Res_61) then
            Transform_Res_137.Last_Attempted_Child := 0;
         elsif Or_Res_61 /= null and then not Is_Ghost (Or_Res_61) then
            Transform_Res_137.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_258 /= null and then Is_Incomplete (Defer_Res_258) then
            Transform_Res_137.Last_Attempted_Child := 0;
         elsif Defer_Res_258 /= null and then not Is_Ghost (Defer_Res_258) then
            Transform_Res_137.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_259 /= null and then Is_Incomplete (Defer_Res_259) then
            Transform_Res_137.Last_Attempted_Child := 0;
         elsif Defer_Res_259 /= null and then not Is_Ghost (Defer_Res_259) then
            Transform_Res_137.Last_Attempted_Child := -1;
         end if;
         if List_Res_18 /= null and then Is_Incomplete (List_Res_18) then
            Transform_Res_137.Last_Attempted_Child := 0;
         elsif List_Res_18 /= null and then not Is_Ghost (List_Res_18) then
            Transform_Res_137.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_261 /= null and then Is_Incomplete (Defer_Res_261) then
            Transform_Res_137.Last_Attempted_Child := 0;
         elsif Defer_Res_261 /= null and then not Is_Ghost (Defer_Res_261) then
            Transform_Res_137.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_156 /= No_Token_Index then
         Or_Pos_62 := Row_Pos_156;
         Or_Res_62 := Transform_Res_137;
         goto Exit_Or_61;
      end if;
      <<Exit_Or_61>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Generic_Instantiation_Or_Parse_1_Memo,
         Or_Pos_62 /= No_Token_Index, Or_Res_62, Pos, Or_Pos_62);

      Parser.Current_Pos := Or_Pos_62;

      return Or_Res_62;
   end Generic_Instantiation_Or_Parse_1;

   function Recov_Decl_Part_Dont_Skip_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Declarative_Part
   is
      use Bare_Declarative_Part_Memos;

      Defer_Pos_273 : Token_Index           := No_Token_Index;
      Defer_Res_273 : Bare_Declarative_Part := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Recov_Decl_Part_Dont_Skip_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Defer_Res_273      := M.Instance;
         return Defer_Res_273;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Defer_Res_273;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

      Parser.Private_Part.Dont_Skip.Append
        (Dontskip_Recov_Decl_Part_0_Extract_Parse_0'Access);

      Defer_Res_273 := Decl_Part_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_273 := Parser.Current_Pos;

      Parser.Private_Part.Dont_Skip.Delete_Last;

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Recov_Decl_Part_Dont_Skip_Parse_0_Memo,
         Defer_Pos_273 /= No_Token_Index, Defer_Res_273, Pos, Defer_Pos_273);

      Parser.Current_Pos := Defer_Pos_273;

      return Defer_Res_273;
   end Recov_Decl_Part_Dont_Skip_Parse_0;

   function If_Stmt_Transform_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_If_Stmt
   is
      use Bare_If_Stmt_Memos;

      Nobt_15                 : Boolean                   := False;
      Row_Pos_166             : Token_Index               := No_Token_Index;
      Token_Pos_221           : Token_Index               := No_Token_Index;
      Token_Res_221           : Token_Index               := No_Token_Index;
      Defer_Pos_288           : Token_Index               := No_Token_Index;
      Defer_Res_288           : Bare_Expr                 := No_Bare_Ada_Node;
      Token_Pos_222           : Token_Index               := No_Token_Index;
      Token_Res_222           : Token_Index               := No_Token_Index;
      Defer_Pos_289           : Token_Index               := No_Token_Index;
      Defer_Res_289           : Bare_Stmt_List            := No_Bare_Ada_Node;
      Lst_Cpos_21             : Token_Index               := No_Token_Index;
      Tmp_List_21             : Free_Parse_List;
      Row_Pos_167             : Token_Index               := No_Token_Index;
      Token_Pos_223           : Token_Index               := No_Token_Index;
      Token_Res_223           : Token_Index               := No_Token_Index;
      Defer_Pos_290           : Token_Index               := No_Token_Index;
      Defer_Res_290           : Bare_Expr                 := No_Bare_Ada_Node;
      Token_Pos_224           : Token_Index               := No_Token_Index;
      Token_Res_224           : Token_Index               := No_Token_Index;
      Defer_Pos_291           : Token_Index               := No_Token_Index;
      Defer_Res_291           : Bare_Stmt_List            := No_Bare_Ada_Node;
      Transform_Res_142       : Bare_Elsif_Stmt_Part      := No_Bare_Ada_Node;
      List_Pos_21             : Token_Index               := No_Token_Index;
      List_Res_21             : Bare_Elsif_Stmt_Part_List := No_Bare_Ada_Node;
      Row_Pos_168             : Token_Index               := No_Token_Index;
      Token_Pos_225           : Token_Index               := No_Token_Index;
      Token_Res_225           : Token_Index               := No_Token_Index;
      Defer_Pos_292           : Token_Index               := No_Token_Index;
      Defer_Res_292           : Bare_Stmt_List            := No_Bare_Ada_Node;
      Token_Pos_226           : Token_Index               := No_Token_Index;
      Token_Res_226           : Token_Index               := No_Token_Index;
      Token_Pos_227           : Token_Index               := No_Token_Index;
      Token_Res_227           : Token_Index               := No_Token_Index;
      Token_Pos_228           : Token_Index               := No_Token_Index;
      Token_Res_228           : Token_Index               := No_Token_Index;
      Row_Progress_15         : Integer                   := 0;
      Transform_Res_143       : Bare_If_Stmt              := No_Bare_Ada_Node;
      Transform_Has_Failed_15 : Boolean                   := False;

      M : Memo_Entry :=
        Get (Parser.Private_Part.If_Stmt_Transform_Parse_1_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_143  := M.Instance;
         return Transform_Res_143;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_143;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_166 := Pos;

--  Start tok_code

      Token_Res_221 := Row_Pos_166;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_221));
      begin
         if T.Kind /= From_Token_Kind (Ada_If) then
            Token_Pos_221 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_166 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_166,
                  Expected_Token_Id => Ada_If,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_221 := Row_Pos_166 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_15 := 1;

      if Token_Pos_221 /= No_Token_Index then

         Row_Pos_166 := Token_Pos_221;

      else
         Row_Pos_166 := No_Token_Index;
         goto Exit_Row_161_0;

      end if;

      Nobt_15 := True;

      Row_Progress_15 := 2;

      if Row_Pos_166 /= No_Token_Index then

         Row_Pos_166 := Row_Pos_166;

      else
         Row_Pos_166 := No_Token_Index;
         goto Exit_Row_161_0;

      end if;

      Defer_Res_288 := Expr_Or_Parse_0 (Parser, Row_Pos_166);
      Defer_Pos_288 := Parser.Current_Pos;

      Row_Progress_15 := 3;

      if Defer_Pos_288 /= No_Token_Index then

         Row_Pos_166 := Defer_Pos_288;

      else
         Row_Pos_166 := No_Token_Index;
         goto Exit_Row_161_0;

      end if;

--  Start tok_code

      Token_Res_222 := Row_Pos_166;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_222));
      begin
         if T.Kind /= From_Token_Kind (Ada_Then) then
            Token_Pos_222 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_166 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_166,
                  Expected_Token_Id => Ada_Then,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_222 := Row_Pos_166 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_15 := 4;

      if Token_Pos_222 /= No_Token_Index then

         Row_Pos_166 := Token_Pos_222;

      else
         Row_Pos_166 := No_Token_Index;
         goto Exit_Row_161_0;

      end if;

      Parser.Private_Part.Dont_Skip.Append
        (Dontskip_If_Stmt_0_Extract_Parse_0'Access);

      Defer_Res_289 := Stmts_List_Parse_0 (Parser, Row_Pos_166);
      Defer_Pos_289 := Parser.Current_Pos;

      Parser.Private_Part.Dont_Skip.Delete_Last;

      Row_Progress_15 := 5;

      if Defer_Pos_289 /= No_Token_Index then

         Row_Pos_166 := Defer_Pos_289;

      else
         Row_Pos_166 := No_Token_Index;
         goto Exit_Row_161_0;

      end if;

--  Start list_code

      List_Pos_21 := Row_Pos_166;

      Lst_Cpos_21 := Row_Pos_166;
      Tmp_List_21 := Get_Parse_List (Parser);

      loop

--  Start transform_code

--  Start row_code

         Row_Pos_167 := Lst_Cpos_21;

--  Start tok_code

         Token_Res_223 := Row_Pos_167;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_223));
         begin
            if T.Kind /= From_Token_Kind (Ada_Elsif) then
               Token_Pos_223 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Row_Pos_167 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Row_Pos_167,
                     Expected_Token_Id => Ada_Elsif,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_223 := Row_Pos_167 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_223 /= No_Token_Index then

            Row_Pos_167 := Token_Pos_223;

         else
            Row_Pos_167 := No_Token_Index;
            goto Exit_Row_162_0;

         end if;

         Defer_Res_290 := Expr_Or_Parse_0 (Parser, Row_Pos_167);
         Defer_Pos_290 := Parser.Current_Pos;

         if Defer_Pos_290 /= No_Token_Index then

            Row_Pos_167 := Defer_Pos_290;

         else
            Row_Pos_167 := No_Token_Index;
            goto Exit_Row_162_0;

         end if;

--  Start tok_code

         Token_Res_224 := Row_Pos_167;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_224));
         begin
            if T.Kind /= From_Token_Kind (Ada_Then) then
               Token_Pos_224 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Row_Pos_167 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Row_Pos_167,
                     Expected_Token_Id => Ada_Then,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_224 := Row_Pos_167 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_224 /= No_Token_Index then

            Row_Pos_167 := Token_Pos_224;

         else
            Row_Pos_167 := No_Token_Index;
            goto Exit_Row_162_0;

         end if;

         Parser.Private_Part.Dont_Skip.Append
           (Dontskip_If_Stmt_1_Extract_Parse_0'Access);

         Defer_Res_291 := Stmts_List_Parse_0 (Parser, Row_Pos_167);
         Defer_Pos_291 := Parser.Current_Pos;

         Parser.Private_Part.Dont_Skip.Delete_Last;

         if Defer_Pos_291 /= No_Token_Index then

            Row_Pos_167 := Defer_Pos_291;

         else
            Row_Pos_167 := No_Token_Index;
            goto Exit_Row_162_0;

         end if;

         pragma Warnings (Off, "referenced");
         <<Exit_Row_162_0>>
         pragma Warnings (On, "referenced");

--  End row_code

         if Row_Pos_167 /= No_Token_Index then

            Transform_Res_142 := Allocate_Elsif_Stmt_Part (Parser.Mem_Pool);

            Initialize
              (Self => Transform_Res_142, Kind => Ada_Elsif_Stmt_Part,
               Unit            => Parser.Unit,
Token_Start_Index              => Lst_Cpos_21,
               Token_End_Index =>
                 (if Row_Pos_167 = Lst_Cpos_21 then No_Token_Index
                  else Row_Pos_167 - 1));

            Initialize_Fields_For_Elsif_Stmt_Part
              (Self                        => Transform_Res_142,
               Elsif_Stmt_Part_F_Cond_Expr => Defer_Res_290,
               Elsif_Stmt_Part_F_Stmts     => Defer_Res_291);

            if Defer_Res_290 /= null and then Is_Incomplete (Defer_Res_290)
            then
               Transform_Res_142.Last_Attempted_Child := 0;
            elsif Defer_Res_290 /= null and then not Is_Ghost (Defer_Res_290)
            then
               Transform_Res_142.Last_Attempted_Child := -1;
            end if;
            if Defer_Res_291 /= null and then Is_Incomplete (Defer_Res_291)
            then
               Transform_Res_142.Last_Attempted_Child := 0;
            elsif Defer_Res_291 /= null and then not Is_Ghost (Defer_Res_291)
            then
               Transform_Res_142.Last_Attempted_Child := -1;
            end if;

         end if;

--  End transform_code

         exit when Row_Pos_167 = No_Token_Index;

         List_Pos_21 := Row_Pos_167;
         Lst_Cpos_21 := List_Pos_21;

         Tmp_List_21.Nodes.Append (Transform_Res_142);

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_21.Nodes.Length;
      begin
         List_Res_21 := Allocate_Elsif_Stmt_Part_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_166;
            Token_End   :=
              (if Lst_Cpos_21 = Row_Pos_166 then Row_Pos_166
               else Lst_Cpos_21 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_166, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self            => List_Res_21, Kind => Ada_Elsif_Stmt_Part_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_21, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_21.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_21.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_21);

--  End list_code

      Row_Progress_15 := 6;

      if List_Pos_21 /= No_Token_Index then

         Row_Pos_166 := List_Pos_21;

      else
         Row_Pos_166 := No_Token_Index;
         goto Exit_Row_161_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_168 := Row_Pos_166;

--  Start tok_code

      Token_Res_225 := Row_Pos_168;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_225));
      begin
         if T.Kind /= From_Token_Kind (Ada_Else) then
            Token_Pos_225 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_168 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_168,
                  Expected_Token_Id => Ada_Else,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_225 := Row_Pos_168 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_225 /= No_Token_Index then

         Row_Pos_168 := Token_Pos_225;

      else
         Row_Pos_168 := No_Token_Index;
         goto Exit_Row_163_0;

      end if;

      Parser.Private_Part.Dont_Skip.Append
        (Dontskip_If_Stmt_2_Extract_Parse_0'Access);

      Defer_Res_292 := Stmts_List_Parse_0 (Parser, Row_Pos_168);
      Defer_Pos_292 := Parser.Current_Pos;

      Parser.Private_Part.Dont_Skip.Delete_Last;

      if Defer_Pos_292 /= No_Token_Index then

         Row_Pos_168 := Defer_Pos_292;

      else
         Row_Pos_168 := No_Token_Index;
         goto Exit_Row_163_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_163_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_168 = No_Token_Index then

         Defer_Res_292 := Allocate_Stmt_List (Parser.Mem_Pool);
         Initialize
           (Self => Defer_Res_292, Kind => Ada_Stmt_List, Unit => Parser.Unit,
            Token_Start_Index => Row_Pos_166 - 1,
            Token_End_Index   => No_Token_Index);
         Initialize_List (Self => Defer_Res_292, Parser => Parser, Count => 0);

         Row_Pos_168 := Row_Pos_166;

      end if;

--  End opt_code

      Row_Progress_15 := 7;

      if Row_Pos_168 /= No_Token_Index then

         Row_Pos_166 := Row_Pos_168;

      else
         Row_Pos_166 := No_Token_Index;
         goto Exit_Row_161_0;

      end if;

--  Start tok_code

      Token_Res_226 := Row_Pos_166;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_226));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_226 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_166 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_166,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_226 := Row_Pos_166 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_15 := 8;

      if Token_Pos_226 /= No_Token_Index then

         Row_Pos_166 := Token_Pos_226;

      else
         Row_Pos_166 := No_Token_Index;
         goto Exit_Row_161_0;

      end if;

--  Start tok_code

      Token_Res_227 := Row_Pos_166;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_227));
      begin
         if T.Kind /= From_Token_Kind (Ada_If) then
            Token_Pos_227 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_166 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_166,
                  Expected_Token_Id => Ada_If,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_227 := Row_Pos_166 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_15 := 9;

      if Token_Pos_227 /= No_Token_Index then

         Row_Pos_166 := Token_Pos_227;

      else
         Row_Pos_166 := No_Token_Index;
         goto Exit_Row_161_0;

      end if;

--  Start tok_code

      Token_Res_228 := Row_Pos_166;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_228));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_228 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_166 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_166,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_228 := Row_Pos_166 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_15 := 10;

      if Token_Pos_228 /= No_Token_Index then

         Row_Pos_166 := Token_Pos_228;

      else
         Row_Pos_166 := No_Token_Index;
         goto Exit_Row_161_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_161_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_166 = No_Token_Index and then Nobt_15 then
         Row_Pos_166             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_15 := True;
      end if;

      if Row_Pos_166 /= No_Token_Index then

         Transform_Res_143 := Allocate_If_Stmt (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_143, Kind => Ada_If_Stmt,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_166 = Pos then No_Token_Index else Row_Pos_166 - 1));

         Initialize_Fields_For_If_Stmt
           (Self => Transform_Res_143, If_Stmt_F_Cond_Expr => Defer_Res_288,
            If_Stmt_F_Then_Stmts   => Defer_Res_289,
            If_Stmt_F_Alternatives => List_Res_21,
            If_Stmt_F_Else_Stmts   => Defer_Res_292);

         if Defer_Res_288 /= null and then Is_Incomplete (Defer_Res_288) then
            Transform_Res_143.Last_Attempted_Child := 0;
         elsif Defer_Res_288 /= null and then not Is_Ghost (Defer_Res_288) then
            Transform_Res_143.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_289 /= null and then Is_Incomplete (Defer_Res_289) then
            Transform_Res_143.Last_Attempted_Child := 0;
         elsif Defer_Res_289 /= null and then not Is_Ghost (Defer_Res_289) then
            Transform_Res_143.Last_Attempted_Child := -1;
         end if;
         if List_Res_21 /= null and then Is_Incomplete (List_Res_21) then
            Transform_Res_143.Last_Attempted_Child := 0;
         elsif List_Res_21 /= null and then not Is_Ghost (List_Res_21) then
            Transform_Res_143.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_292 /= null and then Is_Incomplete (Defer_Res_292) then
            Transform_Res_143.Last_Attempted_Child := 0;
         elsif Defer_Res_292 /= null and then not Is_Ghost (Defer_Res_292) then
            Transform_Res_143.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_15 then
            Transform_Res_143.Last_Attempted_Child := Row_Progress_15;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <if_stmt>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.If_Stmt_Transform_Parse_1_Memo,
         Row_Pos_166 /= No_Token_Index, Transform_Res_143, Pos, Row_Pos_166);

      Parser.Current_Pos := Row_Pos_166;

      return Transform_Res_143;
   end If_Stmt_Transform_Parse_1;

   function Iblock_Stmt_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Block_Stmt
   is
      use Bare_Block_Stmt_Memos;

      Nobt_16                 : Boolean               := False;
      Nobt_17                 : Boolean               := False;
      Row_Pos_171             : Token_Index           := No_Token_Index;
      Token_Pos_230           : Token_Index           := No_Token_Index;
      Token_Res_230           : Token_Index           := No_Token_Index;
      Defer_Pos_296           : Token_Index           := No_Token_Index;
      Defer_Res_296           : Bare_Handled_Stmts    := No_Bare_Ada_Node;
      Row_Pos_172             : Token_Index           := No_Token_Index;
      Token_Pos_231           : Token_Index           := No_Token_Index;
      Token_Res_231           : Token_Index           := No_Token_Index;
      Row_Pos_173             : Token_Index           := No_Token_Index;
      Defer_Pos_297           : Token_Index           := No_Token_Index;
      Defer_Res_297           : Bare_Identifier       := No_Bare_Ada_Node;
      Transform_Res_146       : Bare_End_Name         := No_Bare_Ada_Node;
      Token_Pos_232           : Token_Index           := No_Token_Index;
      Token_Res_232           : Token_Index           := No_Token_Index;
      Row_Progress_16         : Integer               := 0;
      Transform_Res_147       : Bare_Begin_Block      := No_Bare_Ada_Node;
      Transform_Has_Failed_16 : Boolean               := False;
      Row_Pos_174             : Token_Index           := No_Token_Index;
      Token_Pos_233           : Token_Index           := No_Token_Index;
      Token_Res_233           : Token_Index           := No_Token_Index;
      Defer_Pos_298           : Token_Index           := No_Token_Index;
      Defer_Res_298           : Bare_Declarative_Part := No_Bare_Ada_Node;
      Token_Pos_234           : Token_Index           := No_Token_Index;
      Token_Res_234           : Token_Index           := No_Token_Index;
      Defer_Pos_299           : Token_Index           := No_Token_Index;
      Defer_Res_299           : Bare_Handled_Stmts    := No_Bare_Ada_Node;
      Row_Pos_175             : Token_Index           := No_Token_Index;
      Token_Pos_235           : Token_Index           := No_Token_Index;
      Token_Res_235           : Token_Index           := No_Token_Index;
      Row_Pos_176             : Token_Index           := No_Token_Index;
      Defer_Pos_300           : Token_Index           := No_Token_Index;
      Defer_Res_300           : Bare_Identifier       := No_Bare_Ada_Node;
      Transform_Res_148       : Bare_End_Name         := No_Bare_Ada_Node;
      Token_Pos_236           : Token_Index           := No_Token_Index;
      Token_Res_236           : Token_Index           := No_Token_Index;
      Row_Progress_17         : Integer               := 0;
      Transform_Res_149       : Bare_Decl_Block       := No_Bare_Ada_Node;
      Transform_Has_Failed_17 : Boolean               := False;
      Or_Pos_69               : Token_Index           := No_Token_Index;
      Or_Res_69               : Bare_Block_Stmt       := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Iblock_Stmt_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_69          := M.Instance;
         return Or_Res_69;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_69;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_69 := No_Token_Index;
      Or_Res_69 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_171 := Pos;

--  Start tok_code

      Token_Res_230 := Row_Pos_171;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_230));
      begin
         if T.Kind /= From_Token_Kind (Ada_Begin) then
            Token_Pos_230 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_171 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_171,
                  Expected_Token_Id => Ada_Begin,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_230 := Row_Pos_171 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_16 := 1;

      if Token_Pos_230 /= No_Token_Index then

         Row_Pos_171 := Token_Pos_230;

      else
         Row_Pos_171 := No_Token_Index;
         goto Exit_Row_164_0;

      end if;

      Nobt_16 := True;

      Row_Progress_16 := 2;

      if Row_Pos_171 /= No_Token_Index then

         Row_Pos_171 := Row_Pos_171;

      else
         Row_Pos_171 := No_Token_Index;
         goto Exit_Row_164_0;

      end if;

      Defer_Res_296 := Handled_Stmts_Transform_Parse_0 (Parser, Row_Pos_171);
      Defer_Pos_296 := Parser.Current_Pos;

      Row_Progress_16 := 3;

      if Defer_Pos_296 /= No_Token_Index then

         Row_Pos_171 := Defer_Pos_296;

      else
         Row_Pos_171 := No_Token_Index;
         goto Exit_Row_164_0;

      end if;

--  Start row_code

      Row_Pos_172 := Row_Pos_171;

--  Start tok_code

      Token_Res_231 := Row_Pos_172;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_231));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_231 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_172 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_172,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_231 := Row_Pos_172 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_231 /= No_Token_Index then

         Row_Pos_172 := Token_Pos_231;

      else
         Row_Pos_172 := No_Token_Index;
         goto Exit_Row_165_0;

      end if;

--  Start opt_code

--  Start transform_code

--  Start row_code

      Row_Pos_173 := Row_Pos_172;

      Defer_Res_297 := Identifier_Transform_Parse_0 (Parser, Row_Pos_173);
      Defer_Pos_297 := Parser.Current_Pos;

      if Defer_Pos_297 /= No_Token_Index then

         Row_Pos_173 := Defer_Pos_297;

      else
         Row_Pos_173 := No_Token_Index;
         goto Exit_Row_166_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_166_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_173 /= No_Token_Index then

         Transform_Res_146 := Allocate_End_Name (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_146, Kind => Ada_End_Name,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_172,
            Token_End_Index =>
              (if Row_Pos_173 = Row_Pos_172 then No_Token_Index
               else Row_Pos_173 - 1));

         Initialize_Fields_For_End_Name
           (Self => Transform_Res_146, End_Name_F_Name => Defer_Res_297);

         if Defer_Res_297 /= null and then Is_Incomplete (Defer_Res_297) then
            Transform_Res_146.Last_Attempted_Child := 0;
         elsif Defer_Res_297 /= null and then not Is_Ghost (Defer_Res_297) then
            Transform_Res_146.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_173 = No_Token_Index then

         Transform_Res_146 := No_Bare_Ada_Node;

         Row_Pos_173 := Row_Pos_172;

      end if;

--  End opt_code

      if Row_Pos_173 /= No_Token_Index then

         Row_Pos_172 := Row_Pos_173;

      else
         Row_Pos_172 := No_Token_Index;
         goto Exit_Row_165_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_165_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      Row_Progress_16 := 4;

      if Row_Pos_172 /= No_Token_Index then

         Row_Pos_171 := Row_Pos_172;

      else
         Row_Pos_171 := No_Token_Index;
         goto Exit_Row_164_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_232 := Row_Pos_171;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_232));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_232 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_171 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_171,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_232 := Row_Pos_171 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_232 = No_Token_Index then

         Token_Res_232 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_171).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_232 := Row_Pos_171;

      end if;

--  End opt_code

      Row_Progress_16 := 5;

      if Token_Pos_232 /= No_Token_Index then

         Row_Pos_171 := Token_Pos_232;

      else
         Row_Pos_171 := No_Token_Index;
         goto Exit_Row_164_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_164_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_171 = No_Token_Index and then Nobt_16 then
         Row_Pos_171             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_16 := True;
      end if;

      if Row_Pos_171 /= No_Token_Index then

         Transform_Res_147 := Allocate_Begin_Block (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_147, Kind => Ada_Begin_Block,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_171 = Pos then No_Token_Index else Row_Pos_171 - 1));

         Initialize_Fields_For_Begin_Block
           (Self => Transform_Res_147, Begin_Block_F_Stmts => Defer_Res_296,
            Begin_Block_F_End_Name => Transform_Res_146);

         if Defer_Res_296 /= null and then Is_Incomplete (Defer_Res_296) then
            Transform_Res_147.Last_Attempted_Child := 0;
         elsif Defer_Res_296 /= null and then not Is_Ghost (Defer_Res_296) then
            Transform_Res_147.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_146 /= null
           and then Is_Incomplete (Transform_Res_146)
         then
            Transform_Res_147.Last_Attempted_Child := 0;
         elsif Transform_Res_146 /= null
           and then not Is_Ghost (Transform_Res_146)
         then
            Transform_Res_147.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_16 then
            Transform_Res_147.Last_Attempted_Child := Row_Progress_16;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <iblock_stmt>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      if Row_Pos_171 /= No_Token_Index then
         Or_Pos_69 := Row_Pos_171;
         Or_Res_69 := Transform_Res_147;
         goto Exit_Or_68;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_174 := Pos;

--  Start tok_code

      Token_Res_233 := Row_Pos_174;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_233));
      begin
         if T.Kind /= From_Token_Kind (Ada_Declare) then
            Token_Pos_233 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_174 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_174,
                  Expected_Token_Id => Ada_Declare,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_233 := Row_Pos_174 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_17 := 1;

      if Token_Pos_233 /= No_Token_Index then

         Row_Pos_174 := Token_Pos_233;

      else
         Row_Pos_174 := No_Token_Index;
         goto Exit_Row_167_0;

      end if;

      Nobt_17 := True;

      Row_Progress_17 := 2;

      if Row_Pos_174 /= No_Token_Index then

         Row_Pos_174 := Row_Pos_174;

      else
         Row_Pos_174 := No_Token_Index;
         goto Exit_Row_167_0;

      end if;

      Defer_Res_298 := Recov_Decl_Part_Dont_Skip_Parse_0 (Parser, Row_Pos_174);
      Defer_Pos_298 := Parser.Current_Pos;

      Row_Progress_17 := 3;

      if Defer_Pos_298 /= No_Token_Index then

         Row_Pos_174 := Defer_Pos_298;

      else
         Row_Pos_174 := No_Token_Index;
         goto Exit_Row_167_0;

      end if;

--  Start tok_code

      Token_Res_234 := Row_Pos_174;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_234));
      begin
         if T.Kind /= From_Token_Kind (Ada_Begin) then
            Token_Pos_234 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_174 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_174,
                  Expected_Token_Id => Ada_Begin,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_234 := Row_Pos_174 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_17 := 4;

      if Token_Pos_234 /= No_Token_Index then

         Row_Pos_174 := Token_Pos_234;

      else
         Row_Pos_174 := No_Token_Index;
         goto Exit_Row_167_0;

      end if;

      Defer_Res_299 := Handled_Stmts_Transform_Parse_0 (Parser, Row_Pos_174);
      Defer_Pos_299 := Parser.Current_Pos;

      Row_Progress_17 := 5;

      if Defer_Pos_299 /= No_Token_Index then

         Row_Pos_174 := Defer_Pos_299;

      else
         Row_Pos_174 := No_Token_Index;
         goto Exit_Row_167_0;

      end if;

--  Start row_code

      Row_Pos_175 := Row_Pos_174;

--  Start tok_code

      Token_Res_235 := Row_Pos_175;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_235));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_235 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_175 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_175,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_235 := Row_Pos_175 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_235 /= No_Token_Index then

         Row_Pos_175 := Token_Pos_235;

      else
         Row_Pos_175 := No_Token_Index;
         goto Exit_Row_168_0;

      end if;

--  Start opt_code

--  Start transform_code

--  Start row_code

      Row_Pos_176 := Row_Pos_175;

      Defer_Res_300 := Identifier_Transform_Parse_0 (Parser, Row_Pos_176);
      Defer_Pos_300 := Parser.Current_Pos;

      if Defer_Pos_300 /= No_Token_Index then

         Row_Pos_176 := Defer_Pos_300;

      else
         Row_Pos_176 := No_Token_Index;
         goto Exit_Row_169_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_169_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_176 /= No_Token_Index then

         Transform_Res_148 := Allocate_End_Name (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_148, Kind => Ada_End_Name,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_175,
            Token_End_Index =>
              (if Row_Pos_176 = Row_Pos_175 then No_Token_Index
               else Row_Pos_176 - 1));

         Initialize_Fields_For_End_Name
           (Self => Transform_Res_148, End_Name_F_Name => Defer_Res_300);

         if Defer_Res_300 /= null and then Is_Incomplete (Defer_Res_300) then
            Transform_Res_148.Last_Attempted_Child := 0;
         elsif Defer_Res_300 /= null and then not Is_Ghost (Defer_Res_300) then
            Transform_Res_148.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_176 = No_Token_Index then

         Transform_Res_148 := No_Bare_Ada_Node;

         Row_Pos_176 := Row_Pos_175;

      end if;

--  End opt_code

      if Row_Pos_176 /= No_Token_Index then

         Row_Pos_175 := Row_Pos_176;

      else
         Row_Pos_175 := No_Token_Index;
         goto Exit_Row_168_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_168_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      Row_Progress_17 := 6;

      if Row_Pos_175 /= No_Token_Index then

         Row_Pos_174 := Row_Pos_175;

      else
         Row_Pos_174 := No_Token_Index;
         goto Exit_Row_167_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_236 := Row_Pos_174;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_236));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_236 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_174 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_174,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_236 := Row_Pos_174 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_236 = No_Token_Index then

         Token_Res_236 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_174).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_236 := Row_Pos_174;

      end if;

--  End opt_code

      Row_Progress_17 := 7;

      if Token_Pos_236 /= No_Token_Index then

         Row_Pos_174 := Token_Pos_236;

      else
         Row_Pos_174 := No_Token_Index;
         goto Exit_Row_167_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_167_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_174 = No_Token_Index and then Nobt_17 then
         Row_Pos_174             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_17 := True;
      end if;

      if Row_Pos_174 /= No_Token_Index then

         Transform_Res_149 := Allocate_Decl_Block (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_149, Kind => Ada_Decl_Block,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_174 = Pos then No_Token_Index else Row_Pos_174 - 1));

         Initialize_Fields_For_Decl_Block
           (Self => Transform_Res_149, Decl_Block_F_Decls => Defer_Res_298,
            Decl_Block_F_Stmts    => Defer_Res_299,
            Decl_Block_F_End_Name => Transform_Res_148);

         if Defer_Res_298 /= null and then Is_Incomplete (Defer_Res_298) then
            Transform_Res_149.Last_Attempted_Child := 0;
         elsif Defer_Res_298 /= null and then not Is_Ghost (Defer_Res_298) then
            Transform_Res_149.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_299 /= null and then Is_Incomplete (Defer_Res_299) then
            Transform_Res_149.Last_Attempted_Child := 0;
         elsif Defer_Res_299 /= null and then not Is_Ghost (Defer_Res_299) then
            Transform_Res_149.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_148 /= null
           and then Is_Incomplete (Transform_Res_148)
         then
            Transform_Res_149.Last_Attempted_Child := 0;
         elsif Transform_Res_148 /= null
           and then not Is_Ghost (Transform_Res_148)
         then
            Transform_Res_149.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_17 then
            Transform_Res_149.Last_Attempted_Child := Row_Progress_17;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <iblock_stmt>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      if Row_Pos_174 /= No_Token_Index then
         Or_Pos_69 := Row_Pos_174;
         Or_Res_69 := Transform_Res_149;
         goto Exit_Or_68;
      end if;
      <<Exit_Or_68>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Iblock_Stmt_Or_Parse_0_Memo,
         Or_Pos_69 /= No_Token_Index, Or_Res_69, Pos, Or_Pos_69);

      Parser.Current_Pos := Or_Pos_69;

      return Or_Res_69;
   end Iblock_Stmt_Or_Parse_0;

   function Block_Stmt_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Composite_Stmt
   is
      use Bare_Composite_Stmt_Memos;

      Defer_Pos_293     : Token_Index          := No_Token_Index;
      Defer_Res_293     : Bare_Block_Stmt      := No_Bare_Ada_Node;
      Row_Pos_169       : Token_Index          := No_Token_Index;
      Row_Pos_170       : Token_Index          := No_Token_Index;
      Defer_Pos_294     : Token_Index          := No_Token_Index;
      Defer_Res_294     : Bare_Defining_Name   := No_Bare_Ada_Node;
      Transform_Res_144 : Bare_Named_Stmt_Decl := No_Bare_Ada_Node;
      Token_Pos_229     : Token_Index          := No_Token_Index;
      Token_Res_229     : Token_Index          := No_Token_Index;
      Defer_Pos_295     : Token_Index          := No_Token_Index;
      Defer_Res_295     : Bare_Block_Stmt      := No_Bare_Ada_Node;
      Transform_Res_145 : Bare_Named_Stmt      := No_Bare_Ada_Node;
      Or_Pos_68         : Token_Index          := No_Token_Index;
      Or_Res_68         : Bare_Composite_Stmt  := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Block_Stmt_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_68          := M.Instance;
         return Or_Res_68;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_68;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_68 := No_Token_Index;
      Or_Res_68 := No_Bare_Ada_Node;

      Defer_Res_293 := Iblock_Stmt_Or_Parse_0 (Parser, Pos);
      Defer_Pos_293 := Parser.Current_Pos;

      if Defer_Pos_293 /= No_Token_Index then
         Or_Pos_68 := Defer_Pos_293;
         Or_Res_68 := Defer_Res_293;
         goto Exit_Or_67;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_169 := Pos;

--  Start transform_code

--  Start row_code

      Row_Pos_170 := Row_Pos_169;

      Defer_Res_294 := Defining_Id_Transform_Parse_0 (Parser, Row_Pos_170);
      Defer_Pos_294 := Parser.Current_Pos;

      if Defer_Pos_294 /= No_Token_Index then

         Row_Pos_170 := Defer_Pos_294;

      else
         Row_Pos_170 := No_Token_Index;
         goto Exit_Row_171_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_171_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_170 /= No_Token_Index then

         Transform_Res_144 := Allocate_Named_Stmt_Decl (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_144, Kind => Ada_Named_Stmt_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_169,
            Token_End_Index =>
              (if Row_Pos_170 = Row_Pos_169 then No_Token_Index
               else Row_Pos_170 - 1));

         Initialize_Fields_For_Named_Stmt_Decl
           (Self                   => Transform_Res_144,
            Named_Stmt_Decl_F_Name => Defer_Res_294);

         if Defer_Res_294 /= null and then Is_Incomplete (Defer_Res_294) then
            Transform_Res_144.Last_Attempted_Child := 0;
         elsif Defer_Res_294 /= null and then not Is_Ghost (Defer_Res_294) then
            Transform_Res_144.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_170 /= No_Token_Index then

         Row_Pos_169 := Row_Pos_170;

      else
         Row_Pos_169 := No_Token_Index;
         goto Exit_Row_170_0;

      end if;

--  Start tok_code

      Token_Res_229 := Row_Pos_169;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_229));
      begin
         if T.Kind /= From_Token_Kind (Ada_Colon) then
            Token_Pos_229 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_169 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_169,
                  Expected_Token_Id => Ada_Colon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_229 := Row_Pos_169 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_229 /= No_Token_Index then

         Row_Pos_169 := Token_Pos_229;

      else
         Row_Pos_169 := No_Token_Index;
         goto Exit_Row_170_0;

      end if;

      Defer_Res_295 := Iblock_Stmt_Or_Parse_0 (Parser, Row_Pos_169);
      Defer_Pos_295 := Parser.Current_Pos;

      if Defer_Pos_295 /= No_Token_Index then

         Row_Pos_169 := Defer_Pos_295;

      else
         Row_Pos_169 := No_Token_Index;
         goto Exit_Row_170_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_170_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_169 /= No_Token_Index then

         Transform_Res_145 := Allocate_Named_Stmt (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_145, Kind => Ada_Named_Stmt,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_169 = Pos then No_Token_Index else Row_Pos_169 - 1));

         Initialize_Fields_For_Named_Stmt
           (Self => Transform_Res_145, Named_Stmt_F_Decl => Transform_Res_144,
            Named_Stmt_F_Stmt => Defer_Res_295);

         if Transform_Res_144 /= null
           and then Is_Incomplete (Transform_Res_144)
         then
            Transform_Res_145.Last_Attempted_Child := 0;
         elsif Transform_Res_144 /= null
           and then not Is_Ghost (Transform_Res_144)
         then
            Transform_Res_145.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_295 /= null and then Is_Incomplete (Defer_Res_295) then
            Transform_Res_145.Last_Attempted_Child := 0;
         elsif Defer_Res_295 /= null and then not Is_Ghost (Defer_Res_295) then
            Transform_Res_145.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_169 /= No_Token_Index then
         Or_Pos_68 := Row_Pos_169;
         Or_Res_68 := Transform_Res_145;
         goto Exit_Or_67;
      end if;
      <<Exit_Or_67>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Block_Stmt_Or_Parse_0_Memo,
         Or_Pos_68 /= No_Token_Index, Or_Res_68, Pos, Or_Pos_68);

      Parser.Current_Pos := Or_Pos_68;

      return Or_Res_68;
   end Block_Stmt_Or_Parse_0;

   function Iloop_Stmt_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Base_Loop_Stmt
   is
      use Bare_Base_Loop_Stmt_Memos;

      Nobt_18                 : Boolean              := False;
      Nobt_19                 : Boolean              := False;
      Nobt_20                 : Boolean              := False;
      Row_Pos_179             : Token_Index          := No_Token_Index;
      Token_Pos_238           : Token_Index          := No_Token_Index;
      Token_Res_238           : Token_Index          := No_Token_Index;
      Defer_Pos_304           : Token_Index          := No_Token_Index;
      Defer_Res_304           : Bare_For_Loop_Spec   := No_Bare_Ada_Node;
      Token_Pos_239           : Token_Index          := No_Token_Index;
      Token_Res_239           : Token_Index          := No_Token_Index;
      Defer_Pos_305           : Token_Index          := No_Token_Index;
      Defer_Res_305           : Bare_Stmt_List       := No_Bare_Ada_Node;
      Token_Pos_240           : Token_Index          := No_Token_Index;
      Token_Res_240           : Token_Index          := No_Token_Index;
      Token_Pos_241           : Token_Index          := No_Token_Index;
      Token_Res_241           : Token_Index          := No_Token_Index;
      Row_Pos_180             : Token_Index          := No_Token_Index;
      Defer_Pos_306           : Token_Index          := No_Token_Index;
      Defer_Res_306           : Bare_Identifier      := No_Bare_Ada_Node;
      Transform_Res_152       : Bare_End_Name        := No_Bare_Ada_Node;
      Token_Pos_242           : Token_Index          := No_Token_Index;
      Token_Res_242           : Token_Index          := No_Token_Index;
      Row_Progress_18         : Integer              := 0;
      Transform_Res_153       : Bare_For_Loop_Stmt   := No_Bare_Ada_Node;
      Transform_Has_Failed_18 : Boolean              := False;
      Row_Pos_181             : Token_Index          := No_Token_Index;
      Row_Pos_182             : Token_Index          := No_Token_Index;
      Token_Pos_243           : Token_Index          := No_Token_Index;
      Token_Res_243           : Token_Index          := No_Token_Index;
      Defer_Pos_307           : Token_Index          := No_Token_Index;
      Defer_Res_307           : Bare_Expr            := No_Bare_Ada_Node;
      Row_Progress_19         : Integer              := 0;
      Transform_Res_154       : Bare_While_Loop_Spec := No_Bare_Ada_Node;
      Transform_Has_Failed_19 : Boolean              := False;
      Token_Pos_244           : Token_Index          := No_Token_Index;
      Token_Res_244           : Token_Index          := No_Token_Index;
      Defer_Pos_308           : Token_Index          := No_Token_Index;
      Defer_Res_308           : Bare_Stmt_List       := No_Bare_Ada_Node;
      Token_Pos_245           : Token_Index          := No_Token_Index;
      Token_Res_245           : Token_Index          := No_Token_Index;
      Token_Pos_246           : Token_Index          := No_Token_Index;
      Token_Res_246           : Token_Index          := No_Token_Index;
      Row_Pos_183             : Token_Index          := No_Token_Index;
      Defer_Pos_309           : Token_Index          := No_Token_Index;
      Defer_Res_309           : Bare_Identifier      := No_Bare_Ada_Node;
      Transform_Res_155       : Bare_End_Name        := No_Bare_Ada_Node;
      Token_Pos_247           : Token_Index          := No_Token_Index;
      Token_Res_247           : Token_Index          := No_Token_Index;
      Row_Progress_20         : Integer              := 0;
      Transform_Res_156       : Bare_While_Loop_Stmt := No_Bare_Ada_Node;
      Transform_Has_Failed_20 : Boolean              := False;
      Row_Pos_184             : Token_Index          := No_Token_Index;
      Null_Res_9              : Bare_Loop_Spec       := No_Bare_Ada_Node;
      Token_Pos_248           : Token_Index          := No_Token_Index;
      Token_Res_248           : Token_Index          := No_Token_Index;
      Defer_Pos_310           : Token_Index          := No_Token_Index;
      Defer_Res_310           : Bare_Stmt_List       := No_Bare_Ada_Node;
      Token_Pos_249           : Token_Index          := No_Token_Index;
      Token_Res_249           : Token_Index          := No_Token_Index;
      Token_Pos_250           : Token_Index          := No_Token_Index;
      Token_Res_250           : Token_Index          := No_Token_Index;
      Row_Pos_185             : Token_Index          := No_Token_Index;
      Defer_Pos_311           : Token_Index          := No_Token_Index;
      Defer_Res_311           : Bare_Identifier      := No_Bare_Ada_Node;
      Transform_Res_157       : Bare_End_Name        := No_Bare_Ada_Node;
      Token_Pos_251           : Token_Index          := No_Token_Index;
      Token_Res_251           : Token_Index          := No_Token_Index;
      Row_Progress_21         : Integer              := 0;
      Transform_Res_158       : Bare_Loop_Stmt       := No_Bare_Ada_Node;
      Transform_Has_Failed_21 : Boolean              := False;
      Or_Pos_71               : Token_Index          := No_Token_Index;
      Or_Res_71               : Bare_Base_Loop_Stmt  := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Iloop_Stmt_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_71          := M.Instance;
         return Or_Res_71;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_71;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_71 := No_Token_Index;
      Or_Res_71 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_179 := Pos;

--  Start tok_code

      Token_Res_238 := Row_Pos_179;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_238));
      begin
         if T.Kind /= From_Token_Kind (Ada_For) then
            Token_Pos_238 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_179 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_179,
                  Expected_Token_Id => Ada_For,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_238 := Row_Pos_179 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_18 := 1;

      if Token_Pos_238 /= No_Token_Index then

         Row_Pos_179 := Token_Pos_238;

      else
         Row_Pos_179 := No_Token_Index;
         goto Exit_Row_172_0;

      end if;

      Nobt_18 := True;

      Row_Progress_18 := 2;

      if Row_Pos_179 /= No_Token_Index then

         Row_Pos_179 := Row_Pos_179;

      else
         Row_Pos_179 := No_Token_Index;
         goto Exit_Row_172_0;

      end if;

      Defer_Res_304 :=
        For_Loop_Param_Spec_Transform_Parse_3 (Parser, Row_Pos_179);
      Defer_Pos_304 := Parser.Current_Pos;

      Row_Progress_18 := 3;

      if Defer_Pos_304 /= No_Token_Index then

         Row_Pos_179 := Defer_Pos_304;

      else
         Row_Pos_179 := No_Token_Index;
         goto Exit_Row_172_0;

      end if;

--  Start tok_code

      Token_Res_239 := Row_Pos_179;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_239));
      begin
         if T.Kind /= From_Token_Kind (Ada_Loop) then
            Token_Pos_239 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_179 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_179,
                  Expected_Token_Id => Ada_Loop,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_239 := Row_Pos_179 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_18 := 4;

      if Token_Pos_239 /= No_Token_Index then

         Row_Pos_179 := Token_Pos_239;

      else
         Row_Pos_179 := No_Token_Index;
         goto Exit_Row_172_0;

      end if;

      Parser.Private_Part.Dont_Skip.Append
        (Dontskip_Iloop_Stmt_0_Extract_Parse_0'Access);

      Defer_Res_305 := Stmts_List_Parse_0 (Parser, Row_Pos_179);
      Defer_Pos_305 := Parser.Current_Pos;

      Parser.Private_Part.Dont_Skip.Delete_Last;

      Row_Progress_18 := 5;

      if Defer_Pos_305 /= No_Token_Index then

         Row_Pos_179 := Defer_Pos_305;

      else
         Row_Pos_179 := No_Token_Index;
         goto Exit_Row_172_0;

      end if;

--  Start tok_code

      Token_Res_240 := Row_Pos_179;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_240));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_240 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_179 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_179,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_240 := Row_Pos_179 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_18 := 6;

      if Token_Pos_240 /= No_Token_Index then

         Row_Pos_179 := Token_Pos_240;

      else
         Row_Pos_179 := No_Token_Index;
         goto Exit_Row_172_0;

      end if;

--  Start tok_code

      Token_Res_241 := Row_Pos_179;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_241));
      begin
         if T.Kind /= From_Token_Kind (Ada_Loop) then
            Token_Pos_241 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_179 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_179,
                  Expected_Token_Id => Ada_Loop,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_241 := Row_Pos_179 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_18 := 7;

      if Token_Pos_241 /= No_Token_Index then

         Row_Pos_179 := Token_Pos_241;

      else
         Row_Pos_179 := No_Token_Index;
         goto Exit_Row_172_0;

      end if;

--  Start opt_code

--  Start transform_code

--  Start row_code

      Row_Pos_180 := Row_Pos_179;

      Defer_Res_306 := Identifier_Transform_Parse_0 (Parser, Row_Pos_180);
      Defer_Pos_306 := Parser.Current_Pos;

      if Defer_Pos_306 /= No_Token_Index then

         Row_Pos_180 := Defer_Pos_306;

      else
         Row_Pos_180 := No_Token_Index;
         goto Exit_Row_173_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_173_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_180 /= No_Token_Index then

         Transform_Res_152 := Allocate_End_Name (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_152, Kind => Ada_End_Name,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_179,
            Token_End_Index =>
              (if Row_Pos_180 = Row_Pos_179 then No_Token_Index
               else Row_Pos_180 - 1));

         Initialize_Fields_For_End_Name
           (Self => Transform_Res_152, End_Name_F_Name => Defer_Res_306);

         if Defer_Res_306 /= null and then Is_Incomplete (Defer_Res_306) then
            Transform_Res_152.Last_Attempted_Child := 0;
         elsif Defer_Res_306 /= null and then not Is_Ghost (Defer_Res_306) then
            Transform_Res_152.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_180 = No_Token_Index then

         Transform_Res_152 := No_Bare_Ada_Node;

         Row_Pos_180 := Row_Pos_179;

      end if;

--  End opt_code

      Row_Progress_18 := 8;

      if Row_Pos_180 /= No_Token_Index then

         Row_Pos_179 := Row_Pos_180;

      else
         Row_Pos_179 := No_Token_Index;
         goto Exit_Row_172_0;

      end if;

--  Start tok_code

      Token_Res_242 := Row_Pos_179;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_242));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_242 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_179 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_179,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_242 := Row_Pos_179 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_18 := 9;

      if Token_Pos_242 /= No_Token_Index then

         Row_Pos_179 := Token_Pos_242;

      else
         Row_Pos_179 := No_Token_Index;
         goto Exit_Row_172_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_172_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_179 = No_Token_Index and then Nobt_18 then
         Row_Pos_179             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_18 := True;
      end if;

      if Row_Pos_179 /= No_Token_Index then

         Transform_Res_153 := Allocate_For_Loop_Stmt (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_153, Kind => Ada_For_Loop_Stmt,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_179 = Pos then No_Token_Index else Row_Pos_179 - 1));

         Initialize_Fields_For_For_Loop_Stmt
           (Self => Transform_Res_153, Base_Loop_Stmt_F_Spec => Defer_Res_304,
            Base_Loop_Stmt_F_Stmts    => Defer_Res_305,
            Base_Loop_Stmt_F_End_Name => Transform_Res_152);

         if Defer_Res_304 /= null and then Is_Incomplete (Defer_Res_304) then
            Transform_Res_153.Last_Attempted_Child := 0;
         elsif Defer_Res_304 /= null and then not Is_Ghost (Defer_Res_304) then
            Transform_Res_153.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_305 /= null and then Is_Incomplete (Defer_Res_305) then
            Transform_Res_153.Last_Attempted_Child := 0;
         elsif Defer_Res_305 /= null and then not Is_Ghost (Defer_Res_305) then
            Transform_Res_153.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_152 /= null
           and then Is_Incomplete (Transform_Res_152)
         then
            Transform_Res_153.Last_Attempted_Child := 0;
         elsif Transform_Res_152 /= null
           and then not Is_Ghost (Transform_Res_152)
         then
            Transform_Res_153.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_18 then
            Transform_Res_153.Last_Attempted_Child := Row_Progress_18;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <iloop_stmt>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      if Row_Pos_179 /= No_Token_Index then
         Or_Pos_71 := Row_Pos_179;
         Or_Res_71 := Transform_Res_153;
         goto Exit_Or_70;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_181 := Pos;

--  Start transform_code

--  Start row_code

      Row_Pos_182 := Row_Pos_181;

--  Start tok_code

      Token_Res_243 := Row_Pos_182;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_243));
      begin
         if T.Kind /= From_Token_Kind (Ada_While) then
            Token_Pos_243 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_182 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_182,
                  Expected_Token_Id => Ada_While,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_243 := Row_Pos_182 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_19 := 1;

      if Token_Pos_243 /= No_Token_Index then

         Row_Pos_182 := Token_Pos_243;

      else
         Row_Pos_182 := No_Token_Index;
         goto Exit_Row_175_0;

      end if;

      Nobt_19 := True;

      Row_Progress_19 := 2;

      if Row_Pos_182 /= No_Token_Index then

         Row_Pos_182 := Row_Pos_182;

      else
         Row_Pos_182 := No_Token_Index;
         goto Exit_Row_175_0;

      end if;

      Defer_Res_307 := Expr_Or_Parse_0 (Parser, Row_Pos_182);
      Defer_Pos_307 := Parser.Current_Pos;

      Row_Progress_19 := 3;

      if Defer_Pos_307 /= No_Token_Index then

         Row_Pos_182 := Defer_Pos_307;

      else
         Row_Pos_182 := No_Token_Index;
         goto Exit_Row_175_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_175_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_182 = No_Token_Index and then Nobt_19 then
         Row_Pos_182             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_19 := True;
      end if;

      if Row_Pos_182 /= No_Token_Index then

         Transform_Res_154 := Allocate_While_Loop_Spec (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_154, Kind => Ada_While_Loop_Spec,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_181,
            Token_End_Index =>
              (if Row_Pos_182 = Row_Pos_181 then No_Token_Index
               else Row_Pos_182 - 1));

         Initialize_Fields_For_While_Loop_Spec
           (Self                   => Transform_Res_154,
            While_Loop_Spec_F_Expr => Defer_Res_307);

         if Defer_Res_307 /= null and then Is_Incomplete (Defer_Res_307) then
            Transform_Res_154.Last_Attempted_Child := 0;
         elsif Defer_Res_307 /= null and then not Is_Ghost (Defer_Res_307) then
            Transform_Res_154.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_19 then
            Transform_Res_154.Last_Attempted_Child := Row_Progress_19;

            Append
              (Parser.Diagnostics,
               Get_Token (Parser.TDH.all, Row_Pos_181).Sloc_Range,
               To_Text ("Cannot parse <iloop_stmt>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      Row_Progress_20 := 1;

      if Row_Pos_182 /= No_Token_Index then

         Row_Pos_181 := Row_Pos_182;

      else
         Row_Pos_181 := No_Token_Index;
         goto Exit_Row_174_0;

      end if;

--  Start tok_code

      Token_Res_244 := Row_Pos_181;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_244));
      begin
         if T.Kind /= From_Token_Kind (Ada_Loop) then
            Token_Pos_244 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_181 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_181,
                  Expected_Token_Id => Ada_Loop,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_244 := Row_Pos_181 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_20 := 2;

      if Token_Pos_244 /= No_Token_Index then

         Row_Pos_181 := Token_Pos_244;

      else
         Row_Pos_181 := No_Token_Index;
         goto Exit_Row_174_0;

      end if;

      Parser.Private_Part.Dont_Skip.Append
        (Dontskip_Iloop_Stmt_1_Extract_Parse_0'Access);

      Defer_Res_308 := Stmts_List_Parse_0 (Parser, Row_Pos_181);
      Defer_Pos_308 := Parser.Current_Pos;

      Parser.Private_Part.Dont_Skip.Delete_Last;

      Row_Progress_20 := 3;

      if Defer_Pos_308 /= No_Token_Index then

         Row_Pos_181 := Defer_Pos_308;

      else
         Row_Pos_181 := No_Token_Index;
         goto Exit_Row_174_0;

      end if;

--  Start tok_code

      Token_Res_245 := Row_Pos_181;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_245));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_245 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_181 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_181,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_245 := Row_Pos_181 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_20 := 4;

      if Token_Pos_245 /= No_Token_Index then

         Row_Pos_181 := Token_Pos_245;

      else
         Row_Pos_181 := No_Token_Index;
         goto Exit_Row_174_0;

      end if;

--  Start tok_code

      Token_Res_246 := Row_Pos_181;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_246));
      begin
         if T.Kind /= From_Token_Kind (Ada_Loop) then
            Token_Pos_246 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_181 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_181,
                  Expected_Token_Id => Ada_Loop,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_246 := Row_Pos_181 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_20 := 5;

      if Token_Pos_246 /= No_Token_Index then

         Row_Pos_181 := Token_Pos_246;

      else
         Row_Pos_181 := No_Token_Index;
         goto Exit_Row_174_0;

      end if;

--  Start opt_code

--  Start transform_code

--  Start row_code

      Row_Pos_183 := Row_Pos_181;

      Defer_Res_309 := Identifier_Transform_Parse_0 (Parser, Row_Pos_183);
      Defer_Pos_309 := Parser.Current_Pos;

      if Defer_Pos_309 /= No_Token_Index then

         Row_Pos_183 := Defer_Pos_309;

      else
         Row_Pos_183 := No_Token_Index;
         goto Exit_Row_176_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_176_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_183 /= No_Token_Index then

         Transform_Res_155 := Allocate_End_Name (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_155, Kind => Ada_End_Name,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_181,
            Token_End_Index =>
              (if Row_Pos_183 = Row_Pos_181 then No_Token_Index
               else Row_Pos_183 - 1));

         Initialize_Fields_For_End_Name
           (Self => Transform_Res_155, End_Name_F_Name => Defer_Res_309);

         if Defer_Res_309 /= null and then Is_Incomplete (Defer_Res_309) then
            Transform_Res_155.Last_Attempted_Child := 0;
         elsif Defer_Res_309 /= null and then not Is_Ghost (Defer_Res_309) then
            Transform_Res_155.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_183 = No_Token_Index then

         Transform_Res_155 := No_Bare_Ada_Node;

         Row_Pos_183 := Row_Pos_181;

      end if;

--  End opt_code

      Row_Progress_20 := 6;

      if Row_Pos_183 /= No_Token_Index then

         Row_Pos_181 := Row_Pos_183;

      else
         Row_Pos_181 := No_Token_Index;
         goto Exit_Row_174_0;

      end if;

--  Start tok_code

      Token_Res_247 := Row_Pos_181;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_247));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_247 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_181 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_181,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_247 := Row_Pos_181 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_20 := 7;

      if Token_Pos_247 /= No_Token_Index then

         Row_Pos_181 := Token_Pos_247;

      else
         Row_Pos_181 := No_Token_Index;
         goto Exit_Row_174_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_174_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_181 = No_Token_Index and then Nobt_19 then
         Row_Pos_181             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_20 := True;
      end if;

      if Row_Pos_181 /= No_Token_Index then

         Transform_Res_156 := Allocate_While_Loop_Stmt (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_156, Kind => Ada_While_Loop_Stmt,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_181 = Pos then No_Token_Index else Row_Pos_181 - 1));

         Initialize_Fields_For_While_Loop_Stmt
           (Self                      => Transform_Res_156,
            Base_Loop_Stmt_F_Spec     => Transform_Res_154,
            Base_Loop_Stmt_F_Stmts    => Defer_Res_308,
            Base_Loop_Stmt_F_End_Name => Transform_Res_155);

         if Transform_Res_154 /= null
           and then Is_Incomplete (Transform_Res_154)
         then
            Transform_Res_156.Last_Attempted_Child := 0;
         elsif Transform_Res_154 /= null
           and then not Is_Ghost (Transform_Res_154)
         then
            Transform_Res_156.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_308 /= null and then Is_Incomplete (Defer_Res_308) then
            Transform_Res_156.Last_Attempted_Child := 0;
         elsif Defer_Res_308 /= null and then not Is_Ghost (Defer_Res_308) then
            Transform_Res_156.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_155 /= null
           and then Is_Incomplete (Transform_Res_155)
         then
            Transform_Res_156.Last_Attempted_Child := 0;
         elsif Transform_Res_155 /= null
           and then not Is_Ghost (Transform_Res_155)
         then
            Transform_Res_156.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_20 then
            Transform_Res_156.Last_Attempted_Child := Row_Progress_20;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <iloop_stmt>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      if Row_Pos_181 /= No_Token_Index then
         Or_Pos_71 := Row_Pos_181;
         Or_Res_71 := Transform_Res_156;
         goto Exit_Or_70;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_184 := Pos;

      Null_Res_9 := No_Bare_Ada_Node;

      Row_Progress_21 := 1;

      if Row_Pos_184 /= No_Token_Index then

         Row_Pos_184 := Row_Pos_184;

      else
         Row_Pos_184 := No_Token_Index;
         goto Exit_Row_177_0;

      end if;

--  Start tok_code

      Token_Res_248 := Row_Pos_184;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_248));
      begin
         if T.Kind /= From_Token_Kind (Ada_Loop) then
            Token_Pos_248 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_184 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_184,
                  Expected_Token_Id => Ada_Loop,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_248 := Row_Pos_184 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_21 := 2;

      if Token_Pos_248 /= No_Token_Index then

         Row_Pos_184 := Token_Pos_248;

      else
         Row_Pos_184 := No_Token_Index;
         goto Exit_Row_177_0;

      end if;

      Nobt_20 := True;

      Row_Progress_21 := 3;

      if Row_Pos_184 /= No_Token_Index then

         Row_Pos_184 := Row_Pos_184;

      else
         Row_Pos_184 := No_Token_Index;
         goto Exit_Row_177_0;

      end if;

      Parser.Private_Part.Dont_Skip.Append
        (Dontskip_Iloop_Stmt_2_Extract_Parse_0'Access);

      Defer_Res_310 := Stmts_List_Parse_0 (Parser, Row_Pos_184);
      Defer_Pos_310 := Parser.Current_Pos;

      Parser.Private_Part.Dont_Skip.Delete_Last;

      Row_Progress_21 := 4;

      if Defer_Pos_310 /= No_Token_Index then

         Row_Pos_184 := Defer_Pos_310;

      else
         Row_Pos_184 := No_Token_Index;
         goto Exit_Row_177_0;

      end if;

--  Start tok_code

      Token_Res_249 := Row_Pos_184;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_249));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_249 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_184 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_184,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_249 := Row_Pos_184 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_21 := 5;

      if Token_Pos_249 /= No_Token_Index then

         Row_Pos_184 := Token_Pos_249;

      else
         Row_Pos_184 := No_Token_Index;
         goto Exit_Row_177_0;

      end if;

--  Start tok_code

      Token_Res_250 := Row_Pos_184;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_250));
      begin
         if T.Kind /= From_Token_Kind (Ada_Loop) then
            Token_Pos_250 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_184 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_184,
                  Expected_Token_Id => Ada_Loop,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_250 := Row_Pos_184 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_21 := 6;

      if Token_Pos_250 /= No_Token_Index then

         Row_Pos_184 := Token_Pos_250;

      else
         Row_Pos_184 := No_Token_Index;
         goto Exit_Row_177_0;

      end if;

--  Start opt_code

--  Start transform_code

--  Start row_code

      Row_Pos_185 := Row_Pos_184;

      Defer_Res_311 := Identifier_Transform_Parse_0 (Parser, Row_Pos_185);
      Defer_Pos_311 := Parser.Current_Pos;

      if Defer_Pos_311 /= No_Token_Index then

         Row_Pos_185 := Defer_Pos_311;

      else
         Row_Pos_185 := No_Token_Index;
         goto Exit_Row_178_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_178_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_185 /= No_Token_Index then

         Transform_Res_157 := Allocate_End_Name (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_157, Kind => Ada_End_Name,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_184,
            Token_End_Index =>
              (if Row_Pos_185 = Row_Pos_184 then No_Token_Index
               else Row_Pos_185 - 1));

         Initialize_Fields_For_End_Name
           (Self => Transform_Res_157, End_Name_F_Name => Defer_Res_311);

         if Defer_Res_311 /= null and then Is_Incomplete (Defer_Res_311) then
            Transform_Res_157.Last_Attempted_Child := 0;
         elsif Defer_Res_311 /= null and then not Is_Ghost (Defer_Res_311) then
            Transform_Res_157.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_185 = No_Token_Index then

         Transform_Res_157 := No_Bare_Ada_Node;

         Row_Pos_185 := Row_Pos_184;

      end if;

--  End opt_code

      Row_Progress_21 := 7;

      if Row_Pos_185 /= No_Token_Index then

         Row_Pos_184 := Row_Pos_185;

      else
         Row_Pos_184 := No_Token_Index;
         goto Exit_Row_177_0;

      end if;

--  Start tok_code

      Token_Res_251 := Row_Pos_184;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_251));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_251 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_184 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_184,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_251 := Row_Pos_184 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_21 := 8;

      if Token_Pos_251 /= No_Token_Index then

         Row_Pos_184 := Token_Pos_251;

      else
         Row_Pos_184 := No_Token_Index;
         goto Exit_Row_177_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_177_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_184 = No_Token_Index and then Nobt_20 then
         Row_Pos_184             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_21 := True;
      end if;

      if Row_Pos_184 /= No_Token_Index then

         Transform_Res_158 := Allocate_Loop_Stmt (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_158, Kind => Ada_Loop_Stmt,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_184 = Pos then No_Token_Index else Row_Pos_184 - 1));

         Initialize_Fields_For_Loop_Stmt
           (Self => Transform_Res_158, Base_Loop_Stmt_F_Spec => Null_Res_9,
            Base_Loop_Stmt_F_Stmts    => Defer_Res_310,
            Base_Loop_Stmt_F_End_Name => Transform_Res_157);

         if Null_Res_9 /= null and then Is_Incomplete (Null_Res_9) then
            Transform_Res_158.Last_Attempted_Child := 0;
         elsif Null_Res_9 /= null and then not Is_Ghost (Null_Res_9) then
            Transform_Res_158.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_310 /= null and then Is_Incomplete (Defer_Res_310) then
            Transform_Res_158.Last_Attempted_Child := 0;
         elsif Defer_Res_310 /= null and then not Is_Ghost (Defer_Res_310) then
            Transform_Res_158.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_157 /= null
           and then Is_Incomplete (Transform_Res_157)
         then
            Transform_Res_158.Last_Attempted_Child := 0;
         elsif Transform_Res_157 /= null
           and then not Is_Ghost (Transform_Res_157)
         then
            Transform_Res_158.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_21 then
            Transform_Res_158.Last_Attempted_Child := Row_Progress_21;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <iloop_stmt>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      if Row_Pos_184 /= No_Token_Index then
         Or_Pos_71 := Row_Pos_184;
         Or_Res_71 := Transform_Res_158;
         goto Exit_Or_70;
      end if;
      <<Exit_Or_70>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Iloop_Stmt_Or_Parse_0_Memo,
         Or_Pos_71 /= No_Token_Index, Or_Res_71, Pos, Or_Pos_71);

      Parser.Current_Pos := Or_Pos_71;

      return Or_Res_71;
   end Iloop_Stmt_Or_Parse_0;

   function Loop_Stmt_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Composite_Stmt
   is
      use Bare_Composite_Stmt_Memos;

      Defer_Pos_301     : Token_Index          := No_Token_Index;
      Defer_Res_301     : Bare_Base_Loop_Stmt  := No_Bare_Ada_Node;
      Row_Pos_177       : Token_Index          := No_Token_Index;
      Row_Pos_178       : Token_Index          := No_Token_Index;
      Defer_Pos_302     : Token_Index          := No_Token_Index;
      Defer_Res_302     : Bare_Defining_Name   := No_Bare_Ada_Node;
      Transform_Res_150 : Bare_Named_Stmt_Decl := No_Bare_Ada_Node;
      Token_Pos_237     : Token_Index          := No_Token_Index;
      Token_Res_237     : Token_Index          := No_Token_Index;
      Defer_Pos_303     : Token_Index          := No_Token_Index;
      Defer_Res_303     : Bare_Base_Loop_Stmt  := No_Bare_Ada_Node;
      Transform_Res_151 : Bare_Named_Stmt      := No_Bare_Ada_Node;
      Or_Pos_70         : Token_Index          := No_Token_Index;
      Or_Res_70         : Bare_Composite_Stmt  := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Loop_Stmt_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_70          := M.Instance;
         return Or_Res_70;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_70;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_70 := No_Token_Index;
      Or_Res_70 := No_Bare_Ada_Node;

      Defer_Res_301 := Iloop_Stmt_Or_Parse_0 (Parser, Pos);
      Defer_Pos_301 := Parser.Current_Pos;

      if Defer_Pos_301 /= No_Token_Index then
         Or_Pos_70 := Defer_Pos_301;
         Or_Res_70 := Defer_Res_301;
         goto Exit_Or_69;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_177 := Pos;

--  Start transform_code

--  Start row_code

      Row_Pos_178 := Row_Pos_177;

      Defer_Res_302 := Defining_Id_Transform_Parse_0 (Parser, Row_Pos_178);
      Defer_Pos_302 := Parser.Current_Pos;

      if Defer_Pos_302 /= No_Token_Index then

         Row_Pos_178 := Defer_Pos_302;

      else
         Row_Pos_178 := No_Token_Index;
         goto Exit_Row_180_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_180_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_178 /= No_Token_Index then

         Transform_Res_150 := Allocate_Named_Stmt_Decl (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_150, Kind => Ada_Named_Stmt_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_177,
            Token_End_Index =>
              (if Row_Pos_178 = Row_Pos_177 then No_Token_Index
               else Row_Pos_178 - 1));

         Initialize_Fields_For_Named_Stmt_Decl
           (Self                   => Transform_Res_150,
            Named_Stmt_Decl_F_Name => Defer_Res_302);

         if Defer_Res_302 /= null and then Is_Incomplete (Defer_Res_302) then
            Transform_Res_150.Last_Attempted_Child := 0;
         elsif Defer_Res_302 /= null and then not Is_Ghost (Defer_Res_302) then
            Transform_Res_150.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_178 /= No_Token_Index then

         Row_Pos_177 := Row_Pos_178;

      else
         Row_Pos_177 := No_Token_Index;
         goto Exit_Row_179_0;

      end if;

--  Start tok_code

      Token_Res_237 := Row_Pos_177;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_237));
      begin
         if T.Kind /= From_Token_Kind (Ada_Colon) then
            Token_Pos_237 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_177 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_177,
                  Expected_Token_Id => Ada_Colon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_237 := Row_Pos_177 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_237 /= No_Token_Index then

         Row_Pos_177 := Token_Pos_237;

      else
         Row_Pos_177 := No_Token_Index;
         goto Exit_Row_179_0;

      end if;

      Defer_Res_303 := Iloop_Stmt_Or_Parse_0 (Parser, Row_Pos_177);
      Defer_Pos_303 := Parser.Current_Pos;

      if Defer_Pos_303 /= No_Token_Index then

         Row_Pos_177 := Defer_Pos_303;

      else
         Row_Pos_177 := No_Token_Index;
         goto Exit_Row_179_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_179_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_177 /= No_Token_Index then

         Transform_Res_151 := Allocate_Named_Stmt (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_151, Kind => Ada_Named_Stmt,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_177 = Pos then No_Token_Index else Row_Pos_177 - 1));

         Initialize_Fields_For_Named_Stmt
           (Self => Transform_Res_151, Named_Stmt_F_Decl => Transform_Res_150,
            Named_Stmt_F_Stmt => Defer_Res_303);

         if Transform_Res_150 /= null
           and then Is_Incomplete (Transform_Res_150)
         then
            Transform_Res_151.Last_Attempted_Child := 0;
         elsif Transform_Res_150 /= null
           and then not Is_Ghost (Transform_Res_150)
         then
            Transform_Res_151.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_303 /= null and then Is_Incomplete (Defer_Res_303) then
            Transform_Res_151.Last_Attempted_Child := 0;
         elsif Defer_Res_303 /= null and then not Is_Ghost (Defer_Res_303) then
            Transform_Res_151.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_177 /= No_Token_Index then
         Or_Pos_70 := Row_Pos_177;
         Or_Res_70 := Transform_Res_151;
         goto Exit_Or_69;
      end if;
      <<Exit_Or_69>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Loop_Stmt_Or_Parse_0_Memo,
         Or_Pos_70 /= No_Token_Index, Or_Res_70, Pos, Or_Pos_70);

      Parser.Current_Pos := Or_Pos_70;

      return Or_Res_70;
   end Loop_Stmt_Or_Parse_0;

   function Defining_Id_List_List_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Defining_Name_List
   is
      use Bare_Defining_Name_List_Memos;

      Lst_Cpos_22   : Token_Index             := No_Token_Index;
      Tmp_List_22   : Free_Parse_List;
      Defer_Pos_320 : Token_Index             := No_Token_Index;
      Defer_Res_320 : Bare_Defining_Name      := No_Bare_Ada_Node;
      Token_Pos_261 : Token_Index             := No_Token_Index;
      Token_Res_261 : Token_Index             := No_Token_Index;
      List_Pos_22   : Token_Index             := No_Token_Index;
      List_Res_22   : Bare_Defining_Name_List := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Defining_Id_List_List_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         List_Res_22        := M.Instance;
         return List_Res_22;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return List_Res_22;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start list_code

      List_Pos_22 := No_Token_Index;

      Lst_Cpos_22 := Pos;
      Tmp_List_22 := Get_Parse_List (Parser);

      loop

         Defer_Res_320 := Defining_Id_Transform_Parse_0 (Parser, Lst_Cpos_22);
         Defer_Pos_320 := Parser.Current_Pos;

         exit when Defer_Pos_320 = No_Token_Index;

         List_Pos_22 := Defer_Pos_320;
         Lst_Cpos_22 := List_Pos_22;

         Tmp_List_22.Nodes.Append (Defer_Res_320);

--  Start tok_code

         Token_Res_261 := Lst_Cpos_22;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_261));
         begin
            if T.Kind /= From_Token_Kind (Ada_Comma) then
               Token_Pos_261 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_22 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_22,
                     Expected_Token_Id => Ada_Comma,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_261 := Lst_Cpos_22 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_261 /= No_Token_Index then
            Lst_Cpos_22 := Token_Pos_261;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_22.Nodes.Length;
      begin
         List_Res_22 := Allocate_Defining_Name_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Pos;
            Token_End := (if Lst_Cpos_22 = Pos then Pos else Lst_Cpos_22 - 1);

         else
            Token_Start := Token_Index'Max (Pos, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self            => List_Res_22, Kind => Ada_Defining_Name_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_22, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_22.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_22.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_22);

--  End list_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Defining_Id_List_List_Parse_0_Memo,
         List_Pos_22 /= No_Token_Index, List_Res_22, Pos, List_Pos_22);

      Parser.Current_Pos := List_Pos_22;

      return List_Res_22;
   end Defining_Id_List_List_Parse_0;

   function Ext_Ret_Stmt_Object_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Extended_Return_Stmt_Object_Decl
   is
      use Bare_Extended_Return_Stmt_Object_Decl_Memos;

      Row_Pos_188       : Token_Index := No_Token_Index;
      Defer_Pos_314     : Token_Index := No_Token_Index;
      Defer_Res_314     : Bare_Defining_Name_List := No_Bare_Ada_Node;
      Token_Pos_257     : Token_Index := No_Token_Index;
      Token_Res_257     : Token_Index := No_Token_Index;
      Token_Pos_258     : Token_Index := No_Token_Index;
      Token_Res_258     : Token_Index := No_Token_Index;
      Opt_Res_11        : Bare_Aliased_Node := No_Bare_Ada_Node;
      Token_Pos_259     : Token_Index := No_Token_Index;
      Token_Res_259     : Token_Index := No_Token_Index;
      Opt_Res_12        : Bare_Constant_Node := No_Bare_Ada_Node;
      Defer_Pos_315     : Token_Index := No_Token_Index;
      Defer_Res_315     : Bare_Mode := No_Bare_Ada_Node;
      Defer_Pos_316     : Token_Index := No_Token_Index;
      Defer_Res_316     : Bare_Type_Expr := No_Bare_Ada_Node;
      Row_Pos_189       : Token_Index := No_Token_Index;
      Token_Pos_260     : Token_Index := No_Token_Index;
      Token_Res_260     : Token_Index := No_Token_Index;
      Defer_Pos_317     : Token_Index := No_Token_Index;
      Defer_Res_317     : Bare_Expr := No_Bare_Ada_Node;
      Defer_Pos_318     : Token_Index := No_Token_Index;
      Defer_Res_318     : Bare_Renaming_Clause := No_Bare_Ada_Node;
      Defer_Pos_319     : Token_Index := No_Token_Index;
      Defer_Res_319     : Bare_Aspect_Spec := No_Bare_Ada_Node;
      Transform_Res_160 : Bare_Extended_Return_Stmt_Object_Decl :=
        No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Ext_Ret_Stmt_Object_Decl_Transform_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_160  := M.Instance;
         return Transform_Res_160;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_160;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_188 := Pos;

      Defer_Res_314 := Defining_Id_List_List_Parse_0 (Parser, Row_Pos_188);
      Defer_Pos_314 := Parser.Current_Pos;

      if Defer_Pos_314 /= No_Token_Index then

         Row_Pos_188 := Defer_Pos_314;

      else
         Row_Pos_188 := No_Token_Index;
         goto Exit_Row_182_0;

      end if;

--  Start tok_code

      Token_Res_257 := Row_Pos_188;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_257));
      begin
         if T.Kind /= From_Token_Kind (Ada_Colon) then
            Token_Pos_257 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_188 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_188,
                  Expected_Token_Id => Ada_Colon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_257 := Row_Pos_188 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_257 /= No_Token_Index then

         Row_Pos_188 := Token_Pos_257;

      else
         Row_Pos_188 := No_Token_Index;
         goto Exit_Row_182_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_258 := Row_Pos_188;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_258));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol
               (Parser.TDH.Symbols, Precomputed_Symbol_Aliased)
         then
            Token_Pos_258 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_188 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_188,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_258 := Row_Pos_188 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_258 = No_Token_Index then

         Opt_Res_11 := Allocate_Aliased_Absent (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_11, Kind => Ada_Aliased_Absent,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_188,
            Token_End_Index => No_Token_Index);

         Token_Pos_258 := Row_Pos_188;

      else

         Opt_Res_11 := Allocate_Aliased_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_11, Kind => Ada_Aliased_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_188,
            Token_End_Index => Token_Pos_258 - 1);

      end if;

--  End opt_code

      if Token_Pos_258 /= No_Token_Index then

         Row_Pos_188 := Token_Pos_258;

      else
         Row_Pos_188 := No_Token_Index;
         goto Exit_Row_182_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_259 := Row_Pos_188;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_259));
      begin
         if T.Kind /= From_Token_Kind (Ada_Constant) then
            Token_Pos_259 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_188 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_188,
                  Expected_Token_Id => Ada_Constant,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_259 := Row_Pos_188 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_259 = No_Token_Index then

         Opt_Res_12 := Allocate_Constant_Absent (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_12, Kind => Ada_Constant_Absent,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_188,
            Token_End_Index => No_Token_Index);

         Token_Pos_259 := Row_Pos_188;

      else

         Opt_Res_12 := Allocate_Constant_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_12, Kind => Ada_Constant_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_188,
            Token_End_Index => Token_Pos_259 - 1);

      end if;

--  End opt_code

      if Token_Pos_259 /= No_Token_Index then

         Row_Pos_188 := Token_Pos_259;

      else
         Row_Pos_188 := No_Token_Index;
         goto Exit_Row_182_0;

      end if;

--  Start opt_code

      Defer_Res_315 := Mode_Or_Parse_0 (Parser, Row_Pos_188);
      Defer_Pos_315 := Parser.Current_Pos;

      if Defer_Pos_315 = No_Token_Index then

         Defer_Res_315 := No_Bare_Ada_Node;

         Defer_Pos_315 := Row_Pos_188;

      end if;

--  End opt_code

      if Defer_Pos_315 /= No_Token_Index then

         Row_Pos_188 := Defer_Pos_315;

      else
         Row_Pos_188 := No_Token_Index;
         goto Exit_Row_182_0;

      end if;

      Defer_Res_316 := Type_Expr_Or_Parse_0 (Parser, Row_Pos_188);
      Defer_Pos_316 := Parser.Current_Pos;

      if Defer_Pos_316 /= No_Token_Index then

         Row_Pos_188 := Defer_Pos_316;

      else
         Row_Pos_188 := No_Token_Index;
         goto Exit_Row_182_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_189 := Row_Pos_188;

--  Start tok_code

      Token_Res_260 := Row_Pos_189;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_260));
      begin
         if T.Kind /= From_Token_Kind (Ada_Assign) then
            Token_Pos_260 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_189 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_189,
                  Expected_Token_Id => Ada_Assign,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_260 := Row_Pos_189 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_260 /= No_Token_Index then

         Row_Pos_189 := Token_Pos_260;

      else
         Row_Pos_189 := No_Token_Index;
         goto Exit_Row_183_0;

      end if;

      Defer_Res_317 := Expr_Or_Parse_0 (Parser, Row_Pos_189);
      Defer_Pos_317 := Parser.Current_Pos;

      if Defer_Pos_317 /= No_Token_Index then

         Row_Pos_189 := Defer_Pos_317;

      else
         Row_Pos_189 := No_Token_Index;
         goto Exit_Row_183_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_183_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_189 = No_Token_Index then

         Defer_Res_317 := No_Bare_Ada_Node;

         Row_Pos_189 := Row_Pos_188;

      end if;

--  End opt_code

      if Row_Pos_189 /= No_Token_Index then

         Row_Pos_188 := Row_Pos_189;

      else
         Row_Pos_188 := No_Token_Index;
         goto Exit_Row_182_0;

      end if;

--  Start opt_code

      Defer_Res_318 := Renaming_Clause_Transform_Parse_0 (Parser, Row_Pos_188);
      Defer_Pos_318 := Parser.Current_Pos;

      if Defer_Pos_318 = No_Token_Index then

         Defer_Res_318 := No_Bare_Ada_Node;

         Defer_Pos_318 := Row_Pos_188;

      end if;

--  End opt_code

      if Defer_Pos_318 /= No_Token_Index then

         Row_Pos_188 := Defer_Pos_318;

      else
         Row_Pos_188 := No_Token_Index;
         goto Exit_Row_182_0;

      end if;

      Defer_Res_319 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_188);
      Defer_Pos_319 := Parser.Current_Pos;

      if Defer_Pos_319 /= No_Token_Index then

         Row_Pos_188 := Defer_Pos_319;

      else
         Row_Pos_188 := No_Token_Index;
         goto Exit_Row_182_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_182_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_188 /= No_Token_Index then

         Transform_Res_160 :=
           Allocate_Extended_Return_Stmt_Object_Decl (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_160,
            Kind => Ada_Extended_Return_Stmt_Object_Decl, Unit => Parser.Unit,

            Token_Start_Index => Pos,
            Token_End_Index   =>
              (if Row_Pos_188 = Pos then No_Token_Index else Row_Pos_188 - 1));

         Initialize_Fields_For_Extended_Return_Stmt_Object_Decl
           (Self => Transform_Res_160, Object_Decl_F_Ids => Defer_Res_314,
            Object_Decl_F_Has_Aliased     => Opt_Res_11,
            Object_Decl_F_Has_Constant    => Opt_Res_12,
            Object_Decl_F_Mode            => Defer_Res_315,
            Object_Decl_F_Type_Expr       => Defer_Res_316,
            Object_Decl_F_Default_Expr    => Defer_Res_317,
            Object_Decl_F_Renaming_Clause => Defer_Res_318,
            Object_Decl_F_Aspects         => Defer_Res_319);

         if Defer_Res_314 /= null and then Is_Incomplete (Defer_Res_314) then
            Transform_Res_160.Last_Attempted_Child := 0;
         elsif Defer_Res_314 /= null and then not Is_Ghost (Defer_Res_314) then
            Transform_Res_160.Last_Attempted_Child := -1;
         end if;
         if Opt_Res_11 /= null and then Is_Incomplete (Opt_Res_11) then
            Transform_Res_160.Last_Attempted_Child := 0;
         elsif Opt_Res_11 /= null and then not Is_Ghost (Opt_Res_11) then
            Transform_Res_160.Last_Attempted_Child := -1;
         end if;
         if Opt_Res_12 /= null and then Is_Incomplete (Opt_Res_12) then
            Transform_Res_160.Last_Attempted_Child := 0;
         elsif Opt_Res_12 /= null and then not Is_Ghost (Opt_Res_12) then
            Transform_Res_160.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_315 /= null and then Is_Incomplete (Defer_Res_315) then
            Transform_Res_160.Last_Attempted_Child := 0;
         elsif Defer_Res_315 /= null and then not Is_Ghost (Defer_Res_315) then
            Transform_Res_160.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_316 /= null and then Is_Incomplete (Defer_Res_316) then
            Transform_Res_160.Last_Attempted_Child := 0;
         elsif Defer_Res_316 /= null and then not Is_Ghost (Defer_Res_316) then
            Transform_Res_160.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_317 /= null and then Is_Incomplete (Defer_Res_317) then
            Transform_Res_160.Last_Attempted_Child := 0;
         elsif Defer_Res_317 /= null and then not Is_Ghost (Defer_Res_317) then
            Transform_Res_160.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_318 /= null and then Is_Incomplete (Defer_Res_318) then
            Transform_Res_160.Last_Attempted_Child := 0;
         elsif Defer_Res_318 /= null and then not Is_Ghost (Defer_Res_318) then
            Transform_Res_160.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_319 /= null and then Is_Incomplete (Defer_Res_319) then
            Transform_Res_160.Last_Attempted_Child := 0;
         elsif Defer_Res_319 /= null and then not Is_Ghost (Defer_Res_319) then
            Transform_Res_160.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Ext_Ret_Stmt_Object_Decl_Transform_Parse_0_Memo,
         Row_Pos_188 /= No_Token_Index, Transform_Res_160, Pos, Row_Pos_188);

      Parser.Current_Pos := Row_Pos_188;

      return Transform_Res_160;
   end Ext_Ret_Stmt_Object_Decl_Transform_Parse_0;

   function Ext_Return_Stmt_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Extended_Return_Stmt
   is
      use Bare_Extended_Return_Stmt_Memos;

      Nobt_21       : Boolean                               := False;
      Row_Pos_186   : Token_Index                           := No_Token_Index;
      Token_Pos_252 : Token_Index                           := No_Token_Index;
      Token_Res_252 : Token_Index                           := No_Token_Index;
      Defer_Pos_312 : Token_Index                           := No_Token_Index;
      Defer_Res_312 : Bare_Extended_Return_Stmt_Object_Decl :=
        No_Bare_Ada_Node;
      Row_Pos_187             : Token_Index               := No_Token_Index;
      Token_Pos_253           : Token_Index               := No_Token_Index;
      Token_Res_253           : Token_Index               := No_Token_Index;
      Defer_Pos_313           : Token_Index               := No_Token_Index;
      Defer_Res_313           : Bare_Handled_Stmts        := No_Bare_Ada_Node;
      Token_Pos_254           : Token_Index               := No_Token_Index;
      Token_Res_254           : Token_Index               := No_Token_Index;
      Token_Pos_255           : Token_Index               := No_Token_Index;
      Token_Res_255           : Token_Index               := No_Token_Index;
      Token_Pos_256           : Token_Index               := No_Token_Index;
      Token_Res_256           : Token_Index               := No_Token_Index;
      Row_Progress_22         : Integer                   := 0;
      Transform_Res_159       : Bare_Extended_Return_Stmt := No_Bare_Ada_Node;
      Transform_Has_Failed_22 : Boolean                   := False;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Ext_Return_Stmt_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_159  := M.Instance;
         return Transform_Res_159;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_159;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_186 := Pos;

--  Start tok_code

      Token_Res_252 := Row_Pos_186;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_252));
      begin
         if T.Kind /= From_Token_Kind (Ada_Return) then
            Token_Pos_252 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_186 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_186,
                  Expected_Token_Id => Ada_Return,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_252 := Row_Pos_186 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_22 := 1;

      if Token_Pos_252 /= No_Token_Index then

         Row_Pos_186 := Token_Pos_252;

      else
         Row_Pos_186 := No_Token_Index;
         goto Exit_Row_181_0;

      end if;

      Defer_Res_312 :=
        Ext_Ret_Stmt_Object_Decl_Transform_Parse_0 (Parser, Row_Pos_186);
      Defer_Pos_312 := Parser.Current_Pos;

      Row_Progress_22 := 2;

      if Defer_Pos_312 /= No_Token_Index then

         Row_Pos_186 := Defer_Pos_312;

      else
         Row_Pos_186 := No_Token_Index;
         goto Exit_Row_181_0;

      end if;

      Nobt_21 := True;

      Row_Progress_22 := 3;

      if Row_Pos_186 /= No_Token_Index then

         Row_Pos_186 := Row_Pos_186;

      else
         Row_Pos_186 := No_Token_Index;
         goto Exit_Row_181_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_187 := Row_Pos_186;

--  Start tok_code

      Token_Res_253 := Row_Pos_187;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_253));
      begin
         if T.Kind /= From_Token_Kind (Ada_Do) then
            Token_Pos_253 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_187 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_187,
                  Expected_Token_Id => Ada_Do,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_253 := Row_Pos_187 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_253 /= No_Token_Index then

         Row_Pos_187 := Token_Pos_253;

      else
         Row_Pos_187 := No_Token_Index;
         goto Exit_Row_184_0;

      end if;

      Defer_Res_313 := Handled_Stmts_Transform_Parse_0 (Parser, Row_Pos_187);
      Defer_Pos_313 := Parser.Current_Pos;

      if Defer_Pos_313 /= No_Token_Index then

         Row_Pos_187 := Defer_Pos_313;

      else
         Row_Pos_187 := No_Token_Index;
         goto Exit_Row_184_0;

      end if;

--  Start tok_code

      Token_Res_254 := Row_Pos_187;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_254));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_254 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_187 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_187,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_254 := Row_Pos_187 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_254 /= No_Token_Index then

         Row_Pos_187 := Token_Pos_254;

      else
         Row_Pos_187 := No_Token_Index;
         goto Exit_Row_184_0;

      end if;

--  Start tok_code

      Token_Res_255 := Row_Pos_187;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_255));
      begin
         if T.Kind /= From_Token_Kind (Ada_Return) then
            Token_Pos_255 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_187 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_187,
                  Expected_Token_Id => Ada_Return,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_255 := Row_Pos_187 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_255 /= No_Token_Index then

         Row_Pos_187 := Token_Pos_255;

      else
         Row_Pos_187 := No_Token_Index;
         goto Exit_Row_184_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_184_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_187 = No_Token_Index then

         Defer_Res_313 := No_Bare_Ada_Node;

         Row_Pos_187 := Row_Pos_186;

      end if;

--  End opt_code

      Row_Progress_22 := 4;

      if Row_Pos_187 /= No_Token_Index then

         Row_Pos_186 := Row_Pos_187;

      else
         Row_Pos_186 := No_Token_Index;
         goto Exit_Row_181_0;

      end if;

--  Start tok_code

      Token_Res_256 := Row_Pos_186;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_256));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_256 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_186 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_186,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_256 := Row_Pos_186 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_22 := 5;

      if Token_Pos_256 /= No_Token_Index then

         Row_Pos_186 := Token_Pos_256;

      else
         Row_Pos_186 := No_Token_Index;
         goto Exit_Row_181_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_181_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_186 = No_Token_Index and then Nobt_21 then
         Row_Pos_186             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_22 := True;
      end if;

      if Row_Pos_186 /= No_Token_Index then

         Transform_Res_159 := Allocate_Extended_Return_Stmt (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_159, Kind => Ada_Extended_Return_Stmt,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_186 = Pos then No_Token_Index else Row_Pos_186 - 1));

         Initialize_Fields_For_Extended_Return_Stmt
           (Self                         => Transform_Res_159,
            Extended_Return_Stmt_F_Decl  => Defer_Res_312,
            Extended_Return_Stmt_F_Stmts => Defer_Res_313);

         if Defer_Res_312 /= null and then Is_Incomplete (Defer_Res_312) then
            Transform_Res_159.Last_Attempted_Child := 0;
         elsif Defer_Res_312 /= null and then not Is_Ghost (Defer_Res_312) then
            Transform_Res_159.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_313 /= null and then Is_Incomplete (Defer_Res_313) then
            Transform_Res_159.Last_Attempted_Child := 0;
         elsif Defer_Res_313 /= null and then not Is_Ghost (Defer_Res_313) then
            Transform_Res_159.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_22 then
            Transform_Res_159.Last_Attempted_Child := Row_Progress_22;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <ext_return_stmt>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Ext_Return_Stmt_Transform_Parse_0_Memo,
         Row_Pos_186 /= No_Token_Index, Transform_Res_159, Pos, Row_Pos_186);

      Parser.Current_Pos := Row_Pos_186;

      return Transform_Res_159;
   end Ext_Return_Stmt_Transform_Parse_0;

   function Case_Alt_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Case_Stmt_Alternative
   is
      use Bare_Case_Stmt_Alternative_Memos;

      Row_Pos_191       : Token_Index                := No_Token_Index;
      Token_Pos_267     : Token_Index                := No_Token_Index;
      Token_Res_267     : Token_Index                := No_Token_Index;
      Defer_Pos_323     : Token_Index                := No_Token_Index;
      Defer_Res_323     : Bare_Alternatives_List     := No_Bare_Ada_Node;
      Token_Pos_268     : Token_Index                := No_Token_Index;
      Token_Res_268     : Token_Index                := No_Token_Index;
      Defer_Pos_324     : Token_Index                := No_Token_Index;
      Defer_Res_324     : Bare_Stmt_List             := No_Bare_Ada_Node;
      Transform_Res_162 : Bare_Case_Stmt_Alternative := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Case_Alt_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_162  := M.Instance;
         return Transform_Res_162;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_162;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_191 := Pos;

--  Start tok_code

      Token_Res_267 := Row_Pos_191;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_267));
      begin
         if T.Kind /= From_Token_Kind (Ada_When) then
            Token_Pos_267 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_191 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_191,
                  Expected_Token_Id => Ada_When,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_267 := Row_Pos_191 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_267 /= No_Token_Index then

         Row_Pos_191 := Token_Pos_267;

      else
         Row_Pos_191 := No_Token_Index;
         goto Exit_Row_186_0;

      end if;

      Defer_Res_323 := Choice_List_List_Parse_0 (Parser, Row_Pos_191);
      Defer_Pos_323 := Parser.Current_Pos;

      if Defer_Pos_323 /= No_Token_Index then

         Row_Pos_191 := Defer_Pos_323;

      else
         Row_Pos_191 := No_Token_Index;
         goto Exit_Row_186_0;

      end if;

--  Start tok_code

      Token_Res_268 := Row_Pos_191;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_268));
      begin
         if T.Kind /= From_Token_Kind (Ada_Arrow) then
            Token_Pos_268 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_191 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_191,
                  Expected_Token_Id => Ada_Arrow,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_268 := Row_Pos_191 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_268 /= No_Token_Index then

         Row_Pos_191 := Token_Pos_268;

      else
         Row_Pos_191 := No_Token_Index;
         goto Exit_Row_186_0;

      end if;

      Parser.Private_Part.Dont_Skip.Append
        (Dontskip_Case_Alt_0_Extract_Parse_0'Access);

      Defer_Res_324 := Stmts_List_Parse_0 (Parser, Row_Pos_191);
      Defer_Pos_324 := Parser.Current_Pos;

      Parser.Private_Part.Dont_Skip.Delete_Last;

      if Defer_Pos_324 /= No_Token_Index then

         Row_Pos_191 := Defer_Pos_324;

      else
         Row_Pos_191 := No_Token_Index;
         goto Exit_Row_186_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_186_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_191 /= No_Token_Index then

         Transform_Res_162 := Allocate_Case_Stmt_Alternative (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_162, Kind => Ada_Case_Stmt_Alternative,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_191 = Pos then No_Token_Index else Row_Pos_191 - 1));

         Initialize_Fields_For_Case_Stmt_Alternative
           (Self                            => Transform_Res_162,
            Case_Stmt_Alternative_F_Choices => Defer_Res_323,
            Case_Stmt_Alternative_F_Stmts   => Defer_Res_324);

         if Defer_Res_323 /= null and then Is_Incomplete (Defer_Res_323) then
            Transform_Res_162.Last_Attempted_Child := 0;
         elsif Defer_Res_323 /= null and then not Is_Ghost (Defer_Res_323) then
            Transform_Res_162.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_324 /= null and then Is_Incomplete (Defer_Res_324) then
            Transform_Res_162.Last_Attempted_Child := 0;
         elsif Defer_Res_324 /= null and then not Is_Ghost (Defer_Res_324) then
            Transform_Res_162.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Case_Alt_Transform_Parse_0_Memo,
         Row_Pos_191 /= No_Token_Index, Transform_Res_162, Pos, Row_Pos_191);

      Parser.Current_Pos := Row_Pos_191;

      return Transform_Res_162;
   end Case_Alt_Transform_Parse_0;

   function Case_Stmt_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Case_Stmt
   is
      use Bare_Case_Stmt_Memos;

      Nobt_22                 : Boolean                         := False;
      Row_Pos_190             : Token_Index := No_Token_Index;
      Token_Pos_262           : Token_Index := No_Token_Index;
      Token_Res_262           : Token_Index := No_Token_Index;
      Defer_Pos_321           : Token_Index := No_Token_Index;
      Defer_Res_321           : Bare_Expr := No_Bare_Ada_Node;
      Token_Pos_263           : Token_Index := No_Token_Index;
      Token_Res_263           : Token_Index := No_Token_Index;
      Lst_Cpos_23             : Token_Index := No_Token_Index;
      Tmp_List_23             : Free_Parse_List;
      Defer_Pos_322           : Token_Index := No_Token_Index;
      Defer_Res_322           : Bare_Case_Stmt_Alternative := No_Bare_Ada_Node;
      List_Pos_23             : Token_Index := No_Token_Index;
      List_Res_23 : Bare_Case_Stmt_Alternative_List := No_Bare_Ada_Node;
      Token_Pos_264           : Token_Index := No_Token_Index;
      Token_Res_264           : Token_Index := No_Token_Index;
      Token_Pos_265           : Token_Index := No_Token_Index;
      Token_Res_265           : Token_Index := No_Token_Index;
      Token_Pos_266           : Token_Index := No_Token_Index;
      Token_Res_266           : Token_Index := No_Token_Index;
      Row_Progress_23         : Integer                         := 0;
      Transform_Res_161       : Bare_Case_Stmt := No_Bare_Ada_Node;
      Transform_Has_Failed_23 : Boolean                         := False;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Case_Stmt_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_161  := M.Instance;
         return Transform_Res_161;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_161;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_190 := Pos;

--  Start tok_code

      Token_Res_262 := Row_Pos_190;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_262));
      begin
         if T.Kind /= From_Token_Kind (Ada_Case) then
            Token_Pos_262 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_190 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_190,
                  Expected_Token_Id => Ada_Case,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_262 := Row_Pos_190 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_23 := 1;

      if Token_Pos_262 /= No_Token_Index then

         Row_Pos_190 := Token_Pos_262;

      else
         Row_Pos_190 := No_Token_Index;
         goto Exit_Row_185_0;

      end if;

      Nobt_22 := True;

      Row_Progress_23 := 2;

      if Row_Pos_190 /= No_Token_Index then

         Row_Pos_190 := Row_Pos_190;

      else
         Row_Pos_190 := No_Token_Index;
         goto Exit_Row_185_0;

      end if;

      Defer_Res_321 := Expr_Or_Parse_0 (Parser, Row_Pos_190);
      Defer_Pos_321 := Parser.Current_Pos;

      Row_Progress_23 := 3;

      if Defer_Pos_321 /= No_Token_Index then

         Row_Pos_190 := Defer_Pos_321;

      else
         Row_Pos_190 := No_Token_Index;
         goto Exit_Row_185_0;

      end if;

--  Start tok_code

      Token_Res_263 := Row_Pos_190;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_263));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_263 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_190 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_190,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_263 := Row_Pos_190 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_23 := 4;

      if Token_Pos_263 /= No_Token_Index then

         Row_Pos_190 := Token_Pos_263;

      else
         Row_Pos_190 := No_Token_Index;
         goto Exit_Row_185_0;

      end if;

--  Start list_code

      List_Pos_23 := No_Token_Index;

      Lst_Cpos_23 := Row_Pos_190;
      Tmp_List_23 := Get_Parse_List (Parser);

      loop

         Defer_Res_322 := Case_Alt_Transform_Parse_0 (Parser, Lst_Cpos_23);
         Defer_Pos_322 := Parser.Current_Pos;

         exit when Defer_Pos_322 = No_Token_Index;

         List_Pos_23 := Defer_Pos_322;
         Lst_Cpos_23 := List_Pos_23;

         Tmp_List_23.Nodes.Append (Defer_Res_322);

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_23.Nodes.Length;
      begin
         List_Res_23 := Allocate_Case_Stmt_Alternative_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_190;
            Token_End   :=
              (if Lst_Cpos_23 = Row_Pos_190 then Row_Pos_190
               else Lst_Cpos_23 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_190, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self => List_Res_23, Kind => Ada_Case_Stmt_Alternative_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_23, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_23.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_23.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_23);

--  End list_code

      Row_Progress_23 := 5;

      if List_Pos_23 /= No_Token_Index then

         Row_Pos_190 := List_Pos_23;

      else
         Row_Pos_190 := No_Token_Index;
         goto Exit_Row_185_0;

      end if;

--  Start tok_code

      Token_Res_264 := Row_Pos_190;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_264));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_264 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_190 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_190,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_264 := Row_Pos_190 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_23 := 6;

      if Token_Pos_264 /= No_Token_Index then

         Row_Pos_190 := Token_Pos_264;

      else
         Row_Pos_190 := No_Token_Index;
         goto Exit_Row_185_0;

      end if;

--  Start tok_code

      Token_Res_265 := Row_Pos_190;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_265));
      begin
         if T.Kind /= From_Token_Kind (Ada_Case) then
            Token_Pos_265 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_190 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_190,
                  Expected_Token_Id => Ada_Case,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_265 := Row_Pos_190 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_23 := 7;

      if Token_Pos_265 /= No_Token_Index then

         Row_Pos_190 := Token_Pos_265;

      else
         Row_Pos_190 := No_Token_Index;
         goto Exit_Row_185_0;

      end if;

--  Start tok_code

      Token_Res_266 := Row_Pos_190;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_266));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_266 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_190 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_190,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_266 := Row_Pos_190 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_23 := 8;

      if Token_Pos_266 /= No_Token_Index then

         Row_Pos_190 := Token_Pos_266;

      else
         Row_Pos_190 := No_Token_Index;
         goto Exit_Row_185_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_185_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_190 = No_Token_Index and then Nobt_22 then
         Row_Pos_190             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_23 := True;
      end if;

      if Row_Pos_190 /= No_Token_Index then

         Transform_Res_161 := Allocate_Case_Stmt (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_161, Kind => Ada_Case_Stmt,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_190 = Pos then No_Token_Index else Row_Pos_190 - 1));

         Initialize_Fields_For_Case_Stmt
           (Self => Transform_Res_161, Case_Stmt_F_Expr => Defer_Res_321,
            Case_Stmt_F_Alternatives => List_Res_23);

         if Defer_Res_321 /= null and then Is_Incomplete (Defer_Res_321) then
            Transform_Res_161.Last_Attempted_Child := 0;
         elsif Defer_Res_321 /= null and then not Is_Ghost (Defer_Res_321) then
            Transform_Res_161.Last_Attempted_Child := -1;
         end if;
         if List_Res_23 /= null and then Is_Incomplete (List_Res_23) then
            Transform_Res_161.Last_Attempted_Child := 0;
         elsif List_Res_23 /= null and then not Is_Ghost (List_Res_23) then
            Transform_Res_161.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_23 then
            Transform_Res_161.Last_Attempted_Child := Row_Progress_23;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <case_stmt>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Case_Stmt_Transform_Parse_0_Memo,
         Row_Pos_190 /= No_Token_Index, Transform_Res_161, Pos, Row_Pos_190);

      Parser.Current_Pos := Row_Pos_190;

      return Transform_Res_161;
   end Case_Stmt_Transform_Parse_0;

   function Accept_Stmt_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Accept_Stmt
   is
      use Bare_Accept_Stmt_Memos;

      Row_Pos_192       : Token_Index := No_Token_Index;
      Token_Pos_269     : Token_Index := No_Token_Index;
      Token_Res_269     : Token_Index := No_Token_Index;
      Defer_Pos_325     : Token_Index := No_Token_Index;
      Defer_Res_325     : Bare_Identifier := No_Bare_Ada_Node;
      Row_Pos_193       : Token_Index := No_Token_Index;
      Token_Pos_270     : Token_Index := No_Token_Index;
      Token_Res_270     : Token_Index := No_Token_Index;
      Defer_Pos_326     : Token_Index := No_Token_Index;
      Defer_Res_326     : Bare_Expr := No_Bare_Ada_Node;
      Token_Pos_271     : Token_Index := No_Token_Index;
      Token_Res_271     : Token_Index := No_Token_Index;
      Row_Pos_194       : Token_Index := No_Token_Index;
      Defer_Pos_327     : Token_Index := No_Token_Index;
      Defer_Res_327     : Bare_Params := No_Bare_Ada_Node;
      Transform_Res_163 : Bare_Entry_Completion_Formal_Params :=
        No_Bare_Ada_Node;
      Token_Pos_272     : Token_Index := No_Token_Index;
      Token_Res_272     : Token_Index := No_Token_Index;
      Transform_Res_164 : Bare_Accept_Stmt := No_Bare_Ada_Node;
      Row_Pos_195       : Token_Index := No_Token_Index;
      Token_Pos_273     : Token_Index := No_Token_Index;
      Token_Res_273     : Token_Index := No_Token_Index;
      Defer_Pos_328     : Token_Index := No_Token_Index;
      Defer_Res_328     : Bare_Identifier := No_Bare_Ada_Node;
      Row_Pos_196       : Token_Index := No_Token_Index;
      Token_Pos_274     : Token_Index := No_Token_Index;
      Token_Res_274     : Token_Index := No_Token_Index;
      Defer_Pos_329     : Token_Index := No_Token_Index;
      Defer_Res_329     : Bare_Expr := No_Bare_Ada_Node;
      Token_Pos_275     : Token_Index := No_Token_Index;
      Token_Res_275     : Token_Index := No_Token_Index;
      Row_Pos_197       : Token_Index := No_Token_Index;
      Defer_Pos_330     : Token_Index := No_Token_Index;
      Defer_Res_330     : Bare_Params := No_Bare_Ada_Node;
      Transform_Res_165 : Bare_Entry_Completion_Formal_Params :=
        No_Bare_Ada_Node;
      Token_Pos_276     : Token_Index                 := No_Token_Index;
      Token_Res_276     : Token_Index                 := No_Token_Index;
      Defer_Pos_331     : Token_Index                 := No_Token_Index;
      Defer_Res_331     : Bare_Handled_Stmts          := No_Bare_Ada_Node;
      Row_Pos_198       : Token_Index                 := No_Token_Index;
      Token_Pos_277     : Token_Index                 := No_Token_Index;
      Token_Res_277     : Token_Index                 := No_Token_Index;
      Row_Pos_199       : Token_Index                 := No_Token_Index;
      Defer_Pos_332     : Token_Index                 := No_Token_Index;
      Defer_Res_332     : Bare_Identifier             := No_Bare_Ada_Node;
      Transform_Res_166 : Bare_End_Name               := No_Bare_Ada_Node;
      Token_Pos_278     : Token_Index                 := No_Token_Index;
      Token_Res_278     : Token_Index                 := No_Token_Index;
      Transform_Res_167 : Bare_Accept_Stmt_With_Stmts := No_Bare_Ada_Node;
      Or_Pos_72         : Token_Index                 := No_Token_Index;
      Or_Res_72         : Bare_Accept_Stmt            := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Accept_Stmt_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_72          := M.Instance;
         return Or_Res_72;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_72;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_72 := No_Token_Index;
      Or_Res_72 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_192 := Pos;

--  Start tok_code

      Token_Res_269 := Row_Pos_192;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_269));
      begin
         if T.Kind /= From_Token_Kind (Ada_Accept) then
            Token_Pos_269 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_192 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_192,
                  Expected_Token_Id => Ada_Accept,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_269 := Row_Pos_192 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_269 /= No_Token_Index then

         Row_Pos_192 := Token_Pos_269;

      else
         Row_Pos_192 := No_Token_Index;
         goto Exit_Row_187_0;

      end if;

      Defer_Res_325 := Identifier_Transform_Parse_0 (Parser, Row_Pos_192);
      Defer_Pos_325 := Parser.Current_Pos;

      if Defer_Pos_325 /= No_Token_Index then

         Row_Pos_192 := Defer_Pos_325;

      else
         Row_Pos_192 := No_Token_Index;
         goto Exit_Row_187_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_193 := Row_Pos_192;

--  Start tok_code

      Token_Res_270 := Row_Pos_193;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_270));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Open) then
            Token_Pos_270 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_193 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_193,
                  Expected_Token_Id => Ada_Par_Open,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_270 := Row_Pos_193 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_270 /= No_Token_Index then

         Row_Pos_193 := Token_Pos_270;

      else
         Row_Pos_193 := No_Token_Index;
         goto Exit_Row_188_0;

      end if;

      Defer_Res_326 := Expr_Or_Parse_0 (Parser, Row_Pos_193);
      Defer_Pos_326 := Parser.Current_Pos;

      if Defer_Pos_326 /= No_Token_Index then

         Row_Pos_193 := Defer_Pos_326;

      else
         Row_Pos_193 := No_Token_Index;
         goto Exit_Row_188_0;

      end if;

--  Start tok_code

      Token_Res_271 := Row_Pos_193;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_271));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Close) then
            Token_Pos_271 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_193 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_193,
                  Expected_Token_Id => Ada_Par_Close,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_271 := Row_Pos_193 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_271 /= No_Token_Index then

         Row_Pos_193 := Token_Pos_271;

      else
         Row_Pos_193 := No_Token_Index;
         goto Exit_Row_188_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_188_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_193 = No_Token_Index then

         Defer_Res_326 := No_Bare_Ada_Node;

         Row_Pos_193 := Row_Pos_192;

      end if;

--  End opt_code

      if Row_Pos_193 /= No_Token_Index then

         Row_Pos_192 := Row_Pos_193;

      else
         Row_Pos_192 := No_Token_Index;
         goto Exit_Row_187_0;

      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_194 := Row_Pos_192;

--  Start opt_code

      Defer_Res_327 := Param_Specs_Transform_Parse_0 (Parser, Row_Pos_194);
      Defer_Pos_327 := Parser.Current_Pos;

      if Defer_Pos_327 = No_Token_Index then

         Defer_Res_327 := No_Bare_Ada_Node;

         Defer_Pos_327 := Row_Pos_194;

      end if;

--  End opt_code

      if Defer_Pos_327 /= No_Token_Index then

         Row_Pos_194 := Defer_Pos_327;

      else
         Row_Pos_194 := No_Token_Index;
         goto Exit_Row_189_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_189_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_194 /= No_Token_Index then

         Transform_Res_163 :=
           Allocate_Entry_Completion_Formal_Params (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_163,
            Kind => Ada_Entry_Completion_Formal_Params, Unit => Parser.Unit,

            Token_Start_Index => Row_Pos_192,
            Token_End_Index   =>
              (if Row_Pos_194 = Row_Pos_192 then No_Token_Index
               else Row_Pos_194 - 1));

         Initialize_Fields_For_Entry_Completion_Formal_Params
           (Self                                    => Transform_Res_163,
            Entry_Completion_Formal_Params_F_Params => Defer_Res_327);

         if Defer_Res_327 /= null and then Is_Incomplete (Defer_Res_327) then
            Transform_Res_163.Last_Attempted_Child := 0;
         elsif Defer_Res_327 /= null and then not Is_Ghost (Defer_Res_327) then
            Transform_Res_163.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_194 /= No_Token_Index then

         Row_Pos_192 := Row_Pos_194;

      else
         Row_Pos_192 := No_Token_Index;
         goto Exit_Row_187_0;

      end if;

--  Start tok_code

      Token_Res_272 := Row_Pos_192;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_272));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_272 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_192 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_192,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_272 := Row_Pos_192 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_272 /= No_Token_Index then

         Row_Pos_192 := Token_Pos_272;

      else
         Row_Pos_192 := No_Token_Index;
         goto Exit_Row_187_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_187_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_192 /= No_Token_Index then

         Transform_Res_164 := Allocate_Accept_Stmt (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_164, Kind => Ada_Accept_Stmt,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_192 = Pos then No_Token_Index else Row_Pos_192 - 1));

         Initialize_Fields_For_Accept_Stmt
           (Self => Transform_Res_164, Accept_Stmt_F_Name => Defer_Res_325,
            Accept_Stmt_F_Entry_Index_Expr => Defer_Res_326,
            Accept_Stmt_F_Params           => Transform_Res_163);

         if Defer_Res_325 /= null and then Is_Incomplete (Defer_Res_325) then
            Transform_Res_164.Last_Attempted_Child := 0;
         elsif Defer_Res_325 /= null and then not Is_Ghost (Defer_Res_325) then
            Transform_Res_164.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_326 /= null and then Is_Incomplete (Defer_Res_326) then
            Transform_Res_164.Last_Attempted_Child := 0;
         elsif Defer_Res_326 /= null and then not Is_Ghost (Defer_Res_326) then
            Transform_Res_164.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_163 /= null
           and then Is_Incomplete (Transform_Res_163)
         then
            Transform_Res_164.Last_Attempted_Child := 0;
         elsif Transform_Res_163 /= null
           and then not Is_Ghost (Transform_Res_163)
         then
            Transform_Res_164.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_192 /= No_Token_Index then
         Or_Pos_72 := Row_Pos_192;
         Or_Res_72 := Transform_Res_164;
         goto Exit_Or_71;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_195 := Pos;

--  Start tok_code

      Token_Res_273 := Row_Pos_195;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_273));
      begin
         if T.Kind /= From_Token_Kind (Ada_Accept) then
            Token_Pos_273 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_195 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_195,
                  Expected_Token_Id => Ada_Accept,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_273 := Row_Pos_195 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_273 /= No_Token_Index then

         Row_Pos_195 := Token_Pos_273;

      else
         Row_Pos_195 := No_Token_Index;
         goto Exit_Row_190_0;

      end if;

      Defer_Res_328 := Identifier_Transform_Parse_0 (Parser, Row_Pos_195);
      Defer_Pos_328 := Parser.Current_Pos;

      if Defer_Pos_328 /= No_Token_Index then

         Row_Pos_195 := Defer_Pos_328;

      else
         Row_Pos_195 := No_Token_Index;
         goto Exit_Row_190_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_196 := Row_Pos_195;

--  Start tok_code

      Token_Res_274 := Row_Pos_196;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_274));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Open) then
            Token_Pos_274 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_196 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_196,
                  Expected_Token_Id => Ada_Par_Open,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_274 := Row_Pos_196 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_274 /= No_Token_Index then

         Row_Pos_196 := Token_Pos_274;

      else
         Row_Pos_196 := No_Token_Index;
         goto Exit_Row_191_0;

      end if;

      Defer_Res_329 := Expr_Or_Parse_0 (Parser, Row_Pos_196);
      Defer_Pos_329 := Parser.Current_Pos;

      if Defer_Pos_329 /= No_Token_Index then

         Row_Pos_196 := Defer_Pos_329;

      else
         Row_Pos_196 := No_Token_Index;
         goto Exit_Row_191_0;

      end if;

--  Start tok_code

      Token_Res_275 := Row_Pos_196;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_275));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Close) then
            Token_Pos_275 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_196 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_196,
                  Expected_Token_Id => Ada_Par_Close,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_275 := Row_Pos_196 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_275 /= No_Token_Index then

         Row_Pos_196 := Token_Pos_275;

      else
         Row_Pos_196 := No_Token_Index;
         goto Exit_Row_191_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_191_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_196 = No_Token_Index then

         Defer_Res_329 := No_Bare_Ada_Node;

         Row_Pos_196 := Row_Pos_195;

      end if;

--  End opt_code

      if Row_Pos_196 /= No_Token_Index then

         Row_Pos_195 := Row_Pos_196;

      else
         Row_Pos_195 := No_Token_Index;
         goto Exit_Row_190_0;

      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_197 := Row_Pos_195;

--  Start opt_code

      Defer_Res_330 := Param_Specs_Transform_Parse_0 (Parser, Row_Pos_197);
      Defer_Pos_330 := Parser.Current_Pos;

      if Defer_Pos_330 = No_Token_Index then

         Defer_Res_330 := No_Bare_Ada_Node;

         Defer_Pos_330 := Row_Pos_197;

      end if;

--  End opt_code

      if Defer_Pos_330 /= No_Token_Index then

         Row_Pos_197 := Defer_Pos_330;

      else
         Row_Pos_197 := No_Token_Index;
         goto Exit_Row_192_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_192_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_197 /= No_Token_Index then

         Transform_Res_165 :=
           Allocate_Entry_Completion_Formal_Params (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_165,
            Kind => Ada_Entry_Completion_Formal_Params, Unit => Parser.Unit,

            Token_Start_Index => Row_Pos_195,
            Token_End_Index   =>
              (if Row_Pos_197 = Row_Pos_195 then No_Token_Index
               else Row_Pos_197 - 1));

         Initialize_Fields_For_Entry_Completion_Formal_Params
           (Self                                    => Transform_Res_165,
            Entry_Completion_Formal_Params_F_Params => Defer_Res_330);

         if Defer_Res_330 /= null and then Is_Incomplete (Defer_Res_330) then
            Transform_Res_165.Last_Attempted_Child := 0;
         elsif Defer_Res_330 /= null and then not Is_Ghost (Defer_Res_330) then
            Transform_Res_165.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_197 /= No_Token_Index then

         Row_Pos_195 := Row_Pos_197;

      else
         Row_Pos_195 := No_Token_Index;
         goto Exit_Row_190_0;

      end if;

--  Start tok_code

      Token_Res_276 := Row_Pos_195;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_276));
      begin
         if T.Kind /= From_Token_Kind (Ada_Do) then
            Token_Pos_276 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_195 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_195,
                  Expected_Token_Id => Ada_Do,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_276 := Row_Pos_195 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_276 /= No_Token_Index then

         Row_Pos_195 := Token_Pos_276;

      else
         Row_Pos_195 := No_Token_Index;
         goto Exit_Row_190_0;

      end if;

      Defer_Res_331 := Handled_Stmts_Transform_Parse_0 (Parser, Row_Pos_195);
      Defer_Pos_331 := Parser.Current_Pos;

      if Defer_Pos_331 /= No_Token_Index then

         Row_Pos_195 := Defer_Pos_331;

      else
         Row_Pos_195 := No_Token_Index;
         goto Exit_Row_190_0;

      end if;

--  Start row_code

      Row_Pos_198 := Row_Pos_195;

--  Start tok_code

      Token_Res_277 := Row_Pos_198;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_277));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_277 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_198 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_198,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_277 := Row_Pos_198 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_277 /= No_Token_Index then

         Row_Pos_198 := Token_Pos_277;

      else
         Row_Pos_198 := No_Token_Index;
         goto Exit_Row_193_0;

      end if;

--  Start opt_code

--  Start transform_code

--  Start row_code

      Row_Pos_199 := Row_Pos_198;

      Defer_Res_332 := Identifier_Transform_Parse_0 (Parser, Row_Pos_199);
      Defer_Pos_332 := Parser.Current_Pos;

      if Defer_Pos_332 /= No_Token_Index then

         Row_Pos_199 := Defer_Pos_332;

      else
         Row_Pos_199 := No_Token_Index;
         goto Exit_Row_194_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_194_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_199 /= No_Token_Index then

         Transform_Res_166 := Allocate_End_Name (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_166, Kind => Ada_End_Name,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_198,
            Token_End_Index =>
              (if Row_Pos_199 = Row_Pos_198 then No_Token_Index
               else Row_Pos_199 - 1));

         Initialize_Fields_For_End_Name
           (Self => Transform_Res_166, End_Name_F_Name => Defer_Res_332);

         if Defer_Res_332 /= null and then Is_Incomplete (Defer_Res_332) then
            Transform_Res_166.Last_Attempted_Child := 0;
         elsif Defer_Res_332 /= null and then not Is_Ghost (Defer_Res_332) then
            Transform_Res_166.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_199 = No_Token_Index then

         Transform_Res_166 := No_Bare_Ada_Node;

         Row_Pos_199 := Row_Pos_198;

      end if;

--  End opt_code

      if Row_Pos_199 /= No_Token_Index then

         Row_Pos_198 := Row_Pos_199;

      else
         Row_Pos_198 := No_Token_Index;
         goto Exit_Row_193_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_193_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_198 /= No_Token_Index then

         Row_Pos_195 := Row_Pos_198;

      else
         Row_Pos_195 := No_Token_Index;
         goto Exit_Row_190_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_278 := Row_Pos_195;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_278));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_278 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_195 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_195,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_278 := Row_Pos_195 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_278 = No_Token_Index then

         Token_Res_278 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_195).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_278 := Row_Pos_195;

      end if;

--  End opt_code

      if Token_Pos_278 /= No_Token_Index then

         Row_Pos_195 := Token_Pos_278;

      else
         Row_Pos_195 := No_Token_Index;
         goto Exit_Row_190_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_190_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_195 /= No_Token_Index then

         Transform_Res_167 :=
           Allocate_Accept_Stmt_With_Stmts (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_167, Kind => Ada_Accept_Stmt_With_Stmts,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_195 = Pos then No_Token_Index else Row_Pos_195 - 1));

         Initialize_Fields_For_Accept_Stmt_With_Stmts
           (Self => Transform_Res_167, Accept_Stmt_F_Name => Defer_Res_328,
            Accept_Stmt_F_Entry_Index_Expr    => Defer_Res_329,
            Accept_Stmt_F_Params              => Transform_Res_165,
            Accept_Stmt_With_Stmts_F_Stmts    => Defer_Res_331,
            Accept_Stmt_With_Stmts_F_End_Name => Transform_Res_166);

         if Defer_Res_328 /= null and then Is_Incomplete (Defer_Res_328) then
            Transform_Res_167.Last_Attempted_Child := 0;
         elsif Defer_Res_328 /= null and then not Is_Ghost (Defer_Res_328) then
            Transform_Res_167.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_329 /= null and then Is_Incomplete (Defer_Res_329) then
            Transform_Res_167.Last_Attempted_Child := 0;
         elsif Defer_Res_329 /= null and then not Is_Ghost (Defer_Res_329) then
            Transform_Res_167.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_165 /= null
           and then Is_Incomplete (Transform_Res_165)
         then
            Transform_Res_167.Last_Attempted_Child := 0;
         elsif Transform_Res_165 /= null
           and then not Is_Ghost (Transform_Res_165)
         then
            Transform_Res_167.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_331 /= null and then Is_Incomplete (Defer_Res_331) then
            Transform_Res_167.Last_Attempted_Child := 0;
         elsif Defer_Res_331 /= null and then not Is_Ghost (Defer_Res_331) then
            Transform_Res_167.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_166 /= null
           and then Is_Incomplete (Transform_Res_166)
         then
            Transform_Res_167.Last_Attempted_Child := 0;
         elsif Transform_Res_166 /= null
           and then not Is_Ghost (Transform_Res_166)
         then
            Transform_Res_167.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_195 /= No_Token_Index then
         Or_Pos_72 := Row_Pos_195;
         Or_Res_72 := Transform_Res_167;
         goto Exit_Or_71;
      end if;
      <<Exit_Or_71>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Accept_Stmt_Or_Parse_0_Memo,
         Or_Pos_72 /= No_Token_Index, Or_Res_72, Pos, Or_Pos_72);

      Parser.Current_Pos := Or_Pos_72;

      return Or_Res_72;
   end Accept_Stmt_Or_Parse_0;

   function Select_Stmt_Transform_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Select_Stmt
   is
      use Bare_Select_Stmt_Memos;

      Nobt_23                 : Boolean                    := False;
      Row_Pos_200             : Token_Index                := No_Token_Index;
      Token_Pos_279           : Token_Index                := No_Token_Index;
      Token_Res_279           : Token_Index                := No_Token_Index;
      Lst_Cpos_24             : Token_Index                := No_Token_Index;
      Tmp_List_24             : Free_Parse_List;
      Row_Pos_201             : Token_Index                := No_Token_Index;
      Row_Pos_202             : Token_Index                := No_Token_Index;
      Token_Pos_280           : Token_Index                := No_Token_Index;
      Token_Res_280           : Token_Index                := No_Token_Index;
      Defer_Pos_333           : Token_Index                := No_Token_Index;
      Defer_Res_333           : Bare_Expr                  := No_Bare_Ada_Node;
      Token_Pos_281           : Token_Index                := No_Token_Index;
      Token_Res_281           : Token_Index                := No_Token_Index;
      Defer_Pos_334           : Token_Index                := No_Token_Index;
      Defer_Res_334           : Bare_Stmt_List             := No_Bare_Ada_Node;
      Transform_Res_168       : Bare_Select_When_Part      := No_Bare_Ada_Node;
      Token_Pos_282           : Token_Index                := No_Token_Index;
      Token_Res_282           : Token_Index                := No_Token_Index;
      List_Pos_24             : Token_Index                := No_Token_Index;
      List_Res_24             : Bare_Select_When_Part_List := No_Bare_Ada_Node;
      Row_Pos_203             : Token_Index                := No_Token_Index;
      Token_Pos_283           : Token_Index                := No_Token_Index;
      Token_Res_283           : Token_Index                := No_Token_Index;
      Defer_Pos_335           : Token_Index                := No_Token_Index;
      Defer_Res_335           : Bare_Stmt_List             := No_Bare_Ada_Node;
      Row_Pos_204             : Token_Index                := No_Token_Index;
      Token_Pos_284           : Token_Index                := No_Token_Index;
      Token_Res_284           : Token_Index                := No_Token_Index;
      Token_Pos_285           : Token_Index                := No_Token_Index;
      Token_Res_285           : Token_Index                := No_Token_Index;
      Defer_Pos_336           : Token_Index                := No_Token_Index;
      Defer_Res_336           : Bare_Stmt_List             := No_Bare_Ada_Node;
      Token_Pos_286           : Token_Index                := No_Token_Index;
      Token_Res_286           : Token_Index                := No_Token_Index;
      Token_Pos_287           : Token_Index                := No_Token_Index;
      Token_Res_287           : Token_Index                := No_Token_Index;
      Token_Pos_288           : Token_Index                := No_Token_Index;
      Token_Res_288           : Token_Index                := No_Token_Index;
      Row_Progress_24         : Integer                    := 0;
      Transform_Res_169       : Bare_Select_Stmt           := No_Bare_Ada_Node;
      Transform_Has_Failed_24 : Boolean                    := False;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Select_Stmt_Transform_Parse_1_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_169  := M.Instance;
         return Transform_Res_169;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_169;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_200 := Pos;

--  Start tok_code

      Token_Res_279 := Row_Pos_200;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_279));
      begin
         if T.Kind /= From_Token_Kind (Ada_Select) then
            Token_Pos_279 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_200 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_200,
                  Expected_Token_Id => Ada_Select,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_279 := Row_Pos_200 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_24 := 1;

      if Token_Pos_279 /= No_Token_Index then

         Row_Pos_200 := Token_Pos_279;

      else
         Row_Pos_200 := No_Token_Index;
         goto Exit_Row_195_0;

      end if;

      Nobt_23 := True;

      Row_Progress_24 := 2;

      if Row_Pos_200 /= No_Token_Index then

         Row_Pos_200 := Row_Pos_200;

      else
         Row_Pos_200 := No_Token_Index;
         goto Exit_Row_195_0;

      end if;

--  Start list_code

      List_Pos_24 := No_Token_Index;

      Lst_Cpos_24 := Row_Pos_200;
      Tmp_List_24 := Get_Parse_List (Parser);

      loop

--  Start transform_code

--  Start row_code

         Row_Pos_201 := Lst_Cpos_24;

--  Start opt_code

--  Start row_code

         Row_Pos_202 := Row_Pos_201;

--  Start tok_code

         Token_Res_280 := Row_Pos_202;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_280));
         begin
            if T.Kind /= From_Token_Kind (Ada_When) then
               Token_Pos_280 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Row_Pos_202 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Row_Pos_202,
                     Expected_Token_Id => Ada_When,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_280 := Row_Pos_202 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_280 /= No_Token_Index then

            Row_Pos_202 := Token_Pos_280;

         else
            Row_Pos_202 := No_Token_Index;
            goto Exit_Row_197_0;

         end if;

         Defer_Res_333 := Expr_Or_Parse_0 (Parser, Row_Pos_202);
         Defer_Pos_333 := Parser.Current_Pos;

         if Defer_Pos_333 /= No_Token_Index then

            Row_Pos_202 := Defer_Pos_333;

         else
            Row_Pos_202 := No_Token_Index;
            goto Exit_Row_197_0;

         end if;

--  Start tok_code

         Token_Res_281 := Row_Pos_202;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_281));
         begin
            if T.Kind /= From_Token_Kind (Ada_Arrow) then
               Token_Pos_281 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Row_Pos_202 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Row_Pos_202,
                     Expected_Token_Id => Ada_Arrow,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_281 := Row_Pos_202 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_281 /= No_Token_Index then

            Row_Pos_202 := Token_Pos_281;

         else
            Row_Pos_202 := No_Token_Index;
            goto Exit_Row_197_0;

         end if;

         pragma Warnings (Off, "referenced");
         <<Exit_Row_197_0>>
         pragma Warnings (On, "referenced");

--  End row_code

         if Row_Pos_202 = No_Token_Index then

            Defer_Res_333 := No_Bare_Ada_Node;

            Row_Pos_202 := Row_Pos_201;

         end if;

--  End opt_code

         if Row_Pos_202 /= No_Token_Index then

            Row_Pos_201 := Row_Pos_202;

         else
            Row_Pos_201 := No_Token_Index;
            goto Exit_Row_196_0;

         end if;

         Parser.Private_Part.Dont_Skip.Append
           (Dontskip_Select_Stmt_0_Extract_Parse_0'Access);

         Defer_Res_334 := Stmts_List_Parse_0 (Parser, Row_Pos_201);
         Defer_Pos_334 := Parser.Current_Pos;

         Parser.Private_Part.Dont_Skip.Delete_Last;

         if Defer_Pos_334 /= No_Token_Index then

            Row_Pos_201 := Defer_Pos_334;

         else
            Row_Pos_201 := No_Token_Index;
            goto Exit_Row_196_0;

         end if;

         pragma Warnings (Off, "referenced");
         <<Exit_Row_196_0>>
         pragma Warnings (On, "referenced");

--  End row_code

         if Row_Pos_201 /= No_Token_Index then

            Transform_Res_168 := Allocate_Select_When_Part (Parser.Mem_Pool);

            Initialize
              (Self => Transform_Res_168, Kind => Ada_Select_When_Part,
               Unit            => Parser.Unit,
Token_Start_Index              => Lst_Cpos_24,
               Token_End_Index =>
                 (if Row_Pos_201 = Lst_Cpos_24 then No_Token_Index
                  else Row_Pos_201 - 1));

            Initialize_Fields_For_Select_When_Part
              (Self                         => Transform_Res_168,
               Select_When_Part_F_Cond_Expr => Defer_Res_333,
               Select_When_Part_F_Stmts     => Defer_Res_334);

            if Defer_Res_333 /= null and then Is_Incomplete (Defer_Res_333)
            then
               Transform_Res_168.Last_Attempted_Child := 0;
            elsif Defer_Res_333 /= null and then not Is_Ghost (Defer_Res_333)
            then
               Transform_Res_168.Last_Attempted_Child := -1;
            end if;
            if Defer_Res_334 /= null and then Is_Incomplete (Defer_Res_334)
            then
               Transform_Res_168.Last_Attempted_Child := 0;
            elsif Defer_Res_334 /= null and then not Is_Ghost (Defer_Res_334)
            then
               Transform_Res_168.Last_Attempted_Child := -1;
            end if;

         end if;

--  End transform_code

         exit when Row_Pos_201 = No_Token_Index;

         List_Pos_24 := Row_Pos_201;
         Lst_Cpos_24 := List_Pos_24;

         Tmp_List_24.Nodes.Append (Transform_Res_168);

--  Start tok_code

         Token_Res_282 := Lst_Cpos_24;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_282));
         begin
            if T.Kind /= From_Token_Kind (Ada_Or) then
               Token_Pos_282 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_24 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_24,
                     Expected_Token_Id => Ada_Or,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_282 := Lst_Cpos_24 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_282 /= No_Token_Index then
            Lst_Cpos_24 := Token_Pos_282;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_24.Nodes.Length;
      begin
         List_Res_24 := Allocate_Select_When_Part_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_200;
            Token_End   :=
              (if Lst_Cpos_24 = Row_Pos_200 then Row_Pos_200
               else Lst_Cpos_24 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_200, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self            => List_Res_24, Kind => Ada_Select_When_Part_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_24, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_24.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_24.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_24);

--  End list_code

      Row_Progress_24 := 3;

      if List_Pos_24 /= No_Token_Index then

         Row_Pos_200 := List_Pos_24;

      else
         Row_Pos_200 := No_Token_Index;
         goto Exit_Row_195_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_203 := Row_Pos_200;

--  Start tok_code

      Token_Res_283 := Row_Pos_203;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_283));
      begin
         if T.Kind /= From_Token_Kind (Ada_Else) then
            Token_Pos_283 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_203 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_203,
                  Expected_Token_Id => Ada_Else,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_283 := Row_Pos_203 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_283 /= No_Token_Index then

         Row_Pos_203 := Token_Pos_283;

      else
         Row_Pos_203 := No_Token_Index;
         goto Exit_Row_198_0;

      end if;

      Parser.Private_Part.Dont_Skip.Append
        (Dontskip_Select_Stmt_1_Extract_Parse_0'Access);

      Defer_Res_335 := Stmts_List_Parse_0 (Parser, Row_Pos_203);
      Defer_Pos_335 := Parser.Current_Pos;

      Parser.Private_Part.Dont_Skip.Delete_Last;

      if Defer_Pos_335 /= No_Token_Index then

         Row_Pos_203 := Defer_Pos_335;

      else
         Row_Pos_203 := No_Token_Index;
         goto Exit_Row_198_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_198_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_203 = No_Token_Index then

         Defer_Res_335 := Allocate_Stmt_List (Parser.Mem_Pool);
         Initialize
           (Self => Defer_Res_335, Kind => Ada_Stmt_List, Unit => Parser.Unit,
            Token_Start_Index => Row_Pos_200 - 1,
            Token_End_Index   => No_Token_Index);
         Initialize_List (Self => Defer_Res_335, Parser => Parser, Count => 0);

         Row_Pos_203 := Row_Pos_200;

      end if;

--  End opt_code

      Row_Progress_24 := 4;

      if Row_Pos_203 /= No_Token_Index then

         Row_Pos_200 := Row_Pos_203;

      else
         Row_Pos_200 := No_Token_Index;
         goto Exit_Row_195_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_204 := Row_Pos_200;

--  Start tok_code

      Token_Res_284 := Row_Pos_204;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_284));
      begin
         if T.Kind /= From_Token_Kind (Ada_Then) then
            Token_Pos_284 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_204 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_204,
                  Expected_Token_Id => Ada_Then,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_284 := Row_Pos_204 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_284 /= No_Token_Index then

         Row_Pos_204 := Token_Pos_284;

      else
         Row_Pos_204 := No_Token_Index;
         goto Exit_Row_199_0;

      end if;

--  Start tok_code

      Token_Res_285 := Row_Pos_204;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_285));
      begin
         if T.Kind /= From_Token_Kind (Ada_Abort) then
            Token_Pos_285 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_204 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_204,
                  Expected_Token_Id => Ada_Abort,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_285 := Row_Pos_204 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_285 /= No_Token_Index then

         Row_Pos_204 := Token_Pos_285;

      else
         Row_Pos_204 := No_Token_Index;
         goto Exit_Row_199_0;

      end if;

      Parser.Private_Part.Dont_Skip.Append
        (Dontskip_Select_Stmt_2_Extract_Parse_0'Access);

      Defer_Res_336 := Stmts_List_Parse_0 (Parser, Row_Pos_204);
      Defer_Pos_336 := Parser.Current_Pos;

      Parser.Private_Part.Dont_Skip.Delete_Last;

      if Defer_Pos_336 /= No_Token_Index then

         Row_Pos_204 := Defer_Pos_336;

      else
         Row_Pos_204 := No_Token_Index;
         goto Exit_Row_199_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_199_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_204 = No_Token_Index then

         Defer_Res_336 := Allocate_Stmt_List (Parser.Mem_Pool);
         Initialize
           (Self => Defer_Res_336, Kind => Ada_Stmt_List, Unit => Parser.Unit,
            Token_Start_Index => Row_Pos_200 - 1,
            Token_End_Index   => No_Token_Index);
         Initialize_List (Self => Defer_Res_336, Parser => Parser, Count => 0);

         Row_Pos_204 := Row_Pos_200;

      end if;

--  End opt_code

      Row_Progress_24 := 5;

      if Row_Pos_204 /= No_Token_Index then

         Row_Pos_200 := Row_Pos_204;

      else
         Row_Pos_200 := No_Token_Index;
         goto Exit_Row_195_0;

      end if;

--  Start tok_code

      Token_Res_286 := Row_Pos_200;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_286));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_286 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_200 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_200,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_286 := Row_Pos_200 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_24 := 6;

      if Token_Pos_286 /= No_Token_Index then

         Row_Pos_200 := Token_Pos_286;

      else
         Row_Pos_200 := No_Token_Index;
         goto Exit_Row_195_0;

      end if;

--  Start tok_code

      Token_Res_287 := Row_Pos_200;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_287));
      begin
         if T.Kind /= From_Token_Kind (Ada_Select) then
            Token_Pos_287 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_200 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_200,
                  Expected_Token_Id => Ada_Select,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_287 := Row_Pos_200 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_24 := 7;

      if Token_Pos_287 /= No_Token_Index then

         Row_Pos_200 := Token_Pos_287;

      else
         Row_Pos_200 := No_Token_Index;
         goto Exit_Row_195_0;

      end if;

--  Start tok_code

      Token_Res_288 := Row_Pos_200;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_288));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_288 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_200 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_200,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_288 := Row_Pos_200 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_24 := 8;

      if Token_Pos_288 /= No_Token_Index then

         Row_Pos_200 := Token_Pos_288;

      else
         Row_Pos_200 := No_Token_Index;
         goto Exit_Row_195_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_195_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_200 = No_Token_Index and then Nobt_23 then
         Row_Pos_200             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_24 := True;
      end if;

      if Row_Pos_200 /= No_Token_Index then

         Transform_Res_169 := Allocate_Select_Stmt (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_169, Kind => Ada_Select_Stmt,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_200 = Pos then No_Token_Index else Row_Pos_200 - 1));

         Initialize_Fields_For_Select_Stmt
           (Self => Transform_Res_169, Select_Stmt_F_Guards => List_Res_24,
            Select_Stmt_F_Else_Stmts  => Defer_Res_335,
            Select_Stmt_F_Abort_Stmts => Defer_Res_336);

         if List_Res_24 /= null and then Is_Incomplete (List_Res_24) then
            Transform_Res_169.Last_Attempted_Child := 0;
         elsif List_Res_24 /= null and then not Is_Ghost (List_Res_24) then
            Transform_Res_169.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_335 /= null and then Is_Incomplete (Defer_Res_335) then
            Transform_Res_169.Last_Attempted_Child := 0;
         elsif Defer_Res_335 /= null and then not Is_Ghost (Defer_Res_335) then
            Transform_Res_169.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_336 /= null and then Is_Incomplete (Defer_Res_336) then
            Transform_Res_169.Last_Attempted_Child := 0;
         elsif Defer_Res_336 /= null and then not Is_Ghost (Defer_Res_336) then
            Transform_Res_169.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_24 then
            Transform_Res_169.Last_Attempted_Child := Row_Progress_24;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <select_stmt>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Select_Stmt_Transform_Parse_1_Memo,
         Row_Pos_200 /= No_Token_Index, Transform_Res_169, Pos, Row_Pos_200);

      Parser.Current_Pos := Row_Pos_200;

      return Transform_Res_169;
   end Select_Stmt_Transform_Parse_1;

   function Compound_Stmt_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Composite_Stmt
   is
      use Bare_Composite_Stmt_Memos;

      Defer_Pos_281 : Token_Index               := No_Token_Index;
      Defer_Res_281 : Bare_If_Stmt              := No_Bare_Ada_Node;
      Defer_Pos_282 : Token_Index               := No_Token_Index;
      Defer_Res_282 : Bare_Composite_Stmt       := No_Bare_Ada_Node;
      Defer_Pos_283 : Token_Index               := No_Token_Index;
      Defer_Res_283 : Bare_Composite_Stmt       := No_Bare_Ada_Node;
      Defer_Pos_284 : Token_Index               := No_Token_Index;
      Defer_Res_284 : Bare_Extended_Return_Stmt := No_Bare_Ada_Node;
      Defer_Pos_285 : Token_Index               := No_Token_Index;
      Defer_Res_285 : Bare_Case_Stmt            := No_Bare_Ada_Node;
      Defer_Pos_286 : Token_Index               := No_Token_Index;
      Defer_Res_286 : Bare_Accept_Stmt          := No_Bare_Ada_Node;
      Defer_Pos_287 : Token_Index               := No_Token_Index;
      Defer_Res_287 : Bare_Select_Stmt          := No_Bare_Ada_Node;
      Or_Pos_67     : Token_Index               := No_Token_Index;
      Or_Res_67     : Bare_Composite_Stmt       := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Compound_Stmt_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_67          := M.Instance;
         return Or_Res_67;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_67;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_67 := No_Token_Index;
      Or_Res_67 := No_Bare_Ada_Node;

      Defer_Res_281 := If_Stmt_Transform_Parse_1 (Parser, Pos);
      Defer_Pos_281 := Parser.Current_Pos;

      if Defer_Pos_281 /= No_Token_Index then
         Or_Pos_67 := Defer_Pos_281;
         Or_Res_67 := Defer_Res_281;
         goto Exit_Or_66;
      end if;

      Defer_Res_282 := Block_Stmt_Or_Parse_0 (Parser, Pos);
      Defer_Pos_282 := Parser.Current_Pos;

      if Defer_Pos_282 /= No_Token_Index then
         Or_Pos_67 := Defer_Pos_282;
         Or_Res_67 := Defer_Res_282;
         goto Exit_Or_66;
      end if;

      Defer_Res_283 := Loop_Stmt_Or_Parse_0 (Parser, Pos);
      Defer_Pos_283 := Parser.Current_Pos;

      if Defer_Pos_283 /= No_Token_Index then
         Or_Pos_67 := Defer_Pos_283;
         Or_Res_67 := Defer_Res_283;
         goto Exit_Or_66;
      end if;

      Defer_Res_284 := Ext_Return_Stmt_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_284 := Parser.Current_Pos;

      if Defer_Pos_284 /= No_Token_Index then
         Or_Pos_67 := Defer_Pos_284;
         Or_Res_67 := Defer_Res_284;
         goto Exit_Or_66;
      end if;

      Defer_Res_285 := Case_Stmt_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_285 := Parser.Current_Pos;

      if Defer_Pos_285 /= No_Token_Index then
         Or_Pos_67 := Defer_Pos_285;
         Or_Res_67 := Defer_Res_285;
         goto Exit_Or_66;
      end if;

      Defer_Res_286 := Accept_Stmt_Or_Parse_0 (Parser, Pos);
      Defer_Pos_286 := Parser.Current_Pos;

      if Defer_Pos_286 /= No_Token_Index then
         Or_Pos_67 := Defer_Pos_286;
         Or_Res_67 := Defer_Res_286;
         goto Exit_Or_66;
      end if;

      Defer_Res_287 := Select_Stmt_Transform_Parse_1 (Parser, Pos);
      Defer_Pos_287 := Parser.Current_Pos;

      if Defer_Pos_287 /= No_Token_Index then
         Or_Pos_67 := Defer_Pos_287;
         Or_Res_67 := Defer_Res_287;
         goto Exit_Or_66;
      end if;
      <<Exit_Or_66>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Compound_Stmt_Or_Parse_0_Memo,
         Or_Pos_67 /= No_Token_Index, Or_Res_67, Pos, Or_Pos_67);

      Parser.Current_Pos := Or_Pos_67;

      return Or_Res_67;
   end Compound_Stmt_Or_Parse_0;

   function Null_Stmt_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Null_Stmt
   is
      use Bare_Null_Stmt_Memos;

      Row_Pos_205       : Token_Index    := No_Token_Index;
      Token_Pos_289     : Token_Index    := No_Token_Index;
      Token_Res_289     : Token_Index    := No_Token_Index;
      Token_Pos_290     : Token_Index    := No_Token_Index;
      Token_Res_290     : Token_Index    := No_Token_Index;
      Transform_Res_170 : Bare_Null_Stmt := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Null_Stmt_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_170  := M.Instance;
         return Transform_Res_170;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_170;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_205 := Pos;

--  Start tok_code

      Token_Res_289 := Row_Pos_205;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_289));
      begin
         if T.Kind /= From_Token_Kind (Ada_Null) then
            Token_Pos_289 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_205 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_205,
                  Expected_Token_Id => Ada_Null,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_289 := Row_Pos_205 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_289 /= No_Token_Index then

         Row_Pos_205 := Token_Pos_289;

      else
         Row_Pos_205 := No_Token_Index;
         goto Exit_Row_200_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_290 := Row_Pos_205;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_290));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_290 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_205 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_205,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_290 := Row_Pos_205 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_290 = No_Token_Index then

         Token_Res_290 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_205).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_290 := Row_Pos_205;

      end if;

--  End opt_code

      if Token_Pos_290 /= No_Token_Index then

         Row_Pos_205 := Token_Pos_290;

      else
         Row_Pos_205 := No_Token_Index;
         goto Exit_Row_200_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_200_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_205 /= No_Token_Index then

         Transform_Res_170 := Allocate_Null_Stmt (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_170, Kind => Ada_Null_Stmt,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_205 = Pos then No_Token_Index else Row_Pos_205 - 1));

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Null_Stmt_Transform_Parse_0_Memo,
         Row_Pos_205 /= No_Token_Index, Transform_Res_170, Pos, Row_Pos_205);

      Parser.Current_Pos := Row_Pos_205;

      return Transform_Res_170;
   end Null_Stmt_Transform_Parse_0;

   function Assignment_Stmt_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Assign_Stmt
   is
      use Bare_Assign_Stmt_Memos;

      Nobt_24                 : Boolean          := False;
      Row_Pos_206             : Token_Index      := No_Token_Index;
      Defer_Pos_349           : Token_Index      := No_Token_Index;
      Defer_Res_349           : Bare_Name        := No_Bare_Ada_Node;
      Token_Pos_291           : Token_Index      := No_Token_Index;
      Token_Res_291           : Token_Index      := No_Token_Index;
      Defer_Pos_350           : Token_Index      := No_Token_Index;
      Defer_Res_350           : Bare_Expr        := No_Bare_Ada_Node;
      Token_Pos_292           : Token_Index      := No_Token_Index;
      Token_Res_292           : Token_Index      := No_Token_Index;
      Row_Progress_25         : Integer          := 0;
      Transform_Res_171       : Bare_Assign_Stmt := No_Bare_Ada_Node;
      Transform_Has_Failed_25 : Boolean          := False;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Assignment_Stmt_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_171  := M.Instance;
         return Transform_Res_171;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_171;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_206 := Pos;

      Defer_Res_349 := Name_Or_Parse_1 (Parser, Row_Pos_206);
      Defer_Pos_349 := Parser.Current_Pos;

      Row_Progress_25 := 1;

      if Defer_Pos_349 /= No_Token_Index then

         Row_Pos_206 := Defer_Pos_349;

      else
         Row_Pos_206 := No_Token_Index;
         goto Exit_Row_201_0;

      end if;

--  Start tok_code

      Token_Res_291 := Row_Pos_206;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_291));
      begin
         if T.Kind /= From_Token_Kind (Ada_Assign) then
            Token_Pos_291 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_206 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_206,
                  Expected_Token_Id => Ada_Assign,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_291 := Row_Pos_206 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_25 := 2;

      if Token_Pos_291 /= No_Token_Index then

         Row_Pos_206 := Token_Pos_291;

      else
         Row_Pos_206 := No_Token_Index;
         goto Exit_Row_201_0;

      end if;

      Nobt_24 := True;

      Row_Progress_25 := 3;

      if Row_Pos_206 /= No_Token_Index then

         Row_Pos_206 := Row_Pos_206;

      else
         Row_Pos_206 := No_Token_Index;
         goto Exit_Row_201_0;

      end if;

      Defer_Res_350 := Expr_Or_Parse_0 (Parser, Row_Pos_206);
      Defer_Pos_350 := Parser.Current_Pos;

      Row_Progress_25 := 4;

      if Defer_Pos_350 /= No_Token_Index then

         Row_Pos_206 := Defer_Pos_350;

      else
         Row_Pos_206 := No_Token_Index;
         goto Exit_Row_201_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_292 := Row_Pos_206;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_292));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_292 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_206 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_206,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_292 := Row_Pos_206 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_292 = No_Token_Index then

         Token_Res_292 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_206).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_292 := Row_Pos_206;

      end if;

--  End opt_code

      Row_Progress_25 := 5;

      if Token_Pos_292 /= No_Token_Index then

         Row_Pos_206 := Token_Pos_292;

      else
         Row_Pos_206 := No_Token_Index;
         goto Exit_Row_201_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_201_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_206 = No_Token_Index and then Nobt_24 then
         Row_Pos_206             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_25 := True;
      end if;

      if Row_Pos_206 /= No_Token_Index then

         Transform_Res_171 := Allocate_Assign_Stmt (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_171, Kind => Ada_Assign_Stmt,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_206 = Pos then No_Token_Index else Row_Pos_206 - 1));

         Initialize_Fields_For_Assign_Stmt
           (Self => Transform_Res_171, Assign_Stmt_F_Dest => Defer_Res_349,
            Assign_Stmt_F_Expr => Defer_Res_350);

         if Defer_Res_349 /= null and then Is_Incomplete (Defer_Res_349) then
            Transform_Res_171.Last_Attempted_Child := 0;
         elsif Defer_Res_349 /= null and then not Is_Ghost (Defer_Res_349) then
            Transform_Res_171.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_350 /= null and then Is_Incomplete (Defer_Res_350) then
            Transform_Res_171.Last_Attempted_Child := 0;
         elsif Defer_Res_350 /= null and then not Is_Ghost (Defer_Res_350) then
            Transform_Res_171.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_25 then
            Transform_Res_171.Last_Attempted_Child := Row_Progress_25;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <assignment_stmt>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Assignment_Stmt_Transform_Parse_0_Memo,
         Row_Pos_206 /= No_Token_Index, Transform_Res_171, Pos, Row_Pos_206);

      Parser.Current_Pos := Row_Pos_206;

      return Transform_Res_171;
   end Assignment_Stmt_Transform_Parse_0;

   function Goto_Stmt_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Goto_Stmt
   is
      use Bare_Goto_Stmt_Memos;

      Nobt_25                 : Boolean        := False;
      Row_Pos_207             : Token_Index    := No_Token_Index;
      Token_Pos_293           : Token_Index    := No_Token_Index;
      Token_Res_293           : Token_Index    := No_Token_Index;
      Defer_Pos_351           : Token_Index    := No_Token_Index;
      Defer_Res_351           : Bare_Name      := No_Bare_Ada_Node;
      Token_Pos_294           : Token_Index    := No_Token_Index;
      Token_Res_294           : Token_Index    := No_Token_Index;
      Row_Progress_26         : Integer        := 0;
      Transform_Res_172       : Bare_Goto_Stmt := No_Bare_Ada_Node;
      Transform_Has_Failed_26 : Boolean        := False;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Goto_Stmt_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_172  := M.Instance;
         return Transform_Res_172;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_172;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_207 := Pos;

--  Start tok_code

      Token_Res_293 := Row_Pos_207;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_293));
      begin
         if T.Kind /= From_Token_Kind (Ada_Goto) then
            Token_Pos_293 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_207 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_207,
                  Expected_Token_Id => Ada_Goto,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_293 := Row_Pos_207 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_26 := 1;

      if Token_Pos_293 /= No_Token_Index then

         Row_Pos_207 := Token_Pos_293;

      else
         Row_Pos_207 := No_Token_Index;
         goto Exit_Row_202_0;

      end if;

      Nobt_25 := True;

      Row_Progress_26 := 2;

      if Row_Pos_207 /= No_Token_Index then

         Row_Pos_207 := Row_Pos_207;

      else
         Row_Pos_207 := No_Token_Index;
         goto Exit_Row_202_0;

      end if;

      Defer_Res_351 := Static_Name_Or_Parse_0 (Parser, Row_Pos_207);
      Defer_Pos_351 := Parser.Current_Pos;

      Row_Progress_26 := 3;

      if Defer_Pos_351 /= No_Token_Index then

         Row_Pos_207 := Defer_Pos_351;

      else
         Row_Pos_207 := No_Token_Index;
         goto Exit_Row_202_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_294 := Row_Pos_207;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_294));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_294 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_207 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_207,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_294 := Row_Pos_207 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_294 = No_Token_Index then

         Token_Res_294 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_207).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_294 := Row_Pos_207;

      end if;

--  End opt_code

      Row_Progress_26 := 4;

      if Token_Pos_294 /= No_Token_Index then

         Row_Pos_207 := Token_Pos_294;

      else
         Row_Pos_207 := No_Token_Index;
         goto Exit_Row_202_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_202_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_207 = No_Token_Index and then Nobt_25 then
         Row_Pos_207             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_26 := True;
      end if;

      if Row_Pos_207 /= No_Token_Index then

         Transform_Res_172 := Allocate_Goto_Stmt (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_172, Kind => Ada_Goto_Stmt,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_207 = Pos then No_Token_Index else Row_Pos_207 - 1));

         Initialize_Fields_For_Goto_Stmt
           (Self                   => Transform_Res_172,
            Goto_Stmt_F_Label_Name => Defer_Res_351);

         if Defer_Res_351 /= null and then Is_Incomplete (Defer_Res_351) then
            Transform_Res_172.Last_Attempted_Child := 0;
         elsif Defer_Res_351 /= null and then not Is_Ghost (Defer_Res_351) then
            Transform_Res_172.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_26 then
            Transform_Res_172.Last_Attempted_Child := Row_Progress_26;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <goto_stmt>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Goto_Stmt_Transform_Parse_0_Memo,
         Row_Pos_207 /= No_Token_Index, Transform_Res_172, Pos, Row_Pos_207);

      Parser.Current_Pos := Row_Pos_207;

      return Transform_Res_172;
   end Goto_Stmt_Transform_Parse_0;

   function Exit_Stmt_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Exit_Stmt
   is
      use Bare_Exit_Stmt_Memos;

      Nobt_26                 : Boolean         := False;
      Row_Pos_208             : Token_Index     := No_Token_Index;
      Token_Pos_295           : Token_Index     := No_Token_Index;
      Token_Res_295           : Token_Index     := No_Token_Index;
      Defer_Pos_352           : Token_Index     := No_Token_Index;
      Defer_Res_352           : Bare_Identifier := No_Bare_Ada_Node;
      Row_Pos_209             : Token_Index     := No_Token_Index;
      Token_Pos_296           : Token_Index     := No_Token_Index;
      Token_Res_296           : Token_Index     := No_Token_Index;
      Defer_Pos_353           : Token_Index     := No_Token_Index;
      Defer_Res_353           : Bare_Expr       := No_Bare_Ada_Node;
      Token_Pos_297           : Token_Index     := No_Token_Index;
      Token_Res_297           : Token_Index     := No_Token_Index;
      Row_Progress_27         : Integer         := 0;
      Transform_Res_173       : Bare_Exit_Stmt  := No_Bare_Ada_Node;
      Transform_Has_Failed_27 : Boolean         := False;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Exit_Stmt_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_173  := M.Instance;
         return Transform_Res_173;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_173;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_208 := Pos;

--  Start tok_code

      Token_Res_295 := Row_Pos_208;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_295));
      begin
         if T.Kind /= From_Token_Kind (Ada_Exit) then
            Token_Pos_295 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_208 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_208,
                  Expected_Token_Id => Ada_Exit,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_295 := Row_Pos_208 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_27 := 1;

      if Token_Pos_295 /= No_Token_Index then

         Row_Pos_208 := Token_Pos_295;

      else
         Row_Pos_208 := No_Token_Index;
         goto Exit_Row_203_0;

      end if;

      Nobt_26 := True;

      Row_Progress_27 := 2;

      if Row_Pos_208 /= No_Token_Index then

         Row_Pos_208 := Row_Pos_208;

      else
         Row_Pos_208 := No_Token_Index;
         goto Exit_Row_203_0;

      end if;

--  Start opt_code

      Defer_Res_352 := Identifier_Transform_Parse_0 (Parser, Row_Pos_208);
      Defer_Pos_352 := Parser.Current_Pos;

      if Defer_Pos_352 = No_Token_Index then

         Defer_Res_352 := No_Bare_Ada_Node;

         Defer_Pos_352 := Row_Pos_208;

      end if;

--  End opt_code

      Row_Progress_27 := 3;

      if Defer_Pos_352 /= No_Token_Index then

         Row_Pos_208 := Defer_Pos_352;

      else
         Row_Pos_208 := No_Token_Index;
         goto Exit_Row_203_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_209 := Row_Pos_208;

--  Start tok_code

      Token_Res_296 := Row_Pos_209;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_296));
      begin
         if T.Kind /= From_Token_Kind (Ada_When) then
            Token_Pos_296 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_209 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_209,
                  Expected_Token_Id => Ada_When,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_296 := Row_Pos_209 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_296 /= No_Token_Index then

         Row_Pos_209 := Token_Pos_296;

      else
         Row_Pos_209 := No_Token_Index;
         goto Exit_Row_204_0;

      end if;

      Defer_Res_353 := Expr_Or_Parse_0 (Parser, Row_Pos_209);
      Defer_Pos_353 := Parser.Current_Pos;

      if Defer_Pos_353 /= No_Token_Index then

         Row_Pos_209 := Defer_Pos_353;

      else
         Row_Pos_209 := No_Token_Index;
         goto Exit_Row_204_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_204_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_209 = No_Token_Index then

         Defer_Res_353 := No_Bare_Ada_Node;

         Row_Pos_209 := Row_Pos_208;

      end if;

--  End opt_code

      Row_Progress_27 := 4;

      if Row_Pos_209 /= No_Token_Index then

         Row_Pos_208 := Row_Pos_209;

      else
         Row_Pos_208 := No_Token_Index;
         goto Exit_Row_203_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_297 := Row_Pos_208;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_297));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_297 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_208 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_208,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_297 := Row_Pos_208 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_297 = No_Token_Index then

         Token_Res_297 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_208).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_297 := Row_Pos_208;

      end if;

--  End opt_code

      Row_Progress_27 := 5;

      if Token_Pos_297 /= No_Token_Index then

         Row_Pos_208 := Token_Pos_297;

      else
         Row_Pos_208 := No_Token_Index;
         goto Exit_Row_203_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_203_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_208 = No_Token_Index and then Nobt_26 then
         Row_Pos_208             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_27 := True;
      end if;

      if Row_Pos_208 /= No_Token_Index then

         Transform_Res_173 := Allocate_Exit_Stmt (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_173, Kind => Ada_Exit_Stmt,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_208 = Pos then No_Token_Index else Row_Pos_208 - 1));

         Initialize_Fields_For_Exit_Stmt
           (Self => Transform_Res_173, Exit_Stmt_F_Loop_Name => Defer_Res_352,
            Exit_Stmt_F_Cond_Expr => Defer_Res_353);

         if Defer_Res_352 /= null and then Is_Incomplete (Defer_Res_352) then
            Transform_Res_173.Last_Attempted_Child := 0;
         elsif Defer_Res_352 /= null and then not Is_Ghost (Defer_Res_352) then
            Transform_Res_173.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_353 /= null and then Is_Incomplete (Defer_Res_353) then
            Transform_Res_173.Last_Attempted_Child := 0;
         elsif Defer_Res_353 /= null and then not Is_Ghost (Defer_Res_353) then
            Transform_Res_173.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_27 then
            Transform_Res_173.Last_Attempted_Child := Row_Progress_27;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <exit_stmt>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Exit_Stmt_Transform_Parse_0_Memo,
         Row_Pos_208 /= No_Token_Index, Transform_Res_173, Pos, Row_Pos_208);

      Parser.Current_Pos := Row_Pos_208;

      return Transform_Res_173;
   end Exit_Stmt_Transform_Parse_0;

   function Return_Stmt_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Return_Stmt
   is
      use Bare_Return_Stmt_Memos;

      Row_Pos_210       : Token_Index      := No_Token_Index;
      Token_Pos_298     : Token_Index      := No_Token_Index;
      Token_Res_298     : Token_Index      := No_Token_Index;
      Defer_Pos_354     : Token_Index      := No_Token_Index;
      Defer_Res_354     : Bare_Expr        := No_Bare_Ada_Node;
      Token_Pos_299     : Token_Index      := No_Token_Index;
      Token_Res_299     : Token_Index      := No_Token_Index;
      Transform_Res_174 : Bare_Return_Stmt := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Return_Stmt_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_174  := M.Instance;
         return Transform_Res_174;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_174;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_210 := Pos;

--  Start tok_code

      Token_Res_298 := Row_Pos_210;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_298));
      begin
         if T.Kind /= From_Token_Kind (Ada_Return) then
            Token_Pos_298 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_210 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_210,
                  Expected_Token_Id => Ada_Return,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_298 := Row_Pos_210 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_298 /= No_Token_Index then

         Row_Pos_210 := Token_Pos_298;

      else
         Row_Pos_210 := No_Token_Index;
         goto Exit_Row_205_0;

      end if;

--  Start opt_code

      Defer_Res_354 := Expr_Or_Parse_0 (Parser, Row_Pos_210);
      Defer_Pos_354 := Parser.Current_Pos;

      if Defer_Pos_354 = No_Token_Index then

         Defer_Res_354 := No_Bare_Ada_Node;

         Defer_Pos_354 := Row_Pos_210;

      end if;

--  End opt_code

      if Defer_Pos_354 /= No_Token_Index then

         Row_Pos_210 := Defer_Pos_354;

      else
         Row_Pos_210 := No_Token_Index;
         goto Exit_Row_205_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_299 := Row_Pos_210;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_299));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_299 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_210 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_210,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_299 := Row_Pos_210 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_299 = No_Token_Index then

         Token_Res_299 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_210).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_299 := Row_Pos_210;

      end if;

--  End opt_code

      if Token_Pos_299 /= No_Token_Index then

         Row_Pos_210 := Token_Pos_299;

      else
         Row_Pos_210 := No_Token_Index;
         goto Exit_Row_205_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_205_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_210 /= No_Token_Index then

         Transform_Res_174 := Allocate_Return_Stmt (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_174, Kind => Ada_Return_Stmt,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_210 = Pos then No_Token_Index else Row_Pos_210 - 1));

         Initialize_Fields_For_Return_Stmt
           (Self                      => Transform_Res_174,
            Return_Stmt_F_Return_Expr => Defer_Res_354);

         if Defer_Res_354 /= null and then Is_Incomplete (Defer_Res_354) then
            Transform_Res_174.Last_Attempted_Child := 0;
         elsif Defer_Res_354 /= null and then not Is_Ghost (Defer_Res_354) then
            Transform_Res_174.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Return_Stmt_Transform_Parse_0_Memo,
         Row_Pos_210 /= No_Token_Index, Transform_Res_174, Pos, Row_Pos_210);

      Parser.Current_Pos := Row_Pos_210;

      return Transform_Res_174;
   end Return_Stmt_Transform_Parse_0;

   function Requeue_Stmt_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Requeue_Stmt
   is
      use Bare_Requeue_Stmt_Memos;

      Row_Pos_211       : Token_Index       := No_Token_Index;
      Token_Pos_300     : Token_Index       := No_Token_Index;
      Token_Res_300     : Token_Index       := No_Token_Index;
      Defer_Pos_355     : Token_Index       := No_Token_Index;
      Defer_Res_355     : Bare_Name         := No_Bare_Ada_Node;
      Row_Pos_212       : Token_Index       := No_Token_Index;
      Token_Pos_301     : Token_Index       := No_Token_Index;
      Token_Res_301     : Token_Index       := No_Token_Index;
      Token_Pos_302     : Token_Index       := No_Token_Index;
      Token_Res_302     : Token_Index       := No_Token_Index;
      Opt_Res_13        : Bare_Abort_Node   := No_Bare_Ada_Node;
      Token_Pos_303     : Token_Index       := No_Token_Index;
      Token_Res_303     : Token_Index       := No_Token_Index;
      Transform_Res_175 : Bare_Requeue_Stmt := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Requeue_Stmt_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_175  := M.Instance;
         return Transform_Res_175;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_175;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_211 := Pos;

--  Start tok_code

      Token_Res_300 := Row_Pos_211;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_300));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol
               (Parser.TDH.Symbols, Precomputed_Symbol_Requeue)
         then
            Token_Pos_300 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_211 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_211,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_300 := Row_Pos_211 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_300 /= No_Token_Index then

         Row_Pos_211 := Token_Pos_300;

      else
         Row_Pos_211 := No_Token_Index;
         goto Exit_Row_206_0;

      end if;

      Defer_Res_355 := Name_Or_Parse_1 (Parser, Row_Pos_211);
      Defer_Pos_355 := Parser.Current_Pos;

      if Defer_Pos_355 /= No_Token_Index then

         Row_Pos_211 := Defer_Pos_355;

      else
         Row_Pos_211 := No_Token_Index;
         goto Exit_Row_206_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_212 := Row_Pos_211;

--  Start tok_code

      Token_Res_301 := Row_Pos_212;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_301));
      begin
         if T.Kind /= From_Token_Kind (Ada_With) then
            Token_Pos_301 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_212 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_212,
                  Expected_Token_Id => Ada_With,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_301 := Row_Pos_212 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_301 /= No_Token_Index then

         Row_Pos_212 := Token_Pos_301;

      else
         Row_Pos_212 := No_Token_Index;
         goto Exit_Row_207_0;

      end if;

--  Start tok_code

      Token_Res_302 := Row_Pos_212;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_302));
      begin
         if T.Kind /= From_Token_Kind (Ada_Abort) then
            Token_Pos_302 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_212 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_212,
                  Expected_Token_Id => Ada_Abort,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_302 := Row_Pos_212 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_302 /= No_Token_Index then

         Row_Pos_212 := Token_Pos_302;

      else
         Row_Pos_212 := No_Token_Index;
         goto Exit_Row_207_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_207_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_212 = No_Token_Index then

         Opt_Res_13 := Allocate_Abort_Absent (Parser.Mem_Pool);
         Initialize
           (Self => Opt_Res_13, Kind => Ada_Abort_Absent, Unit => Parser.Unit,
            Token_Start_Index => Row_Pos_211,
            Token_End_Index   => No_Token_Index);

         Row_Pos_212 := Row_Pos_211;

      else

         Opt_Res_13 := Allocate_Abort_Present (Parser.Mem_Pool);
         Initialize
           (Self => Opt_Res_13, Kind => Ada_Abort_Present, Unit => Parser.Unit,
            Token_Start_Index => Row_Pos_211,
            Token_End_Index   => Row_Pos_212 - 1);

      end if;

--  End opt_code

      if Row_Pos_212 /= No_Token_Index then

         Row_Pos_211 := Row_Pos_212;

      else
         Row_Pos_211 := No_Token_Index;
         goto Exit_Row_206_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_303 := Row_Pos_211;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_303));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_303 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_211 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_211,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_303 := Row_Pos_211 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_303 = No_Token_Index then

         Token_Res_303 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_211).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_303 := Row_Pos_211;

      end if;

--  End opt_code

      if Token_Pos_303 /= No_Token_Index then

         Row_Pos_211 := Token_Pos_303;

      else
         Row_Pos_211 := No_Token_Index;
         goto Exit_Row_206_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_206_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_211 /= No_Token_Index then

         Transform_Res_175 := Allocate_Requeue_Stmt (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_175, Kind => Ada_Requeue_Stmt,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_211 = Pos then No_Token_Index else Row_Pos_211 - 1));

         Initialize_Fields_For_Requeue_Stmt
           (Self                     => Transform_Res_175,
            Requeue_Stmt_F_Call_Name => Defer_Res_355,
            Requeue_Stmt_F_Has_Abort => Opt_Res_13);

         if Defer_Res_355 /= null and then Is_Incomplete (Defer_Res_355) then
            Transform_Res_175.Last_Attempted_Child := 0;
         elsif Defer_Res_355 /= null and then not Is_Ghost (Defer_Res_355) then
            Transform_Res_175.Last_Attempted_Child := -1;
         end if;
         if Opt_Res_13 /= null and then Is_Incomplete (Opt_Res_13) then
            Transform_Res_175.Last_Attempted_Child := 0;
         elsif Opt_Res_13 /= null and then not Is_Ghost (Opt_Res_13) then
            Transform_Res_175.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Requeue_Stmt_Transform_Parse_0_Memo,
         Row_Pos_211 /= No_Token_Index, Transform_Res_175, Pos, Row_Pos_211);

      Parser.Current_Pos := Row_Pos_211;

      return Transform_Res_175;
   end Requeue_Stmt_Transform_Parse_0;

   function Call_Stmt_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Call_Stmt
   is
      use Bare_Call_Stmt_Memos;

      Row_Pos_213       : Token_Index    := No_Token_Index;
      Defer_Pos_356     : Token_Index    := No_Token_Index;
      Defer_Res_356     : Bare_Name      := No_Bare_Ada_Node;
      Token_Pos_304     : Token_Index    := No_Token_Index;
      Token_Res_304     : Token_Index    := No_Token_Index;
      Transform_Res_176 : Bare_Call_Stmt := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Call_Stmt_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_176  := M.Instance;
         return Transform_Res_176;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_176;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_213 := Pos;

      Defer_Res_356 := Name_Or_Parse_1 (Parser, Row_Pos_213);
      Defer_Pos_356 := Parser.Current_Pos;

      if Defer_Pos_356 /= No_Token_Index then

         Row_Pos_213 := Defer_Pos_356;

      else
         Row_Pos_213 := No_Token_Index;
         goto Exit_Row_208_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_304 := Row_Pos_213;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_304));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_304 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_213 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_213,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_304 := Row_Pos_213 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_304 = No_Token_Index then

         Token_Res_304 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_213).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_304 := Row_Pos_213;

      end if;

--  End opt_code

      if Token_Pos_304 /= No_Token_Index then

         Row_Pos_213 := Token_Pos_304;

      else
         Row_Pos_213 := No_Token_Index;
         goto Exit_Row_208_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_208_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_213 /= No_Token_Index then

         Transform_Res_176 := Allocate_Call_Stmt (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_176, Kind => Ada_Call_Stmt,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_213 = Pos then No_Token_Index else Row_Pos_213 - 1));

         Initialize_Fields_For_Call_Stmt
           (Self => Transform_Res_176, Call_Stmt_F_Call => Defer_Res_356);

         if Defer_Res_356 /= null and then Is_Incomplete (Defer_Res_356) then
            Transform_Res_176.Last_Attempted_Child := 0;
         elsif Defer_Res_356 /= null and then not Is_Ghost (Defer_Res_356) then
            Transform_Res_176.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Call_Stmt_Transform_Parse_0_Memo,
         Row_Pos_213 /= No_Token_Index, Transform_Res_176, Pos, Row_Pos_213);

      Parser.Current_Pos := Row_Pos_213;

      return Transform_Res_176;
   end Call_Stmt_Transform_Parse_0;

   function Abort_Stmt_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Abort_Stmt
   is
      use Bare_Abort_Stmt_Memos;

      Row_Pos_214       : Token_Index     := No_Token_Index;
      Token_Pos_305     : Token_Index     := No_Token_Index;
      Token_Res_305     : Token_Index     := No_Token_Index;
      Lst_Cpos_25       : Token_Index     := No_Token_Index;
      Tmp_List_25       : Free_Parse_List;
      Defer_Pos_357     : Token_Index     := No_Token_Index;
      Defer_Res_357     : Bare_Name       := No_Bare_Ada_Node;
      Token_Pos_306     : Token_Index     := No_Token_Index;
      Token_Res_306     : Token_Index     := No_Token_Index;
      List_Pos_25       : Token_Index     := No_Token_Index;
      List_Res_25       : Bare_Name_List  := No_Bare_Ada_Node;
      Token_Pos_307     : Token_Index     := No_Token_Index;
      Token_Res_307     : Token_Index     := No_Token_Index;
      Transform_Res_177 : Bare_Abort_Stmt := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Abort_Stmt_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_177  := M.Instance;
         return Transform_Res_177;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_177;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_214 := Pos;

--  Start tok_code

      Token_Res_305 := Row_Pos_214;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_305));
      begin
         if T.Kind /= From_Token_Kind (Ada_Abort) then
            Token_Pos_305 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_214 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_214,
                  Expected_Token_Id => Ada_Abort,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_305 := Row_Pos_214 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_305 /= No_Token_Index then

         Row_Pos_214 := Token_Pos_305;

      else
         Row_Pos_214 := No_Token_Index;
         goto Exit_Row_209_0;

      end if;

--  Start list_code

      List_Pos_25 := No_Token_Index;

      Lst_Cpos_25 := Row_Pos_214;
      Tmp_List_25 := Get_Parse_List (Parser);

      loop

         Defer_Res_357 := Name_Or_Parse_1 (Parser, Lst_Cpos_25);
         Defer_Pos_357 := Parser.Current_Pos;

         exit when Defer_Pos_357 = No_Token_Index;

         List_Pos_25 := Defer_Pos_357;
         Lst_Cpos_25 := List_Pos_25;

         Tmp_List_25.Nodes.Append (Defer_Res_357);

--  Start tok_code

         Token_Res_306 := Lst_Cpos_25;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_306));
         begin
            if T.Kind /= From_Token_Kind (Ada_Comma) then
               Token_Pos_306 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_25 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_25,
                     Expected_Token_Id => Ada_Comma,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_306 := Lst_Cpos_25 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_306 /= No_Token_Index then
            Lst_Cpos_25 := Token_Pos_306;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_25.Nodes.Length;
      begin
         List_Res_25 := Allocate_Name_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_214;
            Token_End   :=
              (if Lst_Cpos_25 = Row_Pos_214 then Row_Pos_214
               else Lst_Cpos_25 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_214, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self => List_Res_25, Kind => Ada_Name_List, Unit => Parser.Unit,
            Token_Start_Index => Token_Start, Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_25, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_25.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_25.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_25);

--  End list_code

      if List_Pos_25 /= No_Token_Index then

         Row_Pos_214 := List_Pos_25;

      else
         Row_Pos_214 := No_Token_Index;
         goto Exit_Row_209_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_307 := Row_Pos_214;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_307));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_307 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_214 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_214,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_307 := Row_Pos_214 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_307 = No_Token_Index then

         Token_Res_307 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_214).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_307 := Row_Pos_214;

      end if;

--  End opt_code

      if Token_Pos_307 /= No_Token_Index then

         Row_Pos_214 := Token_Pos_307;

      else
         Row_Pos_214 := No_Token_Index;
         goto Exit_Row_209_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_209_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_214 /= No_Token_Index then

         Transform_Res_177 := Allocate_Abort_Stmt (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_177, Kind => Ada_Abort_Stmt,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_214 = Pos then No_Token_Index else Row_Pos_214 - 1));

         Initialize_Fields_For_Abort_Stmt
           (Self => Transform_Res_177, Abort_Stmt_F_Names => List_Res_25);

         if List_Res_25 /= null and then Is_Incomplete (List_Res_25) then
            Transform_Res_177.Last_Attempted_Child := 0;
         elsif List_Res_25 /= null and then not Is_Ghost (List_Res_25) then
            Transform_Res_177.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Abort_Stmt_Transform_Parse_0_Memo,
         Row_Pos_214 /= No_Token_Index, Transform_Res_177, Pos, Row_Pos_214);

      Parser.Current_Pos := Row_Pos_214;

      return Transform_Res_177;
   end Abort_Stmt_Transform_Parse_0;

   function Delay_Stmt_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Delay_Stmt
   is
      use Bare_Delay_Stmt_Memos;

      Row_Pos_215       : Token_Index     := No_Token_Index;
      Token_Pos_308     : Token_Index     := No_Token_Index;
      Token_Res_308     : Token_Index     := No_Token_Index;
      Token_Pos_309     : Token_Index     := No_Token_Index;
      Token_Res_309     : Token_Index     := No_Token_Index;
      Opt_Res_14        : Bare_Until_Node := No_Bare_Ada_Node;
      Defer_Pos_358     : Token_Index     := No_Token_Index;
      Defer_Res_358     : Bare_Expr       := No_Bare_Ada_Node;
      Token_Pos_310     : Token_Index     := No_Token_Index;
      Token_Res_310     : Token_Index     := No_Token_Index;
      Transform_Res_178 : Bare_Delay_Stmt := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Delay_Stmt_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_178  := M.Instance;
         return Transform_Res_178;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_178;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_215 := Pos;

--  Start tok_code

      Token_Res_308 := Row_Pos_215;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_308));
      begin
         if T.Kind /= From_Token_Kind (Ada_Delay) then
            Token_Pos_308 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_215 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_215,
                  Expected_Token_Id => Ada_Delay,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_308 := Row_Pos_215 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_308 /= No_Token_Index then

         Row_Pos_215 := Token_Pos_308;

      else
         Row_Pos_215 := No_Token_Index;
         goto Exit_Row_210_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_309 := Row_Pos_215;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_309));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol (Parser.TDH.Symbols, Precomputed_Symbol_Until)
         then
            Token_Pos_309 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_215 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_215,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_309 := Row_Pos_215 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_309 = No_Token_Index then

         Opt_Res_14 := Allocate_Until_Absent (Parser.Mem_Pool);
         Initialize
           (Self => Opt_Res_14, Kind => Ada_Until_Absent, Unit => Parser.Unit,
            Token_Start_Index => Row_Pos_215,
            Token_End_Index   => No_Token_Index);

         Token_Pos_309 := Row_Pos_215;

      else

         Opt_Res_14 := Allocate_Until_Present (Parser.Mem_Pool);
         Initialize
           (Self => Opt_Res_14, Kind => Ada_Until_Present, Unit => Parser.Unit,
            Token_Start_Index => Row_Pos_215,
            Token_End_Index   => Token_Pos_309 - 1);

      end if;

--  End opt_code

      if Token_Pos_309 /= No_Token_Index then

         Row_Pos_215 := Token_Pos_309;

      else
         Row_Pos_215 := No_Token_Index;
         goto Exit_Row_210_0;

      end if;

      Defer_Res_358 := Expr_Or_Parse_0 (Parser, Row_Pos_215);
      Defer_Pos_358 := Parser.Current_Pos;

      if Defer_Pos_358 /= No_Token_Index then

         Row_Pos_215 := Defer_Pos_358;

      else
         Row_Pos_215 := No_Token_Index;
         goto Exit_Row_210_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_310 := Row_Pos_215;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_310));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_310 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_215 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_215,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_310 := Row_Pos_215 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_310 = No_Token_Index then

         Token_Res_310 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_215).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_310 := Row_Pos_215;

      end if;

--  End opt_code

      if Token_Pos_310 /= No_Token_Index then

         Row_Pos_215 := Token_Pos_310;

      else
         Row_Pos_215 := No_Token_Index;
         goto Exit_Row_210_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_210_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_215 /= No_Token_Index then

         Transform_Res_178 := Allocate_Delay_Stmt (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_178, Kind => Ada_Delay_Stmt,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_215 = Pos then No_Token_Index else Row_Pos_215 - 1));

         Initialize_Fields_For_Delay_Stmt
           (Self => Transform_Res_178, Delay_Stmt_F_Has_Until => Opt_Res_14,
            Delay_Stmt_F_Expr => Defer_Res_358);

         if Opt_Res_14 /= null and then Is_Incomplete (Opt_Res_14) then
            Transform_Res_178.Last_Attempted_Child := 0;
         elsif Opt_Res_14 /= null and then not Is_Ghost (Opt_Res_14) then
            Transform_Res_178.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_358 /= null and then Is_Incomplete (Defer_Res_358) then
            Transform_Res_178.Last_Attempted_Child := 0;
         elsif Defer_Res_358 /= null and then not Is_Ghost (Defer_Res_358) then
            Transform_Res_178.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Delay_Stmt_Transform_Parse_0_Memo,
         Row_Pos_215 /= No_Token_Index, Transform_Res_178, Pos, Row_Pos_215);

      Parser.Current_Pos := Row_Pos_215;

      return Transform_Res_178;
   end Delay_Stmt_Transform_Parse_0;

   function Raise_Stmt_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Raise_Stmt
   is
      use Bare_Raise_Stmt_Memos;

      Row_Pos_216       : Token_Index     := No_Token_Index;
      Token_Pos_311     : Token_Index     := No_Token_Index;
      Token_Res_311     : Token_Index     := No_Token_Index;
      Defer_Pos_359     : Token_Index     := No_Token_Index;
      Defer_Res_359     : Bare_Name       := No_Bare_Ada_Node;
      Row_Pos_217       : Token_Index     := No_Token_Index;
      Token_Pos_312     : Token_Index     := No_Token_Index;
      Token_Res_312     : Token_Index     := No_Token_Index;
      Defer_Pos_360     : Token_Index     := No_Token_Index;
      Defer_Res_360     : Bare_Expr       := No_Bare_Ada_Node;
      Token_Pos_313     : Token_Index     := No_Token_Index;
      Token_Res_313     : Token_Index     := No_Token_Index;
      Transform_Res_179 : Bare_Raise_Stmt := No_Bare_Ada_Node;
      Row_Pos_218       : Token_Index     := No_Token_Index;
      Token_Pos_314     : Token_Index     := No_Token_Index;
      Token_Res_314     : Token_Index     := No_Token_Index;
      Null_Res_10       : Bare_Name       := No_Bare_Ada_Node;
      Null_Res_11       : Bare_Expr       := No_Bare_Ada_Node;
      Token_Pos_315     : Token_Index     := No_Token_Index;
      Token_Res_315     : Token_Index     := No_Token_Index;
      Transform_Res_180 : Bare_Raise_Stmt := No_Bare_Ada_Node;
      Or_Pos_74         : Token_Index     := No_Token_Index;
      Or_Res_74         : Bare_Raise_Stmt := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Raise_Stmt_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_74          := M.Instance;
         return Or_Res_74;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_74;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_74 := No_Token_Index;
      Or_Res_74 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_216 := Pos;

--  Start tok_code

      Token_Res_311 := Row_Pos_216;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_311));
      begin
         if T.Kind /= From_Token_Kind (Ada_Raise) then
            Token_Pos_311 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_216 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_216,
                  Expected_Token_Id => Ada_Raise,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_311 := Row_Pos_216 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_311 /= No_Token_Index then

         Row_Pos_216 := Token_Pos_311;

      else
         Row_Pos_216 := No_Token_Index;
         goto Exit_Row_211_0;

      end if;

      Defer_Res_359 := Name_Or_Parse_1 (Parser, Row_Pos_216);
      Defer_Pos_359 := Parser.Current_Pos;

      if Defer_Pos_359 /= No_Token_Index then

         Row_Pos_216 := Defer_Pos_359;

      else
         Row_Pos_216 := No_Token_Index;
         goto Exit_Row_211_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_217 := Row_Pos_216;

--  Start tok_code

      Token_Res_312 := Row_Pos_217;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_312));
      begin
         if T.Kind /= From_Token_Kind (Ada_With) then
            Token_Pos_312 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_217 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_217,
                  Expected_Token_Id => Ada_With,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_312 := Row_Pos_217 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_312 /= No_Token_Index then

         Row_Pos_217 := Token_Pos_312;

      else
         Row_Pos_217 := No_Token_Index;
         goto Exit_Row_212_0;

      end if;

      Defer_Res_360 := Expr_Or_Parse_0 (Parser, Row_Pos_217);
      Defer_Pos_360 := Parser.Current_Pos;

      if Defer_Pos_360 /= No_Token_Index then

         Row_Pos_217 := Defer_Pos_360;

      else
         Row_Pos_217 := No_Token_Index;
         goto Exit_Row_212_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_212_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_217 = No_Token_Index then

         Defer_Res_360 := No_Bare_Ada_Node;

         Row_Pos_217 := Row_Pos_216;

      end if;

--  End opt_code

      if Row_Pos_217 /= No_Token_Index then

         Row_Pos_216 := Row_Pos_217;

      else
         Row_Pos_216 := No_Token_Index;
         goto Exit_Row_211_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_313 := Row_Pos_216;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_313));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_313 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_216 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_216,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_313 := Row_Pos_216 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_313 = No_Token_Index then

         Token_Res_313 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_216).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_313 := Row_Pos_216;

      end if;

--  End opt_code

      if Token_Pos_313 /= No_Token_Index then

         Row_Pos_216 := Token_Pos_313;

      else
         Row_Pos_216 := No_Token_Index;
         goto Exit_Row_211_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_211_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_216 /= No_Token_Index then

         Transform_Res_179 := Allocate_Raise_Stmt (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_179, Kind => Ada_Raise_Stmt,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_216 = Pos then No_Token_Index else Row_Pos_216 - 1));

         Initialize_Fields_For_Raise_Stmt
           (Self                        => Transform_Res_179,
            Raise_Stmt_F_Exception_Name => Defer_Res_359,
            Raise_Stmt_F_Error_Message  => Defer_Res_360);

         if Defer_Res_359 /= null and then Is_Incomplete (Defer_Res_359) then
            Transform_Res_179.Last_Attempted_Child := 0;
         elsif Defer_Res_359 /= null and then not Is_Ghost (Defer_Res_359) then
            Transform_Res_179.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_360 /= null and then Is_Incomplete (Defer_Res_360) then
            Transform_Res_179.Last_Attempted_Child := 0;
         elsif Defer_Res_360 /= null and then not Is_Ghost (Defer_Res_360) then
            Transform_Res_179.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_216 /= No_Token_Index then
         Or_Pos_74 := Row_Pos_216;
         Or_Res_74 := Transform_Res_179;
         goto Exit_Or_73;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_218 := Pos;

--  Start tok_code

      Token_Res_314 := Row_Pos_218;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_314));
      begin
         if T.Kind /= From_Token_Kind (Ada_Raise) then
            Token_Pos_314 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_218 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_218,
                  Expected_Token_Id => Ada_Raise,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_314 := Row_Pos_218 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_314 /= No_Token_Index then

         Row_Pos_218 := Token_Pos_314;

      else
         Row_Pos_218 := No_Token_Index;
         goto Exit_Row_213_0;

      end if;

      Null_Res_10 := No_Bare_Ada_Node;

      if Row_Pos_218 /= No_Token_Index then

         Row_Pos_218 := Row_Pos_218;

      else
         Row_Pos_218 := No_Token_Index;
         goto Exit_Row_213_0;

      end if;

      Null_Res_11 := No_Bare_Ada_Node;

      if Row_Pos_218 /= No_Token_Index then

         Row_Pos_218 := Row_Pos_218;

      else
         Row_Pos_218 := No_Token_Index;
         goto Exit_Row_213_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_315 := Row_Pos_218;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_315));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_315 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_218 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_218,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_315 := Row_Pos_218 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_315 = No_Token_Index then

         Token_Res_315 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_218).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_315 := Row_Pos_218;

      end if;

--  End opt_code

      if Token_Pos_315 /= No_Token_Index then

         Row_Pos_218 := Token_Pos_315;

      else
         Row_Pos_218 := No_Token_Index;
         goto Exit_Row_213_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_213_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_218 /= No_Token_Index then

         Transform_Res_180 := Allocate_Raise_Stmt (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_180, Kind => Ada_Raise_Stmt,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_218 = Pos then No_Token_Index else Row_Pos_218 - 1));

         Initialize_Fields_For_Raise_Stmt
           (Self                        => Transform_Res_180,
            Raise_Stmt_F_Exception_Name => Null_Res_10,
            Raise_Stmt_F_Error_Message  => Null_Res_11);

         if Null_Res_10 /= null and then Is_Incomplete (Null_Res_10) then
            Transform_Res_180.Last_Attempted_Child := 0;
         elsif Null_Res_10 /= null and then not Is_Ghost (Null_Res_10) then
            Transform_Res_180.Last_Attempted_Child := -1;
         end if;
         if Null_Res_11 /= null and then Is_Incomplete (Null_Res_11) then
            Transform_Res_180.Last_Attempted_Child := 0;
         elsif Null_Res_11 /= null and then not Is_Ghost (Null_Res_11) then
            Transform_Res_180.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_218 /= No_Token_Index then
         Or_Pos_74 := Row_Pos_218;
         Or_Res_74 := Transform_Res_180;
         goto Exit_Or_73;
      end if;
      <<Exit_Or_73>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Raise_Stmt_Or_Parse_0_Memo,
         Or_Pos_74 /= No_Token_Index, Or_Res_74, Pos, Or_Pos_74);

      Parser.Current_Pos := Or_Pos_74;

      return Or_Res_74;
   end Raise_Stmt_Or_Parse_0;

   function Terminate_Alternative_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Terminate_Alternative
   is
      use Bare_Terminate_Alternative_Memos;

      Row_Pos_219       : Token_Index                := No_Token_Index;
      Token_Pos_316     : Token_Index                := No_Token_Index;
      Token_Res_316     : Token_Index                := No_Token_Index;
      Token_Pos_317     : Token_Index                := No_Token_Index;
      Token_Res_317     : Token_Index                := No_Token_Index;
      Transform_Res_181 : Bare_Terminate_Alternative := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Terminate_Alternative_Transform_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_181  := M.Instance;
         return Transform_Res_181;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_181;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_219 := Pos;

--  Start tok_code

      Token_Res_316 := Row_Pos_219;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_316));
      begin
         if T.Kind /= From_Token_Kind (Ada_Terminate) then
            Token_Pos_316 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_219 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_219,
                  Expected_Token_Id => Ada_Terminate,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_316 := Row_Pos_219 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_316 /= No_Token_Index then

         Row_Pos_219 := Token_Pos_316;

      else
         Row_Pos_219 := No_Token_Index;
         goto Exit_Row_214_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_317 := Row_Pos_219;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_317));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_317 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_219 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_219,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_317 := Row_Pos_219 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_317 = No_Token_Index then

         Token_Res_317 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_219).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_317 := Row_Pos_219;

      end if;

--  End opt_code

      if Token_Pos_317 /= No_Token_Index then

         Row_Pos_219 := Token_Pos_317;

      else
         Row_Pos_219 := No_Token_Index;
         goto Exit_Row_214_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_214_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_219 /= No_Token_Index then

         Transform_Res_181 := Allocate_Terminate_Alternative (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_181, Kind => Ada_Terminate_Alternative,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_219 = Pos then No_Token_Index else Row_Pos_219 - 1));

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Terminate_Alternative_Transform_Parse_0_Memo,
         Row_Pos_219 /= No_Token_Index, Transform_Res_181, Pos, Row_Pos_219);

      Parser.Current_Pos := Row_Pos_219;

      return Transform_Res_181;
   end Terminate_Alternative_Transform_Parse_0;

   function Pragma_Argument_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Pragma_Argument_Assoc
   is
      use Bare_Pragma_Argument_Assoc_Memos;

      Row_Pos_222       : Token_Index                := No_Token_Index;
      Row_Pos_223       : Token_Index                := No_Token_Index;
      Defer_Pos_364     : Token_Index                := No_Token_Index;
      Defer_Res_364     : Bare_Identifier            := No_Bare_Ada_Node;
      Token_Pos_323     : Token_Index                := No_Token_Index;
      Token_Res_323     : Token_Index                := No_Token_Index;
      Defer_Pos_365     : Token_Index                := No_Token_Index;
      Defer_Res_365     : Bare_Expr                  := No_Bare_Ada_Node;
      Transform_Res_183 : Bare_Pragma_Argument_Assoc := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Pragma_Argument_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_183  := M.Instance;
         return Transform_Res_183;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_183;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_222 := Pos;

--  Start opt_code

--  Start row_code

      Row_Pos_223 := Row_Pos_222;

      Defer_Res_364 := Identifier_Transform_Parse_0 (Parser, Row_Pos_223);
      Defer_Pos_364 := Parser.Current_Pos;

      if Defer_Pos_364 /= No_Token_Index then

         Row_Pos_223 := Defer_Pos_364;

      else
         Row_Pos_223 := No_Token_Index;
         goto Exit_Row_218_0;

      end if;

--  Start tok_code

      Token_Res_323 := Row_Pos_223;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_323));
      begin
         if T.Kind /= From_Token_Kind (Ada_Arrow) then
            Token_Pos_323 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_223 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_223,
                  Expected_Token_Id => Ada_Arrow,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_323 := Row_Pos_223 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_323 /= No_Token_Index then

         Row_Pos_223 := Token_Pos_323;

      else
         Row_Pos_223 := No_Token_Index;
         goto Exit_Row_218_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_218_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_223 = No_Token_Index then

         Defer_Res_364 := No_Bare_Ada_Node;

         Row_Pos_223 := Row_Pos_222;

      end if;

--  End opt_code

      if Row_Pos_223 /= No_Token_Index then

         Row_Pos_222 := Row_Pos_223;

      else
         Row_Pos_222 := No_Token_Index;
         goto Exit_Row_217_0;

      end if;

      Defer_Res_365 := Expr_Or_Parse_0 (Parser, Row_Pos_222);
      Defer_Pos_365 := Parser.Current_Pos;

      if Defer_Pos_365 /= No_Token_Index then

         Row_Pos_222 := Defer_Pos_365;

      else
         Row_Pos_222 := No_Token_Index;
         goto Exit_Row_217_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_217_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_222 /= No_Token_Index then

         Transform_Res_183 := Allocate_Pragma_Argument_Assoc (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_183, Kind => Ada_Pragma_Argument_Assoc,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_222 = Pos then No_Token_Index else Row_Pos_222 - 1));

         Initialize_Fields_For_Pragma_Argument_Assoc
           (Self                         => Transform_Res_183,
            Pragma_Argument_Assoc_F_Id   => Defer_Res_364,
            Pragma_Argument_Assoc_F_Expr => Defer_Res_365);

         if Defer_Res_364 /= null and then Is_Incomplete (Defer_Res_364) then
            Transform_Res_183.Last_Attempted_Child := 0;
         elsif Defer_Res_364 /= null and then not Is_Ghost (Defer_Res_364) then
            Transform_Res_183.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_365 /= null and then Is_Incomplete (Defer_Res_365) then
            Transform_Res_183.Last_Attempted_Child := 0;
         elsif Defer_Res_365 /= null and then not Is_Ghost (Defer_Res_365) then
            Transform_Res_183.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Pragma_Argument_Transform_Parse_0_Memo,
         Row_Pos_222 /= No_Token_Index, Transform_Res_183, Pos, Row_Pos_222);

      Parser.Current_Pos := Row_Pos_222;

      return Transform_Res_183;
   end Pragma_Argument_Transform_Parse_0;

   function Pragma_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Pragma_Node
   is
      use Bare_Pragma_Node_Memos;

      Row_Pos_220       : Token_Index                := No_Token_Index;
      Token_Pos_318     : Token_Index                := No_Token_Index;
      Token_Res_318     : Token_Index                := No_Token_Index;
      Defer_Pos_361     : Token_Index                := No_Token_Index;
      Defer_Res_361     : Bare_Identifier            := No_Bare_Ada_Node;
      Row_Pos_221       : Token_Index                := No_Token_Index;
      Token_Pos_319     : Token_Index                := No_Token_Index;
      Token_Res_319     : Token_Index                := No_Token_Index;
      Lst_Cpos_26       : Token_Index                := No_Token_Index;
      Tmp_List_26       : Free_Parse_List;
      Defer_Pos_362     : Token_Index                := No_Token_Index;
      Defer_Res_362     : Bare_Pragma_Argument_Assoc := No_Bare_Ada_Node;
      Defer_Pos_363     : Token_Index                := No_Token_Index;
      Defer_Res_363     : Bare_Contract_Case_Assoc   := No_Bare_Ada_Node;
      Or_Pos_75         : Token_Index                := No_Token_Index;
      Or_Res_75         : Bare_Base_Assoc            := No_Bare_Ada_Node;
      Token_Pos_320     : Token_Index                := No_Token_Index;
      Token_Res_320     : Token_Index                := No_Token_Index;
      List_Pos_26       : Token_Index                := No_Token_Index;
      List_Res_26       : Bare_Base_Assoc_List       := No_Bare_Ada_Node;
      Token_Pos_321     : Token_Index                := No_Token_Index;
      Token_Res_321     : Token_Index                := No_Token_Index;
      Token_Pos_322     : Token_Index                := No_Token_Index;
      Token_Res_322     : Token_Index                := No_Token_Index;
      Transform_Res_182 : Bare_Pragma_Node           := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Pragma_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_182  := M.Instance;
         return Transform_Res_182;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_182;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_220 := Pos;

--  Start tok_code

      Token_Res_318 := Row_Pos_220;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_318));
      begin
         if T.Kind /= From_Token_Kind (Ada_Pragma) then
            Token_Pos_318 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_220 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_220,
                  Expected_Token_Id => Ada_Pragma,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_318 := Row_Pos_220 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_318 /= No_Token_Index then

         Row_Pos_220 := Token_Pos_318;

      else
         Row_Pos_220 := No_Token_Index;
         goto Exit_Row_215_0;

      end if;

      Defer_Res_361 := Identifier_Transform_Parse_0 (Parser, Row_Pos_220);
      Defer_Pos_361 := Parser.Current_Pos;

      if Defer_Pos_361 /= No_Token_Index then

         Row_Pos_220 := Defer_Pos_361;

      else
         Row_Pos_220 := No_Token_Index;
         goto Exit_Row_215_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_221 := Row_Pos_220;

--  Start tok_code

      Token_Res_319 := Row_Pos_221;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_319));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Open) then
            Token_Pos_319 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_221 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_221,
                  Expected_Token_Id => Ada_Par_Open,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_319 := Row_Pos_221 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_319 /= No_Token_Index then

         Row_Pos_221 := Token_Pos_319;

      else
         Row_Pos_221 := No_Token_Index;
         goto Exit_Row_216_0;

      end if;

--  Start list_code

      List_Pos_26 := No_Token_Index;

      Lst_Cpos_26 := Row_Pos_221;
      Tmp_List_26 := Get_Parse_List (Parser);

      loop

--  Start or_code

         Or_Pos_75 := No_Token_Index;
         Or_Res_75 := No_Bare_Ada_Node;

         Defer_Res_362 :=
           Pragma_Argument_Transform_Parse_0 (Parser, Lst_Cpos_26);
         Defer_Pos_362 := Parser.Current_Pos;

         if Defer_Pos_362 /= No_Token_Index then
            Or_Pos_75 := Defer_Pos_362;
            Or_Res_75 := Defer_Res_362;
            goto Exit_Or_74;
         end if;

         Defer_Res_363 :=
           Contract_Case_Assoc_Transform_Parse_0 (Parser, Lst_Cpos_26);
         Defer_Pos_363 := Parser.Current_Pos;

         if Defer_Pos_363 /= No_Token_Index then
            Or_Pos_75 := Defer_Pos_363;
            Or_Res_75 := Defer_Res_363;
            goto Exit_Or_74;
         end if;
         <<Exit_Or_74>>

--  End or_code

         exit when Or_Pos_75 = No_Token_Index;

         List_Pos_26 := Or_Pos_75;
         Lst_Cpos_26 := List_Pos_26;

         Tmp_List_26.Nodes.Append (Or_Res_75);

--  Start tok_code

         Token_Res_320 := Lst_Cpos_26;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_320));
         begin
            if T.Kind /= From_Token_Kind (Ada_Comma) then
               Token_Pos_320 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_26 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_26,
                     Expected_Token_Id => Ada_Comma,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_320 := Lst_Cpos_26 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_320 /= No_Token_Index then
            Lst_Cpos_26 := Token_Pos_320;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_26.Nodes.Length;
      begin
         List_Res_26 := Allocate_Base_Assoc_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_221;
            Token_End   :=
              (if Lst_Cpos_26 = Row_Pos_221 then Row_Pos_221
               else Lst_Cpos_26 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_221, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self            => List_Res_26, Kind => Ada_Base_Assoc_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_26, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_26.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_26.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_26);

--  End list_code

      if List_Pos_26 /= No_Token_Index then

         Row_Pos_221 := List_Pos_26;

      else
         Row_Pos_221 := No_Token_Index;
         goto Exit_Row_216_0;

      end if;

--  Start tok_code

      Token_Res_321 := Row_Pos_221;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_321));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Close) then
            Token_Pos_321 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_221 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_221,
                  Expected_Token_Id => Ada_Par_Close,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_321 := Row_Pos_221 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_321 /= No_Token_Index then

         Row_Pos_221 := Token_Pos_321;

      else
         Row_Pos_221 := No_Token_Index;
         goto Exit_Row_216_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_216_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_221 = No_Token_Index then

         List_Res_26 := Allocate_Base_Assoc_List (Parser.Mem_Pool);
         Initialize
           (Self            => List_Res_26, Kind => Ada_Base_Assoc_List,
            Unit => Parser.Unit, Token_Start_Index => Row_Pos_220 - 1,
            Token_End_Index => No_Token_Index);
         Initialize_List (Self => List_Res_26, Parser => Parser, Count => 0);

         Row_Pos_221 := Row_Pos_220;

      end if;

--  End opt_code

      if Row_Pos_221 /= No_Token_Index then

         Row_Pos_220 := Row_Pos_221;

      else
         Row_Pos_220 := No_Token_Index;
         goto Exit_Row_215_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_322 := Row_Pos_220;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_322));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_322 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_220 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_220,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_322 := Row_Pos_220 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_322 = No_Token_Index then

         Token_Res_322 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_220).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_322 := Row_Pos_220;

      end if;

--  End opt_code

      if Token_Pos_322 /= No_Token_Index then

         Row_Pos_220 := Token_Pos_322;

      else
         Row_Pos_220 := No_Token_Index;
         goto Exit_Row_215_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_215_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_220 /= No_Token_Index then

         Transform_Res_182 := Allocate_Pragma_Node (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_182, Kind => Ada_Pragma_Node,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_220 = Pos then No_Token_Index else Row_Pos_220 - 1));

         Initialize_Fields_For_Pragma_Node
           (Self => Transform_Res_182, Pragma_Node_F_Id => Defer_Res_361,
            Pragma_Node_F_Args => List_Res_26);

         if Defer_Res_361 /= null and then Is_Incomplete (Defer_Res_361) then
            Transform_Res_182.Last_Attempted_Child := 0;
         elsif Defer_Res_361 /= null and then not Is_Ghost (Defer_Res_361) then
            Transform_Res_182.Last_Attempted_Child := -1;
         end if;
         if List_Res_26 /= null and then Is_Incomplete (List_Res_26) then
            Transform_Res_182.Last_Attempted_Child := 0;
         elsif List_Res_26 /= null and then not Is_Ghost (List_Res_26) then
            Transform_Res_182.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Pragma_Transform_Parse_0_Memo,
         Row_Pos_220 /= No_Token_Index, Transform_Res_182, Pos, Row_Pos_220);

      Parser.Current_Pos := Row_Pos_220;

      return Transform_Res_182;
   end Pragma_Transform_Parse_0;

   function Simple_Stmt_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Defer_Pos_337 : Token_Index                := No_Token_Index;
      Defer_Res_337 : Bare_Null_Stmt             := No_Bare_Ada_Node;
      Defer_Pos_338 : Token_Index                := No_Token_Index;
      Defer_Res_338 : Bare_Assign_Stmt           := No_Bare_Ada_Node;
      Defer_Pos_339 : Token_Index                := No_Token_Index;
      Defer_Res_339 : Bare_Goto_Stmt             := No_Bare_Ada_Node;
      Defer_Pos_340 : Token_Index                := No_Token_Index;
      Defer_Res_340 : Bare_Exit_Stmt             := No_Bare_Ada_Node;
      Defer_Pos_341 : Token_Index                := No_Token_Index;
      Defer_Res_341 : Bare_Return_Stmt           := No_Bare_Ada_Node;
      Defer_Pos_342 : Token_Index                := No_Token_Index;
      Defer_Res_342 : Bare_Requeue_Stmt          := No_Bare_Ada_Node;
      Defer_Pos_343 : Token_Index                := No_Token_Index;
      Defer_Res_343 : Bare_Call_Stmt             := No_Bare_Ada_Node;
      Defer_Pos_344 : Token_Index                := No_Token_Index;
      Defer_Res_344 : Bare_Abort_Stmt            := No_Bare_Ada_Node;
      Defer_Pos_345 : Token_Index                := No_Token_Index;
      Defer_Res_345 : Bare_Delay_Stmt            := No_Bare_Ada_Node;
      Defer_Pos_346 : Token_Index                := No_Token_Index;
      Defer_Res_346 : Bare_Raise_Stmt            := No_Bare_Ada_Node;
      Defer_Pos_347 : Token_Index                := No_Token_Index;
      Defer_Res_347 : Bare_Terminate_Alternative := No_Bare_Ada_Node;
      Defer_Pos_348 : Token_Index                := No_Token_Index;
      Defer_Res_348 : Bare_Pragma_Node           := No_Bare_Ada_Node;
      Or_Pos_73     : Token_Index                := No_Token_Index;
      Or_Res_73     : Bare_Ada_Node              := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Simple_Stmt_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_73          := M.Instance;
         return Or_Res_73;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_73;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_73 := No_Token_Index;
      Or_Res_73 := No_Bare_Ada_Node;

      Defer_Res_337 := Null_Stmt_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_337 := Parser.Current_Pos;

      if Defer_Pos_337 /= No_Token_Index then
         Or_Pos_73 := Defer_Pos_337;
         Or_Res_73 := Defer_Res_337;
         goto Exit_Or_72;
      end if;

      Defer_Res_338 := Assignment_Stmt_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_338 := Parser.Current_Pos;

      if Defer_Pos_338 /= No_Token_Index then
         Or_Pos_73 := Defer_Pos_338;
         Or_Res_73 := Defer_Res_338;
         goto Exit_Or_72;
      end if;

      Defer_Res_339 := Goto_Stmt_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_339 := Parser.Current_Pos;

      if Defer_Pos_339 /= No_Token_Index then
         Or_Pos_73 := Defer_Pos_339;
         Or_Res_73 := Defer_Res_339;
         goto Exit_Or_72;
      end if;

      Defer_Res_340 := Exit_Stmt_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_340 := Parser.Current_Pos;

      if Defer_Pos_340 /= No_Token_Index then
         Or_Pos_73 := Defer_Pos_340;
         Or_Res_73 := Defer_Res_340;
         goto Exit_Or_72;
      end if;

      Defer_Res_341 := Return_Stmt_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_341 := Parser.Current_Pos;

      if Defer_Pos_341 /= No_Token_Index then
         Or_Pos_73 := Defer_Pos_341;
         Or_Res_73 := Defer_Res_341;
         goto Exit_Or_72;
      end if;

      Defer_Res_342 := Requeue_Stmt_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_342 := Parser.Current_Pos;

      if Defer_Pos_342 /= No_Token_Index then
         Or_Pos_73 := Defer_Pos_342;
         Or_Res_73 := Defer_Res_342;
         goto Exit_Or_72;
      end if;

      Defer_Res_343 := Call_Stmt_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_343 := Parser.Current_Pos;

      if Defer_Pos_343 /= No_Token_Index then
         Or_Pos_73 := Defer_Pos_343;
         Or_Res_73 := Defer_Res_343;
         goto Exit_Or_72;
      end if;

      Defer_Res_344 := Abort_Stmt_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_344 := Parser.Current_Pos;

      if Defer_Pos_344 /= No_Token_Index then
         Or_Pos_73 := Defer_Pos_344;
         Or_Res_73 := Defer_Res_344;
         goto Exit_Or_72;
      end if;

      Defer_Res_345 := Delay_Stmt_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_345 := Parser.Current_Pos;

      if Defer_Pos_345 /= No_Token_Index then
         Or_Pos_73 := Defer_Pos_345;
         Or_Res_73 := Defer_Res_345;
         goto Exit_Or_72;
      end if;

      Defer_Res_346 := Raise_Stmt_Or_Parse_0 (Parser, Pos);
      Defer_Pos_346 := Parser.Current_Pos;

      if Defer_Pos_346 /= No_Token_Index then
         Or_Pos_73 := Defer_Pos_346;
         Or_Res_73 := Defer_Res_346;
         goto Exit_Or_72;
      end if;

      Defer_Res_347 := Terminate_Alternative_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_347 := Parser.Current_Pos;

      if Defer_Pos_347 /= No_Token_Index then
         Or_Pos_73 := Defer_Pos_347;
         Or_Res_73 := Defer_Res_347;
         goto Exit_Or_72;
      end if;

      Defer_Res_348 := Pragma_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_348 := Parser.Current_Pos;

      if Defer_Pos_348 /= No_Token_Index then
         Or_Pos_73 := Defer_Pos_348;
         Or_Res_73 := Defer_Res_348;
         goto Exit_Or_72;
      end if;
      <<Exit_Or_72>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Simple_Stmt_Or_Parse_0_Memo,
         Or_Pos_73 /= No_Token_Index, Or_Res_73, Pos, Or_Pos_73);

      Parser.Current_Pos := Or_Pos_73;

      return Or_Res_73;
   end Simple_Stmt_Or_Parse_0;

   function Stmt_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Defer_Pos_279 : Token_Index         := No_Token_Index;
      Defer_Res_279 : Bare_Composite_Stmt := No_Bare_Ada_Node;
      Defer_Pos_280 : Token_Index         := No_Token_Index;
      Defer_Res_280 : Bare_Ada_Node       := No_Bare_Ada_Node;
      Or_Pos_66     : Token_Index         := No_Token_Index;
      Or_Res_66     : Bare_Ada_Node       := No_Bare_Ada_Node;

      M : Memo_Entry := Get (Parser.Private_Part.Stmt_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_66          := M.Instance;
         return Or_Res_66;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_66;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_66 := No_Token_Index;
      Or_Res_66 := No_Bare_Ada_Node;

      Defer_Res_279 := Compound_Stmt_Or_Parse_0 (Parser, Pos);
      Defer_Pos_279 := Parser.Current_Pos;

      if Defer_Pos_279 /= No_Token_Index then
         Or_Pos_66 := Defer_Pos_279;
         Or_Res_66 := Defer_Res_279;
         goto Exit_Or_65;
      end if;

      Defer_Res_280 := Simple_Stmt_Or_Parse_0 (Parser, Pos);
      Defer_Pos_280 := Parser.Current_Pos;

      if Defer_Pos_280 /= No_Token_Index then
         Or_Pos_66 := Defer_Pos_280;
         Or_Res_66 := Defer_Res_280;
         goto Exit_Or_65;
      end if;
      <<Exit_Or_65>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Stmt_Or_Parse_0_Memo, Or_Pos_66 /= No_Token_Index,
         Or_Res_66, Pos, Or_Pos_66);

      Parser.Current_Pos := Or_Pos_66;

      return Or_Res_66;
   end Stmt_Or_Parse_0;

   function Label_Transform_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Label
   is
      use Bare_Label_Memos;

      Nobt_27                 : Boolean            := False;
      Row_Pos_224             : Token_Index        := No_Token_Index;
      Token_Pos_324           : Token_Index        := No_Token_Index;
      Token_Res_324           : Token_Index        := No_Token_Index;
      Row_Pos_225             : Token_Index        := No_Token_Index;
      Defer_Pos_366           : Token_Index        := No_Token_Index;
      Defer_Res_366           : Bare_Defining_Name := No_Bare_Ada_Node;
      Transform_Res_184       : Bare_Label_Decl    := No_Bare_Ada_Node;
      Token_Pos_325           : Token_Index        := No_Token_Index;
      Token_Res_325           : Token_Index        := No_Token_Index;
      Row_Progress_28         : Integer            := 0;
      Transform_Res_185       : Bare_Label         := No_Bare_Ada_Node;
      Transform_Has_Failed_28 : Boolean            := False;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Label_Transform_Parse_1_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_185  := M.Instance;
         return Transform_Res_185;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_185;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_224 := Pos;

--  Start tok_code

      Token_Res_324 := Row_Pos_224;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_324));
      begin
         if T.Kind /= From_Token_Kind (Ada_Label_Start) then
            Token_Pos_324 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_224 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_224,
                  Expected_Token_Id => Ada_Label_Start,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_324 := Row_Pos_224 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_28 := 1;

      if Token_Pos_324 /= No_Token_Index then

         Row_Pos_224 := Token_Pos_324;

      else
         Row_Pos_224 := No_Token_Index;
         goto Exit_Row_219_0;

      end if;

      Nobt_27 := True;

      Row_Progress_28 := 2;

      if Row_Pos_224 /= No_Token_Index then

         Row_Pos_224 := Row_Pos_224;

      else
         Row_Pos_224 := No_Token_Index;
         goto Exit_Row_219_0;

      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_225 := Row_Pos_224;

      Defer_Res_366 := Defining_Id_Transform_Parse_0 (Parser, Row_Pos_225);
      Defer_Pos_366 := Parser.Current_Pos;

      if Defer_Pos_366 /= No_Token_Index then

         Row_Pos_225 := Defer_Pos_366;

      else
         Row_Pos_225 := No_Token_Index;
         goto Exit_Row_220_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_220_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_225 /= No_Token_Index then

         Transform_Res_184 := Allocate_Label_Decl (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_184, Kind => Ada_Label_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_224,
            Token_End_Index =>
              (if Row_Pos_225 = Row_Pos_224 then No_Token_Index
               else Row_Pos_225 - 1));

         Initialize_Fields_For_Label_Decl
           (Self => Transform_Res_184, Label_Decl_F_Name => Defer_Res_366);

         if Defer_Res_366 /= null and then Is_Incomplete (Defer_Res_366) then
            Transform_Res_184.Last_Attempted_Child := 0;
         elsif Defer_Res_366 /= null and then not Is_Ghost (Defer_Res_366) then
            Transform_Res_184.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      Row_Progress_28 := 3;

      if Row_Pos_225 /= No_Token_Index then

         Row_Pos_224 := Row_Pos_225;

      else
         Row_Pos_224 := No_Token_Index;
         goto Exit_Row_219_0;

      end if;

--  Start tok_code

      Token_Res_325 := Row_Pos_224;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_325));
      begin
         if T.Kind /= From_Token_Kind (Ada_Label_End) then
            Token_Pos_325 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_224 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_224,
                  Expected_Token_Id => Ada_Label_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_325 := Row_Pos_224 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_28 := 4;

      if Token_Pos_325 /= No_Token_Index then

         Row_Pos_224 := Token_Pos_325;

      else
         Row_Pos_224 := No_Token_Index;
         goto Exit_Row_219_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_219_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_224 = No_Token_Index and then Nobt_27 then
         Row_Pos_224             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_28 := True;
      end if;

      if Row_Pos_224 /= No_Token_Index then

         Transform_Res_185 := Allocate_Label (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_185, Kind => Ada_Label, Unit => Parser.Unit,

            Token_Start_Index => Pos,
            Token_End_Index   =>
              (if Row_Pos_224 = Pos then No_Token_Index else Row_Pos_224 - 1));

         Initialize_Fields_For_Label
           (Self => Transform_Res_185, Label_F_Decl => Transform_Res_184);

         if Transform_Res_184 /= null
           and then Is_Incomplete (Transform_Res_184)
         then
            Transform_Res_185.Last_Attempted_Child := 0;
         elsif Transform_Res_184 /= null
           and then not Is_Ghost (Transform_Res_184)
         then
            Transform_Res_185.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_28 then
            Transform_Res_185.Last_Attempted_Child := Row_Progress_28;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <label>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Label_Transform_Parse_1_Memo,
         Row_Pos_224 /= No_Token_Index, Transform_Res_185, Pos, Row_Pos_224);

      Parser.Current_Pos := Row_Pos_224;

      return Transform_Res_185;
   end Label_Transform_Parse_1;

   function Stmts_List_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Stmt_List
   is
      use Bare_Stmt_List_Memos;

      Lst_Cpos_20       : Token_Index     := No_Token_Index;
      Tmp_List_20       : Free_Parse_List;
      Defer_Pos_277     : Token_Index     := No_Token_Index;
      Defer_Res_277     : Bare_Ada_Node   := No_Bare_Ada_Node;
      Defer_Pos_278     : Token_Index     := No_Token_Index;
      Defer_Res_278     : Bare_Label      := No_Bare_Ada_Node;
      Row_Pos_165       : Token_Index     := No_Token_Index;
      Transform_Res_141 : Bare_Error_Stmt := No_Bare_Ada_Node;
      Skip_Pos_1        : Token_Index     := No_Token_Index;
      Skip_Dummy_1      : Bare_Ada_Node   := No_Bare_Ada_Node;
      Or_Pos_65         : Token_Index     := No_Token_Index;
      Or_Res_65         : Bare_Ada_Node   := No_Bare_Ada_Node;
      List_Pos_20       : Token_Index     := No_Token_Index;
      List_Res_20       : Bare_Stmt_List  := No_Bare_Ada_Node;

      M : Memo_Entry := Get (Parser.Private_Part.Stmts_List_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         List_Res_20        := M.Instance;
         return List_Res_20;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return List_Res_20;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start list_code

      List_Pos_20 := Pos;

      Lst_Cpos_20 := Pos;
      Tmp_List_20 := Get_Parse_List (Parser);

      loop

--  Start or_code

         Or_Pos_65 := No_Token_Index;
         Or_Res_65 := No_Bare_Ada_Node;

         Defer_Res_277 := Stmt_Or_Parse_0 (Parser, Lst_Cpos_20);
         Defer_Pos_277 := Parser.Current_Pos;

         if Defer_Pos_277 /= No_Token_Index then
            Or_Pos_65 := Defer_Pos_277;
            Or_Res_65 := Defer_Res_277;
            goto Exit_Or_64;
         end if;

         Defer_Res_278 := Label_Transform_Parse_1 (Parser, Lst_Cpos_20);
         Defer_Pos_278 := Parser.Current_Pos;

         if Defer_Pos_278 /= No_Token_Index then
            Or_Pos_65 := Defer_Pos_278;
            Or_Res_65 := Defer_Res_278;
            goto Exit_Or_64;
         end if;

         if Get_Token (Parser.TDH.all, Lst_Cpos_20).Kind =
           From_Token_Kind (Ada_Termination)
         then
            Skip_Pos_1 := No_Token_Index;
            goto Exit_Or_75;
         end if;

         for Fn of Parser.Private_Part.Dont_Skip loop
            Skip_Dummy_1 := Fn (Parser, Lst_Cpos_20);

            if Parser.Current_Pos /= No_Token_Index then
               Skip_Pos_1 := No_Token_Index;
               goto Exit_Or_75;
            end if;
         end loop;

         Skip_Pos_1 := Lst_Cpos_20 + 1;

--  Start transform_code

--  Start row_code

         Row_Pos_165 := Lst_Cpos_20;

         pragma Warnings (Off, "referenced");
         <<Exit_Row_221_0>>
         pragma Warnings (On, "referenced");

--  End row_code

         if Row_Pos_165 /= No_Token_Index then

            Transform_Res_141 := Allocate_Error_Stmt (Parser.Mem_Pool);

            Initialize
              (Self            => Transform_Res_141, Kind => Ada_Error_Stmt,
               Unit            => Parser.Unit,
Token_Start_Index              => Lst_Cpos_20,
               Token_End_Index =>
                 (if Row_Pos_165 = Lst_Cpos_20 then No_Token_Index
                  else Row_Pos_165 - 1));

         end if;

--  End transform_code

         Transform_Res_141.Token_End_Index := Lst_Cpos_20;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Lst_Cpos_20).Sloc_Range,
            To_Text ("Skipped token ") &
            Common.Text
              (Wrap_Token_Reference
                 (Parser.TDH, (Lst_Cpos_20, No_Token_Index))));

         <<Exit_Or_75>>

         if Skip_Pos_1 /= No_Token_Index then
            Or_Pos_65 := Skip_Pos_1;
            Or_Res_65 := Transform_Res_141;
            goto Exit_Or_64;
         end if;
         <<Exit_Or_64>>

--  End or_code

         exit when Or_Pos_65 = No_Token_Index;

         List_Pos_20 := Or_Pos_65;
         Lst_Cpos_20 := List_Pos_20;

         Tmp_List_20.Nodes.Append (Or_Res_65);

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_20.Nodes.Length;
      begin
         List_Res_20 := Allocate_Stmt_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Pos;
            Token_End := (if Lst_Cpos_20 = Pos then Pos else Lst_Cpos_20 - 1);

         else
            Token_Start := Token_Index'Max (Pos, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self => List_Res_20, Kind => Ada_Stmt_List, Unit => Parser.Unit,
            Token_Start_Index => Token_Start, Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_20, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_20.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_20.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_20);

--  End list_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Stmts_List_Parse_0_Memo,
         List_Pos_20 /= No_Token_Index, List_Res_20, Pos, List_Pos_20);

      Parser.Current_Pos := List_Pos_20;

      return List_Res_20;
   end Stmts_List_Parse_0;

   function Exception_Handler_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Exception_Handler
   is
      use Bare_Exception_Handler_Memos;

      Row_Pos_226       : Token_Index            := No_Token_Index;
      Token_Pos_326     : Token_Index            := No_Token_Index;
      Token_Res_326     : Token_Index            := No_Token_Index;
      Row_Pos_227       : Token_Index            := No_Token_Index;
      Defer_Pos_367     : Token_Index            := No_Token_Index;
      Defer_Res_367     : Bare_Defining_Name     := No_Bare_Ada_Node;
      Token_Pos_327     : Token_Index            := No_Token_Index;
      Token_Res_327     : Token_Index            := No_Token_Index;
      Lst_Cpos_27       : Token_Index            := No_Token_Index;
      Tmp_List_27       : Free_Parse_List;
      Defer_Pos_368     : Token_Index            := No_Token_Index;
      Defer_Res_368     : Bare_Name              := No_Bare_Ada_Node;
      Defer_Pos_369     : Token_Index            := No_Token_Index;
      Defer_Res_369     : Bare_Others_Designator := No_Bare_Ada_Node;
      Or_Pos_76         : Token_Index            := No_Token_Index;
      Or_Res_76         : Bare_Ada_Node          := No_Bare_Ada_Node;
      Token_Pos_328     : Token_Index            := No_Token_Index;
      Token_Res_328     : Token_Index            := No_Token_Index;
      List_Pos_27       : Token_Index            := No_Token_Index;
      List_Res_27       : Bare_Alternatives_List := No_Bare_Ada_Node;
      Token_Pos_329     : Token_Index            := No_Token_Index;
      Token_Res_329     : Token_Index            := No_Token_Index;
      Defer_Pos_370     : Token_Index            := No_Token_Index;
      Defer_Res_370     : Bare_Stmt_List         := No_Bare_Ada_Node;
      Transform_Res_186 : Bare_Exception_Handler := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Exception_Handler_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_186  := M.Instance;
         return Transform_Res_186;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_186;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_226 := Pos;

--  Start tok_code

      Token_Res_326 := Row_Pos_226;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_326));
      begin
         if T.Kind /= From_Token_Kind (Ada_When) then
            Token_Pos_326 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_226 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_226,
                  Expected_Token_Id => Ada_When,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_326 := Row_Pos_226 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_326 /= No_Token_Index then

         Row_Pos_226 := Token_Pos_326;

      else
         Row_Pos_226 := No_Token_Index;
         goto Exit_Row_223_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_227 := Row_Pos_226;

      Defer_Res_367 := Defining_Id_Transform_Parse_0 (Parser, Row_Pos_227);
      Defer_Pos_367 := Parser.Current_Pos;

      if Defer_Pos_367 /= No_Token_Index then

         Row_Pos_227 := Defer_Pos_367;

      else
         Row_Pos_227 := No_Token_Index;
         goto Exit_Row_224_0;

      end if;

--  Start tok_code

      Token_Res_327 := Row_Pos_227;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_327));
      begin
         if T.Kind /= From_Token_Kind (Ada_Colon) then
            Token_Pos_327 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_227 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_227,
                  Expected_Token_Id => Ada_Colon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_327 := Row_Pos_227 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_327 /= No_Token_Index then

         Row_Pos_227 := Token_Pos_327;

      else
         Row_Pos_227 := No_Token_Index;
         goto Exit_Row_224_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_224_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_227 = No_Token_Index then

         Defer_Res_367 := No_Bare_Ada_Node;

         Row_Pos_227 := Row_Pos_226;

      end if;

--  End opt_code

      if Row_Pos_227 /= No_Token_Index then

         Row_Pos_226 := Row_Pos_227;

      else
         Row_Pos_226 := No_Token_Index;
         goto Exit_Row_223_0;

      end if;

--  Start list_code

      List_Pos_27 := No_Token_Index;

      Lst_Cpos_27 := Row_Pos_226;
      Tmp_List_27 := Get_Parse_List (Parser);

      loop

--  Start or_code

         Or_Pos_76 := No_Token_Index;
         Or_Res_76 := No_Bare_Ada_Node;

         Defer_Res_368 := Name_Or_Parse_1 (Parser, Lst_Cpos_27);
         Defer_Pos_368 := Parser.Current_Pos;

         if Defer_Pos_368 /= No_Token_Index then
            Or_Pos_76 := Defer_Pos_368;
            Or_Res_76 := Defer_Res_368;
            goto Exit_Or_77;
         end if;

         Defer_Res_369 :=
           Others_Designator_Transform_Parse_0 (Parser, Lst_Cpos_27);
         Defer_Pos_369 := Parser.Current_Pos;

         if Defer_Pos_369 /= No_Token_Index then
            Or_Pos_76 := Defer_Pos_369;
            Or_Res_76 := Defer_Res_369;
            goto Exit_Or_77;
         end if;
         <<Exit_Or_77>>

--  End or_code

         exit when Or_Pos_76 = No_Token_Index;

         List_Pos_27 := Or_Pos_76;
         Lst_Cpos_27 := List_Pos_27;

         Tmp_List_27.Nodes.Append (Or_Res_76);

--  Start tok_code

         Token_Res_328 := Lst_Cpos_27;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_328));
         begin
            if T.Kind /= From_Token_Kind (Ada_Pipe) then
               Token_Pos_328 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_27 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_27,
                     Expected_Token_Id => Ada_Pipe,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_328 := Lst_Cpos_27 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_328 /= No_Token_Index then
            Lst_Cpos_27 := Token_Pos_328;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_27.Nodes.Length;
      begin
         List_Res_27 := Allocate_Alternatives_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_226;
            Token_End   :=
              (if Lst_Cpos_27 = Row_Pos_226 then Row_Pos_226
               else Lst_Cpos_27 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_226, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self            => List_Res_27, Kind => Ada_Alternatives_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_27, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_27.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_27.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_27);

--  End list_code

      if List_Pos_27 /= No_Token_Index then

         Row_Pos_226 := List_Pos_27;

      else
         Row_Pos_226 := No_Token_Index;
         goto Exit_Row_223_0;

      end if;

--  Start tok_code

      Token_Res_329 := Row_Pos_226;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_329));
      begin
         if T.Kind /= From_Token_Kind (Ada_Arrow) then
            Token_Pos_329 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_226 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_226,
                  Expected_Token_Id => Ada_Arrow,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_329 := Row_Pos_226 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_329 /= No_Token_Index then

         Row_Pos_226 := Token_Pos_329;

      else
         Row_Pos_226 := No_Token_Index;
         goto Exit_Row_223_0;

      end if;

      Parser.Private_Part.Dont_Skip.Append
        (Dontskip_Exception_Handler_0_Extract_Parse_0'Access);

      Defer_Res_370 := Stmts_List_Parse_0 (Parser, Row_Pos_226);
      Defer_Pos_370 := Parser.Current_Pos;

      Parser.Private_Part.Dont_Skip.Delete_Last;

      if Defer_Pos_370 /= No_Token_Index then

         Row_Pos_226 := Defer_Pos_370;

      else
         Row_Pos_226 := No_Token_Index;
         goto Exit_Row_223_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_223_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_226 /= No_Token_Index then

         Transform_Res_186 := Allocate_Exception_Handler (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_186, Kind => Ada_Exception_Handler,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_226 = Pos then No_Token_Index else Row_Pos_226 - 1));

         Initialize_Fields_For_Exception_Handler
           (Self                                   => Transform_Res_186,
            Exception_Handler_F_Exception_Name     => Defer_Res_367,
            Exception_Handler_F_Handled_Exceptions => List_Res_27,
            Exception_Handler_F_Stmts              => Defer_Res_370);

         if Defer_Res_367 /= null and then Is_Incomplete (Defer_Res_367) then
            Transform_Res_186.Last_Attempted_Child := 0;
         elsif Defer_Res_367 /= null and then not Is_Ghost (Defer_Res_367) then
            Transform_Res_186.Last_Attempted_Child := -1;
         end if;
         if List_Res_27 /= null and then Is_Incomplete (List_Res_27) then
            Transform_Res_186.Last_Attempted_Child := 0;
         elsif List_Res_27 /= null and then not Is_Ghost (List_Res_27) then
            Transform_Res_186.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_370 /= null and then Is_Incomplete (Defer_Res_370) then
            Transform_Res_186.Last_Attempted_Child := 0;
         elsif Defer_Res_370 /= null and then not Is_Ghost (Defer_Res_370) then
            Transform_Res_186.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Exception_Handler_Transform_Parse_0_Memo,
         Row_Pos_226 /= No_Token_Index, Transform_Res_186, Pos, Row_Pos_226);

      Parser.Current_Pos := Row_Pos_226;

      return Transform_Res_186;
   end Exception_Handler_Transform_Parse_0;

   function Handled_Stmts_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Handled_Stmts
   is
      use Bare_Handled_Stmts_Memos;

      Row_Pos_163       : Token_Index            := No_Token_Index;
      Defer_Pos_274     : Token_Index            := No_Token_Index;
      Defer_Res_274     : Bare_Stmt_List         := No_Bare_Ada_Node;
      Row_Pos_164       : Token_Index            := No_Token_Index;
      Token_Pos_220     : Token_Index            := No_Token_Index;
      Token_Res_220     : Token_Index            := No_Token_Index;
      Lst_Cpos_19       : Token_Index            := No_Token_Index;
      Tmp_List_19       : Free_Parse_List;
      Defer_Pos_275     : Token_Index            := No_Token_Index;
      Defer_Res_275     : Bare_Exception_Handler := No_Bare_Ada_Node;
      Defer_Pos_276     : Token_Index            := No_Token_Index;
      Defer_Res_276     : Bare_Pragma_Node       := No_Bare_Ada_Node;
      Or_Pos_64         : Token_Index            := No_Token_Index;
      Or_Res_64         : Bare_Ada_Node          := No_Bare_Ada_Node;
      List_Pos_19       : Token_Index            := No_Token_Index;
      List_Res_19       : Bare_Ada_Node_List     := No_Bare_Ada_Node;
      Transform_Res_140 : Bare_Handled_Stmts     := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Handled_Stmts_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_140  := M.Instance;
         return Transform_Res_140;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_140;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_163 := Pos;

      Parser.Private_Part.Dont_Skip.Append
        (Dontskip_Handled_Stmts_0_Extract_Parse_0'Access);

      Defer_Res_274 := Stmts_List_Parse_0 (Parser, Row_Pos_163);
      Defer_Pos_274 := Parser.Current_Pos;

      Parser.Private_Part.Dont_Skip.Delete_Last;

      if Defer_Pos_274 /= No_Token_Index then

         Row_Pos_163 := Defer_Pos_274;

      else
         Row_Pos_163 := No_Token_Index;
         goto Exit_Row_160_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_164 := Row_Pos_163;

--  Start tok_code

      Token_Res_220 := Row_Pos_164;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_220));
      begin
         if T.Kind /= From_Token_Kind (Ada_Exception) then
            Token_Pos_220 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_164 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_164,
                  Expected_Token_Id => Ada_Exception,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_220 := Row_Pos_164 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_220 /= No_Token_Index then

         Row_Pos_164 := Token_Pos_220;

      else
         Row_Pos_164 := No_Token_Index;
         goto Exit_Row_222_0;

      end if;

--  Start list_code

      List_Pos_19 := No_Token_Index;

      Lst_Cpos_19 := Row_Pos_164;
      Tmp_List_19 := Get_Parse_List (Parser);

      loop

--  Start or_code

         Or_Pos_64 := No_Token_Index;
         Or_Res_64 := No_Bare_Ada_Node;

         Defer_Res_275 :=
           Exception_Handler_Transform_Parse_0 (Parser, Lst_Cpos_19);
         Defer_Pos_275 := Parser.Current_Pos;

         if Defer_Pos_275 /= No_Token_Index then
            Or_Pos_64 := Defer_Pos_275;
            Or_Res_64 := Defer_Res_275;
            goto Exit_Or_76;
         end if;

         Defer_Res_276 := Pragma_Transform_Parse_0 (Parser, Lst_Cpos_19);
         Defer_Pos_276 := Parser.Current_Pos;

         if Defer_Pos_276 /= No_Token_Index then
            Or_Pos_64 := Defer_Pos_276;
            Or_Res_64 := Defer_Res_276;
            goto Exit_Or_76;
         end if;
         <<Exit_Or_76>>

--  End or_code

         exit when Or_Pos_64 = No_Token_Index;

         List_Pos_19 := Or_Pos_64;
         Lst_Cpos_19 := List_Pos_19;

         Tmp_List_19.Nodes.Append (Or_Res_64);

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_19.Nodes.Length;
      begin
         List_Res_19 := Allocate_Ada_Node_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_164;
            Token_End   :=
              (if Lst_Cpos_19 = Row_Pos_164 then Row_Pos_164
               else Lst_Cpos_19 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_164, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self            => List_Res_19, Kind => Ada_Ada_Node_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_19, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_19.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_19.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_19);

--  End list_code

      if List_Pos_19 /= No_Token_Index then

         Row_Pos_164 := List_Pos_19;

      else
         Row_Pos_164 := No_Token_Index;
         goto Exit_Row_222_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_222_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_164 = No_Token_Index then

         List_Res_19 := Allocate_Ada_Node_List (Parser.Mem_Pool);
         Initialize
           (Self            => List_Res_19, Kind => Ada_Ada_Node_List,
            Unit => Parser.Unit, Token_Start_Index => Row_Pos_163 - 1,
            Token_End_Index => No_Token_Index);
         Initialize_List (Self => List_Res_19, Parser => Parser, Count => 0);

         Row_Pos_164 := Row_Pos_163;

      end if;

--  End opt_code

      if Row_Pos_164 /= No_Token_Index then

         Row_Pos_163 := Row_Pos_164;

      else
         Row_Pos_163 := No_Token_Index;
         goto Exit_Row_160_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_160_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_163 /= No_Token_Index then

         Transform_Res_140 := Allocate_Handled_Stmts (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_140, Kind => Ada_Handled_Stmts,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_163 = Pos then No_Token_Index else Row_Pos_163 - 1));

         Initialize_Fields_For_Handled_Stmts
           (Self => Transform_Res_140, Handled_Stmts_F_Stmts => Defer_Res_274,
            Handled_Stmts_F_Exceptions => List_Res_19);

         if Defer_Res_274 /= null and then Is_Incomplete (Defer_Res_274) then
            Transform_Res_140.Last_Attempted_Child := 0;
         elsif Defer_Res_274 /= null and then not Is_Ghost (Defer_Res_274) then
            Transform_Res_140.Last_Attempted_Child := -1;
         end if;
         if List_Res_19 /= null and then Is_Incomplete (List_Res_19) then
            Transform_Res_140.Last_Attempted_Child := 0;
         elsif List_Res_19 /= null and then not Is_Ghost (List_Res_19) then
            Transform_Res_140.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Handled_Stmts_Transform_Parse_0_Memo,
         Row_Pos_163 /= No_Token_Index, Transform_Res_140, Pos, Row_Pos_163);

      Parser.Current_Pos := Row_Pos_163;

      return Transform_Res_140;
   end Handled_Stmts_Transform_Parse_0;

   function Subp_Body_Transform_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Subp_Body
   is
      use Bare_Subp_Body_Memos;

      Nobt_14                 : Boolean               := False;
      Row_Pos_160             : Token_Index           := No_Token_Index;
      Defer_Pos_267           : Token_Index           := No_Token_Index;
      Defer_Res_267           : Bare_Overriding_Node  := No_Bare_Ada_Node;
      Defer_Pos_268           : Token_Index           := No_Token_Index;
      Defer_Res_268           : Bare_Subp_Spec        := No_Bare_Ada_Node;
      Defer_Pos_269           : Token_Index           := No_Token_Index;
      Defer_Res_269           : Bare_Aspect_Spec      := No_Bare_Ada_Node;
      Token_Pos_216           : Token_Index           := No_Token_Index;
      Token_Res_216           : Token_Index           := No_Token_Index;
      Defer_Pos_270           : Token_Index           := No_Token_Index;
      Defer_Res_270           : Bare_Declarative_Part := No_Bare_Ada_Node;
      Token_Pos_217           : Token_Index           := No_Token_Index;
      Token_Res_217           : Token_Index           := No_Token_Index;
      Defer_Pos_271           : Token_Index           := No_Token_Index;
      Defer_Res_271           : Bare_Handled_Stmts    := No_Bare_Ada_Node;
      Row_Pos_161             : Token_Index           := No_Token_Index;
      Token_Pos_218           : Token_Index           := No_Token_Index;
      Token_Res_218           : Token_Index           := No_Token_Index;
      Row_Pos_162             : Token_Index           := No_Token_Index;
      Defer_Pos_272           : Token_Index           := No_Token_Index;
      Defer_Res_272           : Bare_Name             := No_Bare_Ada_Node;
      Transform_Res_138       : Bare_End_Name         := No_Bare_Ada_Node;
      Token_Pos_219           : Token_Index           := No_Token_Index;
      Token_Res_219           : Token_Index           := No_Token_Index;
      Row_Progress_14         : Integer               := 0;
      Transform_Res_139       : Bare_Subp_Body        := No_Bare_Ada_Node;
      Transform_Has_Failed_14 : Boolean               := False;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Subp_Body_Transform_Parse_1_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_139  := M.Instance;
         return Transform_Res_139;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_139;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_160 := Pos;

      Defer_Res_267 := Overriding_Indicator_Or_Parse_0 (Parser, Row_Pos_160);
      Defer_Pos_267 := Parser.Current_Pos;

      Row_Progress_14 := 1;

      if Defer_Pos_267 /= No_Token_Index then

         Row_Pos_160 := Defer_Pos_267;

      else
         Row_Pos_160 := No_Token_Index;
         goto Exit_Row_159_0;

      end if;

      Defer_Res_268 := Subp_Spec_Transform_Parse_2 (Parser, Row_Pos_160);
      Defer_Pos_268 := Parser.Current_Pos;

      Row_Progress_14 := 2;

      if Defer_Pos_268 /= No_Token_Index then

         Row_Pos_160 := Defer_Pos_268;

      else
         Row_Pos_160 := No_Token_Index;
         goto Exit_Row_159_0;

      end if;

      Defer_Res_269 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_160);
      Defer_Pos_269 := Parser.Current_Pos;

      Row_Progress_14 := 3;

      if Defer_Pos_269 /= No_Token_Index then

         Row_Pos_160 := Defer_Pos_269;

      else
         Row_Pos_160 := No_Token_Index;
         goto Exit_Row_159_0;

      end if;

--  Start tok_code

      Token_Res_216 := Row_Pos_160;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_216));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_216 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_160 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_160,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_216 := Row_Pos_160 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_14 := 4;

      if Token_Pos_216 /= No_Token_Index then

         Row_Pos_160 := Token_Pos_216;

      else
         Row_Pos_160 := No_Token_Index;
         goto Exit_Row_159_0;

      end if;

      Nobt_14 := True;

      Row_Progress_14 := 5;

      if Row_Pos_160 /= No_Token_Index then

         Row_Pos_160 := Row_Pos_160;

      else
         Row_Pos_160 := No_Token_Index;
         goto Exit_Row_159_0;

      end if;

      Defer_Res_270 := Recov_Decl_Part_Dont_Skip_Parse_0 (Parser, Row_Pos_160);
      Defer_Pos_270 := Parser.Current_Pos;

      Row_Progress_14 := 6;

      if Defer_Pos_270 /= No_Token_Index then

         Row_Pos_160 := Defer_Pos_270;

      else
         Row_Pos_160 := No_Token_Index;
         goto Exit_Row_159_0;

      end if;

--  Start tok_code

      Token_Res_217 := Row_Pos_160;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_217));
      begin
         if T.Kind /= From_Token_Kind (Ada_Begin) then
            Token_Pos_217 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_160 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_160,
                  Expected_Token_Id => Ada_Begin,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_217 := Row_Pos_160 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_14 := 7;

      if Token_Pos_217 /= No_Token_Index then

         Row_Pos_160 := Token_Pos_217;

      else
         Row_Pos_160 := No_Token_Index;
         goto Exit_Row_159_0;

      end if;

      Defer_Res_271 := Handled_Stmts_Transform_Parse_0 (Parser, Row_Pos_160);
      Defer_Pos_271 := Parser.Current_Pos;

      Row_Progress_14 := 8;

      if Defer_Pos_271 /= No_Token_Index then

         Row_Pos_160 := Defer_Pos_271;

      else
         Row_Pos_160 := No_Token_Index;
         goto Exit_Row_159_0;

      end if;

--  Start row_code

      Row_Pos_161 := Row_Pos_160;

--  Start tok_code

      Token_Res_218 := Row_Pos_161;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_218));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_218 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_161 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_161,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_218 := Row_Pos_161 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_218 /= No_Token_Index then

         Row_Pos_161 := Token_Pos_218;

      else
         Row_Pos_161 := No_Token_Index;
         goto Exit_Row_225_0;

      end if;

--  Start opt_code

--  Start transform_code

--  Start row_code

      Row_Pos_162 := Row_Pos_161;

      Defer_Res_272 := Static_Name_Or_Parse_0 (Parser, Row_Pos_162);
      Defer_Pos_272 := Parser.Current_Pos;

      if Defer_Pos_272 /= No_Token_Index then

         Row_Pos_162 := Defer_Pos_272;

      else
         Row_Pos_162 := No_Token_Index;
         goto Exit_Row_226_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_226_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_162 /= No_Token_Index then

         Transform_Res_138 := Allocate_End_Name (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_138, Kind => Ada_End_Name,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_161,
            Token_End_Index =>
              (if Row_Pos_162 = Row_Pos_161 then No_Token_Index
               else Row_Pos_162 - 1));

         Initialize_Fields_For_End_Name
           (Self => Transform_Res_138, End_Name_F_Name => Defer_Res_272);

         if Defer_Res_272 /= null and then Is_Incomplete (Defer_Res_272) then
            Transform_Res_138.Last_Attempted_Child := 0;
         elsif Defer_Res_272 /= null and then not Is_Ghost (Defer_Res_272) then
            Transform_Res_138.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_162 = No_Token_Index then

         Transform_Res_138 := No_Bare_Ada_Node;

         Row_Pos_162 := Row_Pos_161;

      end if;

--  End opt_code

      if Row_Pos_162 /= No_Token_Index then

         Row_Pos_161 := Row_Pos_162;

      else
         Row_Pos_161 := No_Token_Index;
         goto Exit_Row_225_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_225_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      Row_Progress_14 := 9;

      if Row_Pos_161 /= No_Token_Index then

         Row_Pos_160 := Row_Pos_161;

      else
         Row_Pos_160 := No_Token_Index;
         goto Exit_Row_159_0;

      end if;

--  Start tok_code

      Token_Res_219 := Row_Pos_160;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_219));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_219 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_160 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_160,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_219 := Row_Pos_160 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_14 := 10;

      if Token_Pos_219 /= No_Token_Index then

         Row_Pos_160 := Token_Pos_219;

      else
         Row_Pos_160 := No_Token_Index;
         goto Exit_Row_159_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_159_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_160 = No_Token_Index and then Nobt_14 then
         Row_Pos_160             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_14 := True;
      end if;

      if Row_Pos_160 /= No_Token_Index then

         Transform_Res_139 := Allocate_Subp_Body (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_139, Kind => Ada_Subp_Body,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_160 = Pos then No_Token_Index else Row_Pos_160 - 1));

         Initialize_Fields_For_Subp_Body
           (Self                        => Transform_Res_139,
            Base_Subp_Body_F_Overriding => Defer_Res_267,
            Base_Subp_Body_F_Subp_Spec  => Defer_Res_268,
            Subp_Body_F_Aspects         => Defer_Res_269,
            Subp_Body_F_Decls           => Defer_Res_270,
            Subp_Body_F_Stmts           => Defer_Res_271,
            Subp_Body_F_End_Name        => Transform_Res_138);

         if Defer_Res_267 /= null and then Is_Incomplete (Defer_Res_267) then
            Transform_Res_139.Last_Attempted_Child := 0;
         elsif Defer_Res_267 /= null and then not Is_Ghost (Defer_Res_267) then
            Transform_Res_139.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_268 /= null and then Is_Incomplete (Defer_Res_268) then
            Transform_Res_139.Last_Attempted_Child := 0;
         elsif Defer_Res_268 /= null and then not Is_Ghost (Defer_Res_268) then
            Transform_Res_139.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_269 /= null and then Is_Incomplete (Defer_Res_269) then
            Transform_Res_139.Last_Attempted_Child := 0;
         elsif Defer_Res_269 /= null and then not Is_Ghost (Defer_Res_269) then
            Transform_Res_139.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_270 /= null and then Is_Incomplete (Defer_Res_270) then
            Transform_Res_139.Last_Attempted_Child := 0;
         elsif Defer_Res_270 /= null and then not Is_Ghost (Defer_Res_270) then
            Transform_Res_139.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_271 /= null and then Is_Incomplete (Defer_Res_271) then
            Transform_Res_139.Last_Attempted_Child := 0;
         elsif Defer_Res_271 /= null and then not Is_Ghost (Defer_Res_271) then
            Transform_Res_139.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_138 /= null
           and then Is_Incomplete (Transform_Res_138)
         then
            Transform_Res_139.Last_Attempted_Child := 0;
         elsif Transform_Res_138 /= null
           and then not Is_Ghost (Transform_Res_138)
         then
            Transform_Res_139.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_14 then
            Transform_Res_139.Last_Attempted_Child := Row_Progress_14;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <subp_body>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Subp_Body_Transform_Parse_1_Memo,
         Row_Pos_160 /= No_Token_Index, Transform_Res_139, Pos, Row_Pos_160);

      Parser.Current_Pos := Row_Pos_160;

      return Transform_Res_139;
   end Subp_Body_Transform_Parse_1;

   function Package_Body_Transform_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Package_Body
   is
      use Bare_Package_Body_Memos;

      Nobt_28                 : Boolean               := False;
      Row_Pos_228             : Token_Index           := No_Token_Index;
      Token_Pos_330           : Token_Index           := No_Token_Index;
      Token_Res_330           : Token_Index           := No_Token_Index;
      Token_Pos_331           : Token_Index           := No_Token_Index;
      Token_Res_331           : Token_Index           := No_Token_Index;
      Defer_Pos_371           : Token_Index           := No_Token_Index;
      Defer_Res_371           : Bare_Defining_Name    := No_Bare_Ada_Node;
      Defer_Pos_372           : Token_Index           := No_Token_Index;
      Defer_Res_372           : Bare_Aspect_Spec      := No_Bare_Ada_Node;
      Token_Pos_332           : Token_Index           := No_Token_Index;
      Token_Res_332           : Token_Index           := No_Token_Index;
      Defer_Pos_373           : Token_Index           := No_Token_Index;
      Defer_Res_373           : Bare_Declarative_Part := No_Bare_Ada_Node;
      Row_Pos_229             : Token_Index           := No_Token_Index;
      Token_Pos_333           : Token_Index           := No_Token_Index;
      Token_Res_333           : Token_Index           := No_Token_Index;
      Defer_Pos_374           : Token_Index           := No_Token_Index;
      Defer_Res_374           : Bare_Handled_Stmts    := No_Bare_Ada_Node;
      Row_Pos_230             : Token_Index           := No_Token_Index;
      Token_Pos_334           : Token_Index           := No_Token_Index;
      Token_Res_334           : Token_Index           := No_Token_Index;
      Row_Pos_231             : Token_Index           := No_Token_Index;
      Defer_Pos_375           : Token_Index           := No_Token_Index;
      Defer_Res_375           : Bare_Name             := No_Bare_Ada_Node;
      Transform_Res_187       : Bare_End_Name         := No_Bare_Ada_Node;
      Token_Pos_335           : Token_Index           := No_Token_Index;
      Token_Res_335           : Token_Index           := No_Token_Index;
      Row_Progress_29         : Integer               := 0;
      Transform_Res_188       : Bare_Package_Body     := No_Bare_Ada_Node;
      Transform_Has_Failed_29 : Boolean               := False;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Package_Body_Transform_Parse_1_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_188  := M.Instance;
         return Transform_Res_188;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_188;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_228 := Pos;

--  Start tok_code

      Token_Res_330 := Row_Pos_228;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_330));
      begin
         if T.Kind /= From_Token_Kind (Ada_Package) then
            Token_Pos_330 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_228 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_228,
                  Expected_Token_Id => Ada_Package,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_330 := Row_Pos_228 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_29 := 1;

      if Token_Pos_330 /= No_Token_Index then

         Row_Pos_228 := Token_Pos_330;

      else
         Row_Pos_228 := No_Token_Index;
         goto Exit_Row_227_0;

      end if;

--  Start tok_code

      Token_Res_331 := Row_Pos_228;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_331));
      begin
         if T.Kind /= From_Token_Kind (Ada_Body) then
            Token_Pos_331 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_228 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_228,
                  Expected_Token_Id => Ada_Body,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_331 := Row_Pos_228 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_29 := 2;

      if Token_Pos_331 /= No_Token_Index then

         Row_Pos_228 := Token_Pos_331;

      else
         Row_Pos_228 := No_Token_Index;
         goto Exit_Row_227_0;

      end if;

      Nobt_28 := True;

      Row_Progress_29 := 3;

      if Row_Pos_228 /= No_Token_Index then

         Row_Pos_228 := Row_Pos_228;

      else
         Row_Pos_228 := No_Token_Index;
         goto Exit_Row_227_0;

      end if;

      Defer_Res_371 := Defining_Name_Transform_Parse_0 (Parser, Row_Pos_228);
      Defer_Pos_371 := Parser.Current_Pos;

      Row_Progress_29 := 4;

      if Defer_Pos_371 /= No_Token_Index then

         Row_Pos_228 := Defer_Pos_371;

      else
         Row_Pos_228 := No_Token_Index;
         goto Exit_Row_227_0;

      end if;

      Defer_Res_372 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_228);
      Defer_Pos_372 := Parser.Current_Pos;

      Row_Progress_29 := 5;

      if Defer_Pos_372 /= No_Token_Index then

         Row_Pos_228 := Defer_Pos_372;

      else
         Row_Pos_228 := No_Token_Index;
         goto Exit_Row_227_0;

      end if;

--  Start tok_code

      Token_Res_332 := Row_Pos_228;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_332));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_332 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_228 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_228,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_332 := Row_Pos_228 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_29 := 6;

      if Token_Pos_332 /= No_Token_Index then

         Row_Pos_228 := Token_Pos_332;

      else
         Row_Pos_228 := No_Token_Index;
         goto Exit_Row_227_0;

      end if;

      Parser.Private_Part.Dont_Skip.Append
        (Dontskip_Package_Body_0_Extract_Parse_0'Access);

      Defer_Res_373 := Decl_Part_Transform_Parse_0 (Parser, Row_Pos_228);
      Defer_Pos_373 := Parser.Current_Pos;

      Parser.Private_Part.Dont_Skip.Delete_Last;

      Row_Progress_29 := 7;

      if Defer_Pos_373 /= No_Token_Index then

         Row_Pos_228 := Defer_Pos_373;

      else
         Row_Pos_228 := No_Token_Index;
         goto Exit_Row_227_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_229 := Row_Pos_228;

--  Start tok_code

      Token_Res_333 := Row_Pos_229;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_333));
      begin
         if T.Kind /= From_Token_Kind (Ada_Begin) then
            Token_Pos_333 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_229 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_229,
                  Expected_Token_Id => Ada_Begin,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_333 := Row_Pos_229 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_333 /= No_Token_Index then

         Row_Pos_229 := Token_Pos_333;

      else
         Row_Pos_229 := No_Token_Index;
         goto Exit_Row_228_0;

      end if;

      Defer_Res_374 := Handled_Stmts_Transform_Parse_0 (Parser, Row_Pos_229);
      Defer_Pos_374 := Parser.Current_Pos;

      if Defer_Pos_374 /= No_Token_Index then

         Row_Pos_229 := Defer_Pos_374;

      else
         Row_Pos_229 := No_Token_Index;
         goto Exit_Row_228_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_228_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_229 = No_Token_Index then

         Defer_Res_374 := No_Bare_Ada_Node;

         Row_Pos_229 := Row_Pos_228;

      end if;

--  End opt_code

      Row_Progress_29 := 8;

      if Row_Pos_229 /= No_Token_Index then

         Row_Pos_228 := Row_Pos_229;

      else
         Row_Pos_228 := No_Token_Index;
         goto Exit_Row_227_0;

      end if;

--  Start row_code

      Row_Pos_230 := Row_Pos_228;

--  Start tok_code

      Token_Res_334 := Row_Pos_230;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_334));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_334 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_230 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_230,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_334 := Row_Pos_230 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_334 /= No_Token_Index then

         Row_Pos_230 := Token_Pos_334;

      else
         Row_Pos_230 := No_Token_Index;
         goto Exit_Row_229_0;

      end if;

--  Start opt_code

--  Start transform_code

--  Start row_code

      Row_Pos_231 := Row_Pos_230;

      Defer_Res_375 := Static_Name_Or_Parse_0 (Parser, Row_Pos_231);
      Defer_Pos_375 := Parser.Current_Pos;

      if Defer_Pos_375 /= No_Token_Index then

         Row_Pos_231 := Defer_Pos_375;

      else
         Row_Pos_231 := No_Token_Index;
         goto Exit_Row_230_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_230_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_231 /= No_Token_Index then

         Transform_Res_187 := Allocate_End_Name (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_187, Kind => Ada_End_Name,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_230,
            Token_End_Index =>
              (if Row_Pos_231 = Row_Pos_230 then No_Token_Index
               else Row_Pos_231 - 1));

         Initialize_Fields_For_End_Name
           (Self => Transform_Res_187, End_Name_F_Name => Defer_Res_375);

         if Defer_Res_375 /= null and then Is_Incomplete (Defer_Res_375) then
            Transform_Res_187.Last_Attempted_Child := 0;
         elsif Defer_Res_375 /= null and then not Is_Ghost (Defer_Res_375) then
            Transform_Res_187.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_231 = No_Token_Index then

         Transform_Res_187 := No_Bare_Ada_Node;

         Row_Pos_231 := Row_Pos_230;

      end if;

--  End opt_code

      if Row_Pos_231 /= No_Token_Index then

         Row_Pos_230 := Row_Pos_231;

      else
         Row_Pos_230 := No_Token_Index;
         goto Exit_Row_229_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_229_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      Row_Progress_29 := 9;

      if Row_Pos_230 /= No_Token_Index then

         Row_Pos_228 := Row_Pos_230;

      else
         Row_Pos_228 := No_Token_Index;
         goto Exit_Row_227_0;

      end if;

--  Start tok_code

      Token_Res_335 := Row_Pos_228;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_335));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_335 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_228 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_228,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_335 := Row_Pos_228 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_29 := 10;

      if Token_Pos_335 /= No_Token_Index then

         Row_Pos_228 := Token_Pos_335;

      else
         Row_Pos_228 := No_Token_Index;
         goto Exit_Row_227_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_227_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_228 = No_Token_Index and then Nobt_28 then
         Row_Pos_228             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_29 := True;
      end if;

      if Row_Pos_228 /= No_Token_Index then

         Transform_Res_188 := Allocate_Package_Body (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_188, Kind => Ada_Package_Body,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_228 = Pos then No_Token_Index else Row_Pos_228 - 1));

         Initialize_Fields_For_Package_Body
           (Self                        => Transform_Res_188,
            Package_Body_F_Package_Name => Defer_Res_371,
            Package_Body_F_Aspects      => Defer_Res_372,
            Package_Body_F_Decls        => Defer_Res_373,
            Package_Body_F_Stmts        => Defer_Res_374,
            Package_Body_F_End_Name     => Transform_Res_187);

         if Defer_Res_371 /= null and then Is_Incomplete (Defer_Res_371) then
            Transform_Res_188.Last_Attempted_Child := 0;
         elsif Defer_Res_371 /= null and then not Is_Ghost (Defer_Res_371) then
            Transform_Res_188.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_372 /= null and then Is_Incomplete (Defer_Res_372) then
            Transform_Res_188.Last_Attempted_Child := 0;
         elsif Defer_Res_372 /= null and then not Is_Ghost (Defer_Res_372) then
            Transform_Res_188.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_373 /= null and then Is_Incomplete (Defer_Res_373) then
            Transform_Res_188.Last_Attempted_Child := 0;
         elsif Defer_Res_373 /= null and then not Is_Ghost (Defer_Res_373) then
            Transform_Res_188.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_374 /= null and then Is_Incomplete (Defer_Res_374) then
            Transform_Res_188.Last_Attempted_Child := 0;
         elsif Defer_Res_374 /= null and then not Is_Ghost (Defer_Res_374) then
            Transform_Res_188.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_187 /= null
           and then Is_Incomplete (Transform_Res_187)
         then
            Transform_Res_188.Last_Attempted_Child := 0;
         elsif Transform_Res_187 /= null
           and then not Is_Ghost (Transform_Res_187)
         then
            Transform_Res_188.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_29 then
            Transform_Res_188.Last_Attempted_Child := Row_Progress_29;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <package_body>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Package_Body_Transform_Parse_1_Memo,
         Row_Pos_228 /= No_Token_Index, Transform_Res_188, Pos, Row_Pos_228);

      Parser.Current_Pos := Row_Pos_228;

      return Transform_Res_188;
   end Package_Body_Transform_Parse_1;

   function Task_Body_Transform_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Task_Body
   is
      use Bare_Task_Body_Memos;

      Nobt_29                 : Boolean               := False;
      Row_Pos_232             : Token_Index           := No_Token_Index;
      Token_Pos_336           : Token_Index           := No_Token_Index;
      Token_Res_336           : Token_Index           := No_Token_Index;
      Token_Pos_337           : Token_Index           := No_Token_Index;
      Token_Res_337           : Token_Index           := No_Token_Index;
      Defer_Pos_376           : Token_Index           := No_Token_Index;
      Defer_Res_376           : Bare_Defining_Name    := No_Bare_Ada_Node;
      Defer_Pos_377           : Token_Index           := No_Token_Index;
      Defer_Res_377           : Bare_Aspect_Spec      := No_Bare_Ada_Node;
      Token_Pos_338           : Token_Index           := No_Token_Index;
      Token_Res_338           : Token_Index           := No_Token_Index;
      Defer_Pos_378           : Token_Index           := No_Token_Index;
      Defer_Res_378           : Bare_Declarative_Part := No_Bare_Ada_Node;
      Token_Pos_339           : Token_Index           := No_Token_Index;
      Token_Res_339           : Token_Index           := No_Token_Index;
      Defer_Pos_379           : Token_Index           := No_Token_Index;
      Defer_Res_379           : Bare_Handled_Stmts    := No_Bare_Ada_Node;
      Row_Pos_233             : Token_Index           := No_Token_Index;
      Token_Pos_340           : Token_Index           := No_Token_Index;
      Token_Res_340           : Token_Index           := No_Token_Index;
      Row_Pos_234             : Token_Index           := No_Token_Index;
      Defer_Pos_380           : Token_Index           := No_Token_Index;
      Defer_Res_380           : Bare_Name             := No_Bare_Ada_Node;
      Transform_Res_189       : Bare_End_Name         := No_Bare_Ada_Node;
      Token_Pos_341           : Token_Index           := No_Token_Index;
      Token_Res_341           : Token_Index           := No_Token_Index;
      Row_Progress_30         : Integer               := 0;
      Transform_Res_190       : Bare_Task_Body        := No_Bare_Ada_Node;
      Transform_Has_Failed_30 : Boolean               := False;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Task_Body_Transform_Parse_1_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_190  := M.Instance;
         return Transform_Res_190;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_190;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_232 := Pos;

--  Start tok_code

      Token_Res_336 := Row_Pos_232;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_336));
      begin
         if T.Kind /= From_Token_Kind (Ada_Task) then
            Token_Pos_336 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_232 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_232,
                  Expected_Token_Id => Ada_Task,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_336 := Row_Pos_232 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_30 := 1;

      if Token_Pos_336 /= No_Token_Index then

         Row_Pos_232 := Token_Pos_336;

      else
         Row_Pos_232 := No_Token_Index;
         goto Exit_Row_231_0;

      end if;

--  Start tok_code

      Token_Res_337 := Row_Pos_232;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_337));
      begin
         if T.Kind /= From_Token_Kind (Ada_Body) then
            Token_Pos_337 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_232 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_232,
                  Expected_Token_Id => Ada_Body,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_337 := Row_Pos_232 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_30 := 2;

      if Token_Pos_337 /= No_Token_Index then

         Row_Pos_232 := Token_Pos_337;

      else
         Row_Pos_232 := No_Token_Index;
         goto Exit_Row_231_0;

      end if;

      Defer_Res_376 := Defining_Name_Transform_Parse_0 (Parser, Row_Pos_232);
      Defer_Pos_376 := Parser.Current_Pos;

      Row_Progress_30 := 3;

      if Defer_Pos_376 /= No_Token_Index then

         Row_Pos_232 := Defer_Pos_376;

      else
         Row_Pos_232 := No_Token_Index;
         goto Exit_Row_231_0;

      end if;

      Defer_Res_377 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_232);
      Defer_Pos_377 := Parser.Current_Pos;

      Row_Progress_30 := 4;

      if Defer_Pos_377 /= No_Token_Index then

         Row_Pos_232 := Defer_Pos_377;

      else
         Row_Pos_232 := No_Token_Index;
         goto Exit_Row_231_0;

      end if;

--  Start tok_code

      Token_Res_338 := Row_Pos_232;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_338));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_338 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_232 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_232,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_338 := Row_Pos_232 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_30 := 5;

      if Token_Pos_338 /= No_Token_Index then

         Row_Pos_232 := Token_Pos_338;

      else
         Row_Pos_232 := No_Token_Index;
         goto Exit_Row_231_0;

      end if;

      Nobt_29 := True;

      Row_Progress_30 := 6;

      if Row_Pos_232 /= No_Token_Index then

         Row_Pos_232 := Row_Pos_232;

      else
         Row_Pos_232 := No_Token_Index;
         goto Exit_Row_231_0;

      end if;

      Defer_Res_378 := Recov_Decl_Part_Dont_Skip_Parse_0 (Parser, Row_Pos_232);
      Defer_Pos_378 := Parser.Current_Pos;

      Row_Progress_30 := 7;

      if Defer_Pos_378 /= No_Token_Index then

         Row_Pos_232 := Defer_Pos_378;

      else
         Row_Pos_232 := No_Token_Index;
         goto Exit_Row_231_0;

      end if;

--  Start tok_code

      Token_Res_339 := Row_Pos_232;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_339));
      begin
         if T.Kind /= From_Token_Kind (Ada_Begin) then
            Token_Pos_339 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_232 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_232,
                  Expected_Token_Id => Ada_Begin,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_339 := Row_Pos_232 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_30 := 8;

      if Token_Pos_339 /= No_Token_Index then

         Row_Pos_232 := Token_Pos_339;

      else
         Row_Pos_232 := No_Token_Index;
         goto Exit_Row_231_0;

      end if;

      Defer_Res_379 := Handled_Stmts_Transform_Parse_0 (Parser, Row_Pos_232);
      Defer_Pos_379 := Parser.Current_Pos;

      Row_Progress_30 := 9;

      if Defer_Pos_379 /= No_Token_Index then

         Row_Pos_232 := Defer_Pos_379;

      else
         Row_Pos_232 := No_Token_Index;
         goto Exit_Row_231_0;

      end if;

--  Start row_code

      Row_Pos_233 := Row_Pos_232;

--  Start tok_code

      Token_Res_340 := Row_Pos_233;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_340));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_340 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_233 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_233,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_340 := Row_Pos_233 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_340 /= No_Token_Index then

         Row_Pos_233 := Token_Pos_340;

      else
         Row_Pos_233 := No_Token_Index;
         goto Exit_Row_232_0;

      end if;

--  Start opt_code

--  Start transform_code

--  Start row_code

      Row_Pos_234 := Row_Pos_233;

      Defer_Res_380 := Static_Name_Or_Parse_0 (Parser, Row_Pos_234);
      Defer_Pos_380 := Parser.Current_Pos;

      if Defer_Pos_380 /= No_Token_Index then

         Row_Pos_234 := Defer_Pos_380;

      else
         Row_Pos_234 := No_Token_Index;
         goto Exit_Row_233_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_233_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_234 /= No_Token_Index then

         Transform_Res_189 := Allocate_End_Name (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_189, Kind => Ada_End_Name,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_233,
            Token_End_Index =>
              (if Row_Pos_234 = Row_Pos_233 then No_Token_Index
               else Row_Pos_234 - 1));

         Initialize_Fields_For_End_Name
           (Self => Transform_Res_189, End_Name_F_Name => Defer_Res_380);

         if Defer_Res_380 /= null and then Is_Incomplete (Defer_Res_380) then
            Transform_Res_189.Last_Attempted_Child := 0;
         elsif Defer_Res_380 /= null and then not Is_Ghost (Defer_Res_380) then
            Transform_Res_189.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_234 = No_Token_Index then

         Transform_Res_189 := No_Bare_Ada_Node;

         Row_Pos_234 := Row_Pos_233;

      end if;

--  End opt_code

      if Row_Pos_234 /= No_Token_Index then

         Row_Pos_233 := Row_Pos_234;

      else
         Row_Pos_233 := No_Token_Index;
         goto Exit_Row_232_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_232_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      Row_Progress_30 := 10;

      if Row_Pos_233 /= No_Token_Index then

         Row_Pos_232 := Row_Pos_233;

      else
         Row_Pos_232 := No_Token_Index;
         goto Exit_Row_231_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_341 := Row_Pos_232;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_341));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_341 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_232 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_232,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_341 := Row_Pos_232 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_341 = No_Token_Index then

         Token_Res_341 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_232).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_341 := Row_Pos_232;

      end if;

--  End opt_code

      Row_Progress_30 := 11;

      if Token_Pos_341 /= No_Token_Index then

         Row_Pos_232 := Token_Pos_341;

      else
         Row_Pos_232 := No_Token_Index;
         goto Exit_Row_231_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_231_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_232 = No_Token_Index and then Nobt_29 then
         Row_Pos_232             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_30 := True;
      end if;

      if Row_Pos_232 /= No_Token_Index then

         Transform_Res_190 := Allocate_Task_Body (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_190, Kind => Ada_Task_Body,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_232 = Pos then No_Token_Index else Row_Pos_232 - 1));

         Initialize_Fields_For_Task_Body
           (Self => Transform_Res_190, Task_Body_F_Name => Defer_Res_376,
            Task_Body_F_Aspects  => Defer_Res_377,
            Task_Body_F_Decls    => Defer_Res_378,
            Task_Body_F_Stmts    => Defer_Res_379,
            Task_Body_F_End_Name => Transform_Res_189);

         if Defer_Res_376 /= null and then Is_Incomplete (Defer_Res_376) then
            Transform_Res_190.Last_Attempted_Child := 0;
         elsif Defer_Res_376 /= null and then not Is_Ghost (Defer_Res_376) then
            Transform_Res_190.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_377 /= null and then Is_Incomplete (Defer_Res_377) then
            Transform_Res_190.Last_Attempted_Child := 0;
         elsif Defer_Res_377 /= null and then not Is_Ghost (Defer_Res_377) then
            Transform_Res_190.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_378 /= null and then Is_Incomplete (Defer_Res_378) then
            Transform_Res_190.Last_Attempted_Child := 0;
         elsif Defer_Res_378 /= null and then not Is_Ghost (Defer_Res_378) then
            Transform_Res_190.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_379 /= null and then Is_Incomplete (Defer_Res_379) then
            Transform_Res_190.Last_Attempted_Child := 0;
         elsif Defer_Res_379 /= null and then not Is_Ghost (Defer_Res_379) then
            Transform_Res_190.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_189 /= null
           and then Is_Incomplete (Transform_Res_189)
         then
            Transform_Res_190.Last_Attempted_Child := 0;
         elsif Transform_Res_189 /= null
           and then not Is_Ghost (Transform_Res_189)
         then
            Transform_Res_190.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_30 then
            Transform_Res_190.Last_Attempted_Child := Row_Progress_30;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <task_body>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Task_Body_Transform_Parse_1_Memo,
         Row_Pos_232 /= No_Token_Index, Transform_Res_190, Pos, Row_Pos_232);

      Parser.Current_Pos := Row_Pos_232;

      return Transform_Res_190;
   end Task_Body_Transform_Parse_1;

   function Protected_Body_Transform_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Protected_Body
   is
      use Bare_Protected_Body_Memos;

      Row_Pos_235       : Token_Index           := No_Token_Index;
      Token_Pos_342     : Token_Index           := No_Token_Index;
      Token_Res_342     : Token_Index           := No_Token_Index;
      Token_Pos_343     : Token_Index           := No_Token_Index;
      Token_Res_343     : Token_Index           := No_Token_Index;
      Defer_Pos_381     : Token_Index           := No_Token_Index;
      Defer_Res_381     : Bare_Defining_Name    := No_Bare_Ada_Node;
      Defer_Pos_382     : Token_Index           := No_Token_Index;
      Defer_Res_382     : Bare_Aspect_Spec      := No_Bare_Ada_Node;
      Token_Pos_344     : Token_Index           := No_Token_Index;
      Token_Res_344     : Token_Index           := No_Token_Index;
      Defer_Pos_383     : Token_Index           := No_Token_Index;
      Defer_Res_383     : Bare_Declarative_Part := No_Bare_Ada_Node;
      Row_Pos_236       : Token_Index           := No_Token_Index;
      Token_Pos_345     : Token_Index           := No_Token_Index;
      Token_Res_345     : Token_Index           := No_Token_Index;
      Row_Pos_237       : Token_Index           := No_Token_Index;
      Defer_Pos_384     : Token_Index           := No_Token_Index;
      Defer_Res_384     : Bare_Name             := No_Bare_Ada_Node;
      Transform_Res_191 : Bare_End_Name         := No_Bare_Ada_Node;
      Token_Pos_346     : Token_Index           := No_Token_Index;
      Token_Res_346     : Token_Index           := No_Token_Index;
      Transform_Res_192 : Bare_Protected_Body   := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Protected_Body_Transform_Parse_1_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_192  := M.Instance;
         return Transform_Res_192;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_192;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_235 := Pos;

--  Start tok_code

      Token_Res_342 := Row_Pos_235;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_342));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol
               (Parser.TDH.Symbols, Precomputed_Symbol_Protected)
         then
            Token_Pos_342 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_235 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_235,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_342 := Row_Pos_235 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_342 /= No_Token_Index then

         Row_Pos_235 := Token_Pos_342;

      else
         Row_Pos_235 := No_Token_Index;
         goto Exit_Row_234_0;

      end if;

--  Start tok_code

      Token_Res_343 := Row_Pos_235;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_343));
      begin
         if T.Kind /= From_Token_Kind (Ada_Body) then
            Token_Pos_343 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_235 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_235,
                  Expected_Token_Id => Ada_Body,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_343 := Row_Pos_235 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_343 /= No_Token_Index then

         Row_Pos_235 := Token_Pos_343;

      else
         Row_Pos_235 := No_Token_Index;
         goto Exit_Row_234_0;

      end if;

      Defer_Res_381 := Defining_Name_Transform_Parse_0 (Parser, Row_Pos_235);
      Defer_Pos_381 := Parser.Current_Pos;

      if Defer_Pos_381 /= No_Token_Index then

         Row_Pos_235 := Defer_Pos_381;

      else
         Row_Pos_235 := No_Token_Index;
         goto Exit_Row_234_0;

      end if;

      Defer_Res_382 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_235);
      Defer_Pos_382 := Parser.Current_Pos;

      if Defer_Pos_382 /= No_Token_Index then

         Row_Pos_235 := Defer_Pos_382;

      else
         Row_Pos_235 := No_Token_Index;
         goto Exit_Row_234_0;

      end if;

--  Start tok_code

      Token_Res_344 := Row_Pos_235;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_344));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_344 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_235 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_235,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_344 := Row_Pos_235 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_344 /= No_Token_Index then

         Row_Pos_235 := Token_Pos_344;

      else
         Row_Pos_235 := No_Token_Index;
         goto Exit_Row_234_0;

      end if;

      Parser.Private_Part.Dont_Skip.Append
        (Dontskip_Protected_Body_0_Extract_Parse_0'Access);

      Defer_Res_383 := Decl_Part_Transform_Parse_0 (Parser, Row_Pos_235);
      Defer_Pos_383 := Parser.Current_Pos;

      Parser.Private_Part.Dont_Skip.Delete_Last;

      if Defer_Pos_383 /= No_Token_Index then

         Row_Pos_235 := Defer_Pos_383;

      else
         Row_Pos_235 := No_Token_Index;
         goto Exit_Row_234_0;

      end if;

--  Start row_code

      Row_Pos_236 := Row_Pos_235;

--  Start tok_code

      Token_Res_345 := Row_Pos_236;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_345));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_345 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_236 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_236,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_345 := Row_Pos_236 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_345 /= No_Token_Index then

         Row_Pos_236 := Token_Pos_345;

      else
         Row_Pos_236 := No_Token_Index;
         goto Exit_Row_235_0;

      end if;

--  Start opt_code

--  Start transform_code

--  Start row_code

      Row_Pos_237 := Row_Pos_236;

      Defer_Res_384 := Static_Name_Or_Parse_0 (Parser, Row_Pos_237);
      Defer_Pos_384 := Parser.Current_Pos;

      if Defer_Pos_384 /= No_Token_Index then

         Row_Pos_237 := Defer_Pos_384;

      else
         Row_Pos_237 := No_Token_Index;
         goto Exit_Row_236_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_236_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_237 /= No_Token_Index then

         Transform_Res_191 := Allocate_End_Name (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_191, Kind => Ada_End_Name,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_236,
            Token_End_Index =>
              (if Row_Pos_237 = Row_Pos_236 then No_Token_Index
               else Row_Pos_237 - 1));

         Initialize_Fields_For_End_Name
           (Self => Transform_Res_191, End_Name_F_Name => Defer_Res_384);

         if Defer_Res_384 /= null and then Is_Incomplete (Defer_Res_384) then
            Transform_Res_191.Last_Attempted_Child := 0;
         elsif Defer_Res_384 /= null and then not Is_Ghost (Defer_Res_384) then
            Transform_Res_191.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_237 = No_Token_Index then

         Transform_Res_191 := No_Bare_Ada_Node;

         Row_Pos_237 := Row_Pos_236;

      end if;

--  End opt_code

      if Row_Pos_237 /= No_Token_Index then

         Row_Pos_236 := Row_Pos_237;

      else
         Row_Pos_236 := No_Token_Index;
         goto Exit_Row_235_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_235_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_236 /= No_Token_Index then

         Row_Pos_235 := Row_Pos_236;

      else
         Row_Pos_235 := No_Token_Index;
         goto Exit_Row_234_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_346 := Row_Pos_235;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_346));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_346 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_235 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_235,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_346 := Row_Pos_235 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_346 = No_Token_Index then

         Token_Res_346 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_235).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_346 := Row_Pos_235;

      end if;

--  End opt_code

      if Token_Pos_346 /= No_Token_Index then

         Row_Pos_235 := Token_Pos_346;

      else
         Row_Pos_235 := No_Token_Index;
         goto Exit_Row_234_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_234_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_235 /= No_Token_Index then

         Transform_Res_192 := Allocate_Protected_Body (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_192, Kind => Ada_Protected_Body,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_235 = Pos then No_Token_Index else Row_Pos_235 - 1));

         Initialize_Fields_For_Protected_Body
           (Self => Transform_Res_192, Protected_Body_F_Name => Defer_Res_381,
            Protected_Body_F_Aspects  => Defer_Res_382,
            Protected_Body_F_Decls    => Defer_Res_383,
            Protected_Body_F_End_Name => Transform_Res_191);

         if Defer_Res_381 /= null and then Is_Incomplete (Defer_Res_381) then
            Transform_Res_192.Last_Attempted_Child := 0;
         elsif Defer_Res_381 /= null and then not Is_Ghost (Defer_Res_381) then
            Transform_Res_192.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_382 /= null and then Is_Incomplete (Defer_Res_382) then
            Transform_Res_192.Last_Attempted_Child := 0;
         elsif Defer_Res_382 /= null and then not Is_Ghost (Defer_Res_382) then
            Transform_Res_192.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_383 /= null and then Is_Incomplete (Defer_Res_383) then
            Transform_Res_192.Last_Attempted_Child := 0;
         elsif Defer_Res_383 /= null and then not Is_Ghost (Defer_Res_383) then
            Transform_Res_192.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_191 /= null
           and then Is_Incomplete (Transform_Res_191)
         then
            Transform_Res_192.Last_Attempted_Child := 0;
         elsif Transform_Res_191 /= null
           and then not Is_Ghost (Transform_Res_191)
         then
            Transform_Res_192.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Protected_Body_Transform_Parse_1_Memo,
         Row_Pos_235 /= No_Token_Index, Transform_Res_192, Pos, Row_Pos_235);

      Parser.Current_Pos := Row_Pos_235;

      return Transform_Res_192;
   end Protected_Body_Transform_Parse_1;

   function Entry_Body_Transform_Parse_3
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Entry_Body
   is
      use Bare_Entry_Body_Memos;

      Nobt_30           : Boolean                             := False;
      Row_Pos_238       : Token_Index := No_Token_Index;
      Token_Pos_347     : Token_Index := No_Token_Index;
      Token_Res_347     : Token_Index := No_Token_Index;
      Defer_Pos_385     : Token_Index := No_Token_Index;
      Defer_Res_385     : Bare_Defining_Name := No_Bare_Ada_Node;
      Row_Pos_239       : Token_Index := No_Token_Index;
      Token_Pos_348     : Token_Index := No_Token_Index;
      Token_Res_348     : Token_Index := No_Token_Index;
      Token_Pos_349     : Token_Index := No_Token_Index;
      Token_Res_349     : Token_Index := No_Token_Index;
      Defer_Pos_386     : Token_Index := No_Token_Index;
      Defer_Res_386     : Bare_Defining_Name := No_Bare_Ada_Node;
      Token_Pos_350     : Token_Index := No_Token_Index;
      Token_Res_350     : Token_Index := No_Token_Index;
      Defer_Pos_387     : Token_Index := No_Token_Index;
      Defer_Res_387     : Bare_Ada_Node := No_Bare_Ada_Node;
      Token_Pos_351     : Token_Index := No_Token_Index;
      Token_Res_351     : Token_Index := No_Token_Index;
      Transform_Res_193 : Bare_Entry_Index_Spec := No_Bare_Ada_Node;
      Row_Pos_240       : Token_Index := No_Token_Index;
      Defer_Pos_388     : Token_Index := No_Token_Index;
      Defer_Res_388     : Bare_Params := No_Bare_Ada_Node;
      Transform_Res_194 : Bare_Entry_Completion_Formal_Params :=
        No_Bare_Ada_Node;
      Token_Pos_352           : Token_Index           := No_Token_Index;
      Token_Res_352           : Token_Index           := No_Token_Index;
      Defer_Pos_389           : Token_Index           := No_Token_Index;
      Defer_Res_389           : Bare_Expr             := No_Bare_Ada_Node;
      Token_Pos_353           : Token_Index           := No_Token_Index;
      Token_Res_353           : Token_Index           := No_Token_Index;
      Defer_Pos_390           : Token_Index           := No_Token_Index;
      Defer_Res_390           : Bare_Declarative_Part := No_Bare_Ada_Node;
      Token_Pos_354           : Token_Index           := No_Token_Index;
      Token_Res_354           : Token_Index           := No_Token_Index;
      Defer_Pos_391           : Token_Index           := No_Token_Index;
      Defer_Res_391           : Bare_Handled_Stmts    := No_Bare_Ada_Node;
      Row_Pos_241             : Token_Index           := No_Token_Index;
      Token_Pos_355           : Token_Index           := No_Token_Index;
      Token_Res_355           : Token_Index           := No_Token_Index;
      Row_Pos_242             : Token_Index           := No_Token_Index;
      Defer_Pos_392           : Token_Index           := No_Token_Index;
      Defer_Res_392           : Bare_Name             := No_Bare_Ada_Node;
      Transform_Res_195       : Bare_End_Name         := No_Bare_Ada_Node;
      Token_Pos_356           : Token_Index           := No_Token_Index;
      Token_Res_356           : Token_Index           := No_Token_Index;
      Row_Progress_31         : Integer               := 0;
      Transform_Res_196       : Bare_Entry_Body       := No_Bare_Ada_Node;
      Transform_Has_Failed_31 : Boolean               := False;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Entry_Body_Transform_Parse_3_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_196  := M.Instance;
         return Transform_Res_196;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_196;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_238 := Pos;

--  Start tok_code

      Token_Res_347 := Row_Pos_238;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_347));
      begin
         if T.Kind /= From_Token_Kind (Ada_Entry) then
            Token_Pos_347 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_238 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_238,
                  Expected_Token_Id => Ada_Entry,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_347 := Row_Pos_238 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_31 := 1;

      if Token_Pos_347 /= No_Token_Index then

         Row_Pos_238 := Token_Pos_347;

      else
         Row_Pos_238 := No_Token_Index;
         goto Exit_Row_237_0;

      end if;

      Defer_Res_385 := Defining_Id_Transform_Parse_0 (Parser, Row_Pos_238);
      Defer_Pos_385 := Parser.Current_Pos;

      Row_Progress_31 := 2;

      if Defer_Pos_385 /= No_Token_Index then

         Row_Pos_238 := Defer_Pos_385;

      else
         Row_Pos_238 := No_Token_Index;
         goto Exit_Row_237_0;

      end if;

--  Start opt_code

--  Start transform_code

--  Start row_code

      Row_Pos_239 := Row_Pos_238;

--  Start tok_code

      Token_Res_348 := Row_Pos_239;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_348));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Open) then
            Token_Pos_348 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_239 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_239,
                  Expected_Token_Id => Ada_Par_Open,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_348 := Row_Pos_239 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_348 /= No_Token_Index then

         Row_Pos_239 := Token_Pos_348;

      else
         Row_Pos_239 := No_Token_Index;
         goto Exit_Row_238_0;

      end if;

--  Start tok_code

      Token_Res_349 := Row_Pos_239;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_349));
      begin
         if T.Kind /= From_Token_Kind (Ada_For) then
            Token_Pos_349 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_239 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_239,
                  Expected_Token_Id => Ada_For,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_349 := Row_Pos_239 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_349 /= No_Token_Index then

         Row_Pos_239 := Token_Pos_349;

      else
         Row_Pos_239 := No_Token_Index;
         goto Exit_Row_238_0;

      end if;

      Defer_Res_386 := Defining_Id_Transform_Parse_0 (Parser, Row_Pos_239);
      Defer_Pos_386 := Parser.Current_Pos;

      if Defer_Pos_386 /= No_Token_Index then

         Row_Pos_239 := Defer_Pos_386;

      else
         Row_Pos_239 := No_Token_Index;
         goto Exit_Row_238_0;

      end if;

--  Start tok_code

      Token_Res_350 := Row_Pos_239;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_350));
      begin
         if T.Kind /= From_Token_Kind (Ada_In) then
            Token_Pos_350 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_239 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_239,
                  Expected_Token_Id => Ada_In,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_350 := Row_Pos_239 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_350 /= No_Token_Index then

         Row_Pos_239 := Token_Pos_350;

      else
         Row_Pos_239 := No_Token_Index;
         goto Exit_Row_238_0;

      end if;

      Defer_Res_387 :=
        Discrete_Subtype_Definition_Or_Parse_0 (Parser, Row_Pos_239);
      Defer_Pos_387 := Parser.Current_Pos;

      if Defer_Pos_387 /= No_Token_Index then

         Row_Pos_239 := Defer_Pos_387;

      else
         Row_Pos_239 := No_Token_Index;
         goto Exit_Row_238_0;

      end if;

--  Start tok_code

      Token_Res_351 := Row_Pos_239;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_351));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Close) then
            Token_Pos_351 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_239 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_239,
                  Expected_Token_Id => Ada_Par_Close,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_351 := Row_Pos_239 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_351 /= No_Token_Index then

         Row_Pos_239 := Token_Pos_351;

      else
         Row_Pos_239 := No_Token_Index;
         goto Exit_Row_238_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_238_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_239 /= No_Token_Index then

         Transform_Res_193 := Allocate_Entry_Index_Spec (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_193, Kind => Ada_Entry_Index_Spec,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_238,
            Token_End_Index =>
              (if Row_Pos_239 = Row_Pos_238 then No_Token_Index
               else Row_Pos_239 - 1));

         Initialize_Fields_For_Entry_Index_Spec
           (Self => Transform_Res_193, Entry_Index_Spec_F_Id => Defer_Res_386,
            Entry_Index_Spec_F_Subtype => Defer_Res_387);

         if Defer_Res_386 /= null and then Is_Incomplete (Defer_Res_386) then
            Transform_Res_193.Last_Attempted_Child := 0;
         elsif Defer_Res_386 /= null and then not Is_Ghost (Defer_Res_386) then
            Transform_Res_193.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_387 /= null and then Is_Incomplete (Defer_Res_387) then
            Transform_Res_193.Last_Attempted_Child := 0;
         elsif Defer_Res_387 /= null and then not Is_Ghost (Defer_Res_387) then
            Transform_Res_193.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_239 = No_Token_Index then

         Transform_Res_193 := No_Bare_Ada_Node;

         Row_Pos_239 := Row_Pos_238;

      end if;

--  End opt_code

      Row_Progress_31 := 3;

      if Row_Pos_239 /= No_Token_Index then

         Row_Pos_238 := Row_Pos_239;

      else
         Row_Pos_238 := No_Token_Index;
         goto Exit_Row_237_0;

      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_240 := Row_Pos_238;

--  Start opt_code

      Defer_Res_388 := Param_Specs_Transform_Parse_0 (Parser, Row_Pos_240);
      Defer_Pos_388 := Parser.Current_Pos;

      if Defer_Pos_388 = No_Token_Index then

         Defer_Res_388 := No_Bare_Ada_Node;

         Defer_Pos_388 := Row_Pos_240;

      end if;

--  End opt_code

      if Defer_Pos_388 /= No_Token_Index then

         Row_Pos_240 := Defer_Pos_388;

      else
         Row_Pos_240 := No_Token_Index;
         goto Exit_Row_239_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_239_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_240 /= No_Token_Index then

         Transform_Res_194 :=
           Allocate_Entry_Completion_Formal_Params (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_194,
            Kind => Ada_Entry_Completion_Formal_Params, Unit => Parser.Unit,

            Token_Start_Index => Row_Pos_238,
            Token_End_Index   =>
              (if Row_Pos_240 = Row_Pos_238 then No_Token_Index
               else Row_Pos_240 - 1));

         Initialize_Fields_For_Entry_Completion_Formal_Params
           (Self                                    => Transform_Res_194,
            Entry_Completion_Formal_Params_F_Params => Defer_Res_388);

         if Defer_Res_388 /= null and then Is_Incomplete (Defer_Res_388) then
            Transform_Res_194.Last_Attempted_Child := 0;
         elsif Defer_Res_388 /= null and then not Is_Ghost (Defer_Res_388) then
            Transform_Res_194.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      Row_Progress_31 := 4;

      if Row_Pos_240 /= No_Token_Index then

         Row_Pos_238 := Row_Pos_240;

      else
         Row_Pos_238 := No_Token_Index;
         goto Exit_Row_237_0;

      end if;

--  Start tok_code

      Token_Res_352 := Row_Pos_238;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_352));
      begin
         if T.Kind /= From_Token_Kind (Ada_When) then
            Token_Pos_352 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_238 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_238,
                  Expected_Token_Id => Ada_When,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_352 := Row_Pos_238 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_31 := 5;

      if Token_Pos_352 /= No_Token_Index then

         Row_Pos_238 := Token_Pos_352;

      else
         Row_Pos_238 := No_Token_Index;
         goto Exit_Row_237_0;

      end if;

      Defer_Res_389 := Expr_Or_Parse_0 (Parser, Row_Pos_238);
      Defer_Pos_389 := Parser.Current_Pos;

      Row_Progress_31 := 6;

      if Defer_Pos_389 /= No_Token_Index then

         Row_Pos_238 := Defer_Pos_389;

      else
         Row_Pos_238 := No_Token_Index;
         goto Exit_Row_237_0;

      end if;

--  Start tok_code

      Token_Res_353 := Row_Pos_238;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_353));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_353 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_238 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_238,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_353 := Row_Pos_238 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_31 := 7;

      if Token_Pos_353 /= No_Token_Index then

         Row_Pos_238 := Token_Pos_353;

      else
         Row_Pos_238 := No_Token_Index;
         goto Exit_Row_237_0;

      end if;

      Nobt_30 := True;

      Row_Progress_31 := 8;

      if Row_Pos_238 /= No_Token_Index then

         Row_Pos_238 := Row_Pos_238;

      else
         Row_Pos_238 := No_Token_Index;
         goto Exit_Row_237_0;

      end if;

      Defer_Res_390 := Recov_Decl_Part_Dont_Skip_Parse_0 (Parser, Row_Pos_238);
      Defer_Pos_390 := Parser.Current_Pos;

      Row_Progress_31 := 9;

      if Defer_Pos_390 /= No_Token_Index then

         Row_Pos_238 := Defer_Pos_390;

      else
         Row_Pos_238 := No_Token_Index;
         goto Exit_Row_237_0;

      end if;

--  Start tok_code

      Token_Res_354 := Row_Pos_238;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_354));
      begin
         if T.Kind /= From_Token_Kind (Ada_Begin) then
            Token_Pos_354 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_238 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_238,
                  Expected_Token_Id => Ada_Begin,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_354 := Row_Pos_238 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_31 := 10;

      if Token_Pos_354 /= No_Token_Index then

         Row_Pos_238 := Token_Pos_354;

      else
         Row_Pos_238 := No_Token_Index;
         goto Exit_Row_237_0;

      end if;

      Defer_Res_391 := Handled_Stmts_Transform_Parse_0 (Parser, Row_Pos_238);
      Defer_Pos_391 := Parser.Current_Pos;

      Row_Progress_31 := 11;

      if Defer_Pos_391 /= No_Token_Index then

         Row_Pos_238 := Defer_Pos_391;

      else
         Row_Pos_238 := No_Token_Index;
         goto Exit_Row_237_0;

      end if;

--  Start row_code

      Row_Pos_241 := Row_Pos_238;

--  Start tok_code

      Token_Res_355 := Row_Pos_241;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_355));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_355 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_241 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_241,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_355 := Row_Pos_241 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_355 /= No_Token_Index then

         Row_Pos_241 := Token_Pos_355;

      else
         Row_Pos_241 := No_Token_Index;
         goto Exit_Row_240_0;

      end if;

--  Start opt_code

--  Start transform_code

--  Start row_code

      Row_Pos_242 := Row_Pos_241;

      Defer_Res_392 := Static_Name_Or_Parse_0 (Parser, Row_Pos_242);
      Defer_Pos_392 := Parser.Current_Pos;

      if Defer_Pos_392 /= No_Token_Index then

         Row_Pos_242 := Defer_Pos_392;

      else
         Row_Pos_242 := No_Token_Index;
         goto Exit_Row_241_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_241_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_242 /= No_Token_Index then

         Transform_Res_195 := Allocate_End_Name (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_195, Kind => Ada_End_Name,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_241,
            Token_End_Index =>
              (if Row_Pos_242 = Row_Pos_241 then No_Token_Index
               else Row_Pos_242 - 1));

         Initialize_Fields_For_End_Name
           (Self => Transform_Res_195, End_Name_F_Name => Defer_Res_392);

         if Defer_Res_392 /= null and then Is_Incomplete (Defer_Res_392) then
            Transform_Res_195.Last_Attempted_Child := 0;
         elsif Defer_Res_392 /= null and then not Is_Ghost (Defer_Res_392) then
            Transform_Res_195.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_242 = No_Token_Index then

         Transform_Res_195 := No_Bare_Ada_Node;

         Row_Pos_242 := Row_Pos_241;

      end if;

--  End opt_code

      if Row_Pos_242 /= No_Token_Index then

         Row_Pos_241 := Row_Pos_242;

      else
         Row_Pos_241 := No_Token_Index;
         goto Exit_Row_240_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_240_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      Row_Progress_31 := 12;

      if Row_Pos_241 /= No_Token_Index then

         Row_Pos_238 := Row_Pos_241;

      else
         Row_Pos_238 := No_Token_Index;
         goto Exit_Row_237_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_356 := Row_Pos_238;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_356));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_356 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_238 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_238,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_356 := Row_Pos_238 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_356 = No_Token_Index then

         Token_Res_356 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_238).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_356 := Row_Pos_238;

      end if;

--  End opt_code

      Row_Progress_31 := 13;

      if Token_Pos_356 /= No_Token_Index then

         Row_Pos_238 := Token_Pos_356;

      else
         Row_Pos_238 := No_Token_Index;
         goto Exit_Row_237_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_237_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_238 = No_Token_Index and then Nobt_30 then
         Row_Pos_238             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_31 := True;
      end if;

      if Row_Pos_238 /= No_Token_Index then

         Transform_Res_196 := Allocate_Entry_Body (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_196, Kind => Ada_Entry_Body,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_238 = Pos then No_Token_Index else Row_Pos_238 - 1));

         Initialize_Fields_For_Entry_Body
           (Self                    => Transform_Res_196,
            Entry_Body_F_Entry_Name => Defer_Res_385,
            Entry_Body_F_Index_Spec => Transform_Res_193,
            Entry_Body_F_Params     => Transform_Res_194,
            Entry_Body_F_Barrier    => Defer_Res_389,
            Entry_Body_F_Decls      => Defer_Res_390,
            Entry_Body_F_Stmts      => Defer_Res_391,
            Entry_Body_F_End_Name   => Transform_Res_195);

         if Defer_Res_385 /= null and then Is_Incomplete (Defer_Res_385) then
            Transform_Res_196.Last_Attempted_Child := 0;
         elsif Defer_Res_385 /= null and then not Is_Ghost (Defer_Res_385) then
            Transform_Res_196.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_193 /= null
           and then Is_Incomplete (Transform_Res_193)
         then
            Transform_Res_196.Last_Attempted_Child := 0;
         elsif Transform_Res_193 /= null
           and then not Is_Ghost (Transform_Res_193)
         then
            Transform_Res_196.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_194 /= null
           and then Is_Incomplete (Transform_Res_194)
         then
            Transform_Res_196.Last_Attempted_Child := 0;
         elsif Transform_Res_194 /= null
           and then not Is_Ghost (Transform_Res_194)
         then
            Transform_Res_196.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_389 /= null and then Is_Incomplete (Defer_Res_389) then
            Transform_Res_196.Last_Attempted_Child := 0;
         elsif Defer_Res_389 /= null and then not Is_Ghost (Defer_Res_389) then
            Transform_Res_196.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_390 /= null and then Is_Incomplete (Defer_Res_390) then
            Transform_Res_196.Last_Attempted_Child := 0;
         elsif Defer_Res_390 /= null and then not Is_Ghost (Defer_Res_390) then
            Transform_Res_196.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_391 /= null and then Is_Incomplete (Defer_Res_391) then
            Transform_Res_196.Last_Attempted_Child := 0;
         elsif Defer_Res_391 /= null and then not Is_Ghost (Defer_Res_391) then
            Transform_Res_196.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_195 /= null
           and then Is_Incomplete (Transform_Res_195)
         then
            Transform_Res_196.Last_Attempted_Child := 0;
         elsif Transform_Res_195 /= null
           and then not Is_Ghost (Transform_Res_195)
         then
            Transform_Res_196.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_31 then
            Transform_Res_196.Last_Attempted_Child := Row_Progress_31;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <entry_body>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Entry_Body_Transform_Parse_3_Memo,
         Row_Pos_238 /= No_Token_Index, Transform_Res_196, Pos, Row_Pos_238);

      Parser.Current_Pos := Row_Pos_238;

      return Transform_Res_196;
   end Entry_Body_Transform_Parse_3;

   function Body_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Body_Node
   is
      use Bare_Body_Node_Memos;

      Defer_Pos_262 : Token_Index         := No_Token_Index;
      Defer_Res_262 : Bare_Subp_Body      := No_Bare_Ada_Node;
      Defer_Pos_263 : Token_Index         := No_Token_Index;
      Defer_Res_263 : Bare_Package_Body   := No_Bare_Ada_Node;
      Defer_Pos_264 : Token_Index         := No_Token_Index;
      Defer_Res_264 : Bare_Task_Body      := No_Bare_Ada_Node;
      Defer_Pos_265 : Token_Index         := No_Token_Index;
      Defer_Res_265 : Bare_Protected_Body := No_Bare_Ada_Node;
      Defer_Pos_266 : Token_Index         := No_Token_Index;
      Defer_Res_266 : Bare_Entry_Body     := No_Bare_Ada_Node;
      Or_Pos_63     : Token_Index         := No_Token_Index;
      Or_Res_63     : Bare_Body_Node      := No_Bare_Ada_Node;

      M : Memo_Entry := Get (Parser.Private_Part.Body_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_63          := M.Instance;
         return Or_Res_63;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_63;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_63 := No_Token_Index;
      Or_Res_63 := No_Bare_Ada_Node;

      Defer_Res_262 := Subp_Body_Transform_Parse_1 (Parser, Pos);
      Defer_Pos_262 := Parser.Current_Pos;

      if Defer_Pos_262 /= No_Token_Index then
         Or_Pos_63 := Defer_Pos_262;
         Or_Res_63 := Defer_Res_262;
         goto Exit_Or_63;
      end if;

      Defer_Res_263 := Package_Body_Transform_Parse_1 (Parser, Pos);
      Defer_Pos_263 := Parser.Current_Pos;

      if Defer_Pos_263 /= No_Token_Index then
         Or_Pos_63 := Defer_Pos_263;
         Or_Res_63 := Defer_Res_263;
         goto Exit_Or_63;
      end if;

      Defer_Res_264 := Task_Body_Transform_Parse_1 (Parser, Pos);
      Defer_Pos_264 := Parser.Current_Pos;

      if Defer_Pos_264 /= No_Token_Index then
         Or_Pos_63 := Defer_Pos_264;
         Or_Res_63 := Defer_Res_264;
         goto Exit_Or_63;
      end if;

      Defer_Res_265 := Protected_Body_Transform_Parse_1 (Parser, Pos);
      Defer_Pos_265 := Parser.Current_Pos;

      if Defer_Pos_265 /= No_Token_Index then
         Or_Pos_63 := Defer_Pos_265;
         Or_Res_63 := Defer_Res_265;
         goto Exit_Or_63;
      end if;

      Defer_Res_266 := Entry_Body_Transform_Parse_3 (Parser, Pos);
      Defer_Pos_266 := Parser.Current_Pos;

      if Defer_Pos_266 /= No_Token_Index then
         Or_Pos_63 := Defer_Pos_266;
         Or_Res_63 := Defer_Res_266;
         goto Exit_Or_63;
      end if;
      <<Exit_Or_63>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Body_Or_Parse_0_Memo, Or_Pos_63 /= No_Token_Index,
         Or_Res_63, Pos, Or_Pos_63);

      Parser.Current_Pos := Or_Pos_63;

      return Or_Res_63;
   end Body_Or_Parse_0;

   function Discriminant_Spec_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Discriminant_Spec
   is
      use Bare_Discriminant_Spec_Memos;

      Row_Pos_249       : Token_Index             := No_Token_Index;
      Lst_Cpos_29       : Token_Index             := No_Token_Index;
      Tmp_List_29       : Free_Parse_List;
      Defer_Pos_403     : Token_Index             := No_Token_Index;
      Defer_Res_403     : Bare_Defining_Name      := No_Bare_Ada_Node;
      Token_Pos_377     : Token_Index             := No_Token_Index;
      Token_Res_377     : Token_Index             := No_Token_Index;
      List_Pos_29       : Token_Index             := No_Token_Index;
      List_Res_29       : Bare_Defining_Name_List := No_Bare_Ada_Node;
      Token_Pos_378     : Token_Index             := No_Token_Index;
      Token_Res_378     : Token_Index             := No_Token_Index;
      Defer_Pos_404     : Token_Index             := No_Token_Index;
      Defer_Res_404     : Bare_Type_Expr          := No_Bare_Ada_Node;
      Row_Pos_250       : Token_Index             := No_Token_Index;
      Token_Pos_379     : Token_Index             := No_Token_Index;
      Token_Res_379     : Token_Index             := No_Token_Index;
      Defer_Pos_405     : Token_Index             := No_Token_Index;
      Defer_Res_405     : Bare_Expr               := No_Bare_Ada_Node;
      Transform_Res_203 : Bare_Discriminant_Spec  := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Discriminant_Spec_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_203  := M.Instance;
         return Transform_Res_203;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_203;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_249 := Pos;

--  Start list_code

      List_Pos_29 := No_Token_Index;

      Lst_Cpos_29 := Row_Pos_249;
      Tmp_List_29 := Get_Parse_List (Parser);

      loop

         Defer_Res_403 := Defining_Id_Transform_Parse_0 (Parser, Lst_Cpos_29);
         Defer_Pos_403 := Parser.Current_Pos;

         exit when Defer_Pos_403 = No_Token_Index;

         List_Pos_29 := Defer_Pos_403;
         Lst_Cpos_29 := List_Pos_29;

         Tmp_List_29.Nodes.Append (Defer_Res_403);

--  Start tok_code

         Token_Res_377 := Lst_Cpos_29;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_377));
         begin
            if T.Kind /= From_Token_Kind (Ada_Comma) then
               Token_Pos_377 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_29 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_29,
                     Expected_Token_Id => Ada_Comma,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_377 := Lst_Cpos_29 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_377 /= No_Token_Index then
            Lst_Cpos_29 := Token_Pos_377;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_29.Nodes.Length;
      begin
         List_Res_29 := Allocate_Defining_Name_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_249;
            Token_End   :=
              (if Lst_Cpos_29 = Row_Pos_249 then Row_Pos_249
               else Lst_Cpos_29 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_249, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self            => List_Res_29, Kind => Ada_Defining_Name_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_29, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_29.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_29.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_29);

--  End list_code

      if List_Pos_29 /= No_Token_Index then

         Row_Pos_249 := List_Pos_29;

      else
         Row_Pos_249 := No_Token_Index;
         goto Exit_Row_244_0;

      end if;

--  Start tok_code

      Token_Res_378 := Row_Pos_249;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_378));
      begin
         if T.Kind /= From_Token_Kind (Ada_Colon) then
            Token_Pos_378 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_249 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_249,
                  Expected_Token_Id => Ada_Colon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_378 := Row_Pos_249 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_378 /= No_Token_Index then

         Row_Pos_249 := Token_Pos_378;

      else
         Row_Pos_249 := No_Token_Index;
         goto Exit_Row_244_0;

      end if;

      Defer_Res_404 := Type_Expr_Or_Parse_0 (Parser, Row_Pos_249);
      Defer_Pos_404 := Parser.Current_Pos;

      if Defer_Pos_404 /= No_Token_Index then

         Row_Pos_249 := Defer_Pos_404;

      else
         Row_Pos_249 := No_Token_Index;
         goto Exit_Row_244_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_250 := Row_Pos_249;

--  Start tok_code

      Token_Res_379 := Row_Pos_250;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_379));
      begin
         if T.Kind /= From_Token_Kind (Ada_Assign) then
            Token_Pos_379 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_250 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_250,
                  Expected_Token_Id => Ada_Assign,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_379 := Row_Pos_250 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_379 /= No_Token_Index then

         Row_Pos_250 := Token_Pos_379;

      else
         Row_Pos_250 := No_Token_Index;
         goto Exit_Row_245_0;

      end if;

      Defer_Res_405 := Expr_Or_Parse_0 (Parser, Row_Pos_250);
      Defer_Pos_405 := Parser.Current_Pos;

      if Defer_Pos_405 /= No_Token_Index then

         Row_Pos_250 := Defer_Pos_405;

      else
         Row_Pos_250 := No_Token_Index;
         goto Exit_Row_245_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_245_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_250 = No_Token_Index then

         Defer_Res_405 := No_Bare_Ada_Node;

         Row_Pos_250 := Row_Pos_249;

      end if;

--  End opt_code

      if Row_Pos_250 /= No_Token_Index then

         Row_Pos_249 := Row_Pos_250;

      else
         Row_Pos_249 := No_Token_Index;
         goto Exit_Row_244_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_244_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_249 /= No_Token_Index then

         Transform_Res_203 := Allocate_Discriminant_Spec (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_203, Kind => Ada_Discriminant_Spec,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_249 = Pos then No_Token_Index else Row_Pos_249 - 1));

         Initialize_Fields_For_Discriminant_Spec
           (Self => Transform_Res_203, Discriminant_Spec_F_Ids => List_Res_29,
            Discriminant_Spec_F_Type_Expr    => Defer_Res_404,
            Discriminant_Spec_F_Default_Expr => Defer_Res_405);

         if List_Res_29 /= null and then Is_Incomplete (List_Res_29) then
            Transform_Res_203.Last_Attempted_Child := 0;
         elsif List_Res_29 /= null and then not Is_Ghost (List_Res_29) then
            Transform_Res_203.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_404 /= null and then Is_Incomplete (Defer_Res_404) then
            Transform_Res_203.Last_Attempted_Child := 0;
         elsif Defer_Res_404 /= null and then not Is_Ghost (Defer_Res_404) then
            Transform_Res_203.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_405 /= null and then Is_Incomplete (Defer_Res_405) then
            Transform_Res_203.Last_Attempted_Child := 0;
         elsif Defer_Res_405 /= null and then not Is_Ghost (Defer_Res_405) then
            Transform_Res_203.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Discriminant_Spec_Transform_Parse_0_Memo,
         Row_Pos_249 /= No_Token_Index, Transform_Res_203, Pos, Row_Pos_249);

      Parser.Current_Pos := Row_Pos_249;

      return Transform_Res_203;
   end Discriminant_Spec_Transform_Parse_0;

   function Discr_Spec_List_List_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Discriminant_Spec_List
   is
      use Bare_Discriminant_Spec_List_Memos;

      Lst_Cpos_28   : Token_Index                 := No_Token_Index;
      Tmp_List_28   : Free_Parse_List;
      Defer_Pos_402 : Token_Index                 := No_Token_Index;
      Defer_Res_402 : Bare_Discriminant_Spec      := No_Bare_Ada_Node;
      Token_Pos_376 : Token_Index                 := No_Token_Index;
      Token_Res_376 : Token_Index                 := No_Token_Index;
      List_Pos_28   : Token_Index                 := No_Token_Index;
      List_Res_28   : Bare_Discriminant_Spec_List := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Discr_Spec_List_List_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         List_Res_28        := M.Instance;
         return List_Res_28;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return List_Res_28;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start list_code

      List_Pos_28 := No_Token_Index;

      Lst_Cpos_28 := Pos;
      Tmp_List_28 := Get_Parse_List (Parser);

      loop

         Defer_Res_402 :=
           Discriminant_Spec_Transform_Parse_0 (Parser, Lst_Cpos_28);
         Defer_Pos_402 := Parser.Current_Pos;

         exit when Defer_Pos_402 = No_Token_Index;

         List_Pos_28 := Defer_Pos_402;
         Lst_Cpos_28 := List_Pos_28;

         Tmp_List_28.Nodes.Append (Defer_Res_402);

--  Start tok_code

         Token_Res_376 := Lst_Cpos_28;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_376));
         begin
            if T.Kind /= From_Token_Kind (Ada_Semicolon) then
               Token_Pos_376 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_28 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_28,
                     Expected_Token_Id => Ada_Semicolon,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_376 := Lst_Cpos_28 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_376 /= No_Token_Index then
            Lst_Cpos_28 := Token_Pos_376;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_28.Nodes.Length;
      begin
         List_Res_28 := Allocate_Discriminant_Spec_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Pos;
            Token_End := (if Lst_Cpos_28 = Pos then Pos else Lst_Cpos_28 - 1);

         else
            Token_Start := Token_Index'Max (Pos, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self            => List_Res_28, Kind => Ada_Discriminant_Spec_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_28, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_28.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_28.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_28);

--  End list_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Discr_Spec_List_List_Parse_0_Memo,
         List_Pos_28 /= No_Token_Index, List_Res_28, Pos, List_Pos_28);

      Parser.Current_Pos := List_Pos_28;

      return List_Res_28;
   end Discr_Spec_List_List_Parse_0;

   function Discriminant_Part_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Discriminant_Part
   is
      use Bare_Discriminant_Part_Memos;

      Row_Pos_247       : Token_Index                    := No_Token_Index;
      Token_Pos_371     : Token_Index                    := No_Token_Index;
      Token_Res_371     : Token_Index                    := No_Token_Index;
      Defer_Pos_401     : Token_Index                    := No_Token_Index;
      Defer_Res_401     : Bare_Discriminant_Spec_List    := No_Bare_Ada_Node;
      Token_Pos_372     : Token_Index                    := No_Token_Index;
      Token_Res_372     : Token_Index                    := No_Token_Index;
      Transform_Res_201 : Bare_Known_Discriminant_Part   := No_Bare_Ada_Node;
      Row_Pos_248       : Token_Index                    := No_Token_Index;
      Token_Pos_373     : Token_Index                    := No_Token_Index;
      Token_Res_373     : Token_Index                    := No_Token_Index;
      Token_Pos_374     : Token_Index                    := No_Token_Index;
      Token_Res_374     : Token_Index                    := No_Token_Index;
      Token_Pos_375     : Token_Index                    := No_Token_Index;
      Token_Res_375     : Token_Index                    := No_Token_Index;
      Transform_Res_202 : Bare_Unknown_Discriminant_Part := No_Bare_Ada_Node;
      Or_Pos_79         : Token_Index                    := No_Token_Index;
      Or_Res_79         : Bare_Discriminant_Part         := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Discriminant_Part_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_79          := M.Instance;
         return Or_Res_79;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_79;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_79 := No_Token_Index;
      Or_Res_79 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_247 := Pos;

--  Start tok_code

      Token_Res_371 := Row_Pos_247;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_371));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Open) then
            Token_Pos_371 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_247 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_247,
                  Expected_Token_Id => Ada_Par_Open,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_371 := Row_Pos_247 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_371 /= No_Token_Index then

         Row_Pos_247 := Token_Pos_371;

      else
         Row_Pos_247 := No_Token_Index;
         goto Exit_Row_243_0;

      end if;

      Defer_Res_401 := Discr_Spec_List_List_Parse_0 (Parser, Row_Pos_247);
      Defer_Pos_401 := Parser.Current_Pos;

      if Defer_Pos_401 /= No_Token_Index then

         Row_Pos_247 := Defer_Pos_401;

      else
         Row_Pos_247 := No_Token_Index;
         goto Exit_Row_243_0;

      end if;

--  Start tok_code

      Token_Res_372 := Row_Pos_247;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_372));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Close) then
            Token_Pos_372 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_247 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_247,
                  Expected_Token_Id => Ada_Par_Close,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_372 := Row_Pos_247 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_372 /= No_Token_Index then

         Row_Pos_247 := Token_Pos_372;

      else
         Row_Pos_247 := No_Token_Index;
         goto Exit_Row_243_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_243_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_247 /= No_Token_Index then

         Transform_Res_201 :=
           Allocate_Known_Discriminant_Part (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_201, Kind => Ada_Known_Discriminant_Part,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_247 = Pos then No_Token_Index else Row_Pos_247 - 1));

         Initialize_Fields_For_Known_Discriminant_Part
           (Self                                  => Transform_Res_201,
            Known_Discriminant_Part_F_Discr_Specs => Defer_Res_401);

         if Defer_Res_401 /= null and then Is_Incomplete (Defer_Res_401) then
            Transform_Res_201.Last_Attempted_Child := 0;
         elsif Defer_Res_401 /= null and then not Is_Ghost (Defer_Res_401) then
            Transform_Res_201.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_247 /= No_Token_Index then
         Or_Pos_79 := Row_Pos_247;
         Or_Res_79 := Transform_Res_201;
         goto Exit_Or_79;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_248 := Pos;

--  Start tok_code

      Token_Res_373 := Row_Pos_248;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_373));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Open) then
            Token_Pos_373 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_248 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_248,
                  Expected_Token_Id => Ada_Par_Open,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_373 := Row_Pos_248 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_373 /= No_Token_Index then

         Row_Pos_248 := Token_Pos_373;

      else
         Row_Pos_248 := No_Token_Index;
         goto Exit_Row_246_0;

      end if;

--  Start tok_code

      Token_Res_374 := Row_Pos_248;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_374));
      begin
         if T.Kind /= From_Token_Kind (Ada_Diamond) then
            Token_Pos_374 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_248 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_248,
                  Expected_Token_Id => Ada_Diamond,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_374 := Row_Pos_248 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_374 /= No_Token_Index then

         Row_Pos_248 := Token_Pos_374;

      else
         Row_Pos_248 := No_Token_Index;
         goto Exit_Row_246_0;

      end if;

--  Start tok_code

      Token_Res_375 := Row_Pos_248;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_375));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Close) then
            Token_Pos_375 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_248 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_248,
                  Expected_Token_Id => Ada_Par_Close,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_375 := Row_Pos_248 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_375 /= No_Token_Index then

         Row_Pos_248 := Token_Pos_375;

      else
         Row_Pos_248 := No_Token_Index;
         goto Exit_Row_246_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_246_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_248 /= No_Token_Index then

         Transform_Res_202 :=
           Allocate_Unknown_Discriminant_Part (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_202, Kind => Ada_Unknown_Discriminant_Part,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_248 = Pos then No_Token_Index else Row_Pos_248 - 1));

      end if;

--  End transform_code

      if Row_Pos_248 /= No_Token_Index then
         Or_Pos_79 := Row_Pos_248;
         Or_Res_79 := Transform_Res_202;
         goto Exit_Or_79;
      end if;
      <<Exit_Or_79>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Discriminant_Part_Or_Parse_0_Memo,
         Or_Pos_79 /= No_Token_Index, Or_Res_79, Pos, Or_Pos_79);

      Parser.Current_Pos := Or_Pos_79;

      return Or_Res_79;
   end Discriminant_Part_Or_Parse_0;

   function Component_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Component_Decl
   is
      use Bare_Component_Decl_Memos;

      Row_Pos_257       : Token_Index             := No_Token_Index;
      Lst_Cpos_31       : Token_Index             := No_Token_Index;
      Tmp_List_31       : Free_Parse_List;
      Defer_Pos_423     : Token_Index             := No_Token_Index;
      Defer_Res_423     : Bare_Defining_Name      := No_Bare_Ada_Node;
      Token_Pos_390     : Token_Index             := No_Token_Index;
      Token_Res_390     : Token_Index             := No_Token_Index;
      List_Pos_31       : Token_Index             := No_Token_Index;
      List_Res_31       : Bare_Defining_Name_List := No_Bare_Ada_Node;
      Token_Pos_391     : Token_Index             := No_Token_Index;
      Token_Res_391     : Token_Index             := No_Token_Index;
      Defer_Pos_424     : Token_Index             := No_Token_Index;
      Defer_Res_424     : Bare_Component_Def      := No_Bare_Ada_Node;
      Row_Pos_258       : Token_Index             := No_Token_Index;
      Token_Pos_392     : Token_Index             := No_Token_Index;
      Token_Res_392     : Token_Index             := No_Token_Index;
      Defer_Pos_425     : Token_Index             := No_Token_Index;
      Defer_Res_425     : Bare_Expr               := No_Bare_Ada_Node;
      Defer_Pos_426     : Token_Index             := No_Token_Index;
      Defer_Res_426     : Bare_Aspect_Spec        := No_Bare_Ada_Node;
      Token_Pos_393     : Token_Index             := No_Token_Index;
      Token_Res_393     : Token_Index             := No_Token_Index;
      Transform_Res_210 : Bare_Component_Decl     := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Component_Decl_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_210  := M.Instance;
         return Transform_Res_210;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_210;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_257 := Pos;

--  Start list_code

      List_Pos_31 := No_Token_Index;

      Lst_Cpos_31 := Row_Pos_257;
      Tmp_List_31 := Get_Parse_List (Parser);

      loop

         Defer_Res_423 := Defining_Id_Transform_Parse_0 (Parser, Lst_Cpos_31);
         Defer_Pos_423 := Parser.Current_Pos;

         exit when Defer_Pos_423 = No_Token_Index;

         List_Pos_31 := Defer_Pos_423;
         Lst_Cpos_31 := List_Pos_31;

         Tmp_List_31.Nodes.Append (Defer_Res_423);

--  Start tok_code

         Token_Res_390 := Lst_Cpos_31;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_390));
         begin
            if T.Kind /= From_Token_Kind (Ada_Comma) then
               Token_Pos_390 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_31 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_31,
                     Expected_Token_Id => Ada_Comma,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_390 := Lst_Cpos_31 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_390 /= No_Token_Index then
            Lst_Cpos_31 := Token_Pos_390;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_31.Nodes.Length;
      begin
         List_Res_31 := Allocate_Defining_Name_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_257;
            Token_End   :=
              (if Lst_Cpos_31 = Row_Pos_257 then Row_Pos_257
               else Lst_Cpos_31 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_257, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self            => List_Res_31, Kind => Ada_Defining_Name_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_31, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_31.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_31.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_31);

--  End list_code

      if List_Pos_31 /= No_Token_Index then

         Row_Pos_257 := List_Pos_31;

      else
         Row_Pos_257 := No_Token_Index;
         goto Exit_Row_251_0;

      end if;

--  Start tok_code

      Token_Res_391 := Row_Pos_257;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_391));
      begin
         if T.Kind /= From_Token_Kind (Ada_Colon) then
            Token_Pos_391 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_257 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_257,
                  Expected_Token_Id => Ada_Colon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_391 := Row_Pos_257 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_391 /= No_Token_Index then

         Row_Pos_257 := Token_Pos_391;

      else
         Row_Pos_257 := No_Token_Index;
         goto Exit_Row_251_0;

      end if;

      Defer_Res_424 := Component_Def_Transform_Parse_0 (Parser, Row_Pos_257);
      Defer_Pos_424 := Parser.Current_Pos;

      if Defer_Pos_424 /= No_Token_Index then

         Row_Pos_257 := Defer_Pos_424;

      else
         Row_Pos_257 := No_Token_Index;
         goto Exit_Row_251_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_258 := Row_Pos_257;

--  Start tok_code

      Token_Res_392 := Row_Pos_258;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_392));
      begin
         if T.Kind /= From_Token_Kind (Ada_Assign) then
            Token_Pos_392 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_258 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_258,
                  Expected_Token_Id => Ada_Assign,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_392 := Row_Pos_258 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_392 /= No_Token_Index then

         Row_Pos_258 := Token_Pos_392;

      else
         Row_Pos_258 := No_Token_Index;
         goto Exit_Row_252_0;

      end if;

      Defer_Res_425 := Expr_Or_Parse_0 (Parser, Row_Pos_258);
      Defer_Pos_425 := Parser.Current_Pos;

      if Defer_Pos_425 /= No_Token_Index then

         Row_Pos_258 := Defer_Pos_425;

      else
         Row_Pos_258 := No_Token_Index;
         goto Exit_Row_252_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_252_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_258 = No_Token_Index then

         Defer_Res_425 := No_Bare_Ada_Node;

         Row_Pos_258 := Row_Pos_257;

      end if;

--  End opt_code

      if Row_Pos_258 /= No_Token_Index then

         Row_Pos_257 := Row_Pos_258;

      else
         Row_Pos_257 := No_Token_Index;
         goto Exit_Row_251_0;

      end if;

      Defer_Res_426 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_257);
      Defer_Pos_426 := Parser.Current_Pos;

      if Defer_Pos_426 /= No_Token_Index then

         Row_Pos_257 := Defer_Pos_426;

      else
         Row_Pos_257 := No_Token_Index;
         goto Exit_Row_251_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_393 := Row_Pos_257;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_393));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_393 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_257 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_257,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_393 := Row_Pos_257 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_393 = No_Token_Index then

         Token_Res_393 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_257).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_393 := Row_Pos_257;

      end if;

--  End opt_code

      if Token_Pos_393 /= No_Token_Index then

         Row_Pos_257 := Token_Pos_393;

      else
         Row_Pos_257 := No_Token_Index;
         goto Exit_Row_251_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_251_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_257 /= No_Token_Index then

         Transform_Res_210 := Allocate_Component_Decl (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_210, Kind => Ada_Component_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_257 = Pos then No_Token_Index else Row_Pos_257 - 1));

         Initialize_Fields_For_Component_Decl
           (Self => Transform_Res_210, Component_Decl_F_Ids => List_Res_31,
            Component_Decl_F_Component_Def => Defer_Res_424,
            Component_Decl_F_Default_Expr  => Defer_Res_425,
            Component_Decl_F_Aspects       => Defer_Res_426);

         if List_Res_31 /= null and then Is_Incomplete (List_Res_31) then
            Transform_Res_210.Last_Attempted_Child := 0;
         elsif List_Res_31 /= null and then not Is_Ghost (List_Res_31) then
            Transform_Res_210.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_424 /= null and then Is_Incomplete (Defer_Res_424) then
            Transform_Res_210.Last_Attempted_Child := 0;
         elsif Defer_Res_424 /= null and then not Is_Ghost (Defer_Res_424) then
            Transform_Res_210.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_425 /= null and then Is_Incomplete (Defer_Res_425) then
            Transform_Res_210.Last_Attempted_Child := 0;
         elsif Defer_Res_425 /= null and then not Is_Ghost (Defer_Res_425) then
            Transform_Res_210.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_426 /= null and then Is_Incomplete (Defer_Res_426) then
            Transform_Res_210.Last_Attempted_Child := 0;
         elsif Defer_Res_426 /= null and then not Is_Ghost (Defer_Res_426) then
            Transform_Res_210.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Component_Decl_Transform_Parse_0_Memo,
         Row_Pos_257 /= No_Token_Index, Transform_Res_210, Pos, Row_Pos_257);

      Parser.Current_Pos := Row_Pos_257;

      return Transform_Res_210;
   end Component_Decl_Transform_Parse_0;

   function Component_Clause_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Component_Clause
   is
      use Bare_Component_Clause_Memos;

      Row_Pos_264       : Token_Index           := No_Token_Index;
      Defer_Pos_437     : Token_Index           := No_Token_Index;
      Defer_Res_437     : Bare_Identifier       := No_Bare_Ada_Node;
      Token_Pos_413     : Token_Index           := No_Token_Index;
      Token_Res_413     : Token_Index           := No_Token_Index;
      Defer_Pos_438     : Token_Index           := No_Token_Index;
      Defer_Res_438     : Bare_Expr             := No_Bare_Ada_Node;
      Defer_Pos_439     : Token_Index           := No_Token_Index;
      Defer_Res_439     : Bare_Range_Spec       := No_Bare_Ada_Node;
      Token_Pos_414     : Token_Index           := No_Token_Index;
      Token_Res_414     : Token_Index           := No_Token_Index;
      Transform_Res_215 : Bare_Component_Clause := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Component_Clause_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_215  := M.Instance;
         return Transform_Res_215;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_215;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_264 := Pos;

      Defer_Res_437 := Identifier_Transform_Parse_0 (Parser, Row_Pos_264);
      Defer_Pos_437 := Parser.Current_Pos;

      if Defer_Pos_437 /= No_Token_Index then

         Row_Pos_264 := Defer_Pos_437;

      else
         Row_Pos_264 := No_Token_Index;
         goto Exit_Row_256_0;

      end if;

--  Start tok_code

      Token_Res_413 := Row_Pos_264;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_413));
      begin
         if T.Kind /= From_Token_Kind (Ada_At) then
            Token_Pos_413 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_264 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_264,
                  Expected_Token_Id => Ada_At,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_413 := Row_Pos_264 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_413 /= No_Token_Index then

         Row_Pos_264 := Token_Pos_413;

      else
         Row_Pos_264 := No_Token_Index;
         goto Exit_Row_256_0;

      end if;

      Defer_Res_438 := Simple_Expr_Or_Parse_1 (Parser, Row_Pos_264);
      Defer_Pos_438 := Parser.Current_Pos;

      if Defer_Pos_438 /= No_Token_Index then

         Row_Pos_264 := Defer_Pos_438;

      else
         Row_Pos_264 := No_Token_Index;
         goto Exit_Row_256_0;

      end if;

      Defer_Res_439 := Range_Spec_Transform_Parse_0 (Parser, Row_Pos_264);
      Defer_Pos_439 := Parser.Current_Pos;

      if Defer_Pos_439 /= No_Token_Index then

         Row_Pos_264 := Defer_Pos_439;

      else
         Row_Pos_264 := No_Token_Index;
         goto Exit_Row_256_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_414 := Row_Pos_264;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_414));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_414 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_264 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_264,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_414 := Row_Pos_264 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_414 = No_Token_Index then

         Token_Res_414 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_264).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_414 := Row_Pos_264;

      end if;

--  End opt_code

      if Token_Pos_414 /= No_Token_Index then

         Row_Pos_264 := Token_Pos_414;

      else
         Row_Pos_264 := No_Token_Index;
         goto Exit_Row_256_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_256_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_264 /= No_Token_Index then

         Transform_Res_215 := Allocate_Component_Clause (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_215, Kind => Ada_Component_Clause,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_264 = Pos then No_Token_Index else Row_Pos_264 - 1));

         Initialize_Fields_For_Component_Clause
           (Self => Transform_Res_215, Component_Clause_F_Id => Defer_Res_437,
            Component_Clause_F_Position => Defer_Res_438,
            Component_Clause_F_Range    => Defer_Res_439);

         if Defer_Res_437 /= null and then Is_Incomplete (Defer_Res_437) then
            Transform_Res_215.Last_Attempted_Child := 0;
         elsif Defer_Res_437 /= null and then not Is_Ghost (Defer_Res_437) then
            Transform_Res_215.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_438 /= null and then Is_Incomplete (Defer_Res_438) then
            Transform_Res_215.Last_Attempted_Child := 0;
         elsif Defer_Res_438 /= null and then not Is_Ghost (Defer_Res_438) then
            Transform_Res_215.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_439 /= null and then Is_Incomplete (Defer_Res_439) then
            Transform_Res_215.Last_Attempted_Child := 0;
         elsif Defer_Res_439 /= null and then not Is_Ghost (Defer_Res_439) then
            Transform_Res_215.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Component_Clause_Transform_Parse_0_Memo,
         Row_Pos_264 /= No_Token_Index, Transform_Res_215, Pos, Row_Pos_264);

      Parser.Current_Pos := Row_Pos_264;

      return Transform_Res_215;
   end Component_Clause_Transform_Parse_0;

   function Aspect_Clause_Or_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Aspect_Clause
   is
      use Bare_Aspect_Clause_Memos;

      Nobt_31                 : Boolean                   := False;
      Nobt_32                 : Boolean                   := False;
      Row_Pos_259             : Token_Index               := No_Token_Index;
      Token_Pos_394           : Token_Index               := No_Token_Index;
      Token_Res_394           : Token_Index               := No_Token_Index;
      Defer_Pos_427           : Token_Index               := No_Token_Index;
      Defer_Res_427           : Bare_Name                 := No_Bare_Ada_Node;
      Token_Pos_395           : Token_Index               := No_Token_Index;
      Token_Res_395           : Token_Index               := No_Token_Index;
      Defer_Pos_428           : Token_Index               := No_Token_Index;
      Defer_Res_428           : Bare_Base_Aggregate       := No_Bare_Ada_Node;
      Token_Pos_396           : Token_Index               := No_Token_Index;
      Token_Res_396           : Token_Index               := No_Token_Index;
      Row_Progress_32         : Integer                   := 0;
      Transform_Res_211       : Bare_Enum_Rep_Clause      := No_Bare_Ada_Node;
      Transform_Has_Failed_32 : Boolean                   := False;
      Row_Pos_260             : Token_Index               := No_Token_Index;
      Token_Pos_397           : Token_Index               := No_Token_Index;
      Token_Res_397           : Token_Index               := No_Token_Index;
      Defer_Pos_429           : Token_Index               := No_Token_Index;
      Defer_Res_429           : Bare_Name                 := No_Bare_Ada_Node;
      Token_Pos_398           : Token_Index               := No_Token_Index;
      Token_Res_398           : Token_Index               := No_Token_Index;
      Token_Pos_399           : Token_Index               := No_Token_Index;
      Token_Res_399           : Token_Index               := No_Token_Index;
      Row_Pos_261             : Token_Index               := No_Token_Index;
      Token_Pos_400           : Token_Index               := No_Token_Index;
      Token_Res_400           : Token_Index               := No_Token_Index;
      Token_Pos_401           : Token_Index               := No_Token_Index;
      Token_Res_401           : Token_Index               := No_Token_Index;
      Defer_Pos_430           : Token_Index               := No_Token_Index;
      Defer_Res_430           : Bare_Expr                 := No_Bare_Ada_Node;
      Token_Pos_402           : Token_Index               := No_Token_Index;
      Token_Res_402           : Token_Index               := No_Token_Index;
      Lst_Cpos_32             : Token_Index               := No_Token_Index;
      Tmp_List_32             : Free_Parse_List;
      Defer_Pos_431           : Token_Index               := No_Token_Index;
      Defer_Res_431           : Bare_Component_Clause     := No_Bare_Ada_Node;
      Defer_Pos_432           : Token_Index               := No_Token_Index;
      Defer_Res_432           : Bare_Pragma_Node          := No_Bare_Ada_Node;
      Or_Pos_83               : Token_Index               := No_Token_Index;
      Or_Res_83               : Bare_Ada_Node             := No_Bare_Ada_Node;
      List_Pos_32             : Token_Index               := No_Token_Index;
      List_Res_32             : Bare_Ada_Node_List        := No_Bare_Ada_Node;
      Token_Pos_403           : Token_Index               := No_Token_Index;
      Token_Res_403           : Token_Index               := No_Token_Index;
      Token_Pos_404           : Token_Index               := No_Token_Index;
      Token_Res_404           : Token_Index               := No_Token_Index;
      Token_Pos_405           : Token_Index               := No_Token_Index;
      Token_Res_405           : Token_Index               := No_Token_Index;
      Transform_Res_212       : Bare_Record_Rep_Clause    := No_Bare_Ada_Node;
      Row_Pos_262             : Token_Index               := No_Token_Index;
      Token_Pos_406           : Token_Index               := No_Token_Index;
      Token_Res_406           : Token_Index               := No_Token_Index;
      Defer_Pos_433           : Token_Index               := No_Token_Index;
      Defer_Res_433           : Bare_Base_Id              := No_Bare_Ada_Node;
      Token_Pos_407           : Token_Index               := No_Token_Index;
      Token_Res_407           : Token_Index               := No_Token_Index;
      Token_Pos_408           : Token_Index               := No_Token_Index;
      Token_Res_408           : Token_Index               := No_Token_Index;
      Defer_Pos_434           : Token_Index               := No_Token_Index;
      Defer_Res_434           : Bare_Expr                 := No_Bare_Ada_Node;
      Token_Pos_409           : Token_Index               := No_Token_Index;
      Token_Res_409           : Token_Index               := No_Token_Index;
      Transform_Res_213       : Bare_At_Clause            := No_Bare_Ada_Node;
      Row_Pos_263             : Token_Index               := No_Token_Index;
      Token_Pos_410           : Token_Index               := No_Token_Index;
      Token_Res_410           : Token_Index               := No_Token_Index;
      Defer_Pos_435           : Token_Index               := No_Token_Index;
      Defer_Res_435           : Bare_Name                 := No_Bare_Ada_Node;
      Token_Pos_411           : Token_Index               := No_Token_Index;
      Token_Res_411           : Token_Index               := No_Token_Index;
      Defer_Pos_436           : Token_Index               := No_Token_Index;
      Defer_Res_436           : Bare_Expr                 := No_Bare_Ada_Node;
      Token_Pos_412           : Token_Index               := No_Token_Index;
      Token_Res_412           : Token_Index               := No_Token_Index;
      Row_Progress_33         : Integer                   := 0;
      Transform_Res_214       : Bare_Attribute_Def_Clause := No_Bare_Ada_Node;
      Transform_Has_Failed_33 : Boolean                   := False;
      Or_Pos_84               : Token_Index               := No_Token_Index;
      Or_Res_84               : Bare_Aspect_Clause        := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Aspect_Clause_Or_Parse_1_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_84          := M.Instance;
         return Or_Res_84;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_84;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_84 := No_Token_Index;
      Or_Res_84 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_259 := Pos;

--  Start tok_code

      Token_Res_394 := Row_Pos_259;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_394));
      begin
         if T.Kind /= From_Token_Kind (Ada_For) then
            Token_Pos_394 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_259 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_259,
                  Expected_Token_Id => Ada_For,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_394 := Row_Pos_259 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_32 := 1;

      if Token_Pos_394 /= No_Token_Index then

         Row_Pos_259 := Token_Pos_394;

      else
         Row_Pos_259 := No_Token_Index;
         goto Exit_Row_253_0;

      end if;

      Defer_Res_427 := Static_Name_Or_Parse_0 (Parser, Row_Pos_259);
      Defer_Pos_427 := Parser.Current_Pos;

      Row_Progress_32 := 2;

      if Defer_Pos_427 /= No_Token_Index then

         Row_Pos_259 := Defer_Pos_427;

      else
         Row_Pos_259 := No_Token_Index;
         goto Exit_Row_253_0;

      end if;

--  Start tok_code

      Token_Res_395 := Row_Pos_259;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_395));
      begin
         if T.Kind /= From_Token_Kind (Ada_Use) then
            Token_Pos_395 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_259 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_259,
                  Expected_Token_Id => Ada_Use,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_395 := Row_Pos_259 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_32 := 3;

      if Token_Pos_395 /= No_Token_Index then

         Row_Pos_259 := Token_Pos_395;

      else
         Row_Pos_259 := No_Token_Index;
         goto Exit_Row_253_0;

      end if;

      Defer_Res_428 := Aggregate_Or_Parse_0 (Parser, Row_Pos_259);
      Defer_Pos_428 := Parser.Current_Pos;

      Row_Progress_32 := 4;

      if Defer_Pos_428 /= No_Token_Index then

         Row_Pos_259 := Defer_Pos_428;

      else
         Row_Pos_259 := No_Token_Index;
         goto Exit_Row_253_0;

      end if;

      Nobt_31 := True;

      Row_Progress_32 := 5;

      if Row_Pos_259 /= No_Token_Index then

         Row_Pos_259 := Row_Pos_259;

      else
         Row_Pos_259 := No_Token_Index;
         goto Exit_Row_253_0;

      end if;

--  Start tok_code

      Token_Res_396 := Row_Pos_259;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_396));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_396 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_259 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_259,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_396 := Row_Pos_259 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_32 := 6;

      if Token_Pos_396 /= No_Token_Index then

         Row_Pos_259 := Token_Pos_396;

      else
         Row_Pos_259 := No_Token_Index;
         goto Exit_Row_253_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_253_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_259 = No_Token_Index and then Nobt_31 then
         Row_Pos_259             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_32 := True;
      end if;

      if Row_Pos_259 /= No_Token_Index then

         Transform_Res_211 := Allocate_Enum_Rep_Clause (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_211, Kind => Ada_Enum_Rep_Clause,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_259 = Pos then No_Token_Index else Row_Pos_259 - 1));

         Initialize_Fields_For_Enum_Rep_Clause
           (Self                        => Transform_Res_211,
            Enum_Rep_Clause_F_Type_Name => Defer_Res_427,
            Enum_Rep_Clause_F_Aggregate => Defer_Res_428);

         if Defer_Res_427 /= null and then Is_Incomplete (Defer_Res_427) then
            Transform_Res_211.Last_Attempted_Child := 0;
         elsif Defer_Res_427 /= null and then not Is_Ghost (Defer_Res_427) then
            Transform_Res_211.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_428 /= null and then Is_Incomplete (Defer_Res_428) then
            Transform_Res_211.Last_Attempted_Child := 0;
         elsif Defer_Res_428 /= null and then not Is_Ghost (Defer_Res_428) then
            Transform_Res_211.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_32 then
            Transform_Res_211.Last_Attempted_Child := Row_Progress_32;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <aspect_clause>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      if Row_Pos_259 /= No_Token_Index then
         Or_Pos_84 := Row_Pos_259;
         Or_Res_84 := Transform_Res_211;
         goto Exit_Or_84;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_260 := Pos;

--  Start tok_code

      Token_Res_397 := Row_Pos_260;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_397));
      begin
         if T.Kind /= From_Token_Kind (Ada_For) then
            Token_Pos_397 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_260 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_260,
                  Expected_Token_Id => Ada_For,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_397 := Row_Pos_260 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_397 /= No_Token_Index then

         Row_Pos_260 := Token_Pos_397;

      else
         Row_Pos_260 := No_Token_Index;
         goto Exit_Row_254_0;

      end if;

      Defer_Res_429 := Static_Name_Or_Parse_0 (Parser, Row_Pos_260);
      Defer_Pos_429 := Parser.Current_Pos;

      if Defer_Pos_429 /= No_Token_Index then

         Row_Pos_260 := Defer_Pos_429;

      else
         Row_Pos_260 := No_Token_Index;
         goto Exit_Row_254_0;

      end if;

--  Start tok_code

      Token_Res_398 := Row_Pos_260;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_398));
      begin
         if T.Kind /= From_Token_Kind (Ada_Use) then
            Token_Pos_398 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_260 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_260,
                  Expected_Token_Id => Ada_Use,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_398 := Row_Pos_260 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_398 /= No_Token_Index then

         Row_Pos_260 := Token_Pos_398;

      else
         Row_Pos_260 := No_Token_Index;
         goto Exit_Row_254_0;

      end if;

--  Start tok_code

      Token_Res_399 := Row_Pos_260;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_399));
      begin
         if T.Kind /= From_Token_Kind (Ada_Record) then
            Token_Pos_399 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_260 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_260,
                  Expected_Token_Id => Ada_Record,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_399 := Row_Pos_260 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_399 /= No_Token_Index then

         Row_Pos_260 := Token_Pos_399;

      else
         Row_Pos_260 := No_Token_Index;
         goto Exit_Row_254_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_261 := Row_Pos_260;

--  Start tok_code

      Token_Res_400 := Row_Pos_261;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_400));
      begin
         if T.Kind /= From_Token_Kind (Ada_At) then
            Token_Pos_400 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_261 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_261,
                  Expected_Token_Id => Ada_At,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_400 := Row_Pos_261 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_400 /= No_Token_Index then

         Row_Pos_261 := Token_Pos_400;

      else
         Row_Pos_261 := No_Token_Index;
         goto Exit_Row_255_0;

      end if;

--  Start tok_code

      Token_Res_401 := Row_Pos_261;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_401));
      begin
         if T.Kind /= From_Token_Kind (Ada_Mod) then
            Token_Pos_401 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_261 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_261,
                  Expected_Token_Id => Ada_Mod,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_401 := Row_Pos_261 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_401 /= No_Token_Index then

         Row_Pos_261 := Token_Pos_401;

      else
         Row_Pos_261 := No_Token_Index;
         goto Exit_Row_255_0;

      end if;

      Defer_Res_430 := Simple_Expr_Or_Parse_1 (Parser, Row_Pos_261);
      Defer_Pos_430 := Parser.Current_Pos;

      if Defer_Pos_430 /= No_Token_Index then

         Row_Pos_261 := Defer_Pos_430;

      else
         Row_Pos_261 := No_Token_Index;
         goto Exit_Row_255_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_402 := Row_Pos_261;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_402));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_402 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_261 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_261,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_402 := Row_Pos_261 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_402 = No_Token_Index then

         Token_Res_402 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_261).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_402 := Row_Pos_261;

      end if;

--  End opt_code

      if Token_Pos_402 /= No_Token_Index then

         Row_Pos_261 := Token_Pos_402;

      else
         Row_Pos_261 := No_Token_Index;
         goto Exit_Row_255_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_255_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_261 = No_Token_Index then

         Defer_Res_430 := No_Bare_Ada_Node;

         Row_Pos_261 := Row_Pos_260;

      end if;

--  End opt_code

      if Row_Pos_261 /= No_Token_Index then

         Row_Pos_260 := Row_Pos_261;

      else
         Row_Pos_260 := No_Token_Index;
         goto Exit_Row_254_0;

      end if;

--  Start list_code

      List_Pos_32 := Row_Pos_260;

      Lst_Cpos_32 := Row_Pos_260;
      Tmp_List_32 := Get_Parse_List (Parser);

      loop

--  Start or_code

         Or_Pos_83 := No_Token_Index;
         Or_Res_83 := No_Bare_Ada_Node;

         Defer_Res_431 :=
           Component_Clause_Transform_Parse_0 (Parser, Lst_Cpos_32);
         Defer_Pos_431 := Parser.Current_Pos;

         if Defer_Pos_431 /= No_Token_Index then
            Or_Pos_83 := Defer_Pos_431;
            Or_Res_83 := Defer_Res_431;
            goto Exit_Or_85;
         end if;

         Defer_Res_432 := Pragma_Transform_Parse_0 (Parser, Lst_Cpos_32);
         Defer_Pos_432 := Parser.Current_Pos;

         if Defer_Pos_432 /= No_Token_Index then
            Or_Pos_83 := Defer_Pos_432;
            Or_Res_83 := Defer_Res_432;
            goto Exit_Or_85;
         end if;
         <<Exit_Or_85>>

--  End or_code

         exit when Or_Pos_83 = No_Token_Index;

         List_Pos_32 := Or_Pos_83;
         Lst_Cpos_32 := List_Pos_32;

         Tmp_List_32.Nodes.Append (Or_Res_83);

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_32.Nodes.Length;
      begin
         List_Res_32 := Allocate_Ada_Node_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_260;
            Token_End   :=
              (if Lst_Cpos_32 = Row_Pos_260 then Row_Pos_260
               else Lst_Cpos_32 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_260, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self            => List_Res_32, Kind => Ada_Ada_Node_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_32, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_32.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_32.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_32);

--  End list_code

      if List_Pos_32 /= No_Token_Index then

         Row_Pos_260 := List_Pos_32;

      else
         Row_Pos_260 := No_Token_Index;
         goto Exit_Row_254_0;

      end if;

--  Start tok_code

      Token_Res_403 := Row_Pos_260;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_403));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_403 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_260 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_260,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_403 := Row_Pos_260 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_403 /= No_Token_Index then

         Row_Pos_260 := Token_Pos_403;

      else
         Row_Pos_260 := No_Token_Index;
         goto Exit_Row_254_0;

      end if;

--  Start tok_code

      Token_Res_404 := Row_Pos_260;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_404));
      begin
         if T.Kind /= From_Token_Kind (Ada_Record) then
            Token_Pos_404 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_260 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_260,
                  Expected_Token_Id => Ada_Record,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_404 := Row_Pos_260 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_404 /= No_Token_Index then

         Row_Pos_260 := Token_Pos_404;

      else
         Row_Pos_260 := No_Token_Index;
         goto Exit_Row_254_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_405 := Row_Pos_260;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_405));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_405 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_260 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_260,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_405 := Row_Pos_260 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_405 = No_Token_Index then

         Token_Res_405 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_260).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_405 := Row_Pos_260;

      end if;

--  End opt_code

      if Token_Pos_405 /= No_Token_Index then

         Row_Pos_260 := Token_Pos_405;

      else
         Row_Pos_260 := No_Token_Index;
         goto Exit_Row_254_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_254_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_260 /= No_Token_Index then

         Transform_Res_212 := Allocate_Record_Rep_Clause (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_212, Kind => Ada_Record_Rep_Clause,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_260 = Pos then No_Token_Index else Row_Pos_260 - 1));

         Initialize_Fields_For_Record_Rep_Clause
           (Self                           => Transform_Res_212,
            Record_Rep_Clause_F_Name       => Defer_Res_429,
            Record_Rep_Clause_F_At_Expr    => Defer_Res_430,
            Record_Rep_Clause_F_Components => List_Res_32);

         if Defer_Res_429 /= null and then Is_Incomplete (Defer_Res_429) then
            Transform_Res_212.Last_Attempted_Child := 0;
         elsif Defer_Res_429 /= null and then not Is_Ghost (Defer_Res_429) then
            Transform_Res_212.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_430 /= null and then Is_Incomplete (Defer_Res_430) then
            Transform_Res_212.Last_Attempted_Child := 0;
         elsif Defer_Res_430 /= null and then not Is_Ghost (Defer_Res_430) then
            Transform_Res_212.Last_Attempted_Child := -1;
         end if;
         if List_Res_32 /= null and then Is_Incomplete (List_Res_32) then
            Transform_Res_212.Last_Attempted_Child := 0;
         elsif List_Res_32 /= null and then not Is_Ghost (List_Res_32) then
            Transform_Res_212.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_260 /= No_Token_Index then
         Or_Pos_84 := Row_Pos_260;
         Or_Res_84 := Transform_Res_212;
         goto Exit_Or_84;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_262 := Pos;

--  Start tok_code

      Token_Res_406 := Row_Pos_262;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_406));
      begin
         if T.Kind /= From_Token_Kind (Ada_For) then
            Token_Pos_406 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_262 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_262,
                  Expected_Token_Id => Ada_For,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_406 := Row_Pos_262 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_406 /= No_Token_Index then

         Row_Pos_262 := Token_Pos_406;

      else
         Row_Pos_262 := No_Token_Index;
         goto Exit_Row_257_0;

      end if;

      Defer_Res_433 := Direct_Name_Or_Parse_0 (Parser, Row_Pos_262);
      Defer_Pos_433 := Parser.Current_Pos;

      if Defer_Pos_433 /= No_Token_Index then

         Row_Pos_262 := Defer_Pos_433;

      else
         Row_Pos_262 := No_Token_Index;
         goto Exit_Row_257_0;

      end if;

--  Start tok_code

      Token_Res_407 := Row_Pos_262;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_407));
      begin
         if T.Kind /= From_Token_Kind (Ada_Use) then
            Token_Pos_407 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_262 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_262,
                  Expected_Token_Id => Ada_Use,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_407 := Row_Pos_262 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_407 /= No_Token_Index then

         Row_Pos_262 := Token_Pos_407;

      else
         Row_Pos_262 := No_Token_Index;
         goto Exit_Row_257_0;

      end if;

--  Start tok_code

      Token_Res_408 := Row_Pos_262;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_408));
      begin
         if T.Kind /= From_Token_Kind (Ada_At) then
            Token_Pos_408 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_262 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_262,
                  Expected_Token_Id => Ada_At,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_408 := Row_Pos_262 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_408 /= No_Token_Index then

         Row_Pos_262 := Token_Pos_408;

      else
         Row_Pos_262 := No_Token_Index;
         goto Exit_Row_257_0;

      end if;

      Defer_Res_434 := Expr_Or_Parse_0 (Parser, Row_Pos_262);
      Defer_Pos_434 := Parser.Current_Pos;

      if Defer_Pos_434 /= No_Token_Index then

         Row_Pos_262 := Defer_Pos_434;

      else
         Row_Pos_262 := No_Token_Index;
         goto Exit_Row_257_0;

      end if;

--  Start tok_code

      Token_Res_409 := Row_Pos_262;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_409));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_409 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_262 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_262,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_409 := Row_Pos_262 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_409 /= No_Token_Index then

         Row_Pos_262 := Token_Pos_409;

      else
         Row_Pos_262 := No_Token_Index;
         goto Exit_Row_257_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_257_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_262 /= No_Token_Index then

         Transform_Res_213 := Allocate_At_Clause (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_213, Kind => Ada_At_Clause,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_262 = Pos then No_Token_Index else Row_Pos_262 - 1));

         Initialize_Fields_For_At_Clause
           (Self => Transform_Res_213, At_Clause_F_Name => Defer_Res_433,
            At_Clause_F_Expr => Defer_Res_434);

         if Defer_Res_433 /= null and then Is_Incomplete (Defer_Res_433) then
            Transform_Res_213.Last_Attempted_Child := 0;
         elsif Defer_Res_433 /= null and then not Is_Ghost (Defer_Res_433) then
            Transform_Res_213.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_434 /= null and then Is_Incomplete (Defer_Res_434) then
            Transform_Res_213.Last_Attempted_Child := 0;
         elsif Defer_Res_434 /= null and then not Is_Ghost (Defer_Res_434) then
            Transform_Res_213.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_262 /= No_Token_Index then
         Or_Pos_84 := Row_Pos_262;
         Or_Res_84 := Transform_Res_213;
         goto Exit_Or_84;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_263 := Pos;

--  Start tok_code

      Token_Res_410 := Row_Pos_263;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_410));
      begin
         if T.Kind /= From_Token_Kind (Ada_For) then
            Token_Pos_410 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_263 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_263,
                  Expected_Token_Id => Ada_For,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_410 := Row_Pos_263 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_33 := 1;

      if Token_Pos_410 /= No_Token_Index then

         Row_Pos_263 := Token_Pos_410;

      else
         Row_Pos_263 := No_Token_Index;
         goto Exit_Row_258_0;

      end if;

      Defer_Res_435 := Name_Or_Parse_1 (Parser, Row_Pos_263);
      Defer_Pos_435 := Parser.Current_Pos;

      Row_Progress_33 := 2;

      if Defer_Pos_435 /= No_Token_Index then

         Row_Pos_263 := Defer_Pos_435;

      else
         Row_Pos_263 := No_Token_Index;
         goto Exit_Row_258_0;

      end if;

--  Start tok_code

      Token_Res_411 := Row_Pos_263;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_411));
      begin
         if T.Kind /= From_Token_Kind (Ada_Use) then
            Token_Pos_411 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_263 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_263,
                  Expected_Token_Id => Ada_Use,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_411 := Row_Pos_263 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_33 := 3;

      if Token_Pos_411 /= No_Token_Index then

         Row_Pos_263 := Token_Pos_411;

      else
         Row_Pos_263 := No_Token_Index;
         goto Exit_Row_258_0;

      end if;

      Nobt_32 := True;

      Row_Progress_33 := 4;

      if Row_Pos_263 /= No_Token_Index then

         Row_Pos_263 := Row_Pos_263;

      else
         Row_Pos_263 := No_Token_Index;
         goto Exit_Row_258_0;

      end if;

      Defer_Res_436 := Expr_Or_Parse_0 (Parser, Row_Pos_263);
      Defer_Pos_436 := Parser.Current_Pos;

      Row_Progress_33 := 5;

      if Defer_Pos_436 /= No_Token_Index then

         Row_Pos_263 := Defer_Pos_436;

      else
         Row_Pos_263 := No_Token_Index;
         goto Exit_Row_258_0;

      end if;

--  Start tok_code

      Token_Res_412 := Row_Pos_263;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_412));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_412 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_263 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_263,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_412 := Row_Pos_263 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_33 := 6;

      if Token_Pos_412 /= No_Token_Index then

         Row_Pos_263 := Token_Pos_412;

      else
         Row_Pos_263 := No_Token_Index;
         goto Exit_Row_258_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_258_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_263 = No_Token_Index and then Nobt_32 then
         Row_Pos_263             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_33 := True;
      end if;

      if Row_Pos_263 /= No_Token_Index then

         Transform_Res_214 := Allocate_Attribute_Def_Clause (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_214, Kind => Ada_Attribute_Def_Clause,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_263 = Pos then No_Token_Index else Row_Pos_263 - 1));

         Initialize_Fields_For_Attribute_Def_Clause
           (Self                                  => Transform_Res_214,
            Attribute_Def_Clause_F_Attribute_Expr => Defer_Res_435,
            Attribute_Def_Clause_F_Expr           => Defer_Res_436);

         if Defer_Res_435 /= null and then Is_Incomplete (Defer_Res_435) then
            Transform_Res_214.Last_Attempted_Child := 0;
         elsif Defer_Res_435 /= null and then not Is_Ghost (Defer_Res_435) then
            Transform_Res_214.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_436 /= null and then Is_Incomplete (Defer_Res_436) then
            Transform_Res_214.Last_Attempted_Child := 0;
         elsif Defer_Res_436 /= null and then not Is_Ghost (Defer_Res_436) then
            Transform_Res_214.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_33 then
            Transform_Res_214.Last_Attempted_Child := Row_Progress_33;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <aspect_clause>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      if Row_Pos_263 /= No_Token_Index then
         Or_Pos_84 := Row_Pos_263;
         Or_Res_84 := Transform_Res_214;
         goto Exit_Or_84;
      end if;
      <<Exit_Or_84>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Aspect_Clause_Or_Parse_1_Memo,
         Or_Pos_84 /= No_Token_Index, Or_Res_84, Pos, Or_Pos_84);

      Parser.Current_Pos := Or_Pos_84;

      return Or_Res_84;
   end Aspect_Clause_Or_Parse_1;

   function Component_Item_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Row_Pos_256       : Token_Index              := No_Token_Index;
      Token_Pos_388     : Token_Index              := No_Token_Index;
      Token_Res_388     : Token_Index              := No_Token_Index;
      Token_Pos_389     : Token_Index              := No_Token_Index;
      Token_Res_389     : Token_Index              := No_Token_Index;
      Transform_Res_209 : Bare_Null_Component_Decl := No_Bare_Ada_Node;
      Defer_Pos_420     : Token_Index              := No_Token_Index;
      Defer_Res_420     : Bare_Component_Decl      := No_Bare_Ada_Node;
      Defer_Pos_421     : Token_Index              := No_Token_Index;
      Defer_Res_421     : Bare_Aspect_Clause       := No_Bare_Ada_Node;
      Defer_Pos_422     : Token_Index              := No_Token_Index;
      Defer_Res_422     : Bare_Pragma_Node         := No_Bare_Ada_Node;
      Or_Pos_82         : Token_Index              := No_Token_Index;
      Or_Res_82         : Bare_Ada_Node            := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Component_Item_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_82          := M.Instance;
         return Or_Res_82;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_82;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_82 := No_Token_Index;
      Or_Res_82 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_256 := Pos;

--  Start tok_code

      Token_Res_388 := Row_Pos_256;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_388));
      begin
         if T.Kind /= From_Token_Kind (Ada_Null) then
            Token_Pos_388 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_256 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_256,
                  Expected_Token_Id => Ada_Null,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_388 := Row_Pos_256 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_388 /= No_Token_Index then

         Row_Pos_256 := Token_Pos_388;

      else
         Row_Pos_256 := No_Token_Index;
         goto Exit_Row_250_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_389 := Row_Pos_256;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_389));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_389 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_256 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_256,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_389 := Row_Pos_256 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_389 = No_Token_Index then

         Token_Res_389 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_256).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_389 := Row_Pos_256;

      end if;

--  End opt_code

      if Token_Pos_389 /= No_Token_Index then

         Row_Pos_256 := Token_Pos_389;

      else
         Row_Pos_256 := No_Token_Index;
         goto Exit_Row_250_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_250_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_256 /= No_Token_Index then

         Transform_Res_209 := Allocate_Null_Component_Decl (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_209, Kind => Ada_Null_Component_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_256 = Pos then No_Token_Index else Row_Pos_256 - 1));

      end if;

--  End transform_code

      if Row_Pos_256 /= No_Token_Index then
         Or_Pos_82 := Row_Pos_256;
         Or_Res_82 := Transform_Res_209;
         goto Exit_Or_83;
      end if;

      Defer_Res_420 := Component_Decl_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_420 := Parser.Current_Pos;

      if Defer_Pos_420 /= No_Token_Index then
         Or_Pos_82 := Defer_Pos_420;
         Or_Res_82 := Defer_Res_420;
         goto Exit_Or_83;
      end if;

      Defer_Res_421 := Aspect_Clause_Or_Parse_1 (Parser, Pos);
      Defer_Pos_421 := Parser.Current_Pos;

      if Defer_Pos_421 /= No_Token_Index then
         Or_Pos_82 := Defer_Pos_421;
         Or_Res_82 := Defer_Res_421;
         goto Exit_Or_83;
      end if;

      Defer_Res_422 := Pragma_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_422 := Parser.Current_Pos;

      if Defer_Pos_422 /= No_Token_Index then
         Or_Pos_82 := Defer_Pos_422;
         Or_Res_82 := Defer_Res_422;
         goto Exit_Or_83;
      end if;
      <<Exit_Or_83>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Component_Item_Or_Parse_0_Memo,
         Or_Pos_82 /= No_Token_Index, Or_Res_82, Pos, Or_Pos_82);

      Parser.Current_Pos := Or_Pos_82;

      return Or_Res_82;
   end Component_Item_Or_Parse_0;

   function Variant_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Variant
   is
      use Bare_Variant_Memos;

      Row_Pos_266       : Token_Index            := No_Token_Index;
      Token_Pos_420     : Token_Index            := No_Token_Index;
      Token_Res_420     : Token_Index            := No_Token_Index;
      Defer_Pos_442     : Token_Index            := No_Token_Index;
      Defer_Res_442     : Bare_Alternatives_List := No_Bare_Ada_Node;
      Token_Pos_421     : Token_Index            := No_Token_Index;
      Token_Res_421     : Token_Index            := No_Token_Index;
      Defer_Pos_443     : Token_Index            := No_Token_Index;
      Defer_Res_443     : Bare_Component_List    := No_Bare_Ada_Node;
      Transform_Res_217 : Bare_Variant           := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Variant_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_217  := M.Instance;
         return Transform_Res_217;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_217;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_266 := Pos;

--  Start tok_code

      Token_Res_420 := Row_Pos_266;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_420));
      begin
         if T.Kind /= From_Token_Kind (Ada_When) then
            Token_Pos_420 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_266 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_266,
                  Expected_Token_Id => Ada_When,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_420 := Row_Pos_266 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_420 /= No_Token_Index then

         Row_Pos_266 := Token_Pos_420;

      else
         Row_Pos_266 := No_Token_Index;
         goto Exit_Row_260_0;

      end if;

      Defer_Res_442 := Choice_List_List_Parse_0 (Parser, Row_Pos_266);
      Defer_Pos_442 := Parser.Current_Pos;

      if Defer_Pos_442 /= No_Token_Index then

         Row_Pos_266 := Defer_Pos_442;

      else
         Row_Pos_266 := No_Token_Index;
         goto Exit_Row_260_0;

      end if;

--  Start tok_code

      Token_Res_421 := Row_Pos_266;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_421));
      begin
         if T.Kind /= From_Token_Kind (Ada_Arrow) then
            Token_Pos_421 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_266 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_266,
                  Expected_Token_Id => Ada_Arrow,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_421 := Row_Pos_266 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_421 /= No_Token_Index then

         Row_Pos_266 := Token_Pos_421;

      else
         Row_Pos_266 := No_Token_Index;
         goto Exit_Row_260_0;

      end if;

      Defer_Res_443 := Component_List_Transform_Parse_0 (Parser, Row_Pos_266);
      Defer_Pos_443 := Parser.Current_Pos;

      if Defer_Pos_443 /= No_Token_Index then

         Row_Pos_266 := Defer_Pos_443;

      else
         Row_Pos_266 := No_Token_Index;
         goto Exit_Row_260_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_260_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_266 /= No_Token_Index then

         Transform_Res_217 := Allocate_Variant (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_217, Kind => Ada_Variant,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_266 = Pos then No_Token_Index else Row_Pos_266 - 1));

         Initialize_Fields_For_Variant
           (Self => Transform_Res_217, Variant_F_Choices => Defer_Res_442,
            Variant_F_Components => Defer_Res_443);

         if Defer_Res_442 /= null and then Is_Incomplete (Defer_Res_442) then
            Transform_Res_217.Last_Attempted_Child := 0;
         elsif Defer_Res_442 /= null and then not Is_Ghost (Defer_Res_442) then
            Transform_Res_217.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_443 /= null and then Is_Incomplete (Defer_Res_443) then
            Transform_Res_217.Last_Attempted_Child := 0;
         elsif Defer_Res_443 /= null and then not Is_Ghost (Defer_Res_443) then
            Transform_Res_217.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Variant_Transform_Parse_0_Memo,
         Row_Pos_266 /= No_Token_Index, Transform_Res_217, Pos, Row_Pos_266);

      Parser.Current_Pos := Row_Pos_266;

      return Transform_Res_217;
   end Variant_Transform_Parse_0;

   function Variant_Part_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Variant_Part
   is
      use Bare_Variant_Part_Memos;

      Nobt_33                 : Boolean           := False;
      Row_Pos_265             : Token_Index       := No_Token_Index;
      Token_Pos_415           : Token_Index       := No_Token_Index;
      Token_Res_415           : Token_Index       := No_Token_Index;
      Defer_Pos_440           : Token_Index       := No_Token_Index;
      Defer_Res_440           : Bare_Identifier   := No_Bare_Ada_Node;
      Token_Pos_416           : Token_Index       := No_Token_Index;
      Token_Res_416           : Token_Index       := No_Token_Index;
      Lst_Cpos_33             : Token_Index       := No_Token_Index;
      Tmp_List_33             : Free_Parse_List;
      Defer_Pos_441           : Token_Index       := No_Token_Index;
      Defer_Res_441           : Bare_Variant      := No_Bare_Ada_Node;
      List_Pos_33             : Token_Index       := No_Token_Index;
      List_Res_33             : Bare_Variant_List := No_Bare_Ada_Node;
      Token_Pos_417           : Token_Index       := No_Token_Index;
      Token_Res_417           : Token_Index       := No_Token_Index;
      Token_Pos_418           : Token_Index       := No_Token_Index;
      Token_Res_418           : Token_Index       := No_Token_Index;
      Token_Pos_419           : Token_Index       := No_Token_Index;
      Token_Res_419           : Token_Index       := No_Token_Index;
      Row_Progress_34         : Integer           := 0;
      Transform_Res_216       : Bare_Variant_Part := No_Bare_Ada_Node;
      Transform_Has_Failed_34 : Boolean           := False;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Variant_Part_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_216  := M.Instance;
         return Transform_Res_216;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_216;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_265 := Pos;

--  Start tok_code

      Token_Res_415 := Row_Pos_265;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_415));
      begin
         if T.Kind /= From_Token_Kind (Ada_Case) then
            Token_Pos_415 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_265 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_265,
                  Expected_Token_Id => Ada_Case,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_415 := Row_Pos_265 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_34 := 1;

      if Token_Pos_415 /= No_Token_Index then

         Row_Pos_265 := Token_Pos_415;

      else
         Row_Pos_265 := No_Token_Index;
         goto Exit_Row_259_0;

      end if;

      Nobt_33 := True;

      Row_Progress_34 := 2;

      if Row_Pos_265 /= No_Token_Index then

         Row_Pos_265 := Row_Pos_265;

      else
         Row_Pos_265 := No_Token_Index;
         goto Exit_Row_259_0;

      end if;

      Defer_Res_440 := Identifier_Transform_Parse_0 (Parser, Row_Pos_265);
      Defer_Pos_440 := Parser.Current_Pos;

      Row_Progress_34 := 3;

      if Defer_Pos_440 /= No_Token_Index then

         Row_Pos_265 := Defer_Pos_440;

      else
         Row_Pos_265 := No_Token_Index;
         goto Exit_Row_259_0;

      end if;

--  Start tok_code

      Token_Res_416 := Row_Pos_265;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_416));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_416 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_265 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_265,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_416 := Row_Pos_265 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_34 := 4;

      if Token_Pos_416 /= No_Token_Index then

         Row_Pos_265 := Token_Pos_416;

      else
         Row_Pos_265 := No_Token_Index;
         goto Exit_Row_259_0;

      end if;

--  Start list_code

      List_Pos_33 := No_Token_Index;

      Lst_Cpos_33 := Row_Pos_265;
      Tmp_List_33 := Get_Parse_List (Parser);

      loop

         Defer_Res_441 := Variant_Transform_Parse_0 (Parser, Lst_Cpos_33);
         Defer_Pos_441 := Parser.Current_Pos;

         exit when Defer_Pos_441 = No_Token_Index;

         List_Pos_33 := Defer_Pos_441;
         Lst_Cpos_33 := List_Pos_33;

         Tmp_List_33.Nodes.Append (Defer_Res_441);

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_33.Nodes.Length;
      begin
         List_Res_33 := Allocate_Variant_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_265;
            Token_End   :=
              (if Lst_Cpos_33 = Row_Pos_265 then Row_Pos_265
               else Lst_Cpos_33 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_265, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self => List_Res_33, Kind => Ada_Variant_List, Unit => Parser.Unit,
            Token_Start_Index => Token_Start, Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_33, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_33.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_33.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_33);

--  End list_code

      Row_Progress_34 := 5;

      if List_Pos_33 /= No_Token_Index then

         Row_Pos_265 := List_Pos_33;

      else
         Row_Pos_265 := No_Token_Index;
         goto Exit_Row_259_0;

      end if;

--  Start tok_code

      Token_Res_417 := Row_Pos_265;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_417));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_417 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_265 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_265,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_417 := Row_Pos_265 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_34 := 6;

      if Token_Pos_417 /= No_Token_Index then

         Row_Pos_265 := Token_Pos_417;

      else
         Row_Pos_265 := No_Token_Index;
         goto Exit_Row_259_0;

      end if;

--  Start tok_code

      Token_Res_418 := Row_Pos_265;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_418));
      begin
         if T.Kind /= From_Token_Kind (Ada_Case) then
            Token_Pos_418 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_265 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_265,
                  Expected_Token_Id => Ada_Case,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_418 := Row_Pos_265 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_34 := 7;

      if Token_Pos_418 /= No_Token_Index then

         Row_Pos_265 := Token_Pos_418;

      else
         Row_Pos_265 := No_Token_Index;
         goto Exit_Row_259_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_419 := Row_Pos_265;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_419));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_419 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_265 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_265,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_419 := Row_Pos_265 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_419 = No_Token_Index then

         Token_Res_419 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_265).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_419 := Row_Pos_265;

      end if;

--  End opt_code

      Row_Progress_34 := 8;

      if Token_Pos_419 /= No_Token_Index then

         Row_Pos_265 := Token_Pos_419;

      else
         Row_Pos_265 := No_Token_Index;
         goto Exit_Row_259_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_259_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_265 = No_Token_Index and then Nobt_33 then
         Row_Pos_265             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_34 := True;
      end if;

      if Row_Pos_265 /= No_Token_Index then

         Transform_Res_216 := Allocate_Variant_Part (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_216, Kind => Ada_Variant_Part,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_265 = Pos then No_Token_Index else Row_Pos_265 - 1));

         Initialize_Fields_For_Variant_Part
           (Self                      => Transform_Res_216,
            Variant_Part_F_Discr_Name => Defer_Res_440,
            Variant_Part_F_Variant    => List_Res_33);

         if Defer_Res_440 /= null and then Is_Incomplete (Defer_Res_440) then
            Transform_Res_216.Last_Attempted_Child := 0;
         elsif Defer_Res_440 /= null and then not Is_Ghost (Defer_Res_440) then
            Transform_Res_216.Last_Attempted_Child := -1;
         end if;
         if List_Res_33 /= null and then Is_Incomplete (List_Res_33) then
            Transform_Res_216.Last_Attempted_Child := 0;
         elsif List_Res_33 /= null and then not Is_Ghost (List_Res_33) then
            Transform_Res_216.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_34 then
            Transform_Res_216.Last_Attempted_Child := Row_Progress_34;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <variant_part>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Variant_Part_Transform_Parse_0_Memo,
         Row_Pos_265 /= No_Token_Index, Transform_Res_216, Pos, Row_Pos_265);

      Parser.Current_Pos := Row_Pos_265;

      return Transform_Res_216;
   end Variant_Part_Transform_Parse_0;

   function Component_List_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Component_List
   is
      use Bare_Component_List_Memos;

      Row_Pos_255       : Token_Index         := No_Token_Index;
      Lst_Cpos_30       : Token_Index         := No_Token_Index;
      Tmp_List_30       : Free_Parse_List;
      Defer_Pos_418     : Token_Index         := No_Token_Index;
      Defer_Res_418     : Bare_Ada_Node       := No_Bare_Ada_Node;
      List_Pos_30       : Token_Index         := No_Token_Index;
      List_Res_30       : Bare_Ada_Node_List  := No_Bare_Ada_Node;
      Defer_Pos_419     : Token_Index         := No_Token_Index;
      Defer_Res_419     : Bare_Variant_Part   := No_Bare_Ada_Node;
      Transform_Res_208 : Bare_Component_List := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Component_List_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_208  := M.Instance;
         return Transform_Res_208;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_208;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_255 := Pos;

--  Start list_code

      List_Pos_30 := Row_Pos_255;

      Lst_Cpos_30 := Row_Pos_255;
      Tmp_List_30 := Get_Parse_List (Parser);

      loop

         Defer_Res_418 := Component_Item_Or_Parse_0 (Parser, Lst_Cpos_30);
         Defer_Pos_418 := Parser.Current_Pos;

         exit when Defer_Pos_418 = No_Token_Index;

         List_Pos_30 := Defer_Pos_418;
         Lst_Cpos_30 := List_Pos_30;

         Tmp_List_30.Nodes.Append (Defer_Res_418);

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_30.Nodes.Length;
      begin
         List_Res_30 := Allocate_Ada_Node_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_255;
            Token_End   :=
              (if Lst_Cpos_30 = Row_Pos_255 then Row_Pos_255
               else Lst_Cpos_30 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_255, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self            => List_Res_30, Kind => Ada_Ada_Node_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_30, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_30.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_30.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_30);

--  End list_code

      if List_Pos_30 /= No_Token_Index then

         Row_Pos_255 := List_Pos_30;

      else
         Row_Pos_255 := No_Token_Index;
         goto Exit_Row_249_0;

      end if;

--  Start opt_code

      Defer_Res_419 := Variant_Part_Transform_Parse_0 (Parser, Row_Pos_255);
      Defer_Pos_419 := Parser.Current_Pos;

      if Defer_Pos_419 = No_Token_Index then

         Defer_Res_419 := No_Bare_Ada_Node;

         Defer_Pos_419 := Row_Pos_255;

      end if;

--  End opt_code

      if Defer_Pos_419 /= No_Token_Index then

         Row_Pos_255 := Defer_Pos_419;

      else
         Row_Pos_255 := No_Token_Index;
         goto Exit_Row_249_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_249_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_255 /= No_Token_Index then

         Transform_Res_208 := Allocate_Component_List (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_208, Kind => Ada_Component_List,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_255 = Pos then No_Token_Index else Row_Pos_255 - 1));

         Initialize_Fields_For_Component_List
           (Self                          => Transform_Res_208,
            Component_List_F_Components   => List_Res_30,
            Component_List_F_Variant_Part => Defer_Res_419);

         if List_Res_30 /= null and then Is_Incomplete (List_Res_30) then
            Transform_Res_208.Last_Attempted_Child := 0;
         elsif List_Res_30 /= null and then not Is_Ghost (List_Res_30) then
            Transform_Res_208.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_419 /= null and then Is_Incomplete (Defer_Res_419) then
            Transform_Res_208.Last_Attempted_Child := 0;
         elsif Defer_Res_419 /= null and then not Is_Ghost (Defer_Res_419) then
            Transform_Res_208.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Component_List_Transform_Parse_0_Memo,
         Row_Pos_255 /= No_Token_Index, Transform_Res_208, Pos, Row_Pos_255);

      Parser.Current_Pos := Row_Pos_255;

      return Transform_Res_208;
   end Component_List_Transform_Parse_0;

   function Record_Def_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Base_Record_Def
   is
      use Bare_Base_Record_Def_Memos;

      Row_Pos_252       : Token_Index          := No_Token_Index;
      Token_Pos_383     : Token_Index          := No_Token_Index;
      Token_Res_383     : Token_Index          := No_Token_Index;
      Defer_Pos_417     : Token_Index          := No_Token_Index;
      Defer_Res_417     : Bare_Component_List  := No_Bare_Ada_Node;
      Token_Pos_384     : Token_Index          := No_Token_Index;
      Token_Res_384     : Token_Index          := No_Token_Index;
      Token_Pos_385     : Token_Index          := No_Token_Index;
      Token_Res_385     : Token_Index          := No_Token_Index;
      Transform_Res_205 : Bare_Record_Def      := No_Bare_Ada_Node;
      Row_Pos_253       : Token_Index          := No_Token_Index;
      Token_Pos_386     : Token_Index          := No_Token_Index;
      Token_Res_386     : Token_Index          := No_Token_Index;
      Token_Pos_387     : Token_Index          := No_Token_Index;
      Token_Res_387     : Token_Index          := No_Token_Index;
      Row_Pos_254       : Token_Index          := No_Token_Index;
      Null_Res_12       : Bare_Ada_Node_List   := No_Bare_Ada_Node;
      Null_Res_13       : Bare_Variant_Part    := No_Bare_Ada_Node;
      Transform_Res_206 : Bare_Component_List  := No_Bare_Ada_Node;
      Transform_Res_207 : Bare_Null_Record_Def := No_Bare_Ada_Node;
      Or_Pos_81         : Token_Index          := No_Token_Index;
      Or_Res_81         : Bare_Base_Record_Def := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Record_Def_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_81          := M.Instance;
         return Or_Res_81;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_81;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_81 := No_Token_Index;
      Or_Res_81 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_252 := Pos;

--  Start tok_code

      Token_Res_383 := Row_Pos_252;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_383));
      begin
         if T.Kind /= From_Token_Kind (Ada_Record) then
            Token_Pos_383 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_252 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_252,
                  Expected_Token_Id => Ada_Record,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_383 := Row_Pos_252 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_383 /= No_Token_Index then

         Row_Pos_252 := Token_Pos_383;

      else
         Row_Pos_252 := No_Token_Index;
         goto Exit_Row_248_0;

      end if;

      Defer_Res_417 := Component_List_Transform_Parse_0 (Parser, Row_Pos_252);
      Defer_Pos_417 := Parser.Current_Pos;

      if Defer_Pos_417 /= No_Token_Index then

         Row_Pos_252 := Defer_Pos_417;

      else
         Row_Pos_252 := No_Token_Index;
         goto Exit_Row_248_0;

      end if;

--  Start tok_code

      Token_Res_384 := Row_Pos_252;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_384));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_384 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_252 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_252,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_384 := Row_Pos_252 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_384 /= No_Token_Index then

         Row_Pos_252 := Token_Pos_384;

      else
         Row_Pos_252 := No_Token_Index;
         goto Exit_Row_248_0;

      end if;

--  Start tok_code

      Token_Res_385 := Row_Pos_252;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_385));
      begin
         if T.Kind /= From_Token_Kind (Ada_Record) then
            Token_Pos_385 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_252 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_252,
                  Expected_Token_Id => Ada_Record,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_385 := Row_Pos_252 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_385 /= No_Token_Index then

         Row_Pos_252 := Token_Pos_385;

      else
         Row_Pos_252 := No_Token_Index;
         goto Exit_Row_248_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_248_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_252 /= No_Token_Index then

         Transform_Res_205 := Allocate_Record_Def (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_205, Kind => Ada_Record_Def,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_252 = Pos then No_Token_Index else Row_Pos_252 - 1));

         Initialize_Fields_For_Record_Def
           (Self                         => Transform_Res_205,
            Base_Record_Def_F_Components => Defer_Res_417);

         if Defer_Res_417 /= null and then Is_Incomplete (Defer_Res_417) then
            Transform_Res_205.Last_Attempted_Child := 0;
         elsif Defer_Res_417 /= null and then not Is_Ghost (Defer_Res_417) then
            Transform_Res_205.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_252 /= No_Token_Index then
         Or_Pos_81 := Row_Pos_252;
         Or_Res_81 := Transform_Res_205;
         goto Exit_Or_82;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_253 := Pos;

--  Start tok_code

      Token_Res_386 := Row_Pos_253;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_386));
      begin
         if T.Kind /= From_Token_Kind (Ada_Null) then
            Token_Pos_386 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_253 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_253,
                  Expected_Token_Id => Ada_Null,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_386 := Row_Pos_253 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_386 /= No_Token_Index then

         Row_Pos_253 := Token_Pos_386;

      else
         Row_Pos_253 := No_Token_Index;
         goto Exit_Row_261_0;

      end if;

--  Start tok_code

      Token_Res_387 := Row_Pos_253;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_387));
      begin
         if T.Kind /= From_Token_Kind (Ada_Record) then
            Token_Pos_387 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_253 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_253,
                  Expected_Token_Id => Ada_Record,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_387 := Row_Pos_253 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_387 /= No_Token_Index then

         Row_Pos_253 := Token_Pos_387;

      else
         Row_Pos_253 := No_Token_Index;
         goto Exit_Row_261_0;

      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_254 := Row_Pos_253;

      Null_Res_12 := Allocate_Ada_Node_List (Parser.Mem_Pool);
      Initialize
        (Self => Null_Res_12, Kind => Ada_Ada_Node_List, Unit => Parser.Unit,
         Token_Start_Index => Token_Index'Max (Row_Pos_254, 1),
         Token_End_Index   => No_Token_Index);
      Initialize_List (Self => Null_Res_12, Parser => Parser, Count => 0);

      if Row_Pos_254 /= No_Token_Index then

         Row_Pos_254 := Row_Pos_254;

      else
         Row_Pos_254 := No_Token_Index;
         goto Exit_Row_262_0;

      end if;

      Null_Res_13 := No_Bare_Ada_Node;

      if Row_Pos_254 /= No_Token_Index then

         Row_Pos_254 := Row_Pos_254;

      else
         Row_Pos_254 := No_Token_Index;
         goto Exit_Row_262_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_262_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_254 /= No_Token_Index then

         Transform_Res_206 := Allocate_Component_List (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_206, Kind => Ada_Component_List,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_253,
            Token_End_Index =>
              (if Row_Pos_254 = Row_Pos_253 then No_Token_Index
               else Row_Pos_254 - 1));

         Initialize_Fields_For_Component_List
           (Self                          => Transform_Res_206,
            Component_List_F_Components   => Null_Res_12,
            Component_List_F_Variant_Part => Null_Res_13);

         if Null_Res_12 /= null and then Is_Incomplete (Null_Res_12) then
            Transform_Res_206.Last_Attempted_Child := 0;
         elsif Null_Res_12 /= null and then not Is_Ghost (Null_Res_12) then
            Transform_Res_206.Last_Attempted_Child := -1;
         end if;
         if Null_Res_13 /= null and then Is_Incomplete (Null_Res_13) then
            Transform_Res_206.Last_Attempted_Child := 0;
         elsif Null_Res_13 /= null and then not Is_Ghost (Null_Res_13) then
            Transform_Res_206.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_254 /= No_Token_Index then

         Row_Pos_253 := Row_Pos_254;

      else
         Row_Pos_253 := No_Token_Index;
         goto Exit_Row_261_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_261_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_253 /= No_Token_Index then

         Transform_Res_207 := Allocate_Null_Record_Def (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_207, Kind => Ada_Null_Record_Def,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_253 = Pos then No_Token_Index else Row_Pos_253 - 1));

         Initialize_Fields_For_Null_Record_Def
           (Self                         => Transform_Res_207,
            Base_Record_Def_F_Components => Transform_Res_206);

         if Transform_Res_206 /= null
           and then Is_Incomplete (Transform_Res_206)
         then
            Transform_Res_207.Last_Attempted_Child := 0;
         elsif Transform_Res_206 /= null
           and then not Is_Ghost (Transform_Res_206)
         then
            Transform_Res_207.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_253 /= No_Token_Index then
         Or_Pos_81 := Row_Pos_253;
         Or_Res_81 := Transform_Res_207;
         goto Exit_Or_82;
      end if;
      <<Exit_Or_82>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Record_Def_Or_Parse_0_Memo,
         Or_Pos_81 /= No_Token_Index, Or_Res_81, Pos, Or_Pos_81);

      Parser.Current_Pos := Or_Pos_81;

      return Or_Res_81;
   end Record_Def_Or_Parse_0;

   function Record_Type_Def_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Record_Type_Def
   is
      use Bare_Record_Type_Def_Memos;

      Row_Pos_251       : Token_Index          := No_Token_Index;
      Token_Pos_380     : Token_Index          := No_Token_Index;
      Token_Res_380     : Token_Index          := No_Token_Index;
      Opt_Res_19        : Bare_Abstract_Node   := No_Bare_Ada_Node;
      Token_Pos_381     : Token_Index          := No_Token_Index;
      Token_Res_381     : Token_Index          := No_Token_Index;
      Opt_Res_20        : Bare_Tagged_Node     := No_Bare_Ada_Node;
      Token_Pos_382     : Token_Index          := No_Token_Index;
      Token_Res_382     : Token_Index          := No_Token_Index;
      Opt_Res_21        : Bare_Limited_Node    := No_Bare_Ada_Node;
      Defer_Pos_416     : Token_Index          := No_Token_Index;
      Defer_Res_416     : Bare_Base_Record_Def := No_Bare_Ada_Node;
      Transform_Res_204 : Bare_Record_Type_Def := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Record_Type_Def_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_204  := M.Instance;
         return Transform_Res_204;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_204;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_251 := Pos;

--  Start opt_code

--  Start tok_code

      Token_Res_380 := Row_Pos_251;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_380));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol
               (Parser.TDH.Symbols, Precomputed_Symbol_Abstract)
         then
            Token_Pos_380 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_251 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_251,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_380 := Row_Pos_251 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_380 = No_Token_Index then

         Opt_Res_19 := Allocate_Abstract_Absent (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_19, Kind => Ada_Abstract_Absent,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_251,
            Token_End_Index => No_Token_Index);

         Token_Pos_380 := Row_Pos_251;

      else

         Opt_Res_19 := Allocate_Abstract_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_19, Kind => Ada_Abstract_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_251,
            Token_End_Index => Token_Pos_380 - 1);

      end if;

--  End opt_code

      if Token_Pos_380 /= No_Token_Index then

         Row_Pos_251 := Token_Pos_380;

      else
         Row_Pos_251 := No_Token_Index;
         goto Exit_Row_247_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_381 := Row_Pos_251;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_381));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol (Parser.TDH.Symbols, Precomputed_Symbol_Tagged)
         then
            Token_Pos_381 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_251 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_251,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_381 := Row_Pos_251 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_381 = No_Token_Index then

         Opt_Res_20 := Allocate_Tagged_Absent (Parser.Mem_Pool);
         Initialize
           (Self => Opt_Res_20, Kind => Ada_Tagged_Absent, Unit => Parser.Unit,
            Token_Start_Index => Row_Pos_251,
            Token_End_Index   => No_Token_Index);

         Token_Pos_381 := Row_Pos_251;

      else

         Opt_Res_20 := Allocate_Tagged_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_20, Kind => Ada_Tagged_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_251,
            Token_End_Index => Token_Pos_381 - 1);

      end if;

--  End opt_code

      if Token_Pos_381 /= No_Token_Index then

         Row_Pos_251 := Token_Pos_381;

      else
         Row_Pos_251 := No_Token_Index;
         goto Exit_Row_247_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_382 := Row_Pos_251;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_382));
      begin
         if T.Kind /= From_Token_Kind (Ada_Limited) then
            Token_Pos_382 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_251 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_251,
                  Expected_Token_Id => Ada_Limited,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_382 := Row_Pos_251 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_382 = No_Token_Index then

         Opt_Res_21 := Allocate_Limited_Absent (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_21, Kind => Ada_Limited_Absent,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_251,
            Token_End_Index => No_Token_Index);

         Token_Pos_382 := Row_Pos_251;

      else

         Opt_Res_21 := Allocate_Limited_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_21, Kind => Ada_Limited_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_251,
            Token_End_Index => Token_Pos_382 - 1);

      end if;

--  End opt_code

      if Token_Pos_382 /= No_Token_Index then

         Row_Pos_251 := Token_Pos_382;

      else
         Row_Pos_251 := No_Token_Index;
         goto Exit_Row_247_0;

      end if;

      Defer_Res_416 := Record_Def_Or_Parse_0 (Parser, Row_Pos_251);
      Defer_Pos_416 := Parser.Current_Pos;

      if Defer_Pos_416 /= No_Token_Index then

         Row_Pos_251 := Defer_Pos_416;

      else
         Row_Pos_251 := No_Token_Index;
         goto Exit_Row_247_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_247_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_251 /= No_Token_Index then

         Transform_Res_204 := Allocate_Record_Type_Def (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_204, Kind => Ada_Record_Type_Def,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_251 = Pos then No_Token_Index else Row_Pos_251 - 1));

         Initialize_Fields_For_Record_Type_Def
           (Self                           => Transform_Res_204,
            Record_Type_Def_F_Has_Abstract => Opt_Res_19,
            Record_Type_Def_F_Has_Tagged   => Opt_Res_20,
            Record_Type_Def_F_Has_Limited  => Opt_Res_21,
            Record_Type_Def_F_Record_Def   => Defer_Res_416);

         if Opt_Res_19 /= null and then Is_Incomplete (Opt_Res_19) then
            Transform_Res_204.Last_Attempted_Child := 0;
         elsif Opt_Res_19 /= null and then not Is_Ghost (Opt_Res_19) then
            Transform_Res_204.Last_Attempted_Child := -1;
         end if;
         if Opt_Res_20 /= null and then Is_Incomplete (Opt_Res_20) then
            Transform_Res_204.Last_Attempted_Child := 0;
         elsif Opt_Res_20 /= null and then not Is_Ghost (Opt_Res_20) then
            Transform_Res_204.Last_Attempted_Child := -1;
         end if;
         if Opt_Res_21 /= null and then Is_Incomplete (Opt_Res_21) then
            Transform_Res_204.Last_Attempted_Child := 0;
         elsif Opt_Res_21 /= null and then not Is_Ghost (Opt_Res_21) then
            Transform_Res_204.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_416 /= null and then Is_Incomplete (Defer_Res_416) then
            Transform_Res_204.Last_Attempted_Child := 0;
         elsif Defer_Res_416 /= null and then not Is_Ghost (Defer_Res_416) then
            Transform_Res_204.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Record_Type_Def_Transform_Parse_0_Memo,
         Row_Pos_251 /= No_Token_Index, Transform_Res_204, Pos, Row_Pos_251);

      Parser.Current_Pos := Row_Pos_251;

      return Transform_Res_204;
   end Record_Type_Def_Transform_Parse_0;

   function Floating_Point_Def_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Floating_Point_Def
   is
      use Bare_Floating_Point_Def_Memos;

      Row_Pos_267       : Token_Index             := No_Token_Index;
      Token_Pos_422     : Token_Index             := No_Token_Index;
      Token_Res_422     : Token_Index             := No_Token_Index;
      Defer_Pos_447     : Token_Index             := No_Token_Index;
      Defer_Res_447     : Bare_Expr               := No_Bare_Ada_Node;
      Defer_Pos_448     : Token_Index             := No_Token_Index;
      Defer_Res_448     : Bare_Range_Spec         := No_Bare_Ada_Node;
      Transform_Res_218 : Bare_Floating_Point_Def := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Floating_Point_Def_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_218  := M.Instance;
         return Transform_Res_218;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_218;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_267 := Pos;

--  Start tok_code

      Token_Res_422 := Row_Pos_267;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_422));
      begin
         if T.Kind /= From_Token_Kind (Ada_Digits) then
            Token_Pos_422 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_267 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_267,
                  Expected_Token_Id => Ada_Digits,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_422 := Row_Pos_267 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_422 /= No_Token_Index then

         Row_Pos_267 := Token_Pos_422;

      else
         Row_Pos_267 := No_Token_Index;
         goto Exit_Row_263_0;

      end if;

      Defer_Res_447 := Sexpr_Or_Box_Or_Parse_0 (Parser, Row_Pos_267);
      Defer_Pos_447 := Parser.Current_Pos;

      if Defer_Pos_447 /= No_Token_Index then

         Row_Pos_267 := Defer_Pos_447;

      else
         Row_Pos_267 := No_Token_Index;
         goto Exit_Row_263_0;

      end if;

--  Start opt_code

      Defer_Res_448 := Range_Spec_Transform_Parse_0 (Parser, Row_Pos_267);
      Defer_Pos_448 := Parser.Current_Pos;

      if Defer_Pos_448 = No_Token_Index then

         Defer_Res_448 := No_Bare_Ada_Node;

         Defer_Pos_448 := Row_Pos_267;

      end if;

--  End opt_code

      if Defer_Pos_448 /= No_Token_Index then

         Row_Pos_267 := Defer_Pos_448;

      else
         Row_Pos_267 := No_Token_Index;
         goto Exit_Row_263_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_263_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_267 /= No_Token_Index then

         Transform_Res_218 := Allocate_Floating_Point_Def (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_218, Kind => Ada_Floating_Point_Def,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_267 = Pos then No_Token_Index else Row_Pos_267 - 1));

         Initialize_Fields_For_Floating_Point_Def
           (Self                            => Transform_Res_218,
            Floating_Point_Def_F_Num_Digits => Defer_Res_447,
            Floating_Point_Def_F_Range      => Defer_Res_448);

         if Defer_Res_447 /= null and then Is_Incomplete (Defer_Res_447) then
            Transform_Res_218.Last_Attempted_Child := 0;
         elsif Defer_Res_447 /= null and then not Is_Ghost (Defer_Res_447) then
            Transform_Res_218.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_448 /= null and then Is_Incomplete (Defer_Res_448) then
            Transform_Res_218.Last_Attempted_Child := 0;
         elsif Defer_Res_448 /= null and then not Is_Ghost (Defer_Res_448) then
            Transform_Res_218.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Floating_Point_Def_Transform_Parse_0_Memo,
         Row_Pos_267 /= No_Token_Index, Transform_Res_218, Pos, Row_Pos_267);

      Parser.Current_Pos := Row_Pos_267;

      return Transform_Res_218;
   end Floating_Point_Def_Transform_Parse_0;

   function Ordinary_Fixed_Point_Def_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Ordinary_Fixed_Point_Def
   is
      use Bare_Ordinary_Fixed_Point_Def_Memos;

      Row_Pos_268       : Token_Index                   := No_Token_Index;
      Token_Pos_423     : Token_Index                   := No_Token_Index;
      Token_Res_423     : Token_Index                   := No_Token_Index;
      Defer_Pos_449     : Token_Index                   := No_Token_Index;
      Defer_Res_449     : Bare_Expr                     := No_Bare_Ada_Node;
      Defer_Pos_450     : Token_Index                   := No_Token_Index;
      Defer_Res_450     : Bare_Range_Spec               := No_Bare_Ada_Node;
      Transform_Res_219 : Bare_Ordinary_Fixed_Point_Def := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Ordinary_Fixed_Point_Def_Transform_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_219  := M.Instance;
         return Transform_Res_219;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_219;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_268 := Pos;

--  Start tok_code

      Token_Res_423 := Row_Pos_268;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_423));
      begin
         if T.Kind /= From_Token_Kind (Ada_Delta) then
            Token_Pos_423 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_268 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_268,
                  Expected_Token_Id => Ada_Delta,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_423 := Row_Pos_268 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_423 /= No_Token_Index then

         Row_Pos_268 := Token_Pos_423;

      else
         Row_Pos_268 := No_Token_Index;
         goto Exit_Row_264_0;

      end if;

      Defer_Res_449 := Sexpr_Or_Box_Or_Parse_0 (Parser, Row_Pos_268);
      Defer_Pos_449 := Parser.Current_Pos;

      if Defer_Pos_449 /= No_Token_Index then

         Row_Pos_268 := Defer_Pos_449;

      else
         Row_Pos_268 := No_Token_Index;
         goto Exit_Row_264_0;

      end if;

--  Start opt_code

      Defer_Res_450 := Range_Spec_Transform_Parse_0 (Parser, Row_Pos_268);
      Defer_Pos_450 := Parser.Current_Pos;

      if Defer_Pos_450 = No_Token_Index then

         Defer_Res_450 := No_Bare_Ada_Node;

         Defer_Pos_450 := Row_Pos_268;

      end if;

--  End opt_code

      if Defer_Pos_450 /= No_Token_Index then

         Row_Pos_268 := Defer_Pos_450;

      else
         Row_Pos_268 := No_Token_Index;
         goto Exit_Row_264_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_264_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_268 /= No_Token_Index then

         Transform_Res_219 :=
           Allocate_Ordinary_Fixed_Point_Def (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_219, Kind => Ada_Ordinary_Fixed_Point_Def,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_268 = Pos then No_Token_Index else Row_Pos_268 - 1));

         Initialize_Fields_For_Ordinary_Fixed_Point_Def
           (Self                             => Transform_Res_219,
            Ordinary_Fixed_Point_Def_F_Delta => Defer_Res_449,
            Ordinary_Fixed_Point_Def_F_Range => Defer_Res_450);

         if Defer_Res_449 /= null and then Is_Incomplete (Defer_Res_449) then
            Transform_Res_219.Last_Attempted_Child := 0;
         elsif Defer_Res_449 /= null and then not Is_Ghost (Defer_Res_449) then
            Transform_Res_219.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_450 /= null and then Is_Incomplete (Defer_Res_450) then
            Transform_Res_219.Last_Attempted_Child := 0;
         elsif Defer_Res_450 /= null and then not Is_Ghost (Defer_Res_450) then
            Transform_Res_219.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Ordinary_Fixed_Point_Def_Transform_Parse_0_Memo,
         Row_Pos_268 /= No_Token_Index, Transform_Res_219, Pos, Row_Pos_268);

      Parser.Current_Pos := Row_Pos_268;

      return Transform_Res_219;
   end Ordinary_Fixed_Point_Def_Transform_Parse_0;

   function Real_Type_Def_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Real_Type_Def
   is
      use Bare_Real_Type_Def_Memos;

      Defer_Pos_444 : Token_Index                   := No_Token_Index;
      Defer_Res_444 : Bare_Floating_Point_Def       := No_Bare_Ada_Node;
      Defer_Pos_445 : Token_Index                   := No_Token_Index;
      Defer_Res_445 : Bare_Decimal_Fixed_Point_Def  := No_Bare_Ada_Node;
      Defer_Pos_446 : Token_Index                   := No_Token_Index;
      Defer_Res_446 : Bare_Ordinary_Fixed_Point_Def := No_Bare_Ada_Node;
      Or_Pos_85     : Token_Index                   := No_Token_Index;
      Or_Res_85     : Bare_Real_Type_Def            := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Real_Type_Def_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_85          := M.Instance;
         return Or_Res_85;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_85;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_85 := No_Token_Index;
      Or_Res_85 := No_Bare_Ada_Node;

      Defer_Res_444 := Floating_Point_Def_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_444 := Parser.Current_Pos;

      if Defer_Pos_444 /= No_Token_Index then
         Or_Pos_85 := Defer_Pos_444;
         Or_Res_85 := Defer_Res_444;
         goto Exit_Or_86;
      end if;

      Defer_Res_445 := Decimal_Fixed_Point_Def_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_445 := Parser.Current_Pos;

      if Defer_Pos_445 /= No_Token_Index then
         Or_Pos_85 := Defer_Pos_445;
         Or_Res_85 := Defer_Res_445;
         goto Exit_Or_86;
      end if;

      Defer_Res_446 :=
        Ordinary_Fixed_Point_Def_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_446 := Parser.Current_Pos;

      if Defer_Pos_446 /= No_Token_Index then
         Or_Pos_85 := Defer_Pos_446;
         Or_Res_85 := Defer_Res_446;
         goto Exit_Or_86;
      end if;
      <<Exit_Or_86>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Real_Type_Def_Or_Parse_0_Memo,
         Or_Pos_85 /= No_Token_Index, Or_Res_85, Pos, Or_Pos_85);

      Parser.Current_Pos := Or_Pos_85;

      return Or_Res_85;
   end Real_Type_Def_Or_Parse_0;

   function Parent_List_List_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Parent_List
   is
      use Bare_Parent_List_Memos;

      Lst_Cpos_34   : Token_Index      := No_Token_Index;
      Tmp_List_34   : Free_Parse_List;
      Defer_Pos_454 : Token_Index      := No_Token_Index;
      Defer_Res_454 : Bare_Name        := No_Bare_Ada_Node;
      Token_Pos_432 : Token_Index      := No_Token_Index;
      Token_Res_432 : Token_Index      := No_Token_Index;
      List_Pos_34   : Token_Index      := No_Token_Index;
      List_Res_34   : Bare_Parent_List := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Parent_List_List_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         List_Res_34        := M.Instance;
         return List_Res_34;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return List_Res_34;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start list_code

      List_Pos_34 := No_Token_Index;

      Lst_Cpos_34 := Pos;
      Tmp_List_34 := Get_Parse_List (Parser);

      loop

         Defer_Res_454 := Static_Name_Or_Parse_0 (Parser, Lst_Cpos_34);
         Defer_Pos_454 := Parser.Current_Pos;

         exit when Defer_Pos_454 = No_Token_Index;

         List_Pos_34 := Defer_Pos_454;
         Lst_Cpos_34 := List_Pos_34;

         Tmp_List_34.Nodes.Append (Defer_Res_454);

--  Start tok_code

         Token_Res_432 := Lst_Cpos_34;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_432));
         begin
            if T.Kind /= From_Token_Kind (Ada_And) then
               Token_Pos_432 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_34 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_34,
                     Expected_Token_Id => Ada_And,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_432 := Lst_Cpos_34 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_432 /= No_Token_Index then
            Lst_Cpos_34 := Token_Pos_432;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_34.Nodes.Length;
      begin
         List_Res_34 := Allocate_Parent_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Pos;
            Token_End := (if Lst_Cpos_34 = Pos then Pos else Lst_Cpos_34 - 1);

         else
            Token_Start := Token_Index'Max (Pos, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self => List_Res_34, Kind => Ada_Parent_List, Unit => Parser.Unit,
            Token_Start_Index => Token_Start, Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_34, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_34.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_34.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_34);

--  End list_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Parent_List_List_Parse_0_Memo,
         List_Pos_34 /= No_Token_Index, List_Res_34, Pos, List_Pos_34);

      Parser.Current_Pos := List_Pos_34;

      return List_Res_34;
   end Parent_List_List_Parse_0;

   function Derived_Type_Def_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Derived_Type_Def
   is
      use Bare_Derived_Type_Def_Memos;

      Row_Pos_269       : Token_Index             := No_Token_Index;
      Token_Pos_424     : Token_Index             := No_Token_Index;
      Token_Res_424     : Token_Index             := No_Token_Index;
      Opt_Res_22        : Bare_Abstract_Node      := No_Bare_Ada_Node;
      Token_Pos_425     : Token_Index             := No_Token_Index;
      Token_Res_425     : Token_Index             := No_Token_Index;
      Opt_Res_23        : Bare_Limited_Node       := No_Bare_Ada_Node;
      Token_Pos_426     : Token_Index             := No_Token_Index;
      Token_Res_426     : Token_Index             := No_Token_Index;
      Opt_Res_24        : Bare_Synchronized_Node  := No_Bare_Ada_Node;
      Token_Pos_427     : Token_Index             := No_Token_Index;
      Token_Res_427     : Token_Index             := No_Token_Index;
      Defer_Pos_451     : Token_Index             := No_Token_Index;
      Defer_Res_451     : Bare_Subtype_Indication := No_Bare_Ada_Node;
      Row_Pos_270       : Token_Index             := No_Token_Index;
      Token_Pos_428     : Token_Index             := No_Token_Index;
      Token_Res_428     : Token_Index             := No_Token_Index;
      Defer_Pos_452     : Token_Index             := No_Token_Index;
      Defer_Res_452     : Bare_Parent_List        := No_Bare_Ada_Node;
      Row_Pos_271       : Token_Index             := No_Token_Index;
      Token_Pos_429     : Token_Index             := No_Token_Index;
      Token_Res_429     : Token_Index             := No_Token_Index;
      Defer_Pos_453     : Token_Index             := No_Token_Index;
      Defer_Res_453     : Bare_Base_Record_Def    := No_Bare_Ada_Node;
      Row_Pos_272       : Token_Index             := No_Token_Index;
      Token_Pos_430     : Token_Index             := No_Token_Index;
      Token_Res_430     : Token_Index             := No_Token_Index;
      Token_Pos_431     : Token_Index             := No_Token_Index;
      Token_Res_431     : Token_Index             := No_Token_Index;
      Opt_Res_25        : Bare_With_Private       := No_Bare_Ada_Node;
      Transform_Res_220 : Bare_Derived_Type_Def   := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Derived_Type_Def_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_220  := M.Instance;
         return Transform_Res_220;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_220;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_269 := Pos;

--  Start opt_code

--  Start tok_code

      Token_Res_424 := Row_Pos_269;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_424));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol
               (Parser.TDH.Symbols, Precomputed_Symbol_Abstract)
         then
            Token_Pos_424 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_269 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_269,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_424 := Row_Pos_269 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_424 = No_Token_Index then

         Opt_Res_22 := Allocate_Abstract_Absent (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_22, Kind => Ada_Abstract_Absent,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_269,
            Token_End_Index => No_Token_Index);

         Token_Pos_424 := Row_Pos_269;

      else

         Opt_Res_22 := Allocate_Abstract_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_22, Kind => Ada_Abstract_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_269,
            Token_End_Index => Token_Pos_424 - 1);

      end if;

--  End opt_code

      if Token_Pos_424 /= No_Token_Index then

         Row_Pos_269 := Token_Pos_424;

      else
         Row_Pos_269 := No_Token_Index;
         goto Exit_Row_265_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_425 := Row_Pos_269;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_425));
      begin
         if T.Kind /= From_Token_Kind (Ada_Limited) then
            Token_Pos_425 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_269 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_269,
                  Expected_Token_Id => Ada_Limited,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_425 := Row_Pos_269 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_425 = No_Token_Index then

         Opt_Res_23 := Allocate_Limited_Absent (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_23, Kind => Ada_Limited_Absent,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_269,
            Token_End_Index => No_Token_Index);

         Token_Pos_425 := Row_Pos_269;

      else

         Opt_Res_23 := Allocate_Limited_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_23, Kind => Ada_Limited_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_269,
            Token_End_Index => Token_Pos_425 - 1);

      end if;

--  End opt_code

      if Token_Pos_425 /= No_Token_Index then

         Row_Pos_269 := Token_Pos_425;

      else
         Row_Pos_269 := No_Token_Index;
         goto Exit_Row_265_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_426 := Row_Pos_269;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_426));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol
               (Parser.TDH.Symbols, Precomputed_Symbol_Synchronized)
         then
            Token_Pos_426 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_269 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_269,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_426 := Row_Pos_269 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_426 = No_Token_Index then

         Opt_Res_24 := Allocate_Synchronized_Absent (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_24, Kind => Ada_Synchronized_Absent,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_269,
            Token_End_Index => No_Token_Index);

         Token_Pos_426 := Row_Pos_269;

      else

         Opt_Res_24 := Allocate_Synchronized_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_24, Kind => Ada_Synchronized_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_269,
            Token_End_Index => Token_Pos_426 - 1);

      end if;

--  End opt_code

      if Token_Pos_426 /= No_Token_Index then

         Row_Pos_269 := Token_Pos_426;

      else
         Row_Pos_269 := No_Token_Index;
         goto Exit_Row_265_0;

      end if;

--  Start tok_code

      Token_Res_427 := Row_Pos_269;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_427));
      begin
         if T.Kind /= From_Token_Kind (Ada_New) then
            Token_Pos_427 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_269 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_269,
                  Expected_Token_Id => Ada_New,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_427 := Row_Pos_269 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_427 /= No_Token_Index then

         Row_Pos_269 := Token_Pos_427;

      else
         Row_Pos_269 := No_Token_Index;
         goto Exit_Row_265_0;

      end if;

      Defer_Res_451 :=
        Subtype_Indication_Transform_Parse_0 (Parser, Row_Pos_269);
      Defer_Pos_451 := Parser.Current_Pos;

      if Defer_Pos_451 /= No_Token_Index then

         Row_Pos_269 := Defer_Pos_451;

      else
         Row_Pos_269 := No_Token_Index;
         goto Exit_Row_265_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_270 := Row_Pos_269;

--  Start tok_code

      Token_Res_428 := Row_Pos_270;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_428));
      begin
         if T.Kind /= From_Token_Kind (Ada_And) then
            Token_Pos_428 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_270 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_270,
                  Expected_Token_Id => Ada_And,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_428 := Row_Pos_270 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_428 /= No_Token_Index then

         Row_Pos_270 := Token_Pos_428;

      else
         Row_Pos_270 := No_Token_Index;
         goto Exit_Row_266_0;

      end if;

      Defer_Res_452 := Parent_List_List_Parse_0 (Parser, Row_Pos_270);
      Defer_Pos_452 := Parser.Current_Pos;

      if Defer_Pos_452 /= No_Token_Index then

         Row_Pos_270 := Defer_Pos_452;

      else
         Row_Pos_270 := No_Token_Index;
         goto Exit_Row_266_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_266_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_270 = No_Token_Index then

         Defer_Res_452 := Allocate_Parent_List (Parser.Mem_Pool);
         Initialize
           (Self            => Defer_Res_452, Kind => Ada_Parent_List,
            Unit => Parser.Unit, Token_Start_Index => Row_Pos_269 - 1,
            Token_End_Index => No_Token_Index);
         Initialize_List (Self => Defer_Res_452, Parser => Parser, Count => 0);

         Row_Pos_270 := Row_Pos_269;

      end if;

--  End opt_code

      if Row_Pos_270 /= No_Token_Index then

         Row_Pos_269 := Row_Pos_270;

      else
         Row_Pos_269 := No_Token_Index;
         goto Exit_Row_265_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_271 := Row_Pos_269;

--  Start tok_code

      Token_Res_429 := Row_Pos_271;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_429));
      begin
         if T.Kind /= From_Token_Kind (Ada_With) then
            Token_Pos_429 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_271 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_271,
                  Expected_Token_Id => Ada_With,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_429 := Row_Pos_271 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_429 /= No_Token_Index then

         Row_Pos_271 := Token_Pos_429;

      else
         Row_Pos_271 := No_Token_Index;
         goto Exit_Row_267_0;

      end if;

      Defer_Res_453 := Record_Def_Or_Parse_0 (Parser, Row_Pos_271);
      Defer_Pos_453 := Parser.Current_Pos;

      if Defer_Pos_453 /= No_Token_Index then

         Row_Pos_271 := Defer_Pos_453;

      else
         Row_Pos_271 := No_Token_Index;
         goto Exit_Row_267_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_267_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_271 = No_Token_Index then

         Defer_Res_453 := No_Bare_Ada_Node;

         Row_Pos_271 := Row_Pos_269;

      end if;

--  End opt_code

      if Row_Pos_271 /= No_Token_Index then

         Row_Pos_269 := Row_Pos_271;

      else
         Row_Pos_269 := No_Token_Index;
         goto Exit_Row_265_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_272 := Row_Pos_269;

--  Start tok_code

      Token_Res_430 := Row_Pos_272;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_430));
      begin
         if T.Kind /= From_Token_Kind (Ada_With) then
            Token_Pos_430 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_272 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_272,
                  Expected_Token_Id => Ada_With,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_430 := Row_Pos_272 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_430 /= No_Token_Index then

         Row_Pos_272 := Token_Pos_430;

      else
         Row_Pos_272 := No_Token_Index;
         goto Exit_Row_268_0;

      end if;

--  Start tok_code

      Token_Res_431 := Row_Pos_272;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_431));
      begin
         if T.Kind /= From_Token_Kind (Ada_Private) then
            Token_Pos_431 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_272 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_272,
                  Expected_Token_Id => Ada_Private,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_431 := Row_Pos_272 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_431 /= No_Token_Index then

         Row_Pos_272 := Token_Pos_431;

      else
         Row_Pos_272 := No_Token_Index;
         goto Exit_Row_268_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_268_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_272 = No_Token_Index then

         Opt_Res_25 := Allocate_With_Private_Absent (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_25, Kind => Ada_With_Private_Absent,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_269,
            Token_End_Index => No_Token_Index);

         Row_Pos_272 := Row_Pos_269;

      else

         Opt_Res_25 := Allocate_With_Private_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_25, Kind => Ada_With_Private_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_269,
            Token_End_Index => Row_Pos_272 - 1);

      end if;

--  End opt_code

      if Row_Pos_272 /= No_Token_Index then

         Row_Pos_269 := Row_Pos_272;

      else
         Row_Pos_269 := No_Token_Index;
         goto Exit_Row_265_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_265_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_269 /= No_Token_Index then

         Transform_Res_220 := Allocate_Derived_Type_Def (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_220, Kind => Ada_Derived_Type_Def,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_269 = Pos then No_Token_Index else Row_Pos_269 - 1));

         Initialize_Fields_For_Derived_Type_Def
           (Self                                  => Transform_Res_220,
            Derived_Type_Def_F_Has_Abstract       => Opt_Res_22,
            Derived_Type_Def_F_Has_Limited        => Opt_Res_23,
            Derived_Type_Def_F_Has_Synchronized   => Opt_Res_24,
            Derived_Type_Def_F_Subtype_Indication => Defer_Res_451,
            Derived_Type_Def_F_Interfaces         => Defer_Res_452,
            Derived_Type_Def_F_Record_Extension   => Defer_Res_453,
            Derived_Type_Def_F_Has_With_Private   => Opt_Res_25);

         if Opt_Res_22 /= null and then Is_Incomplete (Opt_Res_22) then
            Transform_Res_220.Last_Attempted_Child := 0;
         elsif Opt_Res_22 /= null and then not Is_Ghost (Opt_Res_22) then
            Transform_Res_220.Last_Attempted_Child := -1;
         end if;
         if Opt_Res_23 /= null and then Is_Incomplete (Opt_Res_23) then
            Transform_Res_220.Last_Attempted_Child := 0;
         elsif Opt_Res_23 /= null and then not Is_Ghost (Opt_Res_23) then
            Transform_Res_220.Last_Attempted_Child := -1;
         end if;
         if Opt_Res_24 /= null and then Is_Incomplete (Opt_Res_24) then
            Transform_Res_220.Last_Attempted_Child := 0;
         elsif Opt_Res_24 /= null and then not Is_Ghost (Opt_Res_24) then
            Transform_Res_220.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_451 /= null and then Is_Incomplete (Defer_Res_451) then
            Transform_Res_220.Last_Attempted_Child := 0;
         elsif Defer_Res_451 /= null and then not Is_Ghost (Defer_Res_451) then
            Transform_Res_220.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_452 /= null and then Is_Incomplete (Defer_Res_452) then
            Transform_Res_220.Last_Attempted_Child := 0;
         elsif Defer_Res_452 /= null and then not Is_Ghost (Defer_Res_452) then
            Transform_Res_220.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_453 /= null and then Is_Incomplete (Defer_Res_453) then
            Transform_Res_220.Last_Attempted_Child := 0;
         elsif Defer_Res_453 /= null and then not Is_Ghost (Defer_Res_453) then
            Transform_Res_220.Last_Attempted_Child := -1;
         end if;
         if Opt_Res_25 /= null and then Is_Incomplete (Opt_Res_25) then
            Transform_Res_220.Last_Attempted_Child := 0;
         elsif Opt_Res_25 /= null and then not Is_Ghost (Opt_Res_25) then
            Transform_Res_220.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Derived_Type_Def_Transform_Parse_0_Memo,
         Row_Pos_269 /= No_Token_Index, Transform_Res_220, Pos, Row_Pos_269);

      Parser.Current_Pos := Row_Pos_269;

      return Transform_Res_220;
   end Derived_Type_Def_Transform_Parse_0;

   function Signed_Int_Type_Def_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Signed_Int_Type_Def
   is
      use Bare_Signed_Int_Type_Def_Memos;

      Row_Pos_273       : Token_Index              := No_Token_Index;
      Defer_Pos_455     : Token_Index              := No_Token_Index;
      Defer_Res_455     : Bare_Range_Spec          := No_Bare_Ada_Node;
      Transform_Res_221 : Bare_Signed_Int_Type_Def := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Signed_Int_Type_Def_Transform_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_221  := M.Instance;
         return Transform_Res_221;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_221;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_273 := Pos;

      Defer_Res_455 := Range_Spec_Transform_Parse_0 (Parser, Row_Pos_273);
      Defer_Pos_455 := Parser.Current_Pos;

      if Defer_Pos_455 /= No_Token_Index then

         Row_Pos_273 := Defer_Pos_455;

      else
         Row_Pos_273 := No_Token_Index;
         goto Exit_Row_269_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_269_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_273 /= No_Token_Index then

         Transform_Res_221 := Allocate_Signed_Int_Type_Def (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_221, Kind => Ada_Signed_Int_Type_Def,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_273 = Pos then No_Token_Index else Row_Pos_273 - 1));

         Initialize_Fields_For_Signed_Int_Type_Def
           (Self                        => Transform_Res_221,
            Signed_Int_Type_Def_F_Range => Defer_Res_455);

         if Defer_Res_455 /= null and then Is_Incomplete (Defer_Res_455) then
            Transform_Res_221.Last_Attempted_Child := 0;
         elsif Defer_Res_455 /= null and then not Is_Ghost (Defer_Res_455) then
            Transform_Res_221.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Signed_Int_Type_Def_Transform_Parse_0_Memo,
         Row_Pos_273 /= No_Token_Index, Transform_Res_221, Pos, Row_Pos_273);

      Parser.Current_Pos := Row_Pos_273;

      return Transform_Res_221;
   end Signed_Int_Type_Def_Transform_Parse_0;

   function Mod_Int_Type_Def_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Mod_Int_Type_Def
   is
      use Bare_Mod_Int_Type_Def_Memos;

      Row_Pos_274       : Token_Index           := No_Token_Index;
      Token_Pos_433     : Token_Index           := No_Token_Index;
      Token_Res_433     : Token_Index           := No_Token_Index;
      Defer_Pos_456     : Token_Index           := No_Token_Index;
      Defer_Res_456     : Bare_Expr             := No_Bare_Ada_Node;
      Transform_Res_222 : Bare_Mod_Int_Type_Def := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Mod_Int_Type_Def_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_222  := M.Instance;
         return Transform_Res_222;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_222;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_274 := Pos;

--  Start tok_code

      Token_Res_433 := Row_Pos_274;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_433));
      begin
         if T.Kind /= From_Token_Kind (Ada_Mod) then
            Token_Pos_433 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_274 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_274,
                  Expected_Token_Id => Ada_Mod,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_433 := Row_Pos_274 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_433 /= No_Token_Index then

         Row_Pos_274 := Token_Pos_433;

      else
         Row_Pos_274 := No_Token_Index;
         goto Exit_Row_270_0;

      end if;

      Defer_Res_456 := Sexpr_Or_Box_Or_Parse_0 (Parser, Row_Pos_274);
      Defer_Pos_456 := Parser.Current_Pos;

      if Defer_Pos_456 /= No_Token_Index then

         Row_Pos_274 := Defer_Pos_456;

      else
         Row_Pos_274 := No_Token_Index;
         goto Exit_Row_270_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_270_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_274 /= No_Token_Index then

         Transform_Res_222 := Allocate_Mod_Int_Type_Def (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_222, Kind => Ada_Mod_Int_Type_Def,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_274 = Pos then No_Token_Index else Row_Pos_274 - 1));

         Initialize_Fields_For_Mod_Int_Type_Def
           (Self                    => Transform_Res_222,
            Mod_Int_Type_Def_F_Expr => Defer_Res_456);

         if Defer_Res_456 /= null and then Is_Incomplete (Defer_Res_456) then
            Transform_Res_222.Last_Attempted_Child := 0;
         elsif Defer_Res_456 /= null and then not Is_Ghost (Defer_Res_456) then
            Transform_Res_222.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Mod_Int_Type_Def_Transform_Parse_0_Memo,
         Row_Pos_274 /= No_Token_Index, Transform_Res_222, Pos, Row_Pos_274);

      Parser.Current_Pos := Row_Pos_274;

      return Transform_Res_222;
   end Mod_Int_Type_Def_Transform_Parse_0;

   function Interface_Type_Def_Transform_Parse_4
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Interface_Type_Def
   is
      use Bare_Interface_Type_Def_Memos;

      Row_Pos_275       : Token_Index                      := No_Token_Index;
      Row_Pos_276       : Token_Index                      := No_Token_Index;
      Token_Pos_434     : Token_Index                      := No_Token_Index;
      Token_Res_434     : Token_Index                      := No_Token_Index;
      Transform_Res_223 : Bare_Interface_Kind_Limited      := No_Bare_Ada_Node;
      Row_Pos_277       : Token_Index                      := No_Token_Index;
      Token_Pos_435     : Token_Index                      := No_Token_Index;
      Token_Res_435     : Token_Index                      := No_Token_Index;
      Transform_Res_224 : Bare_Interface_Kind_Task         := No_Bare_Ada_Node;
      Row_Pos_278       : Token_Index                      := No_Token_Index;
      Token_Pos_436     : Token_Index                      := No_Token_Index;
      Token_Res_436     : Token_Index                      := No_Token_Index;
      Transform_Res_225 : Bare_Interface_Kind_Protected    := No_Bare_Ada_Node;
      Row_Pos_279       : Token_Index                      := No_Token_Index;
      Token_Pos_437     : Token_Index                      := No_Token_Index;
      Token_Res_437     : Token_Index                      := No_Token_Index;
      Transform_Res_226 : Bare_Interface_Kind_Synchronized := No_Bare_Ada_Node;
      Or_Pos_86         : Token_Index                      := No_Token_Index;
      Or_Res_86         : Bare_Interface_Kind              := No_Bare_Ada_Node;
      Token_Pos_438     : Token_Index                      := No_Token_Index;
      Token_Res_438     : Token_Index                      := No_Token_Index;
      Row_Pos_280       : Token_Index                      := No_Token_Index;
      Token_Pos_439     : Token_Index                      := No_Token_Index;
      Token_Res_439     : Token_Index                      := No_Token_Index;
      Defer_Pos_457     : Token_Index                      := No_Token_Index;
      Defer_Res_457     : Bare_Parent_List                 := No_Bare_Ada_Node;
      Transform_Res_227 : Bare_Interface_Type_Def          := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Interface_Type_Def_Transform_Parse_4_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_227  := M.Instance;
         return Transform_Res_227;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_227;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_275 := Pos;

--  Start opt_code

--  Start or_code

      Or_Pos_86 := No_Token_Index;
      Or_Res_86 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_276 := Row_Pos_275;

--  Start tok_code

      Token_Res_434 := Row_Pos_276;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_434));
      begin
         if T.Kind /= From_Token_Kind (Ada_Limited) then
            Token_Pos_434 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_276 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_276,
                  Expected_Token_Id => Ada_Limited,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_434 := Row_Pos_276 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_434 /= No_Token_Index then

         Row_Pos_276 := Token_Pos_434;

      else
         Row_Pos_276 := No_Token_Index;
         goto Exit_Row_272_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_272_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_276 /= No_Token_Index then

         Transform_Res_223 :=
           Allocate_Interface_Kind_Limited (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_223, Kind => Ada_Interface_Kind_Limited,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_275,
            Token_End_Index =>
              (if Row_Pos_276 = Row_Pos_275 then No_Token_Index
               else Row_Pos_276 - 1));

      end if;

--  End transform_code

      if Row_Pos_276 /= No_Token_Index then
         Or_Pos_86 := Row_Pos_276;
         Or_Res_86 := Transform_Res_223;
         goto Exit_Or_87;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_277 := Row_Pos_275;

--  Start tok_code

      Token_Res_435 := Row_Pos_277;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_435));
      begin
         if T.Kind /= From_Token_Kind (Ada_Task) then
            Token_Pos_435 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_277 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_277,
                  Expected_Token_Id => Ada_Task,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_435 := Row_Pos_277 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_435 /= No_Token_Index then

         Row_Pos_277 := Token_Pos_435;

      else
         Row_Pos_277 := No_Token_Index;
         goto Exit_Row_273_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_273_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_277 /= No_Token_Index then

         Transform_Res_224 := Allocate_Interface_Kind_Task (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_224, Kind => Ada_Interface_Kind_Task,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_275,
            Token_End_Index =>
              (if Row_Pos_277 = Row_Pos_275 then No_Token_Index
               else Row_Pos_277 - 1));

      end if;

--  End transform_code

      if Row_Pos_277 /= No_Token_Index then
         Or_Pos_86 := Row_Pos_277;
         Or_Res_86 := Transform_Res_224;
         goto Exit_Or_87;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_278 := Row_Pos_275;

--  Start tok_code

      Token_Res_436 := Row_Pos_278;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_436));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol
               (Parser.TDH.Symbols, Precomputed_Symbol_Protected)
         then
            Token_Pos_436 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_278 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_278,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_436 := Row_Pos_278 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_436 /= No_Token_Index then

         Row_Pos_278 := Token_Pos_436;

      else
         Row_Pos_278 := No_Token_Index;
         goto Exit_Row_274_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_274_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_278 /= No_Token_Index then

         Transform_Res_225 :=
           Allocate_Interface_Kind_Protected (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_225, Kind => Ada_Interface_Kind_Protected,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_275,
            Token_End_Index =>
              (if Row_Pos_278 = Row_Pos_275 then No_Token_Index
               else Row_Pos_278 - 1));

      end if;

--  End transform_code

      if Row_Pos_278 /= No_Token_Index then
         Or_Pos_86 := Row_Pos_278;
         Or_Res_86 := Transform_Res_225;
         goto Exit_Or_87;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_279 := Row_Pos_275;

--  Start tok_code

      Token_Res_437 := Row_Pos_279;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_437));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol
               (Parser.TDH.Symbols, Precomputed_Symbol_Synchronized)
         then
            Token_Pos_437 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_279 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_279,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_437 := Row_Pos_279 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_437 /= No_Token_Index then

         Row_Pos_279 := Token_Pos_437;

      else
         Row_Pos_279 := No_Token_Index;
         goto Exit_Row_275_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_275_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_279 /= No_Token_Index then

         Transform_Res_226 :=
           Allocate_Interface_Kind_Synchronized (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_226, Kind => Ada_Interface_Kind_Synchronized,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_275,
            Token_End_Index =>
              (if Row_Pos_279 = Row_Pos_275 then No_Token_Index
               else Row_Pos_279 - 1));

      end if;

--  End transform_code

      if Row_Pos_279 /= No_Token_Index then
         Or_Pos_86 := Row_Pos_279;
         Or_Res_86 := Transform_Res_226;
         goto Exit_Or_87;
      end if;
      <<Exit_Or_87>>

--  End or_code

      if Or_Pos_86 = No_Token_Index then

         Or_Res_86 := No_Bare_Ada_Node;

         Or_Pos_86 := Row_Pos_275;

      end if;

--  End opt_code

      if Or_Pos_86 /= No_Token_Index then

         Row_Pos_275 := Or_Pos_86;

      else
         Row_Pos_275 := No_Token_Index;
         goto Exit_Row_271_0;

      end if;

--  Start tok_code

      Token_Res_438 := Row_Pos_275;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_438));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol
               (Parser.TDH.Symbols, Precomputed_Symbol_Interface_188)
         then
            Token_Pos_438 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_275 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_275,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_438 := Row_Pos_275 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_438 /= No_Token_Index then

         Row_Pos_275 := Token_Pos_438;

      else
         Row_Pos_275 := No_Token_Index;
         goto Exit_Row_271_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_280 := Row_Pos_275;

--  Start tok_code

      Token_Res_439 := Row_Pos_280;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_439));
      begin
         if T.Kind /= From_Token_Kind (Ada_And) then
            Token_Pos_439 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_280 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_280,
                  Expected_Token_Id => Ada_And,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_439 := Row_Pos_280 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_439 /= No_Token_Index then

         Row_Pos_280 := Token_Pos_439;

      else
         Row_Pos_280 := No_Token_Index;
         goto Exit_Row_276_0;

      end if;

      Defer_Res_457 := Parent_List_List_Parse_0 (Parser, Row_Pos_280);
      Defer_Pos_457 := Parser.Current_Pos;

      if Defer_Pos_457 /= No_Token_Index then

         Row_Pos_280 := Defer_Pos_457;

      else
         Row_Pos_280 := No_Token_Index;
         goto Exit_Row_276_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_276_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_280 = No_Token_Index then

         Defer_Res_457 := Allocate_Parent_List (Parser.Mem_Pool);
         Initialize
           (Self            => Defer_Res_457, Kind => Ada_Parent_List,
            Unit => Parser.Unit, Token_Start_Index => Row_Pos_275 - 1,
            Token_End_Index => No_Token_Index);
         Initialize_List (Self => Defer_Res_457, Parser => Parser, Count => 0);

         Row_Pos_280 := Row_Pos_275;

      end if;

--  End opt_code

      if Row_Pos_280 /= No_Token_Index then

         Row_Pos_275 := Row_Pos_280;

      else
         Row_Pos_275 := No_Token_Index;
         goto Exit_Row_271_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_271_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_275 /= No_Token_Index then

         Transform_Res_227 := Allocate_Interface_Type_Def (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_227, Kind => Ada_Interface_Type_Def,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_275 = Pos then No_Token_Index else Row_Pos_275 - 1));

         Initialize_Fields_For_Interface_Type_Def
           (Self                                => Transform_Res_227,
            Interface_Type_Def_F_Interface_Kind => Or_Res_86,
            Interface_Type_Def_F_Interfaces     => Defer_Res_457);

         if Or_Res_86 /= null and then Is_Incomplete (Or_Res_86) then
            Transform_Res_227.Last_Attempted_Child := 0;
         elsif Or_Res_86 /= null and then not Is_Ghost (Or_Res_86) then
            Transform_Res_227.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_457 /= null and then Is_Incomplete (Defer_Res_457) then
            Transform_Res_227.Last_Attempted_Child := 0;
         elsif Defer_Res_457 /= null and then not Is_Ghost (Defer_Res_457) then
            Transform_Res_227.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Interface_Type_Def_Transform_Parse_4_Memo,
         Row_Pos_275 /= No_Token_Index, Transform_Res_227, Pos, Row_Pos_275);

      Parser.Current_Pos := Row_Pos_275;

      return Transform_Res_227;
   end Interface_Type_Def_Transform_Parse_4;

   function Formal_Discrete_Type_Def_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Formal_Discrete_Type_Def
   is
      use Bare_Formal_Discrete_Type_Def_Memos;

      Row_Pos_281       : Token_Index                   := No_Token_Index;
      Token_Pos_440     : Token_Index                   := No_Token_Index;
      Token_Res_440     : Token_Index                   := No_Token_Index;
      Token_Pos_441     : Token_Index                   := No_Token_Index;
      Token_Res_441     : Token_Index                   := No_Token_Index;
      Token_Pos_442     : Token_Index                   := No_Token_Index;
      Token_Res_442     : Token_Index                   := No_Token_Index;
      Transform_Res_228 : Bare_Formal_Discrete_Type_Def := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Formal_Discrete_Type_Def_Transform_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_228  := M.Instance;
         return Transform_Res_228;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_228;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_281 := Pos;

--  Start tok_code

      Token_Res_440 := Row_Pos_281;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_440));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Open) then
            Token_Pos_440 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_281 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_281,
                  Expected_Token_Id => Ada_Par_Open,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_440 := Row_Pos_281 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_440 /= No_Token_Index then

         Row_Pos_281 := Token_Pos_440;

      else
         Row_Pos_281 := No_Token_Index;
         goto Exit_Row_277_0;

      end if;

--  Start tok_code

      Token_Res_441 := Row_Pos_281;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_441));
      begin
         if T.Kind /= From_Token_Kind (Ada_Diamond) then
            Token_Pos_441 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_281 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_281,
                  Expected_Token_Id => Ada_Diamond,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_441 := Row_Pos_281 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_441 /= No_Token_Index then

         Row_Pos_281 := Token_Pos_441;

      else
         Row_Pos_281 := No_Token_Index;
         goto Exit_Row_277_0;

      end if;

--  Start tok_code

      Token_Res_442 := Row_Pos_281;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_442));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Close) then
            Token_Pos_442 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_281 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_281,
                  Expected_Token_Id => Ada_Par_Close,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_442 := Row_Pos_281 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_442 /= No_Token_Index then

         Row_Pos_281 := Token_Pos_442;

      else
         Row_Pos_281 := No_Token_Index;
         goto Exit_Row_277_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_277_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_281 /= No_Token_Index then

         Transform_Res_228 :=
           Allocate_Formal_Discrete_Type_Def (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_228, Kind => Ada_Formal_Discrete_Type_Def,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_281 = Pos then No_Token_Index else Row_Pos_281 - 1));

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Formal_Discrete_Type_Def_Transform_Parse_0_Memo,
         Row_Pos_281 /= No_Token_Index, Transform_Res_228, Pos, Row_Pos_281);

      Parser.Current_Pos := Row_Pos_281;

      return Transform_Res_228;
   end Formal_Discrete_Type_Def_Transform_Parse_0;

   function Enum_Literal_Decl_Transform_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Enum_Literal_Decl
   is
      use Bare_Enum_Literal_Decl_Memos;

      Row_Pos_283       : Token_Index            := No_Token_Index;
      Defer_Pos_459     : Token_Index            := No_Token_Index;
      Defer_Res_459     : Bare_Defining_Name     := No_Bare_Ada_Node;
      Row_Pos_284       : Token_Index            := No_Token_Index;
      Defer_Pos_460     : Token_Index            := No_Token_Index;
      Defer_Res_460     : Bare_Char_Literal      := No_Bare_Ada_Node;
      Transform_Res_230 : Bare_Defining_Name     := No_Bare_Ada_Node;
      Or_Pos_87         : Token_Index            := No_Token_Index;
      Or_Res_87         : Bare_Defining_Name     := No_Bare_Ada_Node;
      Transform_Res_231 : Bare_Enum_Literal_Decl := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Enum_Literal_Decl_Transform_Parse_1_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_231  := M.Instance;
         return Transform_Res_231;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_231;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_283 := Pos;

--  Start or_code

      Or_Pos_87 := No_Token_Index;
      Or_Res_87 := No_Bare_Ada_Node;

      Defer_Res_459 := Defining_Id_Transform_Parse_0 (Parser, Row_Pos_283);
      Defer_Pos_459 := Parser.Current_Pos;

      if Defer_Pos_459 /= No_Token_Index then
         Or_Pos_87 := Defer_Pos_459;
         Or_Res_87 := Defer_Res_459;
         goto Exit_Or_88;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_284 := Row_Pos_283;

      Defer_Res_460 := Char_Literal_Transform_Parse_0 (Parser, Row_Pos_284);
      Defer_Pos_460 := Parser.Current_Pos;

      if Defer_Pos_460 /= No_Token_Index then

         Row_Pos_284 := Defer_Pos_460;

      else
         Row_Pos_284 := No_Token_Index;
         goto Exit_Row_280_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_280_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_284 /= No_Token_Index then

         Transform_Res_230 := Allocate_Defining_Name (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_230, Kind => Ada_Defining_Name,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_283,
            Token_End_Index =>
              (if Row_Pos_284 = Row_Pos_283 then No_Token_Index
               else Row_Pos_284 - 1));

         Initialize_Fields_For_Defining_Name
           (Self => Transform_Res_230, Defining_Name_F_Name => Defer_Res_460);

         if Defer_Res_460 /= null and then Is_Incomplete (Defer_Res_460) then
            Transform_Res_230.Last_Attempted_Child := 0;
         elsif Defer_Res_460 /= null and then not Is_Ghost (Defer_Res_460) then
            Transform_Res_230.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_284 /= No_Token_Index then
         Or_Pos_87 := Row_Pos_284;
         Or_Res_87 := Transform_Res_230;
         goto Exit_Or_88;
      end if;
      <<Exit_Or_88>>

--  End or_code

      if Or_Pos_87 /= No_Token_Index then

         Row_Pos_283 := Or_Pos_87;

      else
         Row_Pos_283 := No_Token_Index;
         goto Exit_Row_279_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_279_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_283 /= No_Token_Index then

         Transform_Res_231 := Allocate_Enum_Literal_Decl (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_231, Kind => Ada_Enum_Literal_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_283 = Pos then No_Token_Index else Row_Pos_283 - 1));

         Initialize_Fields_For_Enum_Literal_Decl
           (Self => Transform_Res_231, Enum_Literal_Decl_F_Name => Or_Res_87);

         if Or_Res_87 /= null and then Is_Incomplete (Or_Res_87) then
            Transform_Res_231.Last_Attempted_Child := 0;
         elsif Or_Res_87 /= null and then not Is_Ghost (Or_Res_87) then
            Transform_Res_231.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Enum_Literal_Decl_Transform_Parse_1_Memo,
         Row_Pos_283 /= No_Token_Index, Transform_Res_231, Pos, Row_Pos_283);

      Parser.Current_Pos := Row_Pos_283;

      return Transform_Res_231;
   end Enum_Literal_Decl_Transform_Parse_1;

   function Enum_Type_Def_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Enum_Type_Def
   is
      use Bare_Enum_Type_Def_Memos;

      Row_Pos_282       : Token_Index                 := No_Token_Index;
      Token_Pos_443     : Token_Index                 := No_Token_Index;
      Token_Res_443     : Token_Index                 := No_Token_Index;
      Lst_Cpos_35       : Token_Index                 := No_Token_Index;
      Tmp_List_35       : Free_Parse_List;
      Defer_Pos_458     : Token_Index                 := No_Token_Index;
      Defer_Res_458     : Bare_Enum_Literal_Decl      := No_Bare_Ada_Node;
      Token_Pos_444     : Token_Index                 := No_Token_Index;
      Token_Res_444     : Token_Index                 := No_Token_Index;
      List_Pos_35       : Token_Index                 := No_Token_Index;
      List_Res_35       : Bare_Enum_Literal_Decl_List := No_Bare_Ada_Node;
      Token_Pos_445     : Token_Index                 := No_Token_Index;
      Token_Res_445     : Token_Index                 := No_Token_Index;
      Transform_Res_229 : Bare_Enum_Type_Def          := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Enum_Type_Def_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_229  := M.Instance;
         return Transform_Res_229;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_229;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_282 := Pos;

--  Start tok_code

      Token_Res_443 := Row_Pos_282;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_443));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Open) then
            Token_Pos_443 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_282 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_282,
                  Expected_Token_Id => Ada_Par_Open,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_443 := Row_Pos_282 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_443 /= No_Token_Index then

         Row_Pos_282 := Token_Pos_443;

      else
         Row_Pos_282 := No_Token_Index;
         goto Exit_Row_278_0;

      end if;

--  Start list_code

      List_Pos_35 := No_Token_Index;

      Lst_Cpos_35 := Row_Pos_282;
      Tmp_List_35 := Get_Parse_List (Parser);

      loop

         Defer_Res_458 :=
           Enum_Literal_Decl_Transform_Parse_1 (Parser, Lst_Cpos_35);
         Defer_Pos_458 := Parser.Current_Pos;

         exit when Defer_Pos_458 = No_Token_Index;

         List_Pos_35 := Defer_Pos_458;
         Lst_Cpos_35 := List_Pos_35;

         Tmp_List_35.Nodes.Append (Defer_Res_458);

--  Start tok_code

         Token_Res_444 := Lst_Cpos_35;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_444));
         begin
            if T.Kind /= From_Token_Kind (Ada_Comma) then
               Token_Pos_444 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_35 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_35,
                     Expected_Token_Id => Ada_Comma,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_444 := Lst_Cpos_35 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_444 /= No_Token_Index then
            Lst_Cpos_35 := Token_Pos_444;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_35.Nodes.Length;
      begin
         List_Res_35 := Allocate_Enum_Literal_Decl_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_282;
            Token_End   :=
              (if Lst_Cpos_35 = Row_Pos_282 then Row_Pos_282
               else Lst_Cpos_35 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_282, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self            => List_Res_35, Kind => Ada_Enum_Literal_Decl_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_35, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_35.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_35.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_35);

--  End list_code

      if List_Pos_35 /= No_Token_Index then

         Row_Pos_282 := List_Pos_35;

      else
         Row_Pos_282 := No_Token_Index;
         goto Exit_Row_278_0;

      end if;

--  Start tok_code

      Token_Res_445 := Row_Pos_282;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_445));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Close) then
            Token_Pos_445 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_282 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_282,
                  Expected_Token_Id => Ada_Par_Close,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_445 := Row_Pos_282 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_445 /= No_Token_Index then

         Row_Pos_282 := Token_Pos_445;

      else
         Row_Pos_282 := No_Token_Index;
         goto Exit_Row_278_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_278_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_282 /= No_Token_Index then

         Transform_Res_229 := Allocate_Enum_Type_Def (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_229, Kind => Ada_Enum_Type_Def,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_282 = Pos then No_Token_Index else Row_Pos_282 - 1));

         Initialize_Fields_For_Enum_Type_Def
           (Self                          => Transform_Res_229,
            Enum_Type_Def_F_Enum_Literals => List_Res_35);

         if List_Res_35 /= null and then Is_Incomplete (List_Res_35) then
            Transform_Res_229.Last_Attempted_Child := 0;
         elsif List_Res_35 /= null and then not Is_Ghost (List_Res_35) then
            Transform_Res_229.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Enum_Type_Def_Transform_Parse_0_Memo,
         Row_Pos_282 /= No_Token_Index, Transform_Res_229, Pos, Row_Pos_282);

      Parser.Current_Pos := Row_Pos_282;

      return Transform_Res_229;
   end Enum_Type_Def_Transform_Parse_0;

   function Type_Def_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Type_Def
   is
      use Bare_Type_Def_Memos;

      Defer_Pos_406 : Token_Index                   := No_Token_Index;
      Defer_Res_406 : Bare_Record_Type_Def          := No_Bare_Ada_Node;
      Defer_Pos_407 : Token_Index                   := No_Token_Index;
      Defer_Res_407 : Bare_Real_Type_Def            := No_Bare_Ada_Node;
      Defer_Pos_408 : Token_Index                   := No_Token_Index;
      Defer_Res_408 : Bare_Derived_Type_Def         := No_Bare_Ada_Node;
      Defer_Pos_409 : Token_Index                   := No_Token_Index;
      Defer_Res_409 : Bare_Signed_Int_Type_Def      := No_Bare_Ada_Node;
      Defer_Pos_410 : Token_Index                   := No_Token_Index;
      Defer_Res_410 : Bare_Mod_Int_Type_Def         := No_Bare_Ada_Node;
      Defer_Pos_411 : Token_Index                   := No_Token_Index;
      Defer_Res_411 : Bare_Array_Type_Def           := No_Bare_Ada_Node;
      Defer_Pos_412 : Token_Index                   := No_Token_Index;
      Defer_Res_412 : Bare_Interface_Type_Def       := No_Bare_Ada_Node;
      Defer_Pos_413 : Token_Index                   := No_Token_Index;
      Defer_Res_413 : Bare_Access_Def               := No_Bare_Ada_Node;
      Defer_Pos_414 : Token_Index                   := No_Token_Index;
      Defer_Res_414 : Bare_Formal_Discrete_Type_Def := No_Bare_Ada_Node;
      Defer_Pos_415 : Token_Index                   := No_Token_Index;
      Defer_Res_415 : Bare_Enum_Type_Def            := No_Bare_Ada_Node;
      Or_Pos_80     : Token_Index                   := No_Token_Index;
      Or_Res_80     : Bare_Type_Def                 := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Type_Def_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_80          := M.Instance;
         return Or_Res_80;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_80;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_80 := No_Token_Index;
      Or_Res_80 := No_Bare_Ada_Node;

      Defer_Res_406 := Record_Type_Def_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_406 := Parser.Current_Pos;

      if Defer_Pos_406 /= No_Token_Index then
         Or_Pos_80 := Defer_Pos_406;
         Or_Res_80 := Defer_Res_406;
         goto Exit_Or_81;
      end if;

      Defer_Res_407 := Real_Type_Def_Or_Parse_0 (Parser, Pos);
      Defer_Pos_407 := Parser.Current_Pos;

      if Defer_Pos_407 /= No_Token_Index then
         Or_Pos_80 := Defer_Pos_407;
         Or_Res_80 := Defer_Res_407;
         goto Exit_Or_81;
      end if;

      Defer_Res_408 := Derived_Type_Def_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_408 := Parser.Current_Pos;

      if Defer_Pos_408 /= No_Token_Index then
         Or_Pos_80 := Defer_Pos_408;
         Or_Res_80 := Defer_Res_408;
         goto Exit_Or_81;
      end if;

      Defer_Res_409 := Signed_Int_Type_Def_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_409 := Parser.Current_Pos;

      if Defer_Pos_409 /= No_Token_Index then
         Or_Pos_80 := Defer_Pos_409;
         Or_Res_80 := Defer_Res_409;
         goto Exit_Or_81;
      end if;

      Defer_Res_410 := Mod_Int_Type_Def_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_410 := Parser.Current_Pos;

      if Defer_Pos_410 /= No_Token_Index then
         Or_Pos_80 := Defer_Pos_410;
         Or_Res_80 := Defer_Res_410;
         goto Exit_Or_81;
      end if;

      Defer_Res_411 := Array_Type_Def_Transform_Parse_2 (Parser, Pos);
      Defer_Pos_411 := Parser.Current_Pos;

      if Defer_Pos_411 /= No_Token_Index then
         Or_Pos_80 := Defer_Pos_411;
         Or_Res_80 := Defer_Res_411;
         goto Exit_Or_81;
      end if;

      Defer_Res_412 := Interface_Type_Def_Transform_Parse_4 (Parser, Pos);
      Defer_Pos_412 := Parser.Current_Pos;

      if Defer_Pos_412 /= No_Token_Index then
         Or_Pos_80 := Defer_Pos_412;
         Or_Res_80 := Defer_Res_412;
         goto Exit_Or_81;
      end if;

      Defer_Res_413 := Access_Def_Or_Parse_0 (Parser, Pos);
      Defer_Pos_413 := Parser.Current_Pos;

      if Defer_Pos_413 /= No_Token_Index then
         Or_Pos_80 := Defer_Pos_413;
         Or_Res_80 := Defer_Res_413;
         goto Exit_Or_81;
      end if;

      Defer_Res_414 :=
        Formal_Discrete_Type_Def_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_414 := Parser.Current_Pos;

      if Defer_Pos_414 /= No_Token_Index then
         Or_Pos_80 := Defer_Pos_414;
         Or_Res_80 := Defer_Res_414;
         goto Exit_Or_81;
      end if;

      Defer_Res_415 := Enum_Type_Def_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_415 := Parser.Current_Pos;

      if Defer_Pos_415 /= No_Token_Index then
         Or_Pos_80 := Defer_Pos_415;
         Or_Res_80 := Defer_Res_415;
         goto Exit_Or_81;
      end if;
      <<Exit_Or_81>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Type_Def_Or_Parse_0_Memo,
         Or_Pos_80 /= No_Token_Index, Or_Res_80, Pos, Or_Pos_80);

      Parser.Current_Pos := Or_Pos_80;

      return Or_Res_80;
   end Type_Def_Or_Parse_0;

   function Type_Decl_Or_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Base_Type_Decl
   is
      use Bare_Base_Type_Decl_Memos;

      Row_Pos_243       : Token_Index                      := No_Token_Index;
      Token_Pos_357     : Token_Index                      := No_Token_Index;
      Token_Res_357     : Token_Index                      := No_Token_Index;
      Defer_Pos_393     : Token_Index                      := No_Token_Index;
      Defer_Res_393     : Bare_Defining_Name               := No_Bare_Ada_Node;
      Defer_Pos_394     : Token_Index                      := No_Token_Index;
      Defer_Res_394     : Bare_Discriminant_Part           := No_Bare_Ada_Node;
      Token_Pos_358     : Token_Index                      := No_Token_Index;
      Token_Res_358     : Token_Index                      := No_Token_Index;
      Defer_Pos_395     : Token_Index                      := No_Token_Index;
      Defer_Res_395     : Bare_Type_Def                    := No_Bare_Ada_Node;
      Row_Pos_244       : Token_Index                      := No_Token_Index;
      Token_Pos_359     : Token_Index                      := No_Token_Index;
      Token_Res_359     : Token_Index                      := No_Token_Index;
      Opt_Res_15        : Bare_Abstract_Node               := No_Bare_Ada_Node;
      Token_Pos_360     : Token_Index                      := No_Token_Index;
      Token_Res_360     : Token_Index                      := No_Token_Index;
      Opt_Res_16        : Bare_Tagged_Node                 := No_Bare_Ada_Node;
      Token_Pos_361     : Token_Index                      := No_Token_Index;
      Token_Res_361     : Token_Index                      := No_Token_Index;
      Opt_Res_17        : Bare_Limited_Node                := No_Bare_Ada_Node;
      Token_Pos_362     : Token_Index                      := No_Token_Index;
      Token_Res_362     : Token_Index                      := No_Token_Index;
      Transform_Res_197 : Bare_Private_Type_Def            := No_Bare_Ada_Node;
      Or_Pos_77         : Token_Index                      := No_Token_Index;
      Or_Res_77         : Bare_Type_Def                    := No_Bare_Ada_Node;
      Defer_Pos_396     : Token_Index                      := No_Token_Index;
      Defer_Res_396     : Bare_Aspect_Spec                 := No_Bare_Ada_Node;
      Token_Pos_363     : Token_Index                      := No_Token_Index;
      Token_Res_363     : Token_Index                      := No_Token_Index;
      Transform_Res_198 : Bare_Type_Decl                   := No_Bare_Ada_Node;
      Row_Pos_245       : Token_Index                      := No_Token_Index;
      Token_Pos_364     : Token_Index                      := No_Token_Index;
      Token_Res_364     : Token_Index                      := No_Token_Index;
      Defer_Pos_397     : Token_Index                      := No_Token_Index;
      Defer_Res_397     : Bare_Defining_Name               := No_Bare_Ada_Node;
      Defer_Pos_398     : Token_Index                      := No_Token_Index;
      Defer_Res_398     : Bare_Discriminant_Part           := No_Bare_Ada_Node;
      Token_Pos_365     : Token_Index                      := No_Token_Index;
      Token_Res_365     : Token_Index                      := No_Token_Index;
      Token_Pos_366     : Token_Index                      := No_Token_Index;
      Token_Res_366     : Token_Index                      := No_Token_Index;
      Opt_Res_18        : Bare_Abstract_Node               := No_Bare_Ada_Node;
      Token_Pos_367     : Token_Index                      := No_Token_Index;
      Token_Res_367     : Token_Index                      := No_Token_Index;
      Token_Pos_368     : Token_Index                      := No_Token_Index;
      Token_Res_368     : Token_Index                      := No_Token_Index;
      Transform_Res_199 : Bare_Incomplete_Tagged_Type_Decl := No_Bare_Ada_Node;
      Row_Pos_246       : Token_Index                      := No_Token_Index;
      Token_Pos_369     : Token_Index                      := No_Token_Index;
      Token_Res_369     : Token_Index                      := No_Token_Index;
      Defer_Pos_399     : Token_Index                      := No_Token_Index;
      Defer_Res_399     : Bare_Defining_Name               := No_Bare_Ada_Node;
      Defer_Pos_400     : Token_Index                      := No_Token_Index;
      Defer_Res_400     : Bare_Discriminant_Part           := No_Bare_Ada_Node;
      Token_Pos_370     : Token_Index                      := No_Token_Index;
      Token_Res_370     : Token_Index                      := No_Token_Index;
      Transform_Res_200 : Bare_Incomplete_Type_Decl        := No_Bare_Ada_Node;
      Or_Pos_78         : Token_Index                      := No_Token_Index;
      Or_Res_78         : Bare_Base_Type_Decl              := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Type_Decl_Or_Parse_1_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_78          := M.Instance;
         return Or_Res_78;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_78;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_78 := No_Token_Index;
      Or_Res_78 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_243 := Pos;

--  Start tok_code

      Token_Res_357 := Row_Pos_243;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_357));
      begin
         if T.Kind /= From_Token_Kind (Ada_Type) then
            Token_Pos_357 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_243 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_243,
                  Expected_Token_Id => Ada_Type,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_357 := Row_Pos_243 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_357 /= No_Token_Index then

         Row_Pos_243 := Token_Pos_357;

      else
         Row_Pos_243 := No_Token_Index;
         goto Exit_Row_242_0;

      end if;

      Defer_Res_393 := Defining_Id_Transform_Parse_0 (Parser, Row_Pos_243);
      Defer_Pos_393 := Parser.Current_Pos;

      if Defer_Pos_393 /= No_Token_Index then

         Row_Pos_243 := Defer_Pos_393;

      else
         Row_Pos_243 := No_Token_Index;
         goto Exit_Row_242_0;

      end if;

--  Start opt_code

      Defer_Res_394 := Discriminant_Part_Or_Parse_0 (Parser, Row_Pos_243);
      Defer_Pos_394 := Parser.Current_Pos;

      if Defer_Pos_394 = No_Token_Index then

         Defer_Res_394 := No_Bare_Ada_Node;

         Defer_Pos_394 := Row_Pos_243;

      end if;

--  End opt_code

      if Defer_Pos_394 /= No_Token_Index then

         Row_Pos_243 := Defer_Pos_394;

      else
         Row_Pos_243 := No_Token_Index;
         goto Exit_Row_242_0;

      end if;

--  Start tok_code

      Token_Res_358 := Row_Pos_243;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_358));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_358 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_243 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_243,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_358 := Row_Pos_243 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_358 /= No_Token_Index then

         Row_Pos_243 := Token_Pos_358;

      else
         Row_Pos_243 := No_Token_Index;
         goto Exit_Row_242_0;

      end if;

--  Start or_code

      Or_Pos_77 := No_Token_Index;
      Or_Res_77 := No_Bare_Ada_Node;

      Defer_Res_395 := Type_Def_Or_Parse_0 (Parser, Row_Pos_243);
      Defer_Pos_395 := Parser.Current_Pos;

      if Defer_Pos_395 /= No_Token_Index then
         Or_Pos_77 := Defer_Pos_395;
         Or_Res_77 := Defer_Res_395;
         goto Exit_Or_80;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_244 := Row_Pos_243;

--  Start opt_code

--  Start tok_code

      Token_Res_359 := Row_Pos_244;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_359));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol
               (Parser.TDH.Symbols, Precomputed_Symbol_Abstract)
         then
            Token_Pos_359 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_244 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_244,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_359 := Row_Pos_244 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_359 = No_Token_Index then

         Opt_Res_15 := Allocate_Abstract_Absent (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_15, Kind => Ada_Abstract_Absent,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_244,
            Token_End_Index => No_Token_Index);

         Token_Pos_359 := Row_Pos_244;

      else

         Opt_Res_15 := Allocate_Abstract_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_15, Kind => Ada_Abstract_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_244,
            Token_End_Index => Token_Pos_359 - 1);

      end if;

--  End opt_code

      if Token_Pos_359 /= No_Token_Index then

         Row_Pos_244 := Token_Pos_359;

      else
         Row_Pos_244 := No_Token_Index;
         goto Exit_Row_281_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_360 := Row_Pos_244;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_360));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol (Parser.TDH.Symbols, Precomputed_Symbol_Tagged)
         then
            Token_Pos_360 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_244 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_244,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_360 := Row_Pos_244 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_360 = No_Token_Index then

         Opt_Res_16 := Allocate_Tagged_Absent (Parser.Mem_Pool);
         Initialize
           (Self => Opt_Res_16, Kind => Ada_Tagged_Absent, Unit => Parser.Unit,
            Token_Start_Index => Row_Pos_244,
            Token_End_Index   => No_Token_Index);

         Token_Pos_360 := Row_Pos_244;

      else

         Opt_Res_16 := Allocate_Tagged_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_16, Kind => Ada_Tagged_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_244,
            Token_End_Index => Token_Pos_360 - 1);

      end if;

--  End opt_code

      if Token_Pos_360 /= No_Token_Index then

         Row_Pos_244 := Token_Pos_360;

      else
         Row_Pos_244 := No_Token_Index;
         goto Exit_Row_281_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_361 := Row_Pos_244;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_361));
      begin
         if T.Kind /= From_Token_Kind (Ada_Limited) then
            Token_Pos_361 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_244 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_244,
                  Expected_Token_Id => Ada_Limited,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_361 := Row_Pos_244 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_361 = No_Token_Index then

         Opt_Res_17 := Allocate_Limited_Absent (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_17, Kind => Ada_Limited_Absent,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_244,
            Token_End_Index => No_Token_Index);

         Token_Pos_361 := Row_Pos_244;

      else

         Opt_Res_17 := Allocate_Limited_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_17, Kind => Ada_Limited_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_244,
            Token_End_Index => Token_Pos_361 - 1);

      end if;

--  End opt_code

      if Token_Pos_361 /= No_Token_Index then

         Row_Pos_244 := Token_Pos_361;

      else
         Row_Pos_244 := No_Token_Index;
         goto Exit_Row_281_0;

      end if;

--  Start tok_code

      Token_Res_362 := Row_Pos_244;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_362));
      begin
         if T.Kind /= From_Token_Kind (Ada_Private) then
            Token_Pos_362 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_244 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_244,
                  Expected_Token_Id => Ada_Private,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_362 := Row_Pos_244 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_362 /= No_Token_Index then

         Row_Pos_244 := Token_Pos_362;

      else
         Row_Pos_244 := No_Token_Index;
         goto Exit_Row_281_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_281_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_244 /= No_Token_Index then

         Transform_Res_197 := Allocate_Private_Type_Def (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_197, Kind => Ada_Private_Type_Def,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_243,
            Token_End_Index =>
              (if Row_Pos_244 = Row_Pos_243 then No_Token_Index
               else Row_Pos_244 - 1));

         Initialize_Fields_For_Private_Type_Def
           (Self                            => Transform_Res_197,
            Private_Type_Def_F_Has_Abstract => Opt_Res_15,
            Private_Type_Def_F_Has_Tagged   => Opt_Res_16,
            Private_Type_Def_F_Has_Limited  => Opt_Res_17);

         if Opt_Res_15 /= null and then Is_Incomplete (Opt_Res_15) then
            Transform_Res_197.Last_Attempted_Child := 0;
         elsif Opt_Res_15 /= null and then not Is_Ghost (Opt_Res_15) then
            Transform_Res_197.Last_Attempted_Child := -1;
         end if;
         if Opt_Res_16 /= null and then Is_Incomplete (Opt_Res_16) then
            Transform_Res_197.Last_Attempted_Child := 0;
         elsif Opt_Res_16 /= null and then not Is_Ghost (Opt_Res_16) then
            Transform_Res_197.Last_Attempted_Child := -1;
         end if;
         if Opt_Res_17 /= null and then Is_Incomplete (Opt_Res_17) then
            Transform_Res_197.Last_Attempted_Child := 0;
         elsif Opt_Res_17 /= null and then not Is_Ghost (Opt_Res_17) then
            Transform_Res_197.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_244 /= No_Token_Index then
         Or_Pos_77 := Row_Pos_244;
         Or_Res_77 := Transform_Res_197;
         goto Exit_Or_80;
      end if;
      <<Exit_Or_80>>

--  End or_code

      if Or_Pos_77 /= No_Token_Index then

         Row_Pos_243 := Or_Pos_77;

      else
         Row_Pos_243 := No_Token_Index;
         goto Exit_Row_242_0;

      end if;

      Defer_Res_396 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_243);
      Defer_Pos_396 := Parser.Current_Pos;

      if Defer_Pos_396 /= No_Token_Index then

         Row_Pos_243 := Defer_Pos_396;

      else
         Row_Pos_243 := No_Token_Index;
         goto Exit_Row_242_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_363 := Row_Pos_243;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_363));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_363 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_243 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_243,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_363 := Row_Pos_243 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_363 = No_Token_Index then

         Token_Res_363 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_243).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_363 := Row_Pos_243;

      end if;

--  End opt_code

      if Token_Pos_363 /= No_Token_Index then

         Row_Pos_243 := Token_Pos_363;

      else
         Row_Pos_243 := No_Token_Index;
         goto Exit_Row_242_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_242_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_243 /= No_Token_Index then

         Transform_Res_198 := Allocate_Type_Decl (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_198, Kind => Ada_Type_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_243 = Pos then No_Token_Index else Row_Pos_243 - 1));

         Initialize_Fields_For_Type_Decl
           (Self => Transform_Res_198, Base_Type_Decl_F_Name => Defer_Res_393,
            Type_Decl_F_Discriminants => Defer_Res_394,
            Type_Decl_F_Type_Def      => Or_Res_77,
            Type_Decl_F_Aspects       => Defer_Res_396);

         if Defer_Res_393 /= null and then Is_Incomplete (Defer_Res_393) then
            Transform_Res_198.Last_Attempted_Child := 0;
         elsif Defer_Res_393 /= null and then not Is_Ghost (Defer_Res_393) then
            Transform_Res_198.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_394 /= null and then Is_Incomplete (Defer_Res_394) then
            Transform_Res_198.Last_Attempted_Child := 0;
         elsif Defer_Res_394 /= null and then not Is_Ghost (Defer_Res_394) then
            Transform_Res_198.Last_Attempted_Child := -1;
         end if;
         if Or_Res_77 /= null and then Is_Incomplete (Or_Res_77) then
            Transform_Res_198.Last_Attempted_Child := 0;
         elsif Or_Res_77 /= null and then not Is_Ghost (Or_Res_77) then
            Transform_Res_198.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_396 /= null and then Is_Incomplete (Defer_Res_396) then
            Transform_Res_198.Last_Attempted_Child := 0;
         elsif Defer_Res_396 /= null and then not Is_Ghost (Defer_Res_396) then
            Transform_Res_198.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_243 /= No_Token_Index then
         Or_Pos_78 := Row_Pos_243;
         Or_Res_78 := Transform_Res_198;
         goto Exit_Or_78;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_245 := Pos;

--  Start tok_code

      Token_Res_364 := Row_Pos_245;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_364));
      begin
         if T.Kind /= From_Token_Kind (Ada_Type) then
            Token_Pos_364 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_245 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_245,
                  Expected_Token_Id => Ada_Type,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_364 := Row_Pos_245 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_364 /= No_Token_Index then

         Row_Pos_245 := Token_Pos_364;

      else
         Row_Pos_245 := No_Token_Index;
         goto Exit_Row_282_0;

      end if;

      Defer_Res_397 := Defining_Id_Transform_Parse_0 (Parser, Row_Pos_245);
      Defer_Pos_397 := Parser.Current_Pos;

      if Defer_Pos_397 /= No_Token_Index then

         Row_Pos_245 := Defer_Pos_397;

      else
         Row_Pos_245 := No_Token_Index;
         goto Exit_Row_282_0;

      end if;

--  Start opt_code

      Defer_Res_398 := Discriminant_Part_Or_Parse_0 (Parser, Row_Pos_245);
      Defer_Pos_398 := Parser.Current_Pos;

      if Defer_Pos_398 = No_Token_Index then

         Defer_Res_398 := No_Bare_Ada_Node;

         Defer_Pos_398 := Row_Pos_245;

      end if;

--  End opt_code

      if Defer_Pos_398 /= No_Token_Index then

         Row_Pos_245 := Defer_Pos_398;

      else
         Row_Pos_245 := No_Token_Index;
         goto Exit_Row_282_0;

      end if;

--  Start tok_code

      Token_Res_365 := Row_Pos_245;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_365));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_365 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_245 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_245,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_365 := Row_Pos_245 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_365 /= No_Token_Index then

         Row_Pos_245 := Token_Pos_365;

      else
         Row_Pos_245 := No_Token_Index;
         goto Exit_Row_282_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_366 := Row_Pos_245;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_366));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol
               (Parser.TDH.Symbols, Precomputed_Symbol_Abstract)
         then
            Token_Pos_366 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_245 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_245,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_366 := Row_Pos_245 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_366 = No_Token_Index then

         Opt_Res_18 := Allocate_Abstract_Absent (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_18, Kind => Ada_Abstract_Absent,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_245,
            Token_End_Index => No_Token_Index);

         Token_Pos_366 := Row_Pos_245;

      else

         Opt_Res_18 := Allocate_Abstract_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_18, Kind => Ada_Abstract_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_245,
            Token_End_Index => Token_Pos_366 - 1);

      end if;

--  End opt_code

      if Token_Pos_366 /= No_Token_Index then

         Row_Pos_245 := Token_Pos_366;

      else
         Row_Pos_245 := No_Token_Index;
         goto Exit_Row_282_0;

      end if;

--  Start tok_code

      Token_Res_367 := Row_Pos_245;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_367));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol (Parser.TDH.Symbols, Precomputed_Symbol_Tagged)
         then
            Token_Pos_367 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_245 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_245,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_367 := Row_Pos_245 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_367 /= No_Token_Index then

         Row_Pos_245 := Token_Pos_367;

      else
         Row_Pos_245 := No_Token_Index;
         goto Exit_Row_282_0;

      end if;

--  Start tok_code

      Token_Res_368 := Row_Pos_245;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_368));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_368 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_245 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_245,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_368 := Row_Pos_245 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_368 /= No_Token_Index then

         Row_Pos_245 := Token_Pos_368;

      else
         Row_Pos_245 := No_Token_Index;
         goto Exit_Row_282_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_282_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_245 /= No_Token_Index then

         Transform_Res_199 :=
           Allocate_Incomplete_Tagged_Type_Decl (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_199, Kind => Ada_Incomplete_Tagged_Type_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_245 = Pos then No_Token_Index else Row_Pos_245 - 1));

         Initialize_Fields_For_Incomplete_Tagged_Type_Decl
           (Self => Transform_Res_199, Base_Type_Decl_F_Name => Defer_Res_397,
            Incomplete_Type_Decl_F_Discriminants       => Defer_Res_398,
            Incomplete_Tagged_Type_Decl_F_Has_Abstract => Opt_Res_18);

         if Defer_Res_397 /= null and then Is_Incomplete (Defer_Res_397) then
            Transform_Res_199.Last_Attempted_Child := 0;
         elsif Defer_Res_397 /= null and then not Is_Ghost (Defer_Res_397) then
            Transform_Res_199.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_398 /= null and then Is_Incomplete (Defer_Res_398) then
            Transform_Res_199.Last_Attempted_Child := 0;
         elsif Defer_Res_398 /= null and then not Is_Ghost (Defer_Res_398) then
            Transform_Res_199.Last_Attempted_Child := -1;
         end if;
         if Opt_Res_18 /= null and then Is_Incomplete (Opt_Res_18) then
            Transform_Res_199.Last_Attempted_Child := 0;
         elsif Opt_Res_18 /= null and then not Is_Ghost (Opt_Res_18) then
            Transform_Res_199.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_245 /= No_Token_Index then
         Or_Pos_78 := Row_Pos_245;
         Or_Res_78 := Transform_Res_199;
         goto Exit_Or_78;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_246 := Pos;

--  Start tok_code

      Token_Res_369 := Row_Pos_246;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_369));
      begin
         if T.Kind /= From_Token_Kind (Ada_Type) then
            Token_Pos_369 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_246 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_246,
                  Expected_Token_Id => Ada_Type,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_369 := Row_Pos_246 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_369 /= No_Token_Index then

         Row_Pos_246 := Token_Pos_369;

      else
         Row_Pos_246 := No_Token_Index;
         goto Exit_Row_283_0;

      end if;

      Defer_Res_399 := Defining_Id_Transform_Parse_0 (Parser, Row_Pos_246);
      Defer_Pos_399 := Parser.Current_Pos;

      if Defer_Pos_399 /= No_Token_Index then

         Row_Pos_246 := Defer_Pos_399;

      else
         Row_Pos_246 := No_Token_Index;
         goto Exit_Row_283_0;

      end if;

--  Start opt_code

      Defer_Res_400 := Discriminant_Part_Or_Parse_0 (Parser, Row_Pos_246);
      Defer_Pos_400 := Parser.Current_Pos;

      if Defer_Pos_400 = No_Token_Index then

         Defer_Res_400 := No_Bare_Ada_Node;

         Defer_Pos_400 := Row_Pos_246;

      end if;

--  End opt_code

      if Defer_Pos_400 /= No_Token_Index then

         Row_Pos_246 := Defer_Pos_400;

      else
         Row_Pos_246 := No_Token_Index;
         goto Exit_Row_283_0;

      end if;

--  Start tok_code

      Token_Res_370 := Row_Pos_246;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_370));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_370 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_246 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_246,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_370 := Row_Pos_246 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_370 /= No_Token_Index then

         Row_Pos_246 := Token_Pos_370;

      else
         Row_Pos_246 := No_Token_Index;
         goto Exit_Row_283_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_283_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_246 /= No_Token_Index then

         Transform_Res_200 := Allocate_Incomplete_Type_Decl (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_200, Kind => Ada_Incomplete_Type_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_246 = Pos then No_Token_Index else Row_Pos_246 - 1));

         Initialize_Fields_For_Incomplete_Type_Decl
           (Self => Transform_Res_200, Base_Type_Decl_F_Name => Defer_Res_399,
            Incomplete_Type_Decl_F_Discriminants => Defer_Res_400);

         if Defer_Res_399 /= null and then Is_Incomplete (Defer_Res_399) then
            Transform_Res_200.Last_Attempted_Child := 0;
         elsif Defer_Res_399 /= null and then not Is_Ghost (Defer_Res_399) then
            Transform_Res_200.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_400 /= null and then Is_Incomplete (Defer_Res_400) then
            Transform_Res_200.Last_Attempted_Child := 0;
         elsif Defer_Res_400 /= null and then not Is_Ghost (Defer_Res_400) then
            Transform_Res_200.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_246 /= No_Token_Index then
         Or_Pos_78 := Row_Pos_246;
         Or_Res_78 := Transform_Res_200;
         goto Exit_Or_78;
      end if;
      <<Exit_Or_78>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Type_Decl_Or_Parse_1_Memo,
         Or_Pos_78 /= No_Token_Index, Or_Res_78, Pos, Or_Pos_78);

      Parser.Current_Pos := Or_Pos_78;

      return Or_Res_78;
   end Type_Decl_Or_Parse_1;

   function Constrained_Subtype_Indication_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Constrained_Subtype_Indication
   is
      use Bare_Constrained_Subtype_Indication_Memos;

      Row_Pos_296       : Token_Index := No_Token_Index;
      Row_Pos_297       : Token_Index := No_Token_Index;
      Token_Pos_458     : Token_Index := No_Token_Index;
      Token_Res_458     : Token_Index := No_Token_Index;
      Token_Pos_459     : Token_Index := No_Token_Index;
      Token_Res_459     : Token_Index := No_Token_Index;
      Opt_Res_26        : Bare_Not_Null := No_Bare_Ada_Node;
      Defer_Pos_479     : Token_Index := No_Token_Index;
      Defer_Res_479     : Bare_Name := No_Bare_Ada_Node;
      Defer_Pos_480     : Token_Index := No_Token_Index;
      Defer_Res_480     : Bare_Constraint := No_Bare_Ada_Node;
      Transform_Res_239 : Bare_Constrained_Subtype_Indication :=
        No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part
             .Constrained_Subtype_Indication_Transform_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_239  := M.Instance;
         return Transform_Res_239;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_239;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_296 := Pos;

--  Start opt_code

--  Start row_code

      Row_Pos_297 := Row_Pos_296;

--  Start tok_code

      Token_Res_458 := Row_Pos_297;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_458));
      begin
         if T.Kind /= From_Token_Kind (Ada_Not) then
            Token_Pos_458 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_297 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_297,
                  Expected_Token_Id => Ada_Not,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_458 := Row_Pos_297 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_458 /= No_Token_Index then

         Row_Pos_297 := Token_Pos_458;

      else
         Row_Pos_297 := No_Token_Index;
         goto Exit_Row_292_0;

      end if;

--  Start tok_code

      Token_Res_459 := Row_Pos_297;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_459));
      begin
         if T.Kind /= From_Token_Kind (Ada_Null) then
            Token_Pos_459 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_297 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_297,
                  Expected_Token_Id => Ada_Null,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_459 := Row_Pos_297 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_459 /= No_Token_Index then

         Row_Pos_297 := Token_Pos_459;

      else
         Row_Pos_297 := No_Token_Index;
         goto Exit_Row_292_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_292_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_297 = No_Token_Index then

         Opt_Res_26 := Allocate_Not_Null_Absent (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_26, Kind => Ada_Not_Null_Absent,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_296,
            Token_End_Index => No_Token_Index);

         Row_Pos_297 := Row_Pos_296;

      else

         Opt_Res_26 := Allocate_Not_Null_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_26, Kind => Ada_Not_Null_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_296,
            Token_End_Index => Row_Pos_297 - 1);

      end if;

--  End opt_code

      if Row_Pos_297 /= No_Token_Index then

         Row_Pos_296 := Row_Pos_297;

      else
         Row_Pos_296 := No_Token_Index;
         goto Exit_Row_291_0;

      end if;

      Defer_Res_479 := Subtype_Name_Or_Parse_0 (Parser, Row_Pos_296);
      Defer_Pos_479 := Parser.Current_Pos;

      if Defer_Pos_479 /= No_Token_Index then

         Row_Pos_296 := Defer_Pos_479;

      else
         Row_Pos_296 := No_Token_Index;
         goto Exit_Row_291_0;

      end if;

      Defer_Res_480 := Constraint_Or_Parse_0 (Parser, Row_Pos_296);
      Defer_Pos_480 := Parser.Current_Pos;

      if Defer_Pos_480 /= No_Token_Index then

         Row_Pos_296 := Defer_Pos_480;

      else
         Row_Pos_296 := No_Token_Index;
         goto Exit_Row_291_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_291_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_296 /= No_Token_Index then

         Transform_Res_239 :=
           Allocate_Constrained_Subtype_Indication (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_239,
            Kind => Ada_Constrained_Subtype_Indication, Unit => Parser.Unit,

            Token_Start_Index => Pos,
            Token_End_Index   =>
              (if Row_Pos_296 = Pos then No_Token_Index else Row_Pos_296 - 1));

         Initialize_Fields_For_Constrained_Subtype_Indication
           (Self                              => Transform_Res_239,
            Subtype_Indication_F_Has_Not_Null => Opt_Res_26,
            Subtype_Indication_F_Name         => Defer_Res_479,
            Subtype_Indication_F_Constraint   => Defer_Res_480);

         if Opt_Res_26 /= null and then Is_Incomplete (Opt_Res_26) then
            Transform_Res_239.Last_Attempted_Child := 0;
         elsif Opt_Res_26 /= null and then not Is_Ghost (Opt_Res_26) then
            Transform_Res_239.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_479 /= null and then Is_Incomplete (Defer_Res_479) then
            Transform_Res_239.Last_Attempted_Child := 0;
         elsif Defer_Res_479 /= null and then not Is_Ghost (Defer_Res_479) then
            Transform_Res_239.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_480 /= null and then Is_Incomplete (Defer_Res_480) then
            Transform_Res_239.Last_Attempted_Child := 0;
         elsif Defer_Res_480 /= null and then not Is_Ghost (Defer_Res_480) then
            Transform_Res_239.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part
           .Constrained_Subtype_Indication_Transform_Parse_0_Memo,
         Row_Pos_296 /= No_Token_Index, Transform_Res_239, Pos, Row_Pos_296);

      Parser.Current_Pos := Row_Pos_296;

      return Transform_Res_239;
   end Constrained_Subtype_Indication_Transform_Parse_0;

   function Entry_Decl_Transform_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Entry_Decl
   is
      use Bare_Entry_Decl_Memos;

      Row_Pos_293       : Token_Index := No_Token_Index;
      Defer_Pos_472     : Token_Index := No_Token_Index;
      Defer_Res_472     : Bare_Overriding_Node := No_Bare_Ada_Node;
      Row_Pos_294       : Token_Index := No_Token_Index;
      Token_Pos_454     : Token_Index := No_Token_Index;
      Token_Res_454     : Token_Index := No_Token_Index;
      Defer_Pos_473     : Token_Index := No_Token_Index;
      Defer_Res_473     : Bare_Defining_Name := No_Bare_Ada_Node;
      Row_Pos_295       : Token_Index := No_Token_Index;
      Token_Pos_455     : Token_Index := No_Token_Index;
      Token_Res_455     : Token_Index := No_Token_Index;
      Defer_Pos_474     : Token_Index := No_Token_Index;
      Defer_Res_474 : Bare_Constrained_Subtype_Indication := No_Bare_Ada_Node;
      Defer_Pos_475     : Token_Index := No_Token_Index;
      Defer_Res_475     : Bare_Expr := No_Bare_Ada_Node;
      Defer_Pos_476     : Token_Index := No_Token_Index;
      Defer_Res_476     : Bare_Subtype_Indication := No_Bare_Ada_Node;
      Or_Pos_89         : Token_Index := No_Token_Index;
      Or_Res_89         : Bare_Ada_Node := No_Bare_Ada_Node;
      Token_Pos_456     : Token_Index := No_Token_Index;
      Token_Res_456     : Token_Index := No_Token_Index;
      Defer_Pos_477     : Token_Index := No_Token_Index;
      Defer_Res_477     : Bare_Params := No_Bare_Ada_Node;
      Transform_Res_237 : Bare_Entry_Spec := No_Bare_Ada_Node;
      Defer_Pos_478     : Token_Index := No_Token_Index;
      Defer_Res_478     : Bare_Aspect_Spec := No_Bare_Ada_Node;
      Token_Pos_457     : Token_Index := No_Token_Index;
      Token_Res_457     : Token_Index := No_Token_Index;
      Transform_Res_238 : Bare_Entry_Decl := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Entry_Decl_Transform_Parse_1_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_238  := M.Instance;
         return Transform_Res_238;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_238;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_293 := Pos;

      Defer_Res_472 := Overriding_Indicator_Or_Parse_0 (Parser, Row_Pos_293);
      Defer_Pos_472 := Parser.Current_Pos;

      if Defer_Pos_472 /= No_Token_Index then

         Row_Pos_293 := Defer_Pos_472;

      else
         Row_Pos_293 := No_Token_Index;
         goto Exit_Row_288_0;

      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_294 := Row_Pos_293;

--  Start tok_code

      Token_Res_454 := Row_Pos_294;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_454));
      begin
         if T.Kind /= From_Token_Kind (Ada_Entry) then
            Token_Pos_454 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_294 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_294,
                  Expected_Token_Id => Ada_Entry,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_454 := Row_Pos_294 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_454 /= No_Token_Index then

         Row_Pos_294 := Token_Pos_454;

      else
         Row_Pos_294 := No_Token_Index;
         goto Exit_Row_289_0;

      end if;

      Defer_Res_473 := Defining_Id_Transform_Parse_0 (Parser, Row_Pos_294);
      Defer_Pos_473 := Parser.Current_Pos;

      if Defer_Pos_473 /= No_Token_Index then

         Row_Pos_294 := Defer_Pos_473;

      else
         Row_Pos_294 := No_Token_Index;
         goto Exit_Row_289_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_295 := Row_Pos_294;

--  Start tok_code

      Token_Res_455 := Row_Pos_295;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_455));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Open) then
            Token_Pos_455 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_295 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_295,
                  Expected_Token_Id => Ada_Par_Open,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_455 := Row_Pos_295 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_455 /= No_Token_Index then

         Row_Pos_295 := Token_Pos_455;

      else
         Row_Pos_295 := No_Token_Index;
         goto Exit_Row_290_0;

      end if;

--  Start or_code

      Or_Pos_89 := No_Token_Index;
      Or_Res_89 := No_Bare_Ada_Node;

      Defer_Res_474 :=
        Constrained_Subtype_Indication_Transform_Parse_0 (Parser, Row_Pos_295);
      Defer_Pos_474 := Parser.Current_Pos;

      if Defer_Pos_474 /= No_Token_Index then
         Or_Pos_89 := Defer_Pos_474;
         Or_Res_89 := Defer_Res_474;
         goto Exit_Or_90;
      end if;

      Defer_Res_475 := Discrete_Range_Or_Parse_0 (Parser, Row_Pos_295);
      Defer_Pos_475 := Parser.Current_Pos;

      if Defer_Pos_475 /= No_Token_Index then
         Or_Pos_89 := Defer_Pos_475;
         Or_Res_89 := Defer_Res_475;
         goto Exit_Or_90;
      end if;

      Defer_Res_476 :=
        Subtype_Indication_Transform_Parse_0 (Parser, Row_Pos_295);
      Defer_Pos_476 := Parser.Current_Pos;

      if Defer_Pos_476 /= No_Token_Index then
         Or_Pos_89 := Defer_Pos_476;
         Or_Res_89 := Defer_Res_476;
         goto Exit_Or_90;
      end if;
      <<Exit_Or_90>>

--  End or_code

      if Or_Pos_89 /= No_Token_Index then

         Row_Pos_295 := Or_Pos_89;

      else
         Row_Pos_295 := No_Token_Index;
         goto Exit_Row_290_0;

      end if;

--  Start tok_code

      Token_Res_456 := Row_Pos_295;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_456));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Close) then
            Token_Pos_456 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_295 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_295,
                  Expected_Token_Id => Ada_Par_Close,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_456 := Row_Pos_295 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_456 /= No_Token_Index then

         Row_Pos_295 := Token_Pos_456;

      else
         Row_Pos_295 := No_Token_Index;
         goto Exit_Row_290_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_290_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_295 = No_Token_Index then

         Or_Res_89 := No_Bare_Ada_Node;

         Row_Pos_295 := Row_Pos_294;

      end if;

--  End opt_code

      if Row_Pos_295 /= No_Token_Index then

         Row_Pos_294 := Row_Pos_295;

      else
         Row_Pos_294 := No_Token_Index;
         goto Exit_Row_289_0;

      end if;

--  Start opt_code

      Defer_Res_477 := Param_Specs_Transform_Parse_0 (Parser, Row_Pos_294);
      Defer_Pos_477 := Parser.Current_Pos;

      if Defer_Pos_477 = No_Token_Index then

         Defer_Res_477 := No_Bare_Ada_Node;

         Defer_Pos_477 := Row_Pos_294;

      end if;

--  End opt_code

      if Defer_Pos_477 /= No_Token_Index then

         Row_Pos_294 := Defer_Pos_477;

      else
         Row_Pos_294 := No_Token_Index;
         goto Exit_Row_289_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_289_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_294 /= No_Token_Index then

         Transform_Res_237 := Allocate_Entry_Spec (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_237, Kind => Ada_Entry_Spec,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_293,
            Token_End_Index =>
              (if Row_Pos_294 = Row_Pos_293 then No_Token_Index
               else Row_Pos_294 - 1));

         Initialize_Fields_For_Entry_Spec
           (Self                      => Transform_Res_237,
            Entry_Spec_F_Entry_Name   => Defer_Res_473,
            Entry_Spec_F_Family_Type  => Or_Res_89,
            Entry_Spec_F_Entry_Params => Defer_Res_477);

         if Defer_Res_473 /= null and then Is_Incomplete (Defer_Res_473) then
            Transform_Res_237.Last_Attempted_Child := 0;
         elsif Defer_Res_473 /= null and then not Is_Ghost (Defer_Res_473) then
            Transform_Res_237.Last_Attempted_Child := -1;
         end if;
         if Or_Res_89 /= null and then Is_Incomplete (Or_Res_89) then
            Transform_Res_237.Last_Attempted_Child := 0;
         elsif Or_Res_89 /= null and then not Is_Ghost (Or_Res_89) then
            Transform_Res_237.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_477 /= null and then Is_Incomplete (Defer_Res_477) then
            Transform_Res_237.Last_Attempted_Child := 0;
         elsif Defer_Res_477 /= null and then not Is_Ghost (Defer_Res_477) then
            Transform_Res_237.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_294 /= No_Token_Index then

         Row_Pos_293 := Row_Pos_294;

      else
         Row_Pos_293 := No_Token_Index;
         goto Exit_Row_288_0;

      end if;

      Defer_Res_478 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_293);
      Defer_Pos_478 := Parser.Current_Pos;

      if Defer_Pos_478 /= No_Token_Index then

         Row_Pos_293 := Defer_Pos_478;

      else
         Row_Pos_293 := No_Token_Index;
         goto Exit_Row_288_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_457 := Row_Pos_293;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_457));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_457 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_293 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_293,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_457 := Row_Pos_293 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_457 = No_Token_Index then

         Token_Res_457 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_293).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_457 := Row_Pos_293;

      end if;

--  End opt_code

      if Token_Pos_457 /= No_Token_Index then

         Row_Pos_293 := Token_Pos_457;

      else
         Row_Pos_293 := No_Token_Index;
         goto Exit_Row_288_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_288_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_293 /= No_Token_Index then

         Transform_Res_238 := Allocate_Entry_Decl (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_238, Kind => Ada_Entry_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_293 = Pos then No_Token_Index else Row_Pos_293 - 1));

         Initialize_Fields_For_Entry_Decl
           (Self                    => Transform_Res_238,
            Entry_Decl_F_Overriding => Defer_Res_472,
            Entry_Decl_F_Spec       => Transform_Res_237,
            Entry_Decl_F_Aspects    => Defer_Res_478);

         if Defer_Res_472 /= null and then Is_Incomplete (Defer_Res_472) then
            Transform_Res_238.Last_Attempted_Child := 0;
         elsif Defer_Res_472 /= null and then not Is_Ghost (Defer_Res_472) then
            Transform_Res_238.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_237 /= null
           and then Is_Incomplete (Transform_Res_237)
         then
            Transform_Res_238.Last_Attempted_Child := 0;
         elsif Transform_Res_237 /= null
           and then not Is_Ghost (Transform_Res_237)
         then
            Transform_Res_238.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_478 /= null and then Is_Incomplete (Defer_Res_478) then
            Transform_Res_238.Last_Attempted_Child := 0;
         elsif Defer_Res_478 /= null and then not Is_Ghost (Defer_Res_478) then
            Transform_Res_238.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Entry_Decl_Transform_Parse_1_Memo,
         Row_Pos_293 /= No_Token_Index, Transform_Res_238, Pos, Row_Pos_293);

      Parser.Current_Pos := Row_Pos_293;

      return Transform_Res_238;
   end Entry_Decl_Transform_Parse_1;

   function Task_Item_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Defer_Pos_469 : Token_Index        := No_Token_Index;
      Defer_Res_469 : Bare_Entry_Decl    := No_Bare_Ada_Node;
      Defer_Pos_470 : Token_Index        := No_Token_Index;
      Defer_Res_470 : Bare_Aspect_Clause := No_Bare_Ada_Node;
      Defer_Pos_471 : Token_Index        := No_Token_Index;
      Defer_Res_471 : Bare_Pragma_Node   := No_Bare_Ada_Node;
      Or_Pos_88     : Token_Index        := No_Token_Index;
      Or_Res_88     : Bare_Ada_Node      := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Task_Item_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_88          := M.Instance;
         return Or_Res_88;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_88;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_88 := No_Token_Index;
      Or_Res_88 := No_Bare_Ada_Node;

      Defer_Res_469 := Entry_Decl_Transform_Parse_1 (Parser, Pos);
      Defer_Pos_469 := Parser.Current_Pos;

      if Defer_Pos_469 /= No_Token_Index then
         Or_Pos_88 := Defer_Pos_469;
         Or_Res_88 := Defer_Res_469;
         goto Exit_Or_89;
      end if;

      Defer_Res_470 := Aspect_Clause_Or_Parse_1 (Parser, Pos);
      Defer_Pos_470 := Parser.Current_Pos;

      if Defer_Pos_470 /= No_Token_Index then
         Or_Pos_88 := Defer_Pos_470;
         Or_Res_88 := Defer_Res_470;
         goto Exit_Or_89;
      end if;

      Defer_Res_471 := Pragma_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_471 := Parser.Current_Pos;

      if Defer_Pos_471 /= No_Token_Index then
         Or_Pos_88 := Defer_Pos_471;
         Or_Res_88 := Defer_Res_471;
         goto Exit_Or_89;
      end if;
      <<Exit_Or_89>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Task_Item_Or_Parse_0_Memo,
         Or_Pos_88 /= No_Token_Index, Or_Res_88, Pos, Or_Pos_88);

      Parser.Current_Pos := Or_Pos_88;

      return Or_Res_88;
   end Task_Item_Or_Parse_0;

   function Task_Def_Transform_Parse_3
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Task_Def
   is
      use Bare_Task_Def_Memos;

      Row_Pos_286       : Token_Index       := No_Token_Index;
      Token_Pos_449     : Token_Index       := No_Token_Index;
      Token_Res_449     : Token_Index       := No_Token_Index;
      Row_Pos_287       : Token_Index       := No_Token_Index;
      Token_Pos_450     : Token_Index       := No_Token_Index;
      Token_Res_450     : Token_Index       := No_Token_Index;
      Defer_Pos_465     : Token_Index       := No_Token_Index;
      Defer_Res_465     : Bare_Parent_List  := No_Bare_Ada_Node;
      Token_Pos_451     : Token_Index       := No_Token_Index;
      Token_Res_451     : Token_Index       := No_Token_Index;
      Row_Pos_288       : Token_Index       := No_Token_Index;
      Lst_Cpos_36       : Token_Index       := No_Token_Index;
      Tmp_List_36       : Free_Parse_List;
      Defer_Pos_466     : Token_Index       := No_Token_Index;
      Defer_Res_466     : Bare_Ada_Node     := No_Bare_Ada_Node;
      List_Pos_36       : Token_Index       := No_Token_Index;
      List_Res_36       : Bare_Decl_List    := No_Bare_Ada_Node;
      Transform_Res_233 : Bare_Public_Part  := No_Bare_Ada_Node;
      Row_Pos_289       : Token_Index       := No_Token_Index;
      Token_Pos_452     : Token_Index       := No_Token_Index;
      Token_Res_452     : Token_Index       := No_Token_Index;
      Row_Pos_290       : Token_Index       := No_Token_Index;
      Lst_Cpos_37       : Token_Index       := No_Token_Index;
      Tmp_List_37       : Free_Parse_List;
      Defer_Pos_467     : Token_Index       := No_Token_Index;
      Defer_Res_467     : Bare_Ada_Node     := No_Bare_Ada_Node;
      List_Pos_37       : Token_Index       := No_Token_Index;
      List_Res_37       : Bare_Decl_List    := No_Bare_Ada_Node;
      Transform_Res_234 : Bare_Private_Part := No_Bare_Ada_Node;
      Row_Pos_291       : Token_Index       := No_Token_Index;
      Token_Pos_453     : Token_Index       := No_Token_Index;
      Token_Res_453     : Token_Index       := No_Token_Index;
      Row_Pos_292       : Token_Index       := No_Token_Index;
      Defer_Pos_468     : Token_Index       := No_Token_Index;
      Defer_Res_468     : Bare_Identifier   := No_Bare_Ada_Node;
      Transform_Res_235 : Bare_End_Name     := No_Bare_Ada_Node;
      Transform_Res_236 : Bare_Task_Def     := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Task_Def_Transform_Parse_3_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_236  := M.Instance;
         return Transform_Res_236;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_236;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_286 := Pos;

--  Start tok_code

      Token_Res_449 := Row_Pos_286;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_449));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_449 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_286 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_286,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_449 := Row_Pos_286 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_449 /= No_Token_Index then

         Row_Pos_286 := Token_Pos_449;

      else
         Row_Pos_286 := No_Token_Index;
         goto Exit_Row_285_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_287 := Row_Pos_286;

--  Start tok_code

      Token_Res_450 := Row_Pos_287;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_450));
      begin
         if T.Kind /= From_Token_Kind (Ada_New) then
            Token_Pos_450 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_287 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_287,
                  Expected_Token_Id => Ada_New,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_450 := Row_Pos_287 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_450 /= No_Token_Index then

         Row_Pos_287 := Token_Pos_450;

      else
         Row_Pos_287 := No_Token_Index;
         goto Exit_Row_286_0;

      end if;

      Defer_Res_465 := Parent_List_List_Parse_0 (Parser, Row_Pos_287);
      Defer_Pos_465 := Parser.Current_Pos;

      if Defer_Pos_465 /= No_Token_Index then

         Row_Pos_287 := Defer_Pos_465;

      else
         Row_Pos_287 := No_Token_Index;
         goto Exit_Row_286_0;

      end if;

--  Start tok_code

      Token_Res_451 := Row_Pos_287;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_451));
      begin
         if T.Kind /= From_Token_Kind (Ada_With) then
            Token_Pos_451 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_287 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_287,
                  Expected_Token_Id => Ada_With,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_451 := Row_Pos_287 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_451 /= No_Token_Index then

         Row_Pos_287 := Token_Pos_451;

      else
         Row_Pos_287 := No_Token_Index;
         goto Exit_Row_286_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_286_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_287 = No_Token_Index then

         Defer_Res_465 := Allocate_Parent_List (Parser.Mem_Pool);
         Initialize
           (Self            => Defer_Res_465, Kind => Ada_Parent_List,
            Unit => Parser.Unit, Token_Start_Index => Row_Pos_286 - 1,
            Token_End_Index => No_Token_Index);
         Initialize_List (Self => Defer_Res_465, Parser => Parser, Count => 0);

         Row_Pos_287 := Row_Pos_286;

      end if;

--  End opt_code

      if Row_Pos_287 /= No_Token_Index then

         Row_Pos_286 := Row_Pos_287;

      else
         Row_Pos_286 := No_Token_Index;
         goto Exit_Row_285_0;

      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_288 := Row_Pos_286;

--  Start list_code

      List_Pos_36 := Row_Pos_288;

      Lst_Cpos_36 := Row_Pos_288;
      Tmp_List_36 := Get_Parse_List (Parser);

      loop

         Defer_Res_466 := Task_Item_Or_Parse_0 (Parser, Lst_Cpos_36);
         Defer_Pos_466 := Parser.Current_Pos;

         exit when Defer_Pos_466 = No_Token_Index;

         List_Pos_36 := Defer_Pos_466;
         Lst_Cpos_36 := List_Pos_36;

         Tmp_List_36.Nodes.Append (Defer_Res_466);

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_36.Nodes.Length;
      begin
         List_Res_36 := Allocate_Decl_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_288;
            Token_End   :=
              (if Lst_Cpos_36 = Row_Pos_288 then Row_Pos_288
               else Lst_Cpos_36 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_288, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self => List_Res_36, Kind => Ada_Decl_List, Unit => Parser.Unit,
            Token_Start_Index => Token_Start, Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_36, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_36.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_36.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_36);

--  End list_code

      if List_Pos_36 /= No_Token_Index then

         Row_Pos_288 := List_Pos_36;

      else
         Row_Pos_288 := No_Token_Index;
         goto Exit_Row_287_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_287_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_288 /= No_Token_Index then

         Transform_Res_233 := Allocate_Public_Part (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_233, Kind => Ada_Public_Part,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_286,
            Token_End_Index =>
              (if Row_Pos_288 = Row_Pos_286 then No_Token_Index
               else Row_Pos_288 - 1));

         Initialize_Fields_For_Public_Part
           (Self                     => Transform_Res_233,
            Declarative_Part_F_Decls => List_Res_36);

         if List_Res_36 /= null and then Is_Incomplete (List_Res_36) then
            Transform_Res_233.Last_Attempted_Child := 0;
         elsif List_Res_36 /= null and then not Is_Ghost (List_Res_36) then
            Transform_Res_233.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_288 /= No_Token_Index then

         Row_Pos_286 := Row_Pos_288;

      else
         Row_Pos_286 := No_Token_Index;
         goto Exit_Row_285_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_289 := Row_Pos_286;

--  Start tok_code

      Token_Res_452 := Row_Pos_289;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_452));
      begin
         if T.Kind /= From_Token_Kind (Ada_Private) then
            Token_Pos_452 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_289 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_289,
                  Expected_Token_Id => Ada_Private,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_452 := Row_Pos_289 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_452 /= No_Token_Index then

         Row_Pos_289 := Token_Pos_452;

      else
         Row_Pos_289 := No_Token_Index;
         goto Exit_Row_293_0;

      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_290 := Row_Pos_289;

--  Start list_code

      List_Pos_37 := Row_Pos_290;

      Lst_Cpos_37 := Row_Pos_290;
      Tmp_List_37 := Get_Parse_List (Parser);

      loop

         Defer_Res_467 := Task_Item_Or_Parse_0 (Parser, Lst_Cpos_37);
         Defer_Pos_467 := Parser.Current_Pos;

         exit when Defer_Pos_467 = No_Token_Index;

         List_Pos_37 := Defer_Pos_467;
         Lst_Cpos_37 := List_Pos_37;

         Tmp_List_37.Nodes.Append (Defer_Res_467);

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_37.Nodes.Length;
      begin
         List_Res_37 := Allocate_Decl_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_290;
            Token_End   :=
              (if Lst_Cpos_37 = Row_Pos_290 then Row_Pos_290
               else Lst_Cpos_37 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_290, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self => List_Res_37, Kind => Ada_Decl_List, Unit => Parser.Unit,
            Token_Start_Index => Token_Start, Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_37, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_37.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_37.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_37);

--  End list_code

      if List_Pos_37 /= No_Token_Index then

         Row_Pos_290 := List_Pos_37;

      else
         Row_Pos_290 := No_Token_Index;
         goto Exit_Row_294_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_294_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_290 /= No_Token_Index then

         Transform_Res_234 := Allocate_Private_Part (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_234, Kind => Ada_Private_Part,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_289,
            Token_End_Index =>
              (if Row_Pos_290 = Row_Pos_289 then No_Token_Index
               else Row_Pos_290 - 1));

         Initialize_Fields_For_Private_Part
           (Self                     => Transform_Res_234,
            Declarative_Part_F_Decls => List_Res_37);

         if List_Res_37 /= null and then Is_Incomplete (List_Res_37) then
            Transform_Res_234.Last_Attempted_Child := 0;
         elsif List_Res_37 /= null and then not Is_Ghost (List_Res_37) then
            Transform_Res_234.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_290 /= No_Token_Index then

         Row_Pos_289 := Row_Pos_290;

      else
         Row_Pos_289 := No_Token_Index;
         goto Exit_Row_293_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_293_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_289 = No_Token_Index then

         Transform_Res_234 := No_Bare_Ada_Node;

         Row_Pos_289 := Row_Pos_286;

      end if;

--  End opt_code

      if Row_Pos_289 /= No_Token_Index then

         Row_Pos_286 := Row_Pos_289;

      else
         Row_Pos_286 := No_Token_Index;
         goto Exit_Row_285_0;

      end if;

--  Start row_code

      Row_Pos_291 := Row_Pos_286;

--  Start tok_code

      Token_Res_453 := Row_Pos_291;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_453));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_453 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_291 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_291,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_453 := Row_Pos_291 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_453 /= No_Token_Index then

         Row_Pos_291 := Token_Pos_453;

      else
         Row_Pos_291 := No_Token_Index;
         goto Exit_Row_295_0;

      end if;

--  Start opt_code

--  Start transform_code

--  Start row_code

      Row_Pos_292 := Row_Pos_291;

      Defer_Res_468 := Identifier_Transform_Parse_0 (Parser, Row_Pos_292);
      Defer_Pos_468 := Parser.Current_Pos;

      if Defer_Pos_468 /= No_Token_Index then

         Row_Pos_292 := Defer_Pos_468;

      else
         Row_Pos_292 := No_Token_Index;
         goto Exit_Row_296_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_296_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_292 /= No_Token_Index then

         Transform_Res_235 := Allocate_End_Name (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_235, Kind => Ada_End_Name,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_291,
            Token_End_Index =>
              (if Row_Pos_292 = Row_Pos_291 then No_Token_Index
               else Row_Pos_292 - 1));

         Initialize_Fields_For_End_Name
           (Self => Transform_Res_235, End_Name_F_Name => Defer_Res_468);

         if Defer_Res_468 /= null and then Is_Incomplete (Defer_Res_468) then
            Transform_Res_235.Last_Attempted_Child := 0;
         elsif Defer_Res_468 /= null and then not Is_Ghost (Defer_Res_468) then
            Transform_Res_235.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_292 = No_Token_Index then

         Transform_Res_235 := No_Bare_Ada_Node;

         Row_Pos_292 := Row_Pos_291;

      end if;

--  End opt_code

      if Row_Pos_292 /= No_Token_Index then

         Row_Pos_291 := Row_Pos_292;

      else
         Row_Pos_291 := No_Token_Index;
         goto Exit_Row_295_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_295_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_291 /= No_Token_Index then

         Row_Pos_286 := Row_Pos_291;

      else
         Row_Pos_286 := No_Token_Index;
         goto Exit_Row_285_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_285_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_286 /= No_Token_Index then

         Transform_Res_236 := Allocate_Task_Def (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_236, Kind => Ada_Task_Def,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_286 = Pos then No_Token_Index else Row_Pos_286 - 1));

         Initialize_Fields_For_Task_Def
           (Self => Transform_Res_236, Task_Def_F_Interfaces => Defer_Res_465,
            Task_Def_F_Public_Part  => Transform_Res_233,
            Task_Def_F_Private_Part => Transform_Res_234,
            Task_Def_F_End_Name     => Transform_Res_235);

         if Defer_Res_465 /= null and then Is_Incomplete (Defer_Res_465) then
            Transform_Res_236.Last_Attempted_Child := 0;
         elsif Defer_Res_465 /= null and then not Is_Ghost (Defer_Res_465) then
            Transform_Res_236.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_233 /= null
           and then Is_Incomplete (Transform_Res_233)
         then
            Transform_Res_236.Last_Attempted_Child := 0;
         elsif Transform_Res_233 /= null
           and then not Is_Ghost (Transform_Res_233)
         then
            Transform_Res_236.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_234 /= null
           and then Is_Incomplete (Transform_Res_234)
         then
            Transform_Res_236.Last_Attempted_Child := 0;
         elsif Transform_Res_234 /= null
           and then not Is_Ghost (Transform_Res_234)
         then
            Transform_Res_236.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_235 /= null
           and then Is_Incomplete (Transform_Res_235)
         then
            Transform_Res_236.Last_Attempted_Child := 0;
         elsif Transform_Res_235 /= null
           and then not Is_Ghost (Transform_Res_235)
         then
            Transform_Res_236.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Task_Def_Transform_Parse_3_Memo,
         Row_Pos_286 /= No_Token_Index, Transform_Res_236, Pos, Row_Pos_286);

      Parser.Current_Pos := Row_Pos_286;

      return Transform_Res_236;
   end Task_Def_Transform_Parse_3;

   function Task_Type_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Task_Type_Decl
   is
      use Bare_Task_Type_Decl_Memos;

      Nobt_34                 : Boolean                := False;
      Row_Pos_285             : Token_Index            := No_Token_Index;
      Token_Pos_446           : Token_Index            := No_Token_Index;
      Token_Res_446           : Token_Index            := No_Token_Index;
      Token_Pos_447           : Token_Index            := No_Token_Index;
      Token_Res_447           : Token_Index            := No_Token_Index;
      Defer_Pos_461           : Token_Index            := No_Token_Index;
      Defer_Res_461           : Bare_Defining_Name     := No_Bare_Ada_Node;
      Defer_Pos_462           : Token_Index            := No_Token_Index;
      Defer_Res_462           : Bare_Discriminant_Part := No_Bare_Ada_Node;
      Defer_Pos_463           : Token_Index            := No_Token_Index;
      Defer_Res_463           : Bare_Aspect_Spec       := No_Bare_Ada_Node;
      Defer_Pos_464           : Token_Index            := No_Token_Index;
      Defer_Res_464           : Bare_Task_Def          := No_Bare_Ada_Node;
      Token_Pos_448           : Token_Index            := No_Token_Index;
      Token_Res_448           : Token_Index            := No_Token_Index;
      Row_Progress_35         : Integer                := 0;
      Transform_Res_232       : Bare_Task_Type_Decl    := No_Bare_Ada_Node;
      Transform_Has_Failed_35 : Boolean                := False;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Task_Type_Decl_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_232  := M.Instance;
         return Transform_Res_232;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_232;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_285 := Pos;

--  Start tok_code

      Token_Res_446 := Row_Pos_285;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_446));
      begin
         if T.Kind /= From_Token_Kind (Ada_Task) then
            Token_Pos_446 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_285 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_285,
                  Expected_Token_Id => Ada_Task,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_446 := Row_Pos_285 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_35 := 1;

      if Token_Pos_446 /= No_Token_Index then

         Row_Pos_285 := Token_Pos_446;

      else
         Row_Pos_285 := No_Token_Index;
         goto Exit_Row_284_0;

      end if;

--  Start tok_code

      Token_Res_447 := Row_Pos_285;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_447));
      begin
         if T.Kind /= From_Token_Kind (Ada_Type) then
            Token_Pos_447 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_285 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_285,
                  Expected_Token_Id => Ada_Type,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_447 := Row_Pos_285 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_35 := 2;

      if Token_Pos_447 /= No_Token_Index then

         Row_Pos_285 := Token_Pos_447;

      else
         Row_Pos_285 := No_Token_Index;
         goto Exit_Row_284_0;

      end if;

      Nobt_34 := True;

      Row_Progress_35 := 3;

      if Row_Pos_285 /= No_Token_Index then

         Row_Pos_285 := Row_Pos_285;

      else
         Row_Pos_285 := No_Token_Index;
         goto Exit_Row_284_0;

      end if;

      Defer_Res_461 := Defining_Id_Transform_Parse_0 (Parser, Row_Pos_285);
      Defer_Pos_461 := Parser.Current_Pos;

      Row_Progress_35 := 4;

      if Defer_Pos_461 /= No_Token_Index then

         Row_Pos_285 := Defer_Pos_461;

      else
         Row_Pos_285 := No_Token_Index;
         goto Exit_Row_284_0;

      end if;

--  Start opt_code

      Defer_Res_462 := Discriminant_Part_Or_Parse_0 (Parser, Row_Pos_285);
      Defer_Pos_462 := Parser.Current_Pos;

      if Defer_Pos_462 = No_Token_Index then

         Defer_Res_462 := No_Bare_Ada_Node;

         Defer_Pos_462 := Row_Pos_285;

      end if;

--  End opt_code

      Row_Progress_35 := 5;

      if Defer_Pos_462 /= No_Token_Index then

         Row_Pos_285 := Defer_Pos_462;

      else
         Row_Pos_285 := No_Token_Index;
         goto Exit_Row_284_0;

      end if;

      Defer_Res_463 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_285);
      Defer_Pos_463 := Parser.Current_Pos;

      Row_Progress_35 := 6;

      if Defer_Pos_463 /= No_Token_Index then

         Row_Pos_285 := Defer_Pos_463;

      else
         Row_Pos_285 := No_Token_Index;
         goto Exit_Row_284_0;

      end if;

--  Start opt_code

      Defer_Res_464 := Task_Def_Transform_Parse_3 (Parser, Row_Pos_285);
      Defer_Pos_464 := Parser.Current_Pos;

      if Defer_Pos_464 = No_Token_Index then

         Defer_Res_464 := No_Bare_Ada_Node;

         Defer_Pos_464 := Row_Pos_285;

      end if;

--  End opt_code

      Row_Progress_35 := 7;

      if Defer_Pos_464 /= No_Token_Index then

         Row_Pos_285 := Defer_Pos_464;

      else
         Row_Pos_285 := No_Token_Index;
         goto Exit_Row_284_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_448 := Row_Pos_285;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_448));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_448 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_285 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_285,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_448 := Row_Pos_285 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_448 = No_Token_Index then

         Token_Res_448 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_285).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_448 := Row_Pos_285;

      end if;

--  End opt_code

      Row_Progress_35 := 8;

      if Token_Pos_448 /= No_Token_Index then

         Row_Pos_285 := Token_Pos_448;

      else
         Row_Pos_285 := No_Token_Index;
         goto Exit_Row_284_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_284_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_285 = No_Token_Index and then Nobt_34 then
         Row_Pos_285             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_35 := True;
      end if;

      if Row_Pos_285 /= No_Token_Index then

         Transform_Res_232 := Allocate_Task_Type_Decl (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_232, Kind => Ada_Task_Type_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_285 = Pos then No_Token_Index else Row_Pos_285 - 1));

         Initialize_Fields_For_Task_Type_Decl
           (Self => Transform_Res_232, Base_Type_Decl_F_Name => Defer_Res_461,
            Task_Type_Decl_F_Discriminants => Defer_Res_462,
            Task_Type_Decl_F_Aspects       => Defer_Res_463,
            Task_Type_Decl_F_Definition    => Defer_Res_464);

         if Defer_Res_461 /= null and then Is_Incomplete (Defer_Res_461) then
            Transform_Res_232.Last_Attempted_Child := 0;
         elsif Defer_Res_461 /= null and then not Is_Ghost (Defer_Res_461) then
            Transform_Res_232.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_462 /= null and then Is_Incomplete (Defer_Res_462) then
            Transform_Res_232.Last_Attempted_Child := 0;
         elsif Defer_Res_462 /= null and then not Is_Ghost (Defer_Res_462) then
            Transform_Res_232.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_463 /= null and then Is_Incomplete (Defer_Res_463) then
            Transform_Res_232.Last_Attempted_Child := 0;
         elsif Defer_Res_463 /= null and then not Is_Ghost (Defer_Res_463) then
            Transform_Res_232.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_464 /= null and then Is_Incomplete (Defer_Res_464) then
            Transform_Res_232.Last_Attempted_Child := 0;
         elsif Defer_Res_464 /= null and then not Is_Ghost (Defer_Res_464) then
            Transform_Res_232.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_35 then
            Transform_Res_232.Last_Attempted_Child := Row_Progress_35;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <task_type_decl>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Task_Type_Decl_Transform_Parse_0_Memo,
         Row_Pos_285 /= No_Token_Index, Transform_Res_232, Pos, Row_Pos_285);

      Parser.Current_Pos := Row_Pos_285;

      return Transform_Res_232;
   end Task_Type_Decl_Transform_Parse_0;

   function Subp_Decl_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Basic_Decl
   is
      use Bare_Basic_Decl_Memos;

      Defer_Pos_493 : Token_Index             := No_Token_Index;
      Defer_Res_493 : Bare_Null_Subp_Decl     := No_Bare_Ada_Node;
      Defer_Pos_494 : Token_Index             := No_Token_Index;
      Defer_Res_494 : Bare_Abstract_Subp_Decl := No_Bare_Ada_Node;
      Defer_Pos_495 : Token_Index             := No_Token_Index;
      Defer_Res_495 : Bare_Expr_Function      := No_Bare_Ada_Node;
      Defer_Pos_496 : Token_Index             := No_Token_Index;
      Defer_Res_496 : Bare_Subp_Renaming_Decl := No_Bare_Ada_Node;
      Defer_Pos_497 : Token_Index             := No_Token_Index;
      Defer_Res_497 : Bare_Subp_Decl          := No_Bare_Ada_Node;
      Or_Pos_91     : Token_Index             := No_Token_Index;
      Or_Res_91     : Bare_Basic_Decl         := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Subp_Decl_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_91          := M.Instance;
         return Or_Res_91;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_91;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_91 := No_Token_Index;
      Or_Res_91 := No_Bare_Ada_Node;

      Defer_Res_493 := Null_Subp_Decl_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_493 := Parser.Current_Pos;

      if Defer_Pos_493 /= No_Token_Index then
         Or_Pos_91 := Defer_Pos_493;
         Or_Res_91 := Defer_Res_493;
         goto Exit_Or_92;
      end if;

      Defer_Res_494 := Abstract_Subp_Decl_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_494 := Parser.Current_Pos;

      if Defer_Pos_494 /= No_Token_Index then
         Or_Pos_91 := Defer_Pos_494;
         Or_Res_91 := Defer_Res_494;
         goto Exit_Or_92;
      end if;

      Defer_Res_495 := Expr_Fn_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_495 := Parser.Current_Pos;

      if Defer_Pos_495 /= No_Token_Index then
         Or_Pos_91 := Defer_Pos_495;
         Or_Res_91 := Defer_Res_495;
         goto Exit_Or_92;
      end if;

      Defer_Res_496 := Subp_Renaming_Decl_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_496 := Parser.Current_Pos;

      if Defer_Pos_496 /= No_Token_Index then
         Or_Pos_91 := Defer_Pos_496;
         Or_Res_91 := Defer_Res_496;
         goto Exit_Or_92;
      end if;

      Defer_Res_497 := Simple_Subp_Decl_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_497 := Parser.Current_Pos;

      if Defer_Pos_497 /= No_Token_Index then
         Or_Pos_91 := Defer_Pos_497;
         Or_Res_91 := Defer_Res_497;
         goto Exit_Or_92;
      end if;
      <<Exit_Or_92>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Subp_Decl_Or_Parse_0_Memo,
         Or_Pos_91 /= No_Token_Index, Or_Res_91, Pos, Or_Pos_91);

      Parser.Current_Pos := Or_Pos_91;

      return Or_Res_91;
   end Subp_Decl_Or_Parse_0;

   function Protected_Op_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Defer_Pos_489 : Token_Index        := No_Token_Index;
      Defer_Res_489 : Bare_Basic_Decl    := No_Bare_Ada_Node;
      Defer_Pos_490 : Token_Index        := No_Token_Index;
      Defer_Res_490 : Bare_Entry_Decl    := No_Bare_Ada_Node;
      Defer_Pos_491 : Token_Index        := No_Token_Index;
      Defer_Res_491 : Bare_Aspect_Clause := No_Bare_Ada_Node;
      Defer_Pos_492 : Token_Index        := No_Token_Index;
      Defer_Res_492 : Bare_Pragma_Node   := No_Bare_Ada_Node;
      Or_Pos_90     : Token_Index        := No_Token_Index;
      Or_Res_90     : Bare_Ada_Node      := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Protected_Op_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_90          := M.Instance;
         return Or_Res_90;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_90;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_90 := No_Token_Index;
      Or_Res_90 := No_Bare_Ada_Node;

      Defer_Res_489 := Subp_Decl_Or_Parse_0 (Parser, Pos);
      Defer_Pos_489 := Parser.Current_Pos;

      if Defer_Pos_489 /= No_Token_Index then
         Or_Pos_90 := Defer_Pos_489;
         Or_Res_90 := Defer_Res_489;
         goto Exit_Or_91;
      end if;

      Defer_Res_490 := Entry_Decl_Transform_Parse_1 (Parser, Pos);
      Defer_Pos_490 := Parser.Current_Pos;

      if Defer_Pos_490 /= No_Token_Index then
         Or_Pos_90 := Defer_Pos_490;
         Or_Res_90 := Defer_Res_490;
         goto Exit_Or_91;
      end if;

      Defer_Res_491 := Aspect_Clause_Or_Parse_1 (Parser, Pos);
      Defer_Pos_491 := Parser.Current_Pos;

      if Defer_Pos_491 /= No_Token_Index then
         Or_Pos_90 := Defer_Pos_491;
         Or_Res_90 := Defer_Res_491;
         goto Exit_Or_91;
      end if;

      Defer_Res_492 := Pragma_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_492 := Parser.Current_Pos;

      if Defer_Pos_492 /= No_Token_Index then
         Or_Pos_90 := Defer_Pos_492;
         Or_Res_90 := Defer_Res_492;
         goto Exit_Or_91;
      end if;
      <<Exit_Or_91>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Protected_Op_Or_Parse_0_Memo,
         Or_Pos_90 /= No_Token_Index, Or_Res_90, Pos, Or_Pos_90);

      Parser.Current_Pos := Or_Pos_90;

      return Or_Res_90;
   end Protected_Op_Or_Parse_0;

   function Protected_El_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Defer_Pos_498 : Token_Index         := No_Token_Index;
      Defer_Res_498 : Bare_Ada_Node       := No_Bare_Ada_Node;
      Defer_Pos_499 : Token_Index         := No_Token_Index;
      Defer_Res_499 : Bare_Component_Decl := No_Bare_Ada_Node;
      Or_Pos_92     : Token_Index         := No_Token_Index;
      Or_Res_92     : Bare_Ada_Node       := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Protected_El_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_92          := M.Instance;
         return Or_Res_92;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_92;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_92 := No_Token_Index;
      Or_Res_92 := No_Bare_Ada_Node;

      Defer_Res_498 := Protected_Op_Or_Parse_0 (Parser, Pos);
      Defer_Pos_498 := Parser.Current_Pos;

      if Defer_Pos_498 /= No_Token_Index then
         Or_Pos_92 := Defer_Pos_498;
         Or_Res_92 := Defer_Res_498;
         goto Exit_Or_93;
      end if;

      Defer_Res_499 := Component_Decl_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_499 := Parser.Current_Pos;

      if Defer_Pos_499 /= No_Token_Index then
         Or_Pos_92 := Defer_Pos_499;
         Or_Res_92 := Defer_Res_499;
         goto Exit_Or_93;
      end if;
      <<Exit_Or_93>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Protected_El_Or_Parse_0_Memo,
         Or_Pos_92 /= No_Token_Index, Or_Res_92, Pos, Or_Pos_92);

      Parser.Current_Pos := Or_Pos_92;

      return Or_Res_92;
   end Protected_El_Or_Parse_0;

   function Protected_Def_Transform_Parse_3
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Protected_Def
   is
      use Bare_Protected_Def_Memos;

      Row_Pos_300       : Token_Index        := No_Token_Index;
      Row_Pos_301       : Token_Index        := No_Token_Index;
      Lst_Cpos_38       : Token_Index        := No_Token_Index;
      Tmp_List_38       : Free_Parse_List;
      Defer_Pos_486     : Token_Index        := No_Token_Index;
      Defer_Res_486     : Bare_Ada_Node      := No_Bare_Ada_Node;
      List_Pos_38       : Token_Index        := No_Token_Index;
      List_Res_38       : Bare_Decl_List     := No_Bare_Ada_Node;
      Transform_Res_241 : Bare_Public_Part   := No_Bare_Ada_Node;
      Row_Pos_302       : Token_Index        := No_Token_Index;
      Token_Pos_466     : Token_Index        := No_Token_Index;
      Token_Res_466     : Token_Index        := No_Token_Index;
      Row_Pos_303       : Token_Index        := No_Token_Index;
      Lst_Cpos_39       : Token_Index        := No_Token_Index;
      Tmp_List_39       : Free_Parse_List;
      Defer_Pos_487     : Token_Index        := No_Token_Index;
      Defer_Res_487     : Bare_Ada_Node      := No_Bare_Ada_Node;
      List_Pos_39       : Token_Index        := No_Token_Index;
      List_Res_39       : Bare_Decl_List     := No_Bare_Ada_Node;
      Transform_Res_242 : Bare_Private_Part  := No_Bare_Ada_Node;
      Row_Pos_304       : Token_Index        := No_Token_Index;
      Token_Pos_467     : Token_Index        := No_Token_Index;
      Token_Res_467     : Token_Index        := No_Token_Index;
      Row_Pos_305       : Token_Index        := No_Token_Index;
      Defer_Pos_488     : Token_Index        := No_Token_Index;
      Defer_Res_488     : Bare_Identifier    := No_Bare_Ada_Node;
      Transform_Res_243 : Bare_End_Name      := No_Bare_Ada_Node;
      Transform_Res_244 : Bare_Protected_Def := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Protected_Def_Transform_Parse_3_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_244  := M.Instance;
         return Transform_Res_244;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_244;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_300 := Pos;

--  Start transform_code

--  Start row_code

      Row_Pos_301 := Row_Pos_300;

--  Start list_code

      List_Pos_38 := Row_Pos_301;

      Lst_Cpos_38 := Row_Pos_301;
      Tmp_List_38 := Get_Parse_List (Parser);

      loop

         Defer_Res_486 := Protected_Op_Or_Parse_0 (Parser, Lst_Cpos_38);
         Defer_Pos_486 := Parser.Current_Pos;

         exit when Defer_Pos_486 = No_Token_Index;

         List_Pos_38 := Defer_Pos_486;
         Lst_Cpos_38 := List_Pos_38;

         Tmp_List_38.Nodes.Append (Defer_Res_486);

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_38.Nodes.Length;
      begin
         List_Res_38 := Allocate_Decl_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_301;
            Token_End   :=
              (if Lst_Cpos_38 = Row_Pos_301 then Row_Pos_301
               else Lst_Cpos_38 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_301, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self => List_Res_38, Kind => Ada_Decl_List, Unit => Parser.Unit,
            Token_Start_Index => Token_Start, Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_38, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_38.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_38.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_38);

--  End list_code

      if List_Pos_38 /= No_Token_Index then

         Row_Pos_301 := List_Pos_38;

      else
         Row_Pos_301 := No_Token_Index;
         goto Exit_Row_300_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_300_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_301 /= No_Token_Index then

         Transform_Res_241 := Allocate_Public_Part (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_241, Kind => Ada_Public_Part,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_300,
            Token_End_Index =>
              (if Row_Pos_301 = Row_Pos_300 then No_Token_Index
               else Row_Pos_301 - 1));

         Initialize_Fields_For_Public_Part
           (Self                     => Transform_Res_241,
            Declarative_Part_F_Decls => List_Res_38);

         if List_Res_38 /= null and then Is_Incomplete (List_Res_38) then
            Transform_Res_241.Last_Attempted_Child := 0;
         elsif List_Res_38 /= null and then not Is_Ghost (List_Res_38) then
            Transform_Res_241.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_301 /= No_Token_Index then

         Row_Pos_300 := Row_Pos_301;

      else
         Row_Pos_300 := No_Token_Index;
         goto Exit_Row_299_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_302 := Row_Pos_300;

--  Start tok_code

      Token_Res_466 := Row_Pos_302;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_466));
      begin
         if T.Kind /= From_Token_Kind (Ada_Private) then
            Token_Pos_466 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_302 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_302,
                  Expected_Token_Id => Ada_Private,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_466 := Row_Pos_302 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_466 /= No_Token_Index then

         Row_Pos_302 := Token_Pos_466;

      else
         Row_Pos_302 := No_Token_Index;
         goto Exit_Row_301_0;

      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_303 := Row_Pos_302;

--  Start list_code

      List_Pos_39 := Row_Pos_303;

      Lst_Cpos_39 := Row_Pos_303;
      Tmp_List_39 := Get_Parse_List (Parser);

      loop

         Defer_Res_487 := Protected_El_Or_Parse_0 (Parser, Lst_Cpos_39);
         Defer_Pos_487 := Parser.Current_Pos;

         exit when Defer_Pos_487 = No_Token_Index;

         List_Pos_39 := Defer_Pos_487;
         Lst_Cpos_39 := List_Pos_39;

         Tmp_List_39.Nodes.Append (Defer_Res_487);

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_39.Nodes.Length;
      begin
         List_Res_39 := Allocate_Decl_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_303;
            Token_End   :=
              (if Lst_Cpos_39 = Row_Pos_303 then Row_Pos_303
               else Lst_Cpos_39 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_303, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self => List_Res_39, Kind => Ada_Decl_List, Unit => Parser.Unit,
            Token_Start_Index => Token_Start, Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_39, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_39.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_39.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_39);

--  End list_code

      if List_Pos_39 /= No_Token_Index then

         Row_Pos_303 := List_Pos_39;

      else
         Row_Pos_303 := No_Token_Index;
         goto Exit_Row_302_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_302_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_303 /= No_Token_Index then

         Transform_Res_242 := Allocate_Private_Part (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_242, Kind => Ada_Private_Part,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_302,
            Token_End_Index =>
              (if Row_Pos_303 = Row_Pos_302 then No_Token_Index
               else Row_Pos_303 - 1));

         Initialize_Fields_For_Private_Part
           (Self                     => Transform_Res_242,
            Declarative_Part_F_Decls => List_Res_39);

         if List_Res_39 /= null and then Is_Incomplete (List_Res_39) then
            Transform_Res_242.Last_Attempted_Child := 0;
         elsif List_Res_39 /= null and then not Is_Ghost (List_Res_39) then
            Transform_Res_242.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_303 /= No_Token_Index then

         Row_Pos_302 := Row_Pos_303;

      else
         Row_Pos_302 := No_Token_Index;
         goto Exit_Row_301_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_301_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_302 = No_Token_Index then

         Transform_Res_242 := No_Bare_Ada_Node;

         Row_Pos_302 := Row_Pos_300;

      end if;

--  End opt_code

      if Row_Pos_302 /= No_Token_Index then

         Row_Pos_300 := Row_Pos_302;

      else
         Row_Pos_300 := No_Token_Index;
         goto Exit_Row_299_0;

      end if;

--  Start row_code

      Row_Pos_304 := Row_Pos_300;

--  Start tok_code

      Token_Res_467 := Row_Pos_304;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_467));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_467 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_304 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_304,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_467 := Row_Pos_304 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_467 /= No_Token_Index then

         Row_Pos_304 := Token_Pos_467;

      else
         Row_Pos_304 := No_Token_Index;
         goto Exit_Row_303_0;

      end if;

--  Start opt_code

--  Start transform_code

--  Start row_code

      Row_Pos_305 := Row_Pos_304;

      Defer_Res_488 := Identifier_Transform_Parse_0 (Parser, Row_Pos_305);
      Defer_Pos_488 := Parser.Current_Pos;

      if Defer_Pos_488 /= No_Token_Index then

         Row_Pos_305 := Defer_Pos_488;

      else
         Row_Pos_305 := No_Token_Index;
         goto Exit_Row_304_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_304_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_305 /= No_Token_Index then

         Transform_Res_243 := Allocate_End_Name (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_243, Kind => Ada_End_Name,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_304,
            Token_End_Index =>
              (if Row_Pos_305 = Row_Pos_304 then No_Token_Index
               else Row_Pos_305 - 1));

         Initialize_Fields_For_End_Name
           (Self => Transform_Res_243, End_Name_F_Name => Defer_Res_488);

         if Defer_Res_488 /= null and then Is_Incomplete (Defer_Res_488) then
            Transform_Res_243.Last_Attempted_Child := 0;
         elsif Defer_Res_488 /= null and then not Is_Ghost (Defer_Res_488) then
            Transform_Res_243.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_305 = No_Token_Index then

         Transform_Res_243 := No_Bare_Ada_Node;

         Row_Pos_305 := Row_Pos_304;

      end if;

--  End opt_code

      if Row_Pos_305 /= No_Token_Index then

         Row_Pos_304 := Row_Pos_305;

      else
         Row_Pos_304 := No_Token_Index;
         goto Exit_Row_303_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_303_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_304 /= No_Token_Index then

         Row_Pos_300 := Row_Pos_304;

      else
         Row_Pos_300 := No_Token_Index;
         goto Exit_Row_299_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_299_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_300 /= No_Token_Index then

         Transform_Res_244 := Allocate_Protected_Def (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_244, Kind => Ada_Protected_Def,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_300 = Pos then No_Token_Index else Row_Pos_300 - 1));

         Initialize_Fields_For_Protected_Def
           (Self                         => Transform_Res_244,
            Protected_Def_F_Public_Part  => Transform_Res_241,
            Protected_Def_F_Private_Part => Transform_Res_242,
            Protected_Def_F_End_Name     => Transform_Res_243);

         if Transform_Res_241 /= null
           and then Is_Incomplete (Transform_Res_241)
         then
            Transform_Res_244.Last_Attempted_Child := 0;
         elsif Transform_Res_241 /= null
           and then not Is_Ghost (Transform_Res_241)
         then
            Transform_Res_244.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_242 /= null
           and then Is_Incomplete (Transform_Res_242)
         then
            Transform_Res_244.Last_Attempted_Child := 0;
         elsif Transform_Res_242 /= null
           and then not Is_Ghost (Transform_Res_242)
         then
            Transform_Res_244.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_243 /= null
           and then Is_Incomplete (Transform_Res_243)
         then
            Transform_Res_244.Last_Attempted_Child := 0;
         elsif Transform_Res_243 /= null
           and then not Is_Ghost (Transform_Res_243)
         then
            Transform_Res_244.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Protected_Def_Transform_Parse_3_Memo,
         Row_Pos_300 /= No_Token_Index, Transform_Res_244, Pos, Row_Pos_300);

      Parser.Current_Pos := Row_Pos_300;

      return Transform_Res_244;
   end Protected_Def_Transform_Parse_3;

   function Protected_Type_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Protected_Type_Decl
   is
      use Bare_Protected_Type_Decl_Memos;

      Row_Pos_298       : Token_Index              := No_Token_Index;
      Token_Pos_460     : Token_Index              := No_Token_Index;
      Token_Res_460     : Token_Index              := No_Token_Index;
      Token_Pos_461     : Token_Index              := No_Token_Index;
      Token_Res_461     : Token_Index              := No_Token_Index;
      Defer_Pos_481     : Token_Index              := No_Token_Index;
      Defer_Res_481     : Bare_Defining_Name       := No_Bare_Ada_Node;
      Defer_Pos_482     : Token_Index              := No_Token_Index;
      Defer_Res_482     : Bare_Discriminant_Part   := No_Bare_Ada_Node;
      Defer_Pos_483     : Token_Index              := No_Token_Index;
      Defer_Res_483     : Bare_Aspect_Spec         := No_Bare_Ada_Node;
      Token_Pos_462     : Token_Index              := No_Token_Index;
      Token_Res_462     : Token_Index              := No_Token_Index;
      Row_Pos_299       : Token_Index              := No_Token_Index;
      Token_Pos_463     : Token_Index              := No_Token_Index;
      Token_Res_463     : Token_Index              := No_Token_Index;
      Defer_Pos_484     : Token_Index              := No_Token_Index;
      Defer_Res_484     : Bare_Parent_List         := No_Bare_Ada_Node;
      Token_Pos_464     : Token_Index              := No_Token_Index;
      Token_Res_464     : Token_Index              := No_Token_Index;
      Defer_Pos_485     : Token_Index              := No_Token_Index;
      Defer_Res_485     : Bare_Protected_Def       := No_Bare_Ada_Node;
      Token_Pos_465     : Token_Index              := No_Token_Index;
      Token_Res_465     : Token_Index              := No_Token_Index;
      Transform_Res_240 : Bare_Protected_Type_Decl := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Protected_Type_Decl_Transform_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_240  := M.Instance;
         return Transform_Res_240;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_240;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_298 := Pos;

--  Start tok_code

      Token_Res_460 := Row_Pos_298;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_460));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol
               (Parser.TDH.Symbols, Precomputed_Symbol_Protected)
         then
            Token_Pos_460 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_298 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_298,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_460 := Row_Pos_298 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_460 /= No_Token_Index then

         Row_Pos_298 := Token_Pos_460;

      else
         Row_Pos_298 := No_Token_Index;
         goto Exit_Row_297_0;

      end if;

--  Start tok_code

      Token_Res_461 := Row_Pos_298;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_461));
      begin
         if T.Kind /= From_Token_Kind (Ada_Type) then
            Token_Pos_461 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_298 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_298,
                  Expected_Token_Id => Ada_Type,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_461 := Row_Pos_298 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_461 /= No_Token_Index then

         Row_Pos_298 := Token_Pos_461;

      else
         Row_Pos_298 := No_Token_Index;
         goto Exit_Row_297_0;

      end if;

      Defer_Res_481 := Defining_Id_Transform_Parse_0 (Parser, Row_Pos_298);
      Defer_Pos_481 := Parser.Current_Pos;

      if Defer_Pos_481 /= No_Token_Index then

         Row_Pos_298 := Defer_Pos_481;

      else
         Row_Pos_298 := No_Token_Index;
         goto Exit_Row_297_0;

      end if;

--  Start opt_code

      Defer_Res_482 := Discriminant_Part_Or_Parse_0 (Parser, Row_Pos_298);
      Defer_Pos_482 := Parser.Current_Pos;

      if Defer_Pos_482 = No_Token_Index then

         Defer_Res_482 := No_Bare_Ada_Node;

         Defer_Pos_482 := Row_Pos_298;

      end if;

--  End opt_code

      if Defer_Pos_482 /= No_Token_Index then

         Row_Pos_298 := Defer_Pos_482;

      else
         Row_Pos_298 := No_Token_Index;
         goto Exit_Row_297_0;

      end if;

      Defer_Res_483 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_298);
      Defer_Pos_483 := Parser.Current_Pos;

      if Defer_Pos_483 /= No_Token_Index then

         Row_Pos_298 := Defer_Pos_483;

      else
         Row_Pos_298 := No_Token_Index;
         goto Exit_Row_297_0;

      end if;

--  Start tok_code

      Token_Res_462 := Row_Pos_298;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_462));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_462 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_298 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_298,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_462 := Row_Pos_298 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_462 /= No_Token_Index then

         Row_Pos_298 := Token_Pos_462;

      else
         Row_Pos_298 := No_Token_Index;
         goto Exit_Row_297_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_299 := Row_Pos_298;

--  Start tok_code

      Token_Res_463 := Row_Pos_299;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_463));
      begin
         if T.Kind /= From_Token_Kind (Ada_New) then
            Token_Pos_463 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_299 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_299,
                  Expected_Token_Id => Ada_New,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_463 := Row_Pos_299 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_463 /= No_Token_Index then

         Row_Pos_299 := Token_Pos_463;

      else
         Row_Pos_299 := No_Token_Index;
         goto Exit_Row_298_0;

      end if;

      Defer_Res_484 := Parent_List_List_Parse_0 (Parser, Row_Pos_299);
      Defer_Pos_484 := Parser.Current_Pos;

      if Defer_Pos_484 /= No_Token_Index then

         Row_Pos_299 := Defer_Pos_484;

      else
         Row_Pos_299 := No_Token_Index;
         goto Exit_Row_298_0;

      end if;

--  Start tok_code

      Token_Res_464 := Row_Pos_299;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_464));
      begin
         if T.Kind /= From_Token_Kind (Ada_With) then
            Token_Pos_464 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_299 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_299,
                  Expected_Token_Id => Ada_With,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_464 := Row_Pos_299 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_464 /= No_Token_Index then

         Row_Pos_299 := Token_Pos_464;

      else
         Row_Pos_299 := No_Token_Index;
         goto Exit_Row_298_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_298_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_299 = No_Token_Index then

         Defer_Res_484 := Allocate_Parent_List (Parser.Mem_Pool);
         Initialize
           (Self            => Defer_Res_484, Kind => Ada_Parent_List,
            Unit => Parser.Unit, Token_Start_Index => Row_Pos_298 - 1,
            Token_End_Index => No_Token_Index);
         Initialize_List (Self => Defer_Res_484, Parser => Parser, Count => 0);

         Row_Pos_299 := Row_Pos_298;

      end if;

--  End opt_code

      if Row_Pos_299 /= No_Token_Index then

         Row_Pos_298 := Row_Pos_299;

      else
         Row_Pos_298 := No_Token_Index;
         goto Exit_Row_297_0;

      end if;

      Defer_Res_485 := Protected_Def_Transform_Parse_3 (Parser, Row_Pos_298);
      Defer_Pos_485 := Parser.Current_Pos;

      if Defer_Pos_485 /= No_Token_Index then

         Row_Pos_298 := Defer_Pos_485;

      else
         Row_Pos_298 := No_Token_Index;
         goto Exit_Row_297_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_465 := Row_Pos_298;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_465));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_465 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_298 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_298,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_465 := Row_Pos_298 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_465 = No_Token_Index then

         Token_Res_465 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_298).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_465 := Row_Pos_298;

      end if;

--  End opt_code

      if Token_Pos_465 /= No_Token_Index then

         Row_Pos_298 := Token_Pos_465;

      else
         Row_Pos_298 := No_Token_Index;
         goto Exit_Row_297_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_297_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_298 /= No_Token_Index then

         Transform_Res_240 := Allocate_Protected_Type_Decl (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_240, Kind => Ada_Protected_Type_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_298 = Pos then No_Token_Index else Row_Pos_298 - 1));

         Initialize_Fields_For_Protected_Type_Decl
           (Self => Transform_Res_240, Base_Type_Decl_F_Name => Defer_Res_481,
            Protected_Type_Decl_F_Discriminants => Defer_Res_482,
            Protected_Type_Decl_F_Aspects       => Defer_Res_483,
            Protected_Type_Decl_F_Interfaces    => Defer_Res_484,
            Protected_Type_Decl_F_Definition    => Defer_Res_485);

         if Defer_Res_481 /= null and then Is_Incomplete (Defer_Res_481) then
            Transform_Res_240.Last_Attempted_Child := 0;
         elsif Defer_Res_481 /= null and then not Is_Ghost (Defer_Res_481) then
            Transform_Res_240.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_482 /= null and then Is_Incomplete (Defer_Res_482) then
            Transform_Res_240.Last_Attempted_Child := 0;
         elsif Defer_Res_482 /= null and then not Is_Ghost (Defer_Res_482) then
            Transform_Res_240.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_483 /= null and then Is_Incomplete (Defer_Res_483) then
            Transform_Res_240.Last_Attempted_Child := 0;
         elsif Defer_Res_483 /= null and then not Is_Ghost (Defer_Res_483) then
            Transform_Res_240.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_484 /= null and then Is_Incomplete (Defer_Res_484) then
            Transform_Res_240.Last_Attempted_Child := 0;
         elsif Defer_Res_484 /= null and then not Is_Ghost (Defer_Res_484) then
            Transform_Res_240.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_485 /= null and then Is_Incomplete (Defer_Res_485) then
            Transform_Res_240.Last_Attempted_Child := 0;
         elsif Defer_Res_485 /= null and then not Is_Ghost (Defer_Res_485) then
            Transform_Res_240.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Protected_Type_Decl_Transform_Parse_0_Memo,
         Row_Pos_298 /= No_Token_Index, Transform_Res_240, Pos, Row_Pos_298);

      Parser.Current_Pos := Row_Pos_298;

      return Transform_Res_240;
   end Protected_Type_Decl_Transform_Parse_0;

   function Subtype_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Subtype_Decl
   is
      use Bare_Subtype_Decl_Memos;

      Row_Pos_306       : Token_Index             := No_Token_Index;
      Token_Pos_468     : Token_Index             := No_Token_Index;
      Token_Res_468     : Token_Index             := No_Token_Index;
      Defer_Pos_500     : Token_Index             := No_Token_Index;
      Defer_Res_500     : Bare_Defining_Name      := No_Bare_Ada_Node;
      Token_Pos_469     : Token_Index             := No_Token_Index;
      Token_Res_469     : Token_Index             := No_Token_Index;
      Defer_Pos_501     : Token_Index             := No_Token_Index;
      Defer_Res_501     : Bare_Subtype_Indication := No_Bare_Ada_Node;
      Defer_Pos_502     : Token_Index             := No_Token_Index;
      Defer_Res_502     : Bare_Aspect_Spec        := No_Bare_Ada_Node;
      Token_Pos_470     : Token_Index             := No_Token_Index;
      Token_Res_470     : Token_Index             := No_Token_Index;
      Transform_Res_245 : Bare_Subtype_Decl       := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Subtype_Decl_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_245  := M.Instance;
         return Transform_Res_245;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_245;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_306 := Pos;

--  Start tok_code

      Token_Res_468 := Row_Pos_306;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_468));
      begin
         if T.Kind /= From_Token_Kind (Ada_Subtype) then
            Token_Pos_468 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_306 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_306,
                  Expected_Token_Id => Ada_Subtype,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_468 := Row_Pos_306 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_468 /= No_Token_Index then

         Row_Pos_306 := Token_Pos_468;

      else
         Row_Pos_306 := No_Token_Index;
         goto Exit_Row_305_0;

      end if;

      Defer_Res_500 := Defining_Id_Transform_Parse_0 (Parser, Row_Pos_306);
      Defer_Pos_500 := Parser.Current_Pos;

      if Defer_Pos_500 /= No_Token_Index then

         Row_Pos_306 := Defer_Pos_500;

      else
         Row_Pos_306 := No_Token_Index;
         goto Exit_Row_305_0;

      end if;

--  Start tok_code

      Token_Res_469 := Row_Pos_306;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_469));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_469 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_306 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_306,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_469 := Row_Pos_306 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_469 /= No_Token_Index then

         Row_Pos_306 := Token_Pos_469;

      else
         Row_Pos_306 := No_Token_Index;
         goto Exit_Row_305_0;

      end if;

      Defer_Res_501 :=
        Subtype_Indication_Transform_Parse_0 (Parser, Row_Pos_306);
      Defer_Pos_501 := Parser.Current_Pos;

      if Defer_Pos_501 /= No_Token_Index then

         Row_Pos_306 := Defer_Pos_501;

      else
         Row_Pos_306 := No_Token_Index;
         goto Exit_Row_305_0;

      end if;

      Defer_Res_502 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_306);
      Defer_Pos_502 := Parser.Current_Pos;

      if Defer_Pos_502 /= No_Token_Index then

         Row_Pos_306 := Defer_Pos_502;

      else
         Row_Pos_306 := No_Token_Index;
         goto Exit_Row_305_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_470 := Row_Pos_306;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_470));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_470 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_306 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_306,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_470 := Row_Pos_306 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_470 = No_Token_Index then

         Token_Res_470 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_306).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_470 := Row_Pos_306;

      end if;

--  End opt_code

      if Token_Pos_470 /= No_Token_Index then

         Row_Pos_306 := Token_Pos_470;

      else
         Row_Pos_306 := No_Token_Index;
         goto Exit_Row_305_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_305_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_306 /= No_Token_Index then

         Transform_Res_245 := Allocate_Subtype_Decl (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_245, Kind => Ada_Subtype_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_306 = Pos then No_Token_Index else Row_Pos_306 - 1));

         Initialize_Fields_For_Subtype_Decl
           (Self => Transform_Res_245, Base_Type_Decl_F_Name => Defer_Res_500,
            Subtype_Decl_F_Subtype => Defer_Res_501,
            Subtype_Decl_F_Aspects => Defer_Res_502);

         if Defer_Res_500 /= null and then Is_Incomplete (Defer_Res_500) then
            Transform_Res_245.Last_Attempted_Child := 0;
         elsif Defer_Res_500 /= null and then not Is_Ghost (Defer_Res_500) then
            Transform_Res_245.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_501 /= null and then Is_Incomplete (Defer_Res_501) then
            Transform_Res_245.Last_Attempted_Child := 0;
         elsif Defer_Res_501 /= null and then not Is_Ghost (Defer_Res_501) then
            Transform_Res_245.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_502 /= null and then Is_Incomplete (Defer_Res_502) then
            Transform_Res_245.Last_Attempted_Child := 0;
         elsif Defer_Res_502 /= null and then not Is_Ghost (Defer_Res_502) then
            Transform_Res_245.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Subtype_Decl_Transform_Parse_0_Memo,
         Row_Pos_306 /= No_Token_Index, Transform_Res_245, Pos, Row_Pos_306);

      Parser.Current_Pos := Row_Pos_306;

      return Transform_Res_245;
   end Subtype_Decl_Transform_Parse_0;

   function Sub_Object_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Object_Decl
   is
      use Bare_Object_Decl_Memos;

      Nobt_35                 : Boolean                 := False;
      Row_Pos_307             : Token_Index             := No_Token_Index;
      Defer_Pos_507           : Token_Index             := No_Token_Index;
      Defer_Res_507           : Bare_Defining_Name_List := No_Bare_Ada_Node;
      Token_Pos_471           : Token_Index             := No_Token_Index;
      Token_Res_471           : Token_Index             := No_Token_Index;
      Token_Pos_472           : Token_Index             := No_Token_Index;
      Token_Res_472           : Token_Index             := No_Token_Index;
      Opt_Res_27              : Bare_Aliased_Node       := No_Bare_Ada_Node;
      Token_Pos_473           : Token_Index             := No_Token_Index;
      Token_Res_473           : Token_Index             := No_Token_Index;
      Opt_Res_28              : Bare_Constant_Node      := No_Bare_Ada_Node;
      Defer_Pos_508           : Token_Index             := No_Token_Index;
      Defer_Res_508           : Bare_Mode               := No_Bare_Ada_Node;
      Defer_Pos_509           : Token_Index             := No_Token_Index;
      Defer_Res_509           : Bare_Type_Expr          := No_Bare_Ada_Node;
      Row_Pos_308             : Token_Index             := No_Token_Index;
      Token_Pos_474           : Token_Index             := No_Token_Index;
      Token_Res_474           : Token_Index             := No_Token_Index;
      Defer_Pos_510           : Token_Index             := No_Token_Index;
      Defer_Res_510           : Bare_Expr               := No_Bare_Ada_Node;
      Defer_Pos_511           : Token_Index             := No_Token_Index;
      Defer_Res_511           : Bare_Renaming_Clause    := No_Bare_Ada_Node;
      Defer_Pos_512           : Token_Index             := No_Token_Index;
      Defer_Res_512           : Bare_Aspect_Spec        := No_Bare_Ada_Node;
      Token_Pos_475           : Token_Index             := No_Token_Index;
      Token_Res_475           : Token_Index             := No_Token_Index;
      Row_Progress_36         : Integer                 := 0;
      Transform_Res_246       : Bare_Object_Decl        := No_Bare_Ada_Node;
      Transform_Has_Failed_36 : Boolean                 := False;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Sub_Object_Decl_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_246  := M.Instance;
         return Transform_Res_246;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_246;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_307 := Pos;

      Defer_Res_507 := Defining_Id_List_List_Parse_0 (Parser, Row_Pos_307);
      Defer_Pos_507 := Parser.Current_Pos;

      Row_Progress_36 := 1;

      if Defer_Pos_507 /= No_Token_Index then

         Row_Pos_307 := Defer_Pos_507;

      else
         Row_Pos_307 := No_Token_Index;
         goto Exit_Row_306_0;

      end if;

--  Start tok_code

      Token_Res_471 := Row_Pos_307;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_471));
      begin
         if T.Kind /= From_Token_Kind (Ada_Colon) then
            Token_Pos_471 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_307 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_307,
                  Expected_Token_Id => Ada_Colon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_471 := Row_Pos_307 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_36 := 2;

      if Token_Pos_471 /= No_Token_Index then

         Row_Pos_307 := Token_Pos_471;

      else
         Row_Pos_307 := No_Token_Index;
         goto Exit_Row_306_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_472 := Row_Pos_307;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_472));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol
               (Parser.TDH.Symbols, Precomputed_Symbol_Aliased)
         then
            Token_Pos_472 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_307 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_307,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_472 := Row_Pos_307 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_472 = No_Token_Index then

         Opt_Res_27 := Allocate_Aliased_Absent (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_27, Kind => Ada_Aliased_Absent,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_307,
            Token_End_Index => No_Token_Index);

         Token_Pos_472 := Row_Pos_307;

      else

         Opt_Res_27 := Allocate_Aliased_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_27, Kind => Ada_Aliased_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_307,
            Token_End_Index => Token_Pos_472 - 1);

      end if;

--  End opt_code

      Row_Progress_36 := 3;

      if Token_Pos_472 /= No_Token_Index then

         Row_Pos_307 := Token_Pos_472;

      else
         Row_Pos_307 := No_Token_Index;
         goto Exit_Row_306_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_473 := Row_Pos_307;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_473));
      begin
         if T.Kind /= From_Token_Kind (Ada_Constant) then
            Token_Pos_473 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_307 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_307,
                  Expected_Token_Id => Ada_Constant,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_473 := Row_Pos_307 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_473 = No_Token_Index then

         Opt_Res_28 := Allocate_Constant_Absent (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_28, Kind => Ada_Constant_Absent,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_307,
            Token_End_Index => No_Token_Index);

         Token_Pos_473 := Row_Pos_307;

      else

         Opt_Res_28 := Allocate_Constant_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_28, Kind => Ada_Constant_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_307,
            Token_End_Index => Token_Pos_473 - 1);

      end if;

--  End opt_code

      Row_Progress_36 := 4;

      if Token_Pos_473 /= No_Token_Index then

         Row_Pos_307 := Token_Pos_473;

      else
         Row_Pos_307 := No_Token_Index;
         goto Exit_Row_306_0;

      end if;

--  Start opt_code

      Defer_Res_508 := Mode_Or_Parse_0 (Parser, Row_Pos_307);
      Defer_Pos_508 := Parser.Current_Pos;

      if Defer_Pos_508 = No_Token_Index then

         Defer_Res_508 := No_Bare_Ada_Node;

         Defer_Pos_508 := Row_Pos_307;

      end if;

--  End opt_code

      Row_Progress_36 := 5;

      if Defer_Pos_508 /= No_Token_Index then

         Row_Pos_307 := Defer_Pos_508;

      else
         Row_Pos_307 := No_Token_Index;
         goto Exit_Row_306_0;

      end if;

      Defer_Res_509 := Type_Expr_Or_Parse_0 (Parser, Row_Pos_307);
      Defer_Pos_509 := Parser.Current_Pos;

      Row_Progress_36 := 6;

      if Defer_Pos_509 /= No_Token_Index then

         Row_Pos_307 := Defer_Pos_509;

      else
         Row_Pos_307 := No_Token_Index;
         goto Exit_Row_306_0;

      end if;

      Nobt_35 := True;

      Row_Progress_36 := 7;

      if Row_Pos_307 /= No_Token_Index then

         Row_Pos_307 := Row_Pos_307;

      else
         Row_Pos_307 := No_Token_Index;
         goto Exit_Row_306_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_308 := Row_Pos_307;

--  Start tok_code

      Token_Res_474 := Row_Pos_308;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_474));
      begin
         if T.Kind /= From_Token_Kind (Ada_Assign) then
            Token_Pos_474 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_308 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_308,
                  Expected_Token_Id => Ada_Assign,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_474 := Row_Pos_308 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_474 /= No_Token_Index then

         Row_Pos_308 := Token_Pos_474;

      else
         Row_Pos_308 := No_Token_Index;
         goto Exit_Row_307_0;

      end if;

      Defer_Res_510 := Expr_Or_Parse_0 (Parser, Row_Pos_308);
      Defer_Pos_510 := Parser.Current_Pos;

      if Defer_Pos_510 /= No_Token_Index then

         Row_Pos_308 := Defer_Pos_510;

      else
         Row_Pos_308 := No_Token_Index;
         goto Exit_Row_307_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_307_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_308 = No_Token_Index then

         Defer_Res_510 := No_Bare_Ada_Node;

         Row_Pos_308 := Row_Pos_307;

      end if;

--  End opt_code

      Row_Progress_36 := 8;

      if Row_Pos_308 /= No_Token_Index then

         Row_Pos_307 := Row_Pos_308;

      else
         Row_Pos_307 := No_Token_Index;
         goto Exit_Row_306_0;

      end if;

--  Start opt_code

      Defer_Res_511 := Renaming_Clause_Transform_Parse_0 (Parser, Row_Pos_307);
      Defer_Pos_511 := Parser.Current_Pos;

      if Defer_Pos_511 = No_Token_Index then

         Defer_Res_511 := No_Bare_Ada_Node;

         Defer_Pos_511 := Row_Pos_307;

      end if;

--  End opt_code

      Row_Progress_36 := 9;

      if Defer_Pos_511 /= No_Token_Index then

         Row_Pos_307 := Defer_Pos_511;

      else
         Row_Pos_307 := No_Token_Index;
         goto Exit_Row_306_0;

      end if;

      Defer_Res_512 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_307);
      Defer_Pos_512 := Parser.Current_Pos;

      Row_Progress_36 := 10;

      if Defer_Pos_512 /= No_Token_Index then

         Row_Pos_307 := Defer_Pos_512;

      else
         Row_Pos_307 := No_Token_Index;
         goto Exit_Row_306_0;

      end if;

--  Start tok_code

      Token_Res_475 := Row_Pos_307;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_475));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_475 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_307 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_307,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_475 := Row_Pos_307 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_36 := 11;

      if Token_Pos_475 /= No_Token_Index then

         Row_Pos_307 := Token_Pos_475;

      else
         Row_Pos_307 := No_Token_Index;
         goto Exit_Row_306_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_306_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_307 = No_Token_Index and then Nobt_35 then
         Row_Pos_307             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_36 := True;
      end if;

      if Row_Pos_307 /= No_Token_Index then

         Transform_Res_246 := Allocate_Object_Decl (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_246, Kind => Ada_Object_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_307 = Pos then No_Token_Index else Row_Pos_307 - 1));

         Initialize_Fields_For_Object_Decl
           (Self => Transform_Res_246, Object_Decl_F_Ids => Defer_Res_507,
            Object_Decl_F_Has_Aliased     => Opt_Res_27,
            Object_Decl_F_Has_Constant    => Opt_Res_28,
            Object_Decl_F_Mode            => Defer_Res_508,
            Object_Decl_F_Type_Expr       => Defer_Res_509,
            Object_Decl_F_Default_Expr    => Defer_Res_510,
            Object_Decl_F_Renaming_Clause => Defer_Res_511,
            Object_Decl_F_Aspects         => Defer_Res_512);

         if Defer_Res_507 /= null and then Is_Incomplete (Defer_Res_507) then
            Transform_Res_246.Last_Attempted_Child := 0;
         elsif Defer_Res_507 /= null and then not Is_Ghost (Defer_Res_507) then
            Transform_Res_246.Last_Attempted_Child := -1;
         end if;
         if Opt_Res_27 /= null and then Is_Incomplete (Opt_Res_27) then
            Transform_Res_246.Last_Attempted_Child := 0;
         elsif Opt_Res_27 /= null and then not Is_Ghost (Opt_Res_27) then
            Transform_Res_246.Last_Attempted_Child := -1;
         end if;
         if Opt_Res_28 /= null and then Is_Incomplete (Opt_Res_28) then
            Transform_Res_246.Last_Attempted_Child := 0;
         elsif Opt_Res_28 /= null and then not Is_Ghost (Opt_Res_28) then
            Transform_Res_246.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_508 /= null and then Is_Incomplete (Defer_Res_508) then
            Transform_Res_246.Last_Attempted_Child := 0;
         elsif Defer_Res_508 /= null and then not Is_Ghost (Defer_Res_508) then
            Transform_Res_246.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_509 /= null and then Is_Incomplete (Defer_Res_509) then
            Transform_Res_246.Last_Attempted_Child := 0;
         elsif Defer_Res_509 /= null and then not Is_Ghost (Defer_Res_509) then
            Transform_Res_246.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_510 /= null and then Is_Incomplete (Defer_Res_510) then
            Transform_Res_246.Last_Attempted_Child := 0;
         elsif Defer_Res_510 /= null and then not Is_Ghost (Defer_Res_510) then
            Transform_Res_246.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_511 /= null and then Is_Incomplete (Defer_Res_511) then
            Transform_Res_246.Last_Attempted_Child := 0;
         elsif Defer_Res_511 /= null and then not Is_Ghost (Defer_Res_511) then
            Transform_Res_246.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_512 /= null and then Is_Incomplete (Defer_Res_512) then
            Transform_Res_246.Last_Attempted_Child := 0;
         elsif Defer_Res_512 /= null and then not Is_Ghost (Defer_Res_512) then
            Transform_Res_246.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_36 then
            Transform_Res_246.Last_Attempted_Child := Row_Progress_36;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <sub_object_decl>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Sub_Object_Decl_Transform_Parse_0_Memo,
         Row_Pos_307 /= No_Token_Index, Transform_Res_246, Pos, Row_Pos_307);

      Parser.Current_Pos := Row_Pos_307;

      return Transform_Res_246;
   end Sub_Object_Decl_Transform_Parse_0;

   function Single_Task_Decl_Transform_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Single_Task_Decl
   is
      use Bare_Single_Task_Decl_Memos;

      Nobt_36                 : Boolean                    := False;
      Row_Pos_309             : Token_Index                := No_Token_Index;
      Token_Pos_476           : Token_Index                := No_Token_Index;
      Token_Res_476           : Token_Index                := No_Token_Index;
      Row_Pos_310             : Token_Index                := No_Token_Index;
      Defer_Pos_513           : Token_Index                := No_Token_Index;
      Defer_Res_513           : Bare_Defining_Name         := No_Bare_Ada_Node;
      Null_Res_14             : Bare_Discriminant_Part     := No_Bare_Ada_Node;
      Defer_Pos_514           : Token_Index                := No_Token_Index;
      Defer_Res_514           : Bare_Aspect_Spec           := No_Bare_Ada_Node;
      Defer_Pos_515           : Token_Index                := No_Token_Index;
      Defer_Res_515           : Bare_Task_Def              := No_Bare_Ada_Node;
      Transform_Res_247       : Bare_Single_Task_Type_Decl := No_Bare_Ada_Node;
      Token_Pos_477           : Token_Index                := No_Token_Index;
      Token_Res_477           : Token_Index                := No_Token_Index;
      Row_Progress_37         : Integer                    := 0;
      Transform_Res_248       : Bare_Single_Task_Decl      := No_Bare_Ada_Node;
      Transform_Has_Failed_37 : Boolean                    := False;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Single_Task_Decl_Transform_Parse_1_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_248  := M.Instance;
         return Transform_Res_248;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_248;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_309 := Pos;

--  Start tok_code

      Token_Res_476 := Row_Pos_309;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_476));
      begin
         if T.Kind /= From_Token_Kind (Ada_Task) then
            Token_Pos_476 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_309 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_309,
                  Expected_Token_Id => Ada_Task,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_476 := Row_Pos_309 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_37 := 1;

      if Token_Pos_476 /= No_Token_Index then

         Row_Pos_309 := Token_Pos_476;

      else
         Row_Pos_309 := No_Token_Index;
         goto Exit_Row_308_0;

      end if;

      Nobt_36 := True;

      Row_Progress_37 := 2;

      if Row_Pos_309 /= No_Token_Index then

         Row_Pos_309 := Row_Pos_309;

      else
         Row_Pos_309 := No_Token_Index;
         goto Exit_Row_308_0;

      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_310 := Row_Pos_309;

      Defer_Res_513 := Defining_Id_Transform_Parse_0 (Parser, Row_Pos_310);
      Defer_Pos_513 := Parser.Current_Pos;

      if Defer_Pos_513 /= No_Token_Index then

         Row_Pos_310 := Defer_Pos_513;

      else
         Row_Pos_310 := No_Token_Index;
         goto Exit_Row_309_0;

      end if;

      Null_Res_14 := No_Bare_Ada_Node;

      if Row_Pos_310 /= No_Token_Index then

         Row_Pos_310 := Row_Pos_310;

      else
         Row_Pos_310 := No_Token_Index;
         goto Exit_Row_309_0;

      end if;

      Defer_Res_514 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_310);
      Defer_Pos_514 := Parser.Current_Pos;

      if Defer_Pos_514 /= No_Token_Index then

         Row_Pos_310 := Defer_Pos_514;

      else
         Row_Pos_310 := No_Token_Index;
         goto Exit_Row_309_0;

      end if;

--  Start opt_code

      Defer_Res_515 := Task_Def_Transform_Parse_3 (Parser, Row_Pos_310);
      Defer_Pos_515 := Parser.Current_Pos;

      if Defer_Pos_515 = No_Token_Index then

         Defer_Res_515 := No_Bare_Ada_Node;

         Defer_Pos_515 := Row_Pos_310;

      end if;

--  End opt_code

      if Defer_Pos_515 /= No_Token_Index then

         Row_Pos_310 := Defer_Pos_515;

      else
         Row_Pos_310 := No_Token_Index;
         goto Exit_Row_309_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_309_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_310 /= No_Token_Index then

         Transform_Res_247 := Allocate_Single_Task_Type_Decl (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_247, Kind => Ada_Single_Task_Type_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_309,
            Token_End_Index =>
              (if Row_Pos_310 = Row_Pos_309 then No_Token_Index
               else Row_Pos_310 - 1));

         Initialize_Fields_For_Single_Task_Type_Decl
           (Self => Transform_Res_247, Base_Type_Decl_F_Name => Defer_Res_513,
            Task_Type_Decl_F_Discriminants => Null_Res_14,
            Task_Type_Decl_F_Aspects       => Defer_Res_514,
            Task_Type_Decl_F_Definition    => Defer_Res_515);

         if Defer_Res_513 /= null and then Is_Incomplete (Defer_Res_513) then
            Transform_Res_247.Last_Attempted_Child := 0;
         elsif Defer_Res_513 /= null and then not Is_Ghost (Defer_Res_513) then
            Transform_Res_247.Last_Attempted_Child := -1;
         end if;
         if Null_Res_14 /= null and then Is_Incomplete (Null_Res_14) then
            Transform_Res_247.Last_Attempted_Child := 0;
         elsif Null_Res_14 /= null and then not Is_Ghost (Null_Res_14) then
            Transform_Res_247.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_514 /= null and then Is_Incomplete (Defer_Res_514) then
            Transform_Res_247.Last_Attempted_Child := 0;
         elsif Defer_Res_514 /= null and then not Is_Ghost (Defer_Res_514) then
            Transform_Res_247.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_515 /= null and then Is_Incomplete (Defer_Res_515) then
            Transform_Res_247.Last_Attempted_Child := 0;
         elsif Defer_Res_515 /= null and then not Is_Ghost (Defer_Res_515) then
            Transform_Res_247.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      Row_Progress_37 := 3;

      if Row_Pos_310 /= No_Token_Index then

         Row_Pos_309 := Row_Pos_310;

      else
         Row_Pos_309 := No_Token_Index;
         goto Exit_Row_308_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_477 := Row_Pos_309;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_477));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_477 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_309 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_309,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_477 := Row_Pos_309 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_477 = No_Token_Index then

         Token_Res_477 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_309).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_477 := Row_Pos_309;

      end if;

--  End opt_code

      Row_Progress_37 := 4;

      if Token_Pos_477 /= No_Token_Index then

         Row_Pos_309 := Token_Pos_477;

      else
         Row_Pos_309 := No_Token_Index;
         goto Exit_Row_308_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_308_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_309 = No_Token_Index and then Nobt_36 then
         Row_Pos_309             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_37 := True;
      end if;

      if Row_Pos_309 /= No_Token_Index then

         Transform_Res_248 := Allocate_Single_Task_Decl (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_248, Kind => Ada_Single_Task_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_309 = Pos then No_Token_Index else Row_Pos_309 - 1));

         Initialize_Fields_For_Single_Task_Decl
           (Self                         => Transform_Res_248,
            Single_Task_Decl_F_Task_Type => Transform_Res_247);

         if Transform_Res_247 /= null
           and then Is_Incomplete (Transform_Res_247)
         then
            Transform_Res_248.Last_Attempted_Child := 0;
         elsif Transform_Res_247 /= null
           and then not Is_Ghost (Transform_Res_247)
         then
            Transform_Res_248.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_37 then
            Transform_Res_248.Last_Attempted_Child := Row_Progress_37;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <single_task_decl>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Single_Task_Decl_Transform_Parse_1_Memo,
         Row_Pos_309 /= No_Token_Index, Transform_Res_248, Pos, Row_Pos_309);

      Parser.Current_Pos := Row_Pos_309;

      return Transform_Res_248;
   end Single_Task_Decl_Transform_Parse_1;

   function Protected_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Single_Protected_Decl
   is
      use Bare_Single_Protected_Decl_Memos;

      Row_Pos_311       : Token_Index                := No_Token_Index;
      Token_Pos_478     : Token_Index                := No_Token_Index;
      Token_Res_478     : Token_Index                := No_Token_Index;
      Defer_Pos_516     : Token_Index                := No_Token_Index;
      Defer_Res_516     : Bare_Defining_Name         := No_Bare_Ada_Node;
      Defer_Pos_517     : Token_Index                := No_Token_Index;
      Defer_Res_517     : Bare_Aspect_Spec           := No_Bare_Ada_Node;
      Token_Pos_479     : Token_Index                := No_Token_Index;
      Token_Res_479     : Token_Index                := No_Token_Index;
      Row_Pos_312       : Token_Index                := No_Token_Index;
      Token_Pos_480     : Token_Index                := No_Token_Index;
      Token_Res_480     : Token_Index                := No_Token_Index;
      Defer_Pos_518     : Token_Index                := No_Token_Index;
      Defer_Res_518     : Bare_Parent_List           := No_Bare_Ada_Node;
      Token_Pos_481     : Token_Index                := No_Token_Index;
      Token_Res_481     : Token_Index                := No_Token_Index;
      Defer_Pos_519     : Token_Index                := No_Token_Index;
      Defer_Res_519     : Bare_Protected_Def         := No_Bare_Ada_Node;
      Token_Pos_482     : Token_Index                := No_Token_Index;
      Token_Res_482     : Token_Index                := No_Token_Index;
      Transform_Res_249 : Bare_Single_Protected_Decl := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Protected_Decl_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_249  := M.Instance;
         return Transform_Res_249;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_249;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_311 := Pos;

--  Start tok_code

      Token_Res_478 := Row_Pos_311;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_478));
      begin
         if T.Kind /= From_Token_Kind (Ada_Identifier)
           or else T.Symbol /=
             Precomputed_Symbol
               (Parser.TDH.Symbols, Precomputed_Symbol_Protected)
         then
            Token_Pos_478 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_311 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_311,
                  Expected_Token_Id => Ada_Identifier,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_478 := Row_Pos_311 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_478 /= No_Token_Index then

         Row_Pos_311 := Token_Pos_478;

      else
         Row_Pos_311 := No_Token_Index;
         goto Exit_Row_310_0;

      end if;

      Defer_Res_516 := Defining_Id_Transform_Parse_0 (Parser, Row_Pos_311);
      Defer_Pos_516 := Parser.Current_Pos;

      if Defer_Pos_516 /= No_Token_Index then

         Row_Pos_311 := Defer_Pos_516;

      else
         Row_Pos_311 := No_Token_Index;
         goto Exit_Row_310_0;

      end if;

      Defer_Res_517 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_311);
      Defer_Pos_517 := Parser.Current_Pos;

      if Defer_Pos_517 /= No_Token_Index then

         Row_Pos_311 := Defer_Pos_517;

      else
         Row_Pos_311 := No_Token_Index;
         goto Exit_Row_310_0;

      end if;

--  Start tok_code

      Token_Res_479 := Row_Pos_311;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_479));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_479 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_311 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_311,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_479 := Row_Pos_311 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_479 /= No_Token_Index then

         Row_Pos_311 := Token_Pos_479;

      else
         Row_Pos_311 := No_Token_Index;
         goto Exit_Row_310_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_312 := Row_Pos_311;

--  Start tok_code

      Token_Res_480 := Row_Pos_312;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_480));
      begin
         if T.Kind /= From_Token_Kind (Ada_New) then
            Token_Pos_480 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_312 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_312,
                  Expected_Token_Id => Ada_New,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_480 := Row_Pos_312 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_480 /= No_Token_Index then

         Row_Pos_312 := Token_Pos_480;

      else
         Row_Pos_312 := No_Token_Index;
         goto Exit_Row_311_0;

      end if;

      Defer_Res_518 := Parent_List_List_Parse_0 (Parser, Row_Pos_312);
      Defer_Pos_518 := Parser.Current_Pos;

      if Defer_Pos_518 /= No_Token_Index then

         Row_Pos_312 := Defer_Pos_518;

      else
         Row_Pos_312 := No_Token_Index;
         goto Exit_Row_311_0;

      end if;

--  Start tok_code

      Token_Res_481 := Row_Pos_312;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_481));
      begin
         if T.Kind /= From_Token_Kind (Ada_With) then
            Token_Pos_481 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_312 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_312,
                  Expected_Token_Id => Ada_With,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_481 := Row_Pos_312 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_481 /= No_Token_Index then

         Row_Pos_312 := Token_Pos_481;

      else
         Row_Pos_312 := No_Token_Index;
         goto Exit_Row_311_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_311_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_312 = No_Token_Index then

         Defer_Res_518 := Allocate_Parent_List (Parser.Mem_Pool);
         Initialize
           (Self            => Defer_Res_518, Kind => Ada_Parent_List,
            Unit => Parser.Unit, Token_Start_Index => Row_Pos_311 - 1,
            Token_End_Index => No_Token_Index);
         Initialize_List (Self => Defer_Res_518, Parser => Parser, Count => 0);

         Row_Pos_312 := Row_Pos_311;

      end if;

--  End opt_code

      if Row_Pos_312 /= No_Token_Index then

         Row_Pos_311 := Row_Pos_312;

      else
         Row_Pos_311 := No_Token_Index;
         goto Exit_Row_310_0;

      end if;

      Defer_Res_519 := Protected_Def_Transform_Parse_3 (Parser, Row_Pos_311);
      Defer_Pos_519 := Parser.Current_Pos;

      if Defer_Pos_519 /= No_Token_Index then

         Row_Pos_311 := Defer_Pos_519;

      else
         Row_Pos_311 := No_Token_Index;
         goto Exit_Row_310_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_482 := Row_Pos_311;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_482));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_482 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_311 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_311,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_482 := Row_Pos_311 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_482 = No_Token_Index then

         Token_Res_482 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_311).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_482 := Row_Pos_311;

      end if;

--  End opt_code

      if Token_Pos_482 /= No_Token_Index then

         Row_Pos_311 := Token_Pos_482;

      else
         Row_Pos_311 := No_Token_Index;
         goto Exit_Row_310_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_310_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_311 /= No_Token_Index then

         Transform_Res_249 := Allocate_Single_Protected_Decl (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_249, Kind => Ada_Single_Protected_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_311 = Pos then No_Token_Index else Row_Pos_311 - 1));

         Initialize_Fields_For_Single_Protected_Decl
           (Self                               => Transform_Res_249,
            Single_Protected_Decl_F_Name       => Defer_Res_516,
            Single_Protected_Decl_F_Aspects    => Defer_Res_517,
            Single_Protected_Decl_F_Interfaces => Defer_Res_518,
            Single_Protected_Decl_F_Definition => Defer_Res_519);

         if Defer_Res_516 /= null and then Is_Incomplete (Defer_Res_516) then
            Transform_Res_249.Last_Attempted_Child := 0;
         elsif Defer_Res_516 /= null and then not Is_Ghost (Defer_Res_516) then
            Transform_Res_249.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_517 /= null and then Is_Incomplete (Defer_Res_517) then
            Transform_Res_249.Last_Attempted_Child := 0;
         elsif Defer_Res_517 /= null and then not Is_Ghost (Defer_Res_517) then
            Transform_Res_249.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_518 /= null and then Is_Incomplete (Defer_Res_518) then
            Transform_Res_249.Last_Attempted_Child := 0;
         elsif Defer_Res_518 /= null and then not Is_Ghost (Defer_Res_518) then
            Transform_Res_249.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_519 /= null and then Is_Incomplete (Defer_Res_519) then
            Transform_Res_249.Last_Attempted_Child := 0;
         elsif Defer_Res_519 /= null and then not Is_Ghost (Defer_Res_519) then
            Transform_Res_249.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Protected_Decl_Transform_Parse_0_Memo,
         Row_Pos_311 /= No_Token_Index, Transform_Res_249, Pos, Row_Pos_311);

      Parser.Current_Pos := Row_Pos_311;

      return Transform_Res_249;
   end Protected_Decl_Transform_Parse_0;

   function Number_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Number_Decl
   is
      use Bare_Number_Decl_Memos;

      Nobt_37                 : Boolean                 := False;
      Row_Pos_313             : Token_Index             := No_Token_Index;
      Defer_Pos_520           : Token_Index             := No_Token_Index;
      Defer_Res_520           : Bare_Defining_Name_List := No_Bare_Ada_Node;
      Token_Pos_483           : Token_Index             := No_Token_Index;
      Token_Res_483           : Token_Index             := No_Token_Index;
      Token_Pos_484           : Token_Index             := No_Token_Index;
      Token_Res_484           : Token_Index             := No_Token_Index;
      Token_Pos_485           : Token_Index             := No_Token_Index;
      Token_Res_485           : Token_Index             := No_Token_Index;
      Defer_Pos_521           : Token_Index             := No_Token_Index;
      Defer_Res_521           : Bare_Expr               := No_Bare_Ada_Node;
      Token_Pos_486           : Token_Index             := No_Token_Index;
      Token_Res_486           : Token_Index             := No_Token_Index;
      Row_Progress_38         : Integer                 := 0;
      Transform_Res_250       : Bare_Number_Decl        := No_Bare_Ada_Node;
      Transform_Has_Failed_38 : Boolean                 := False;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Number_Decl_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_250  := M.Instance;
         return Transform_Res_250;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_250;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_313 := Pos;

      Defer_Res_520 := Defining_Id_List_List_Parse_0 (Parser, Row_Pos_313);
      Defer_Pos_520 := Parser.Current_Pos;

      Row_Progress_38 := 1;

      if Defer_Pos_520 /= No_Token_Index then

         Row_Pos_313 := Defer_Pos_520;

      else
         Row_Pos_313 := No_Token_Index;
         goto Exit_Row_312_0;

      end if;

--  Start tok_code

      Token_Res_483 := Row_Pos_313;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_483));
      begin
         if T.Kind /= From_Token_Kind (Ada_Colon) then
            Token_Pos_483 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_313 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_313,
                  Expected_Token_Id => Ada_Colon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_483 := Row_Pos_313 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_38 := 2;

      if Token_Pos_483 /= No_Token_Index then

         Row_Pos_313 := Token_Pos_483;

      else
         Row_Pos_313 := No_Token_Index;
         goto Exit_Row_312_0;

      end if;

--  Start tok_code

      Token_Res_484 := Row_Pos_313;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_484));
      begin
         if T.Kind /= From_Token_Kind (Ada_Constant) then
            Token_Pos_484 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_313 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_313,
                  Expected_Token_Id => Ada_Constant,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_484 := Row_Pos_313 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_38 := 3;

      if Token_Pos_484 /= No_Token_Index then

         Row_Pos_313 := Token_Pos_484;

      else
         Row_Pos_313 := No_Token_Index;
         goto Exit_Row_312_0;

      end if;

      Nobt_37 := True;

      Row_Progress_38 := 4;

      if Row_Pos_313 /= No_Token_Index then

         Row_Pos_313 := Row_Pos_313;

      else
         Row_Pos_313 := No_Token_Index;
         goto Exit_Row_312_0;

      end if;

--  Start tok_code

      Token_Res_485 := Row_Pos_313;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_485));
      begin
         if T.Kind /= From_Token_Kind (Ada_Assign) then
            Token_Pos_485 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_313 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_313,
                  Expected_Token_Id => Ada_Assign,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_485 := Row_Pos_313 + 1;
         end if;
      end;

--  End tok_code

      Row_Progress_38 := 5;

      if Token_Pos_485 /= No_Token_Index then

         Row_Pos_313 := Token_Pos_485;

      else
         Row_Pos_313 := No_Token_Index;
         goto Exit_Row_312_0;

      end if;

      Defer_Res_521 := Simple_Expr_Or_Parse_1 (Parser, Row_Pos_313);
      Defer_Pos_521 := Parser.Current_Pos;

      Row_Progress_38 := 6;

      if Defer_Pos_521 /= No_Token_Index then

         Row_Pos_313 := Defer_Pos_521;

      else
         Row_Pos_313 := No_Token_Index;
         goto Exit_Row_312_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_486 := Row_Pos_313;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_486));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_486 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_313 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_313,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_486 := Row_Pos_313 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_486 = No_Token_Index then

         Token_Res_486 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_313).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_486 := Row_Pos_313;

      end if;

--  End opt_code

      Row_Progress_38 := 7;

      if Token_Pos_486 /= No_Token_Index then

         Row_Pos_313 := Token_Pos_486;

      else
         Row_Pos_313 := No_Token_Index;
         goto Exit_Row_312_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_312_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_313 = No_Token_Index and then Nobt_37 then
         Row_Pos_313             := Parser.Last_Fail.Pos;
         Transform_Has_Failed_38 := True;
      end if;

      if Row_Pos_313 /= No_Token_Index then

         Transform_Res_250 := Allocate_Number_Decl (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_250, Kind => Ada_Number_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_313 = Pos then No_Token_Index else Row_Pos_313 - 1));

         Initialize_Fields_For_Number_Decl
           (Self => Transform_Res_250, Number_Decl_F_Ids => Defer_Res_520,
            Number_Decl_F_Expr => Defer_Res_521);

         if Defer_Res_520 /= null and then Is_Incomplete (Defer_Res_520) then
            Transform_Res_250.Last_Attempted_Child := 0;
         elsif Defer_Res_520 /= null and then not Is_Ghost (Defer_Res_520) then
            Transform_Res_250.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_521 /= null and then Is_Incomplete (Defer_Res_521) then
            Transform_Res_250.Last_Attempted_Child := 0;
         elsif Defer_Res_521 /= null and then not Is_Ghost (Defer_Res_521) then
            Transform_Res_250.Last_Attempted_Child := -1;
         end if;

         if Transform_Has_Failed_38 then
            Transform_Res_250.Last_Attempted_Child := Row_Progress_38;

            Append
              (Parser.Diagnostics, Get_Token (Parser.TDH.all, Pos).Sloc_Range,
               To_Text ("Cannot parse <number_decl>"));

            Add_Last_Fail_Diagnostic (Parser);
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Number_Decl_Transform_Parse_0_Memo,
         Row_Pos_313 /= No_Token_Index, Transform_Res_250, Pos, Row_Pos_313);

      Parser.Current_Pos := Row_Pos_313;

      return Transform_Res_250;
   end Number_Decl_Transform_Parse_0;

   function Object_Decl_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Basic_Decl
   is
      use Bare_Basic_Decl_Memos;

      Defer_Pos_503 : Token_Index                := No_Token_Index;
      Defer_Res_503 : Bare_Object_Decl           := No_Bare_Ada_Node;
      Defer_Pos_504 : Token_Index                := No_Token_Index;
      Defer_Res_504 : Bare_Single_Task_Decl      := No_Bare_Ada_Node;
      Defer_Pos_505 : Token_Index                := No_Token_Index;
      Defer_Res_505 : Bare_Single_Protected_Decl := No_Bare_Ada_Node;
      Defer_Pos_506 : Token_Index                := No_Token_Index;
      Defer_Res_506 : Bare_Number_Decl           := No_Bare_Ada_Node;
      Or_Pos_93     : Token_Index                := No_Token_Index;
      Or_Res_93     : Bare_Basic_Decl            := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Object_Decl_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_93          := M.Instance;
         return Or_Res_93;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_93;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_93 := No_Token_Index;
      Or_Res_93 := No_Bare_Ada_Node;

      Defer_Res_503 := Sub_Object_Decl_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_503 := Parser.Current_Pos;

      if Defer_Pos_503 /= No_Token_Index then
         Or_Pos_93 := Defer_Pos_503;
         Or_Res_93 := Defer_Res_503;
         goto Exit_Or_94;
      end if;

      Defer_Res_504 := Single_Task_Decl_Transform_Parse_1 (Parser, Pos);
      Defer_Pos_504 := Parser.Current_Pos;

      if Defer_Pos_504 /= No_Token_Index then
         Or_Pos_93 := Defer_Pos_504;
         Or_Res_93 := Defer_Res_504;
         goto Exit_Or_94;
      end if;

      Defer_Res_505 := Protected_Decl_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_505 := Parser.Current_Pos;

      if Defer_Pos_505 /= No_Token_Index then
         Or_Pos_93 := Defer_Pos_505;
         Or_Res_93 := Defer_Res_505;
         goto Exit_Or_94;
      end if;

      Defer_Res_506 := Number_Decl_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_506 := Parser.Current_Pos;

      if Defer_Pos_506 /= No_Token_Index then
         Or_Pos_93 := Defer_Pos_506;
         Or_Res_93 := Defer_Res_506;
         goto Exit_Or_94;
      end if;
      <<Exit_Or_94>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Object_Decl_Or_Parse_0_Memo,
         Or_Pos_93 /= No_Token_Index, Or_Res_93, Pos, Or_Pos_93);

      Parser.Current_Pos := Or_Pos_93;

      return Or_Res_93;
   end Object_Decl_Or_Parse_0;

   function Package_Decl_Transform_Parse_3
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Package_Decl
   is
      use Bare_Package_Decl_Memos;

      Row_Pos_314       : Token_Index        := No_Token_Index;
      Token_Pos_487     : Token_Index        := No_Token_Index;
      Token_Res_487     : Token_Index        := No_Token_Index;
      Defer_Pos_522     : Token_Index        := No_Token_Index;
      Defer_Res_522     : Bare_Defining_Name := No_Bare_Ada_Node;
      Defer_Pos_523     : Token_Index        := No_Token_Index;
      Defer_Res_523     : Bare_Aspect_Spec   := No_Bare_Ada_Node;
      Token_Pos_488     : Token_Index        := No_Token_Index;
      Token_Res_488     : Token_Index        := No_Token_Index;
      Row_Pos_315       : Token_Index        := No_Token_Index;
      Defer_Pos_524     : Token_Index        := No_Token_Index;
      Defer_Res_524     : Bare_Ada_Node_List := No_Bare_Ada_Node;
      Transform_Res_251 : Bare_Public_Part   := No_Bare_Ada_Node;
      Row_Pos_316       : Token_Index        := No_Token_Index;
      Token_Pos_489     : Token_Index        := No_Token_Index;
      Token_Res_489     : Token_Index        := No_Token_Index;
      Row_Pos_317       : Token_Index        := No_Token_Index;
      Defer_Pos_525     : Token_Index        := No_Token_Index;
      Defer_Res_525     : Bare_Ada_Node_List := No_Bare_Ada_Node;
      Transform_Res_252 : Bare_Private_Part  := No_Bare_Ada_Node;
      Row_Pos_318       : Token_Index        := No_Token_Index;
      Token_Pos_490     : Token_Index        := No_Token_Index;
      Token_Res_490     : Token_Index        := No_Token_Index;
      Row_Pos_319       : Token_Index        := No_Token_Index;
      Defer_Pos_526     : Token_Index        := No_Token_Index;
      Defer_Res_526     : Bare_Name          := No_Bare_Ada_Node;
      Transform_Res_253 : Bare_End_Name      := No_Bare_Ada_Node;
      Token_Pos_491     : Token_Index        := No_Token_Index;
      Token_Res_491     : Token_Index        := No_Token_Index;
      Transform_Res_254 : Bare_Package_Decl  := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Package_Decl_Transform_Parse_3_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_254  := M.Instance;
         return Transform_Res_254;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_254;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_314 := Pos;

--  Start tok_code

      Token_Res_487 := Row_Pos_314;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_487));
      begin
         if T.Kind /= From_Token_Kind (Ada_Package) then
            Token_Pos_487 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_314 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_314,
                  Expected_Token_Id => Ada_Package,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_487 := Row_Pos_314 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_487 /= No_Token_Index then

         Row_Pos_314 := Token_Pos_487;

      else
         Row_Pos_314 := No_Token_Index;
         goto Exit_Row_313_0;

      end if;

      Defer_Res_522 := Defining_Name_Transform_Parse_0 (Parser, Row_Pos_314);
      Defer_Pos_522 := Parser.Current_Pos;

      if Defer_Pos_522 /= No_Token_Index then

         Row_Pos_314 := Defer_Pos_522;

      else
         Row_Pos_314 := No_Token_Index;
         goto Exit_Row_313_0;

      end if;

      Defer_Res_523 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_314);
      Defer_Pos_523 := Parser.Current_Pos;

      if Defer_Pos_523 /= No_Token_Index then

         Row_Pos_314 := Defer_Pos_523;

      else
         Row_Pos_314 := No_Token_Index;
         goto Exit_Row_313_0;

      end if;

--  Start tok_code

      Token_Res_488 := Row_Pos_314;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_488));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_488 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_314 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_314,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_488 := Row_Pos_314 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_488 /= No_Token_Index then

         Row_Pos_314 := Token_Pos_488;

      else
         Row_Pos_314 := No_Token_Index;
         goto Exit_Row_313_0;

      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_315 := Row_Pos_314;

      Parser.Private_Part.Dont_Skip.Append
        (Dontskip_Package_Decl_0_Extract_Parse_0'Access);

      Defer_Res_524 := Basic_Decls_List_Parse_0 (Parser, Row_Pos_315);
      Defer_Pos_524 := Parser.Current_Pos;

      Parser.Private_Part.Dont_Skip.Delete_Last;

      if Defer_Pos_524 /= No_Token_Index then

         Row_Pos_315 := Defer_Pos_524;

      else
         Row_Pos_315 := No_Token_Index;
         goto Exit_Row_314_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_314_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_315 /= No_Token_Index then

         Transform_Res_251 := Allocate_Public_Part (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_251, Kind => Ada_Public_Part,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_314,
            Token_End_Index =>
              (if Row_Pos_315 = Row_Pos_314 then No_Token_Index
               else Row_Pos_315 - 1));

         Initialize_Fields_For_Public_Part
           (Self                     => Transform_Res_251,
            Declarative_Part_F_Decls => Defer_Res_524);

         if Defer_Res_524 /= null and then Is_Incomplete (Defer_Res_524) then
            Transform_Res_251.Last_Attempted_Child := 0;
         elsif Defer_Res_524 /= null and then not Is_Ghost (Defer_Res_524) then
            Transform_Res_251.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_315 /= No_Token_Index then

         Row_Pos_314 := Row_Pos_315;

      else
         Row_Pos_314 := No_Token_Index;
         goto Exit_Row_313_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_316 := Row_Pos_314;

--  Start tok_code

      Token_Res_489 := Row_Pos_316;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_489));
      begin
         if T.Kind /= From_Token_Kind (Ada_Private) then
            Token_Pos_489 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_316 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_316,
                  Expected_Token_Id => Ada_Private,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_489 := Row_Pos_316 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_489 /= No_Token_Index then

         Row_Pos_316 := Token_Pos_489;

      else
         Row_Pos_316 := No_Token_Index;
         goto Exit_Row_315_0;

      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_317 := Row_Pos_316;

      Parser.Private_Part.Dont_Skip.Append
        (Dontskip_Package_Decl_1_Extract_Parse_0'Access);

      Defer_Res_525 := Basic_Decls_List_Parse_0 (Parser, Row_Pos_317);
      Defer_Pos_525 := Parser.Current_Pos;

      Parser.Private_Part.Dont_Skip.Delete_Last;

      if Defer_Pos_525 /= No_Token_Index then

         Row_Pos_317 := Defer_Pos_525;

      else
         Row_Pos_317 := No_Token_Index;
         goto Exit_Row_316_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_316_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_317 /= No_Token_Index then

         Transform_Res_252 := Allocate_Private_Part (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_252, Kind => Ada_Private_Part,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_316,
            Token_End_Index =>
              (if Row_Pos_317 = Row_Pos_316 then No_Token_Index
               else Row_Pos_317 - 1));

         Initialize_Fields_For_Private_Part
           (Self                     => Transform_Res_252,
            Declarative_Part_F_Decls => Defer_Res_525);

         if Defer_Res_525 /= null and then Is_Incomplete (Defer_Res_525) then
            Transform_Res_252.Last_Attempted_Child := 0;
         elsif Defer_Res_525 /= null and then not Is_Ghost (Defer_Res_525) then
            Transform_Res_252.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_317 /= No_Token_Index then

         Row_Pos_316 := Row_Pos_317;

      else
         Row_Pos_316 := No_Token_Index;
         goto Exit_Row_315_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_315_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_316 = No_Token_Index then

         Transform_Res_252 := No_Bare_Ada_Node;

         Row_Pos_316 := Row_Pos_314;

      end if;

--  End opt_code

      if Row_Pos_316 /= No_Token_Index then

         Row_Pos_314 := Row_Pos_316;

      else
         Row_Pos_314 := No_Token_Index;
         goto Exit_Row_313_0;

      end if;

--  Start row_code

      Row_Pos_318 := Row_Pos_314;

--  Start tok_code

      Token_Res_490 := Row_Pos_318;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_490));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_490 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_318 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_318,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_490 := Row_Pos_318 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_490 /= No_Token_Index then

         Row_Pos_318 := Token_Pos_490;

      else
         Row_Pos_318 := No_Token_Index;
         goto Exit_Row_317_0;

      end if;

--  Start opt_code

--  Start transform_code

--  Start row_code

      Row_Pos_319 := Row_Pos_318;

      Defer_Res_526 := Static_Name_Or_Parse_0 (Parser, Row_Pos_319);
      Defer_Pos_526 := Parser.Current_Pos;

      if Defer_Pos_526 /= No_Token_Index then

         Row_Pos_319 := Defer_Pos_526;

      else
         Row_Pos_319 := No_Token_Index;
         goto Exit_Row_318_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_318_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_319 /= No_Token_Index then

         Transform_Res_253 := Allocate_End_Name (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_253, Kind => Ada_End_Name,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_318,
            Token_End_Index =>
              (if Row_Pos_319 = Row_Pos_318 then No_Token_Index
               else Row_Pos_319 - 1));

         Initialize_Fields_For_End_Name
           (Self => Transform_Res_253, End_Name_F_Name => Defer_Res_526);

         if Defer_Res_526 /= null and then Is_Incomplete (Defer_Res_526) then
            Transform_Res_253.Last_Attempted_Child := 0;
         elsif Defer_Res_526 /= null and then not Is_Ghost (Defer_Res_526) then
            Transform_Res_253.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_319 = No_Token_Index then

         Transform_Res_253 := No_Bare_Ada_Node;

         Row_Pos_319 := Row_Pos_318;

      end if;

--  End opt_code

      if Row_Pos_319 /= No_Token_Index then

         Row_Pos_318 := Row_Pos_319;

      else
         Row_Pos_318 := No_Token_Index;
         goto Exit_Row_317_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_317_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_318 /= No_Token_Index then

         Row_Pos_314 := Row_Pos_318;

      else
         Row_Pos_314 := No_Token_Index;
         goto Exit_Row_313_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_491 := Row_Pos_314;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_491));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_491 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_314 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_314,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_491 := Row_Pos_314 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_491 = No_Token_Index then

         Token_Res_491 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_314).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_491 := Row_Pos_314;

      end if;

--  End opt_code

      if Token_Pos_491 /= No_Token_Index then

         Row_Pos_314 := Token_Pos_491;

      else
         Row_Pos_314 := No_Token_Index;
         goto Exit_Row_313_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_313_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_314 /= No_Token_Index then

         Transform_Res_254 := Allocate_Package_Decl (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_254, Kind => Ada_Package_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_314 = Pos then No_Token_Index else Row_Pos_314 - 1));

         Initialize_Fields_For_Package_Decl
           (Self                             => Transform_Res_254,
            Base_Package_Decl_F_Package_Name => Defer_Res_522,
            Base_Package_Decl_F_Aspects      => Defer_Res_523,
            Base_Package_Decl_F_Public_Part  => Transform_Res_251,
            Base_Package_Decl_F_Private_Part => Transform_Res_252,
            Base_Package_Decl_F_End_Name     => Transform_Res_253);

         if Defer_Res_522 /= null and then Is_Incomplete (Defer_Res_522) then
            Transform_Res_254.Last_Attempted_Child := 0;
         elsif Defer_Res_522 /= null and then not Is_Ghost (Defer_Res_522) then
            Transform_Res_254.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_523 /= null and then Is_Incomplete (Defer_Res_523) then
            Transform_Res_254.Last_Attempted_Child := 0;
         elsif Defer_Res_523 /= null and then not Is_Ghost (Defer_Res_523) then
            Transform_Res_254.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_251 /= null
           and then Is_Incomplete (Transform_Res_251)
         then
            Transform_Res_254.Last_Attempted_Child := 0;
         elsif Transform_Res_251 /= null
           and then not Is_Ghost (Transform_Res_251)
         then
            Transform_Res_254.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_252 /= null
           and then Is_Incomplete (Transform_Res_252)
         then
            Transform_Res_254.Last_Attempted_Child := 0;
         elsif Transform_Res_252 /= null
           and then not Is_Ghost (Transform_Res_252)
         then
            Transform_Res_254.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_253 /= null
           and then Is_Incomplete (Transform_Res_253)
         then
            Transform_Res_254.Last_Attempted_Child := 0;
         elsif Transform_Res_253 /= null
           and then not Is_Ghost (Transform_Res_253)
         then
            Transform_Res_254.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Package_Decl_Transform_Parse_3_Memo,
         Row_Pos_314 /= No_Token_Index, Transform_Res_254, Pos, Row_Pos_314);

      Parser.Current_Pos := Row_Pos_314;

      return Transform_Res_254;
   end Package_Decl_Transform_Parse_3;

   function Use_Package_Clause_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Use_Package_Clause
   is
      use Bare_Use_Package_Clause_Memos;

      Row_Pos_320       : Token_Index             := No_Token_Index;
      Token_Pos_492     : Token_Index             := No_Token_Index;
      Token_Res_492     : Token_Index             := No_Token_Index;
      Lst_Cpos_40       : Token_Index             := No_Token_Index;
      Tmp_List_40       : Free_Parse_List;
      Defer_Pos_529     : Token_Index             := No_Token_Index;
      Defer_Res_529     : Bare_Name               := No_Bare_Ada_Node;
      Token_Pos_493     : Token_Index             := No_Token_Index;
      Token_Res_493     : Token_Index             := No_Token_Index;
      List_Pos_40       : Token_Index             := No_Token_Index;
      List_Res_40       : Bare_Name_List          := No_Bare_Ada_Node;
      Token_Pos_494     : Token_Index             := No_Token_Index;
      Token_Res_494     : Token_Index             := No_Token_Index;
      Transform_Res_255 : Bare_Use_Package_Clause := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Use_Package_Clause_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_255  := M.Instance;
         return Transform_Res_255;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_255;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_320 := Pos;

--  Start tok_code

      Token_Res_492 := Row_Pos_320;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_492));
      begin
         if T.Kind /= From_Token_Kind (Ada_Use) then
            Token_Pos_492 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_320 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_320,
                  Expected_Token_Id => Ada_Use,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_492 := Row_Pos_320 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_492 /= No_Token_Index then

         Row_Pos_320 := Token_Pos_492;

      else
         Row_Pos_320 := No_Token_Index;
         goto Exit_Row_319_0;

      end if;

--  Start list_code

      List_Pos_40 := No_Token_Index;

      Lst_Cpos_40 := Row_Pos_320;
      Tmp_List_40 := Get_Parse_List (Parser);

      loop

         Defer_Res_529 := Static_Name_Or_Parse_0 (Parser, Lst_Cpos_40);
         Defer_Pos_529 := Parser.Current_Pos;

         exit when Defer_Pos_529 = No_Token_Index;

         List_Pos_40 := Defer_Pos_529;
         Lst_Cpos_40 := List_Pos_40;

         Tmp_List_40.Nodes.Append (Defer_Res_529);

--  Start tok_code

         Token_Res_493 := Lst_Cpos_40;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_493));
         begin
            if T.Kind /= From_Token_Kind (Ada_Comma) then
               Token_Pos_493 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_40 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_40,
                     Expected_Token_Id => Ada_Comma,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_493 := Lst_Cpos_40 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_493 /= No_Token_Index then
            Lst_Cpos_40 := Token_Pos_493;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_40.Nodes.Length;
      begin
         List_Res_40 := Allocate_Name_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_320;
            Token_End   :=
              (if Lst_Cpos_40 = Row_Pos_320 then Row_Pos_320
               else Lst_Cpos_40 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_320, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self => List_Res_40, Kind => Ada_Name_List, Unit => Parser.Unit,
            Token_Start_Index => Token_Start, Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_40, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_40.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_40.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_40);

--  End list_code

      if List_Pos_40 /= No_Token_Index then

         Row_Pos_320 := List_Pos_40;

      else
         Row_Pos_320 := No_Token_Index;
         goto Exit_Row_319_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_494 := Row_Pos_320;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_494));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_494 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_320 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_320,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_494 := Row_Pos_320 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_494 = No_Token_Index then

         Token_Res_494 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_320).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_494 := Row_Pos_320;

      end if;

--  End opt_code

      if Token_Pos_494 /= No_Token_Index then

         Row_Pos_320 := Token_Pos_494;

      else
         Row_Pos_320 := No_Token_Index;
         goto Exit_Row_319_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_319_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_320 /= No_Token_Index then

         Transform_Res_255 := Allocate_Use_Package_Clause (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_255, Kind => Ada_Use_Package_Clause,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_320 = Pos then No_Token_Index else Row_Pos_320 - 1));

         Initialize_Fields_For_Use_Package_Clause
           (Self                          => Transform_Res_255,
            Use_Package_Clause_F_Packages => List_Res_40);

         if List_Res_40 /= null and then Is_Incomplete (List_Res_40) then
            Transform_Res_255.Last_Attempted_Child := 0;
         elsif List_Res_40 /= null and then not Is_Ghost (List_Res_40) then
            Transform_Res_255.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Use_Package_Clause_Transform_Parse_0_Memo,
         Row_Pos_320 /= No_Token_Index, Transform_Res_255, Pos, Row_Pos_320);

      Parser.Current_Pos := Row_Pos_320;

      return Transform_Res_255;
   end Use_Package_Clause_Transform_Parse_0;

   function Use_Type_Clause_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Use_Type_Clause
   is
      use Bare_Use_Type_Clause_Memos;

      Row_Pos_321       : Token_Index          := No_Token_Index;
      Token_Pos_495     : Token_Index          := No_Token_Index;
      Token_Res_495     : Token_Index          := No_Token_Index;
      Token_Pos_496     : Token_Index          := No_Token_Index;
      Token_Res_496     : Token_Index          := No_Token_Index;
      Opt_Res_29        : Bare_All_Node        := No_Bare_Ada_Node;
      Token_Pos_497     : Token_Index          := No_Token_Index;
      Token_Res_497     : Token_Index          := No_Token_Index;
      Lst_Cpos_41       : Token_Index          := No_Token_Index;
      Tmp_List_41       : Free_Parse_List;
      Defer_Pos_530     : Token_Index          := No_Token_Index;
      Defer_Res_530     : Bare_Name            := No_Bare_Ada_Node;
      Token_Pos_498     : Token_Index          := No_Token_Index;
      Token_Res_498     : Token_Index          := No_Token_Index;
      List_Pos_41       : Token_Index          := No_Token_Index;
      List_Res_41       : Bare_Name_List       := No_Bare_Ada_Node;
      Token_Pos_499     : Token_Index          := No_Token_Index;
      Token_Res_499     : Token_Index          := No_Token_Index;
      Transform_Res_256 : Bare_Use_Type_Clause := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Use_Type_Clause_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_256  := M.Instance;
         return Transform_Res_256;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_256;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_321 := Pos;

--  Start tok_code

      Token_Res_495 := Row_Pos_321;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_495));
      begin
         if T.Kind /= From_Token_Kind (Ada_Use) then
            Token_Pos_495 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_321 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_321,
                  Expected_Token_Id => Ada_Use,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_495 := Row_Pos_321 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_495 /= No_Token_Index then

         Row_Pos_321 := Token_Pos_495;

      else
         Row_Pos_321 := No_Token_Index;
         goto Exit_Row_320_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_496 := Row_Pos_321;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_496));
      begin
         if T.Kind /= From_Token_Kind (Ada_All) then
            Token_Pos_496 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_321 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_321,
                  Expected_Token_Id => Ada_All,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_496 := Row_Pos_321 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_496 = No_Token_Index then

         Opt_Res_29 := Allocate_All_Absent (Parser.Mem_Pool);
         Initialize
           (Self => Opt_Res_29, Kind => Ada_All_Absent, Unit => Parser.Unit,
            Token_Start_Index => Row_Pos_321,
            Token_End_Index   => No_Token_Index);

         Token_Pos_496 := Row_Pos_321;

      else

         Opt_Res_29 := Allocate_All_Present (Parser.Mem_Pool);
         Initialize
           (Self => Opt_Res_29, Kind => Ada_All_Present, Unit => Parser.Unit,
            Token_Start_Index => Row_Pos_321,
            Token_End_Index   => Token_Pos_496 - 1);

      end if;

--  End opt_code

      if Token_Pos_496 /= No_Token_Index then

         Row_Pos_321 := Token_Pos_496;

      else
         Row_Pos_321 := No_Token_Index;
         goto Exit_Row_320_0;

      end if;

--  Start tok_code

      Token_Res_497 := Row_Pos_321;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_497));
      begin
         if T.Kind /= From_Token_Kind (Ada_Type) then
            Token_Pos_497 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_321 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_321,
                  Expected_Token_Id => Ada_Type,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_497 := Row_Pos_321 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_497 /= No_Token_Index then

         Row_Pos_321 := Token_Pos_497;

      else
         Row_Pos_321 := No_Token_Index;
         goto Exit_Row_320_0;

      end if;

--  Start list_code

      List_Pos_41 := No_Token_Index;

      Lst_Cpos_41 := Row_Pos_321;
      Tmp_List_41 := Get_Parse_List (Parser);

      loop

         Defer_Res_530 := Name_Or_Parse_1 (Parser, Lst_Cpos_41);
         Defer_Pos_530 := Parser.Current_Pos;

         exit when Defer_Pos_530 = No_Token_Index;

         List_Pos_41 := Defer_Pos_530;
         Lst_Cpos_41 := List_Pos_41;

         Tmp_List_41.Nodes.Append (Defer_Res_530);

--  Start tok_code

         Token_Res_498 := Lst_Cpos_41;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_498));
         begin
            if T.Kind /= From_Token_Kind (Ada_Comma) then
               Token_Pos_498 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_41 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_41,
                     Expected_Token_Id => Ada_Comma,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_498 := Lst_Cpos_41 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_498 /= No_Token_Index then
            Lst_Cpos_41 := Token_Pos_498;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_41.Nodes.Length;
      begin
         List_Res_41 := Allocate_Name_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_321;
            Token_End   :=
              (if Lst_Cpos_41 = Row_Pos_321 then Row_Pos_321
               else Lst_Cpos_41 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_321, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self => List_Res_41, Kind => Ada_Name_List, Unit => Parser.Unit,
            Token_Start_Index => Token_Start, Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_41, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_41.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_41.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_41);

--  End list_code

      if List_Pos_41 /= No_Token_Index then

         Row_Pos_321 := List_Pos_41;

      else
         Row_Pos_321 := No_Token_Index;
         goto Exit_Row_320_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_499 := Row_Pos_321;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_499));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_499 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_321 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_321,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_499 := Row_Pos_321 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_499 = No_Token_Index then

         Token_Res_499 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_321).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_499 := Row_Pos_321;

      end if;

--  End opt_code

      if Token_Pos_499 /= No_Token_Index then

         Row_Pos_321 := Token_Pos_499;

      else
         Row_Pos_321 := No_Token_Index;
         goto Exit_Row_320_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_320_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_321 /= No_Token_Index then

         Transform_Res_256 := Allocate_Use_Type_Clause (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_256, Kind => Ada_Use_Type_Clause,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_321 = Pos then No_Token_Index else Row_Pos_321 - 1));

         Initialize_Fields_For_Use_Type_Clause
           (Self => Transform_Res_256, Use_Type_Clause_F_Has_All => Opt_Res_29,
            Use_Type_Clause_F_Types => List_Res_41);

         if Opt_Res_29 /= null and then Is_Incomplete (Opt_Res_29) then
            Transform_Res_256.Last_Attempted_Child := 0;
         elsif Opt_Res_29 /= null and then not Is_Ghost (Opt_Res_29) then
            Transform_Res_256.Last_Attempted_Child := -1;
         end if;
         if List_Res_41 /= null and then Is_Incomplete (List_Res_41) then
            Transform_Res_256.Last_Attempted_Child := 0;
         elsif List_Res_41 /= null and then not Is_Ghost (List_Res_41) then
            Transform_Res_256.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Use_Type_Clause_Transform_Parse_0_Memo,
         Row_Pos_321 /= No_Token_Index, Transform_Res_256, Pos, Row_Pos_321);

      Parser.Current_Pos := Row_Pos_321;

      return Transform_Res_256;
   end Use_Type_Clause_Transform_Parse_0;

   function Use_Clause_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Use_Clause
   is
      use Bare_Use_Clause_Memos;

      Defer_Pos_527 : Token_Index             := No_Token_Index;
      Defer_Res_527 : Bare_Use_Package_Clause := No_Bare_Ada_Node;
      Defer_Pos_528 : Token_Index             := No_Token_Index;
      Defer_Res_528 : Bare_Use_Type_Clause    := No_Bare_Ada_Node;
      Or_Pos_94     : Token_Index             := No_Token_Index;
      Or_Res_94     : Bare_Use_Clause         := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Use_Clause_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_94          := M.Instance;
         return Or_Res_94;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_94;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_94 := No_Token_Index;
      Or_Res_94 := No_Bare_Ada_Node;

      Defer_Res_527 := Use_Package_Clause_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_527 := Parser.Current_Pos;

      if Defer_Pos_527 /= No_Token_Index then
         Or_Pos_94 := Defer_Pos_527;
         Or_Res_94 := Defer_Res_527;
         goto Exit_Or_95;
      end if;

      Defer_Res_528 := Use_Type_Clause_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_528 := Parser.Current_Pos;

      if Defer_Pos_528 /= No_Token_Index then
         Or_Pos_94 := Defer_Pos_528;
         Or_Res_94 := Defer_Res_528;
         goto Exit_Or_95;
      end if;
      <<Exit_Or_95>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Use_Clause_Or_Parse_0_Memo,
         Or_Pos_94 /= No_Token_Index, Or_Res_94, Pos, Or_Pos_94);

      Parser.Current_Pos := Or_Pos_94;

      return Or_Res_94;
   end Use_Clause_Or_Parse_0;

   function Exception_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Exception_Decl
   is
      use Bare_Exception_Decl_Memos;

      Row_Pos_322       : Token_Index             := No_Token_Index;
      Defer_Pos_531     : Token_Index             := No_Token_Index;
      Defer_Res_531     : Bare_Defining_Name_List := No_Bare_Ada_Node;
      Token_Pos_500     : Token_Index             := No_Token_Index;
      Token_Res_500     : Token_Index             := No_Token_Index;
      Token_Pos_501     : Token_Index             := No_Token_Index;
      Token_Res_501     : Token_Index             := No_Token_Index;
      Defer_Pos_532     : Token_Index             := No_Token_Index;
      Defer_Res_532     : Bare_Renaming_Clause    := No_Bare_Ada_Node;
      Defer_Pos_533     : Token_Index             := No_Token_Index;
      Defer_Res_533     : Bare_Aspect_Spec        := No_Bare_Ada_Node;
      Token_Pos_502     : Token_Index             := No_Token_Index;
      Token_Res_502     : Token_Index             := No_Token_Index;
      Transform_Res_257 : Bare_Exception_Decl     := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Exception_Decl_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_257  := M.Instance;
         return Transform_Res_257;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_257;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_322 := Pos;

      Defer_Res_531 := Defining_Id_List_List_Parse_0 (Parser, Row_Pos_322);
      Defer_Pos_531 := Parser.Current_Pos;

      if Defer_Pos_531 /= No_Token_Index then

         Row_Pos_322 := Defer_Pos_531;

      else
         Row_Pos_322 := No_Token_Index;
         goto Exit_Row_321_0;

      end if;

--  Start tok_code

      Token_Res_500 := Row_Pos_322;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_500));
      begin
         if T.Kind /= From_Token_Kind (Ada_Colon) then
            Token_Pos_500 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_322 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_322,
                  Expected_Token_Id => Ada_Colon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_500 := Row_Pos_322 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_500 /= No_Token_Index then

         Row_Pos_322 := Token_Pos_500;

      else
         Row_Pos_322 := No_Token_Index;
         goto Exit_Row_321_0;

      end if;

--  Start tok_code

      Token_Res_501 := Row_Pos_322;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_501));
      begin
         if T.Kind /= From_Token_Kind (Ada_Exception) then
            Token_Pos_501 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_322 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_322,
                  Expected_Token_Id => Ada_Exception,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_501 := Row_Pos_322 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_501 /= No_Token_Index then

         Row_Pos_322 := Token_Pos_501;

      else
         Row_Pos_322 := No_Token_Index;
         goto Exit_Row_321_0;

      end if;

--  Start opt_code

      Defer_Res_532 := Renaming_Clause_Transform_Parse_0 (Parser, Row_Pos_322);
      Defer_Pos_532 := Parser.Current_Pos;

      if Defer_Pos_532 = No_Token_Index then

         Defer_Res_532 := No_Bare_Ada_Node;

         Defer_Pos_532 := Row_Pos_322;

      end if;

--  End opt_code

      if Defer_Pos_532 /= No_Token_Index then

         Row_Pos_322 := Defer_Pos_532;

      else
         Row_Pos_322 := No_Token_Index;
         goto Exit_Row_321_0;

      end if;

      Defer_Res_533 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_322);
      Defer_Pos_533 := Parser.Current_Pos;

      if Defer_Pos_533 /= No_Token_Index then

         Row_Pos_322 := Defer_Pos_533;

      else
         Row_Pos_322 := No_Token_Index;
         goto Exit_Row_321_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_502 := Row_Pos_322;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_502));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_502 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_322 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_322,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_502 := Row_Pos_322 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_502 = No_Token_Index then

         Token_Res_502 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_322).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_502 := Row_Pos_322;

      end if;

--  End opt_code

      if Token_Pos_502 /= No_Token_Index then

         Row_Pos_322 := Token_Pos_502;

      else
         Row_Pos_322 := No_Token_Index;
         goto Exit_Row_321_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_321_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_322 /= No_Token_Index then

         Transform_Res_257 := Allocate_Exception_Decl (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_257, Kind => Ada_Exception_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_322 = Pos then No_Token_Index else Row_Pos_322 - 1));

         Initialize_Fields_For_Exception_Decl
           (Self => Transform_Res_257, Exception_Decl_F_Ids => Defer_Res_531,
            Exception_Decl_F_Renames => Defer_Res_532,
            Exception_Decl_F_Aspects => Defer_Res_533);

         if Defer_Res_531 /= null and then Is_Incomplete (Defer_Res_531) then
            Transform_Res_257.Last_Attempted_Child := 0;
         elsif Defer_Res_531 /= null and then not Is_Ghost (Defer_Res_531) then
            Transform_Res_257.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_532 /= null and then Is_Incomplete (Defer_Res_532) then
            Transform_Res_257.Last_Attempted_Child := 0;
         elsif Defer_Res_532 /= null and then not Is_Ghost (Defer_Res_532) then
            Transform_Res_257.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_533 /= null and then Is_Incomplete (Defer_Res_533) then
            Transform_Res_257.Last_Attempted_Child := 0;
         elsif Defer_Res_533 /= null and then not Is_Ghost (Defer_Res_533) then
            Transform_Res_257.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Exception_Decl_Transform_Parse_0_Memo,
         Row_Pos_322 /= No_Token_Index, Transform_Res_257, Pos, Row_Pos_322);

      Parser.Current_Pos := Row_Pos_322;

      return Transform_Res_257;
   end Exception_Decl_Transform_Parse_0;

   function Package_Renaming_Decl_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Package_Renaming_Decl
   is
      use Bare_Package_Renaming_Decl_Memos;

      Row_Pos_323       : Token_Index                := No_Token_Index;
      Token_Pos_503     : Token_Index                := No_Token_Index;
      Token_Res_503     : Token_Index                := No_Token_Index;
      Defer_Pos_534     : Token_Index                := No_Token_Index;
      Defer_Res_534     : Bare_Defining_Name         := No_Bare_Ada_Node;
      Defer_Pos_535     : Token_Index                := No_Token_Index;
      Defer_Res_535     : Bare_Renaming_Clause       := No_Bare_Ada_Node;
      Defer_Pos_536     : Token_Index                := No_Token_Index;
      Defer_Res_536     : Bare_Aspect_Spec           := No_Bare_Ada_Node;
      Token_Pos_504     : Token_Index                := No_Token_Index;
      Token_Res_504     : Token_Index                := No_Token_Index;
      Transform_Res_258 : Bare_Package_Renaming_Decl := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Package_Renaming_Decl_Transform_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_258  := M.Instance;
         return Transform_Res_258;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_258;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_323 := Pos;

--  Start tok_code

      Token_Res_503 := Row_Pos_323;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_503));
      begin
         if T.Kind /= From_Token_Kind (Ada_Package) then
            Token_Pos_503 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_323 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_323,
                  Expected_Token_Id => Ada_Package,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_503 := Row_Pos_323 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_503 /= No_Token_Index then

         Row_Pos_323 := Token_Pos_503;

      else
         Row_Pos_323 := No_Token_Index;
         goto Exit_Row_322_0;

      end if;

      Defer_Res_534 := Defining_Name_Transform_Parse_0 (Parser, Row_Pos_323);
      Defer_Pos_534 := Parser.Current_Pos;

      if Defer_Pos_534 /= No_Token_Index then

         Row_Pos_323 := Defer_Pos_534;

      else
         Row_Pos_323 := No_Token_Index;
         goto Exit_Row_322_0;

      end if;

      Defer_Res_535 := Renaming_Clause_Transform_Parse_0 (Parser, Row_Pos_323);
      Defer_Pos_535 := Parser.Current_Pos;

      if Defer_Pos_535 /= No_Token_Index then

         Row_Pos_323 := Defer_Pos_535;

      else
         Row_Pos_323 := No_Token_Index;
         goto Exit_Row_322_0;

      end if;

      Defer_Res_536 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_323);
      Defer_Pos_536 := Parser.Current_Pos;

      if Defer_Pos_536 /= No_Token_Index then

         Row_Pos_323 := Defer_Pos_536;

      else
         Row_Pos_323 := No_Token_Index;
         goto Exit_Row_322_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_504 := Row_Pos_323;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_504));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_504 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_323 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_323,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_504 := Row_Pos_323 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_504 = No_Token_Index then

         Token_Res_504 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_323).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_504 := Row_Pos_323;

      end if;

--  End opt_code

      if Token_Pos_504 /= No_Token_Index then

         Row_Pos_323 := Token_Pos_504;

      else
         Row_Pos_323 := No_Token_Index;
         goto Exit_Row_322_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_322_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_323 /= No_Token_Index then

         Transform_Res_258 := Allocate_Package_Renaming_Decl (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_258, Kind => Ada_Package_Renaming_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_323 = Pos then No_Token_Index else Row_Pos_323 - 1));

         Initialize_Fields_For_Package_Renaming_Decl
           (Self                            => Transform_Res_258,
            Package_Renaming_Decl_F_Name    => Defer_Res_534,
            Package_Renaming_Decl_F_Renames => Defer_Res_535,
            Package_Renaming_Decl_F_Aspects => Defer_Res_536);

         if Defer_Res_534 /= null and then Is_Incomplete (Defer_Res_534) then
            Transform_Res_258.Last_Attempted_Child := 0;
         elsif Defer_Res_534 /= null and then not Is_Ghost (Defer_Res_534) then
            Transform_Res_258.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_535 /= null and then Is_Incomplete (Defer_Res_535) then
            Transform_Res_258.Last_Attempted_Child := 0;
         elsif Defer_Res_535 /= null and then not Is_Ghost (Defer_Res_535) then
            Transform_Res_258.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_536 /= null and then Is_Incomplete (Defer_Res_536) then
            Transform_Res_258.Last_Attempted_Child := 0;
         elsif Defer_Res_536 /= null and then not Is_Ghost (Defer_Res_536) then
            Transform_Res_258.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Package_Renaming_Decl_Transform_Parse_0_Memo,
         Row_Pos_323 /= No_Token_Index, Transform_Res_258, Pos, Row_Pos_323);

      Parser.Current_Pos := Row_Pos_323;

      return Transform_Res_258;
   end Package_Renaming_Decl_Transform_Parse_0;

   function Generic_Renaming_Decl_Or_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Generic_Renaming_Decl
   is
      use Bare_Generic_Renaming_Decl_Memos;

      Row_Pos_324       : Token_Index                        := No_Token_Index;
      Token_Pos_505     : Token_Index                        := No_Token_Index;
      Token_Res_505     : Token_Index                        := No_Token_Index;
      Token_Pos_506     : Token_Index                        := No_Token_Index;
      Token_Res_506     : Token_Index                        := No_Token_Index;
      Defer_Pos_537     : Token_Index                        := No_Token_Index;
      Defer_Res_537     : Bare_Defining_Name := No_Bare_Ada_Node;
      Token_Pos_507     : Token_Index                        := No_Token_Index;
      Token_Res_507     : Token_Index                        := No_Token_Index;
      Defer_Pos_538     : Token_Index                        := No_Token_Index;
      Defer_Res_538     : Bare_Name := No_Bare_Ada_Node;
      Defer_Pos_539     : Token_Index                        := No_Token_Index;
      Defer_Res_539     : Bare_Aspect_Spec := No_Bare_Ada_Node;
      Token_Pos_508     : Token_Index                        := No_Token_Index;
      Token_Res_508     : Token_Index                        := No_Token_Index;
      Transform_Res_259 : Bare_Generic_Package_Renaming_Decl :=
        No_Bare_Ada_Node;
      Row_Pos_325       : Token_Index                     := No_Token_Index;
      Token_Pos_509     : Token_Index                     := No_Token_Index;
      Token_Res_509     : Token_Index                     := No_Token_Index;
      Row_Pos_326       : Token_Index                     := No_Token_Index;
      Token_Pos_510     : Token_Index                     := No_Token_Index;
      Token_Res_510     : Token_Index                     := No_Token_Index;
      Transform_Res_260 : Bare_Subp_Kind_Procedure        := No_Bare_Ada_Node;
      Row_Pos_327       : Token_Index                     := No_Token_Index;
      Token_Pos_511     : Token_Index                     := No_Token_Index;
      Token_Res_511     : Token_Index                     := No_Token_Index;
      Transform_Res_261 : Bare_Subp_Kind_Function         := No_Bare_Ada_Node;
      Or_Pos_95         : Token_Index                     := No_Token_Index;
      Or_Res_95         : Bare_Subp_Kind                  := No_Bare_Ada_Node;
      Defer_Pos_540     : Token_Index                     := No_Token_Index;
      Defer_Res_540     : Bare_Defining_Name              := No_Bare_Ada_Node;
      Token_Pos_512     : Token_Index                     := No_Token_Index;
      Token_Res_512     : Token_Index                     := No_Token_Index;
      Defer_Pos_541     : Token_Index                     := No_Token_Index;
      Defer_Res_541     : Bare_Name                       := No_Bare_Ada_Node;
      Defer_Pos_542     : Token_Index                     := No_Token_Index;
      Defer_Res_542     : Bare_Aspect_Spec                := No_Bare_Ada_Node;
      Token_Pos_513     : Token_Index                     := No_Token_Index;
      Token_Res_513     : Token_Index                     := No_Token_Index;
      Transform_Res_262 : Bare_Generic_Subp_Renaming_Decl := No_Bare_Ada_Node;
      Or_Pos_96         : Token_Index                     := No_Token_Index;
      Or_Res_96         : Bare_Generic_Renaming_Decl      := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Generic_Renaming_Decl_Or_Parse_1_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_96          := M.Instance;
         return Or_Res_96;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_96;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_96 := No_Token_Index;
      Or_Res_96 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_324 := Pos;

--  Start tok_code

      Token_Res_505 := Row_Pos_324;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_505));
      begin
         if T.Kind /= From_Token_Kind (Ada_Generic) then
            Token_Pos_505 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_324 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_324,
                  Expected_Token_Id => Ada_Generic,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_505 := Row_Pos_324 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_505 /= No_Token_Index then

         Row_Pos_324 := Token_Pos_505;

      else
         Row_Pos_324 := No_Token_Index;
         goto Exit_Row_323_0;

      end if;

--  Start tok_code

      Token_Res_506 := Row_Pos_324;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_506));
      begin
         if T.Kind /= From_Token_Kind (Ada_Package) then
            Token_Pos_506 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_324 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_324,
                  Expected_Token_Id => Ada_Package,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_506 := Row_Pos_324 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_506 /= No_Token_Index then

         Row_Pos_324 := Token_Pos_506;

      else
         Row_Pos_324 := No_Token_Index;
         goto Exit_Row_323_0;

      end if;

      Defer_Res_537 := Defining_Name_Transform_Parse_0 (Parser, Row_Pos_324);
      Defer_Pos_537 := Parser.Current_Pos;

      if Defer_Pos_537 /= No_Token_Index then

         Row_Pos_324 := Defer_Pos_537;

      else
         Row_Pos_324 := No_Token_Index;
         goto Exit_Row_323_0;

      end if;

--  Start tok_code

      Token_Res_507 := Row_Pos_324;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_507));
      begin
         if T.Kind /= From_Token_Kind (Ada_Renames) then
            Token_Pos_507 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_324 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_324,
                  Expected_Token_Id => Ada_Renames,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_507 := Row_Pos_324 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_507 /= No_Token_Index then

         Row_Pos_324 := Token_Pos_507;

      else
         Row_Pos_324 := No_Token_Index;
         goto Exit_Row_323_0;

      end if;

      Defer_Res_538 := Static_Name_Or_Parse_0 (Parser, Row_Pos_324);
      Defer_Pos_538 := Parser.Current_Pos;

      if Defer_Pos_538 /= No_Token_Index then

         Row_Pos_324 := Defer_Pos_538;

      else
         Row_Pos_324 := No_Token_Index;
         goto Exit_Row_323_0;

      end if;

      Defer_Res_539 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_324);
      Defer_Pos_539 := Parser.Current_Pos;

      if Defer_Pos_539 /= No_Token_Index then

         Row_Pos_324 := Defer_Pos_539;

      else
         Row_Pos_324 := No_Token_Index;
         goto Exit_Row_323_0;

      end if;

--  Start tok_code

      Token_Res_508 := Row_Pos_324;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_508));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_508 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_324 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_324,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_508 := Row_Pos_324 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_508 /= No_Token_Index then

         Row_Pos_324 := Token_Pos_508;

      else
         Row_Pos_324 := No_Token_Index;
         goto Exit_Row_323_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_323_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_324 /= No_Token_Index then

         Transform_Res_259 :=
           Allocate_Generic_Package_Renaming_Decl (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_259,
            Kind => Ada_Generic_Package_Renaming_Decl, Unit => Parser.Unit,

            Token_Start_Index => Pos,
            Token_End_Index   =>
              (if Row_Pos_324 = Pos then No_Token_Index else Row_Pos_324 - 1));

         Initialize_Fields_For_Generic_Package_Renaming_Decl
           (Self                                    => Transform_Res_259,
            Generic_Package_Renaming_Decl_F_Name    => Defer_Res_537,
            Generic_Package_Renaming_Decl_F_Renames => Defer_Res_538,
            Generic_Package_Renaming_Decl_F_Aspects => Defer_Res_539);

         if Defer_Res_537 /= null and then Is_Incomplete (Defer_Res_537) then
            Transform_Res_259.Last_Attempted_Child := 0;
         elsif Defer_Res_537 /= null and then not Is_Ghost (Defer_Res_537) then
            Transform_Res_259.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_538 /= null and then Is_Incomplete (Defer_Res_538) then
            Transform_Res_259.Last_Attempted_Child := 0;
         elsif Defer_Res_538 /= null and then not Is_Ghost (Defer_Res_538) then
            Transform_Res_259.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_539 /= null and then Is_Incomplete (Defer_Res_539) then
            Transform_Res_259.Last_Attempted_Child := 0;
         elsif Defer_Res_539 /= null and then not Is_Ghost (Defer_Res_539) then
            Transform_Res_259.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_324 /= No_Token_Index then
         Or_Pos_96 := Row_Pos_324;
         Or_Res_96 := Transform_Res_259;
         goto Exit_Or_96;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_325 := Pos;

--  Start tok_code

      Token_Res_509 := Row_Pos_325;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_509));
      begin
         if T.Kind /= From_Token_Kind (Ada_Generic) then
            Token_Pos_509 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_325 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_325,
                  Expected_Token_Id => Ada_Generic,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_509 := Row_Pos_325 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_509 /= No_Token_Index then

         Row_Pos_325 := Token_Pos_509;

      else
         Row_Pos_325 := No_Token_Index;
         goto Exit_Row_324_0;

      end if;

--  Start or_code

      Or_Pos_95 := No_Token_Index;
      Or_Res_95 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_326 := Row_Pos_325;

--  Start tok_code

      Token_Res_510 := Row_Pos_326;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_510));
      begin
         if T.Kind /= From_Token_Kind (Ada_Procedure) then
            Token_Pos_510 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_326 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_326,
                  Expected_Token_Id => Ada_Procedure,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_510 := Row_Pos_326 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_510 /= No_Token_Index then

         Row_Pos_326 := Token_Pos_510;

      else
         Row_Pos_326 := No_Token_Index;
         goto Exit_Row_325_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_325_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_326 /= No_Token_Index then

         Transform_Res_260 := Allocate_Subp_Kind_Procedure (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_260, Kind => Ada_Subp_Kind_Procedure,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_325,
            Token_End_Index =>
              (if Row_Pos_326 = Row_Pos_325 then No_Token_Index
               else Row_Pos_326 - 1));

      end if;

--  End transform_code

      if Row_Pos_326 /= No_Token_Index then
         Or_Pos_95 := Row_Pos_326;
         Or_Res_95 := Transform_Res_260;
         goto Exit_Or_97;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_327 := Row_Pos_325;

--  Start tok_code

      Token_Res_511 := Row_Pos_327;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_511));
      begin
         if T.Kind /= From_Token_Kind (Ada_Function) then
            Token_Pos_511 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_327 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_327,
                  Expected_Token_Id => Ada_Function,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_511 := Row_Pos_327 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_511 /= No_Token_Index then

         Row_Pos_327 := Token_Pos_511;

      else
         Row_Pos_327 := No_Token_Index;
         goto Exit_Row_326_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_326_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_327 /= No_Token_Index then

         Transform_Res_261 := Allocate_Subp_Kind_Function (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_261, Kind => Ada_Subp_Kind_Function,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_325,
            Token_End_Index =>
              (if Row_Pos_327 = Row_Pos_325 then No_Token_Index
               else Row_Pos_327 - 1));

      end if;

--  End transform_code

      if Row_Pos_327 /= No_Token_Index then
         Or_Pos_95 := Row_Pos_327;
         Or_Res_95 := Transform_Res_261;
         goto Exit_Or_97;
      end if;
      <<Exit_Or_97>>

--  End or_code

      if Or_Pos_95 /= No_Token_Index then

         Row_Pos_325 := Or_Pos_95;

      else
         Row_Pos_325 := No_Token_Index;
         goto Exit_Row_324_0;

      end if;

      Defer_Res_540 := Defining_Name_Transform_Parse_0 (Parser, Row_Pos_325);
      Defer_Pos_540 := Parser.Current_Pos;

      if Defer_Pos_540 /= No_Token_Index then

         Row_Pos_325 := Defer_Pos_540;

      else
         Row_Pos_325 := No_Token_Index;
         goto Exit_Row_324_0;

      end if;

--  Start tok_code

      Token_Res_512 := Row_Pos_325;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_512));
      begin
         if T.Kind /= From_Token_Kind (Ada_Renames) then
            Token_Pos_512 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_325 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_325,
                  Expected_Token_Id => Ada_Renames,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_512 := Row_Pos_325 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_512 /= No_Token_Index then

         Row_Pos_325 := Token_Pos_512;

      else
         Row_Pos_325 := No_Token_Index;
         goto Exit_Row_324_0;

      end if;

      Defer_Res_541 := Static_Name_Or_Parse_0 (Parser, Row_Pos_325);
      Defer_Pos_541 := Parser.Current_Pos;

      if Defer_Pos_541 /= No_Token_Index then

         Row_Pos_325 := Defer_Pos_541;

      else
         Row_Pos_325 := No_Token_Index;
         goto Exit_Row_324_0;

      end if;

      Defer_Res_542 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_325);
      Defer_Pos_542 := Parser.Current_Pos;

      if Defer_Pos_542 /= No_Token_Index then

         Row_Pos_325 := Defer_Pos_542;

      else
         Row_Pos_325 := No_Token_Index;
         goto Exit_Row_324_0;

      end if;

--  Start tok_code

      Token_Res_513 := Row_Pos_325;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_513));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_513 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_325 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_325,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_513 := Row_Pos_325 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_513 /= No_Token_Index then

         Row_Pos_325 := Token_Pos_513;

      else
         Row_Pos_325 := No_Token_Index;
         goto Exit_Row_324_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_324_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_325 /= No_Token_Index then

         Transform_Res_262 :=
           Allocate_Generic_Subp_Renaming_Decl (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_262, Kind => Ada_Generic_Subp_Renaming_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_325 = Pos then No_Token_Index else Row_Pos_325 - 1));

         Initialize_Fields_For_Generic_Subp_Renaming_Decl
           (Self                                 => Transform_Res_262,
            Generic_Subp_Renaming_Decl_F_Kind    => Or_Res_95,
            Generic_Subp_Renaming_Decl_F_Name    => Defer_Res_540,
            Generic_Subp_Renaming_Decl_F_Renames => Defer_Res_541,
            Generic_Subp_Renaming_Decl_F_Aspects => Defer_Res_542);

         if Or_Res_95 /= null and then Is_Incomplete (Or_Res_95) then
            Transform_Res_262.Last_Attempted_Child := 0;
         elsif Or_Res_95 /= null and then not Is_Ghost (Or_Res_95) then
            Transform_Res_262.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_540 /= null and then Is_Incomplete (Defer_Res_540) then
            Transform_Res_262.Last_Attempted_Child := 0;
         elsif Defer_Res_540 /= null and then not Is_Ghost (Defer_Res_540) then
            Transform_Res_262.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_541 /= null and then Is_Incomplete (Defer_Res_541) then
            Transform_Res_262.Last_Attempted_Child := 0;
         elsif Defer_Res_541 /= null and then not Is_Ghost (Defer_Res_541) then
            Transform_Res_262.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_542 /= null and then Is_Incomplete (Defer_Res_542) then
            Transform_Res_262.Last_Attempted_Child := 0;
         elsif Defer_Res_542 /= null and then not Is_Ghost (Defer_Res_542) then
            Transform_Res_262.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_325 /= No_Token_Index then
         Or_Pos_96 := Row_Pos_325;
         Or_Res_96 := Transform_Res_262;
         goto Exit_Or_96;
      end if;
      <<Exit_Or_96>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Generic_Renaming_Decl_Or_Parse_1_Memo,
         Or_Pos_96 /= No_Token_Index, Or_Res_96, Pos, Or_Pos_96);

      Parser.Current_Pos := Or_Pos_96;

      return Or_Res_96;
   end Generic_Renaming_Decl_Or_Parse_1;

   function Generic_Formal_Decl_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Defer_Pos_554     : Token_Index                   := No_Token_Index;
      Defer_Res_554     : Bare_Pragma_Node              := No_Bare_Ada_Node;
      Row_Pos_338       : Token_Index                   := No_Token_Index;
      Defer_Pos_555     : Token_Index                   := No_Token_Index;
      Defer_Res_555     : Bare_Basic_Decl               := No_Bare_Ada_Node;
      Transform_Res_271 : Bare_Generic_Formal_Obj_Decl  := No_Bare_Ada_Node;
      Row_Pos_339       : Token_Index                   := No_Token_Index;
      Defer_Pos_556     : Token_Index                   := No_Token_Index;
      Defer_Res_556     : Bare_Base_Type_Decl           := No_Bare_Ada_Node;
      Transform_Res_272 : Bare_Generic_Formal_Type_Decl := No_Bare_Ada_Node;
      Row_Pos_340       : Token_Index                   := No_Token_Index;
      Defer_Pos_557     : Token_Index                   := No_Token_Index;
      Defer_Res_557     : Bare_Formal_Subp_Decl         := No_Bare_Ada_Node;
      Transform_Res_273 : Bare_Generic_Formal_Subp_Decl := No_Bare_Ada_Node;
      Row_Pos_341       : Token_Index                   := No_Token_Index;
      Token_Pos_521     : Token_Index                   := No_Token_Index;
      Token_Res_521     : Token_Index                   := No_Token_Index;
      Defer_Pos_558     : Token_Index                   := No_Token_Index;
      Defer_Res_558     : Bare_Generic_Instantiation    := No_Bare_Ada_Node;
      Transform_Res_274 : Bare_Generic_Formal_Package   := No_Bare_Ada_Node;
      Or_Pos_99         : Token_Index                   := No_Token_Index;
      Or_Res_99         : Bare_Ada_Node                 := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Generic_Formal_Decl_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_99          := M.Instance;
         return Or_Res_99;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_99;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_99 := No_Token_Index;
      Or_Res_99 := No_Bare_Ada_Node;

      Defer_Res_554 := Pragma_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_554 := Parser.Current_Pos;

      if Defer_Pos_554 /= No_Token_Index then
         Or_Pos_99 := Defer_Pos_554;
         Or_Res_99 := Defer_Res_554;
         goto Exit_Or_100;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_338 := Pos;

      Defer_Res_555 := Object_Decl_Or_Parse_0 (Parser, Row_Pos_338);
      Defer_Pos_555 := Parser.Current_Pos;

      if Defer_Pos_555 /= No_Token_Index then

         Row_Pos_338 := Defer_Pos_555;

      else
         Row_Pos_338 := No_Token_Index;
         goto Exit_Row_329_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_329_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_338 /= No_Token_Index then

         Transform_Res_271 :=
           Allocate_Generic_Formal_Obj_Decl (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_271, Kind => Ada_Generic_Formal_Obj_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_338 = Pos then No_Token_Index else Row_Pos_338 - 1));

         Initialize_Fields_For_Generic_Formal_Obj_Decl
           (Self => Transform_Res_271, Generic_Formal_F_Decl => Defer_Res_555);

         if Defer_Res_555 /= null and then Is_Incomplete (Defer_Res_555) then
            Transform_Res_271.Last_Attempted_Child := 0;
         elsif Defer_Res_555 /= null and then not Is_Ghost (Defer_Res_555) then
            Transform_Res_271.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_338 /= No_Token_Index then
         Or_Pos_99 := Row_Pos_338;
         Or_Res_99 := Transform_Res_271;
         goto Exit_Or_100;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_339 := Pos;

      Defer_Res_556 := Type_Decl_Or_Parse_1 (Parser, Row_Pos_339);
      Defer_Pos_556 := Parser.Current_Pos;

      if Defer_Pos_556 /= No_Token_Index then

         Row_Pos_339 := Defer_Pos_556;

      else
         Row_Pos_339 := No_Token_Index;
         goto Exit_Row_330_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_330_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_339 /= No_Token_Index then

         Transform_Res_272 :=
           Allocate_Generic_Formal_Type_Decl (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_272, Kind => Ada_Generic_Formal_Type_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_339 = Pos then No_Token_Index else Row_Pos_339 - 1));

         Initialize_Fields_For_Generic_Formal_Type_Decl
           (Self => Transform_Res_272, Generic_Formal_F_Decl => Defer_Res_556);

         if Defer_Res_556 /= null and then Is_Incomplete (Defer_Res_556) then
            Transform_Res_272.Last_Attempted_Child := 0;
         elsif Defer_Res_556 /= null and then not Is_Ghost (Defer_Res_556) then
            Transform_Res_272.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_339 /= No_Token_Index then
         Or_Pos_99 := Row_Pos_339;
         Or_Res_99 := Transform_Res_272;
         goto Exit_Or_100;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_340 := Pos;

      Defer_Res_557 := Formal_Subp_Decl_Or_Parse_2 (Parser, Row_Pos_340);
      Defer_Pos_557 := Parser.Current_Pos;

      if Defer_Pos_557 /= No_Token_Index then

         Row_Pos_340 := Defer_Pos_557;

      else
         Row_Pos_340 := No_Token_Index;
         goto Exit_Row_331_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_331_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_340 /= No_Token_Index then

         Transform_Res_273 :=
           Allocate_Generic_Formal_Subp_Decl (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_273, Kind => Ada_Generic_Formal_Subp_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_340 = Pos then No_Token_Index else Row_Pos_340 - 1));

         Initialize_Fields_For_Generic_Formal_Subp_Decl
           (Self => Transform_Res_273, Generic_Formal_F_Decl => Defer_Res_557);

         if Defer_Res_557 /= null and then Is_Incomplete (Defer_Res_557) then
            Transform_Res_273.Last_Attempted_Child := 0;
         elsif Defer_Res_557 /= null and then not Is_Ghost (Defer_Res_557) then
            Transform_Res_273.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_340 /= No_Token_Index then
         Or_Pos_99 := Row_Pos_340;
         Or_Res_99 := Transform_Res_273;
         goto Exit_Or_100;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_341 := Pos;

--  Start tok_code

      Token_Res_521 := Row_Pos_341;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_521));
      begin
         if T.Kind /= From_Token_Kind (Ada_With) then
            Token_Pos_521 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_341 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_341,
                  Expected_Token_Id => Ada_With,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_521 := Row_Pos_341 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_521 /= No_Token_Index then

         Row_Pos_341 := Token_Pos_521;

      else
         Row_Pos_341 := No_Token_Index;
         goto Exit_Row_332_0;

      end if;

      Defer_Res_558 := Generic_Instantiation_Or_Parse_1 (Parser, Row_Pos_341);
      Defer_Pos_558 := Parser.Current_Pos;

      if Defer_Pos_558 /= No_Token_Index then

         Row_Pos_341 := Defer_Pos_558;

      else
         Row_Pos_341 := No_Token_Index;
         goto Exit_Row_332_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_332_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_341 /= No_Token_Index then

         Transform_Res_274 :=
           Allocate_Generic_Formal_Package (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_274, Kind => Ada_Generic_Formal_Package,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_341 = Pos then No_Token_Index else Row_Pos_341 - 1));

         Initialize_Fields_For_Generic_Formal_Package
           (Self => Transform_Res_274, Generic_Formal_F_Decl => Defer_Res_558);

         if Defer_Res_558 /= null and then Is_Incomplete (Defer_Res_558) then
            Transform_Res_274.Last_Attempted_Child := 0;
         elsif Defer_Res_558 /= null and then not Is_Ghost (Defer_Res_558) then
            Transform_Res_274.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_341 /= No_Token_Index then
         Or_Pos_99 := Row_Pos_341;
         Or_Res_99 := Transform_Res_274;
         goto Exit_Or_100;
      end if;
      <<Exit_Or_100>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Generic_Formal_Decl_Or_Parse_0_Memo,
         Or_Pos_99 /= No_Token_Index, Or_Res_99, Pos, Or_Pos_99);

      Parser.Current_Pos := Or_Pos_99;

      return Or_Res_99;
   end Generic_Formal_Decl_Or_Parse_0;

   function Generic_Formal_Part_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Generic_Formal_Part
   is
      use Bare_Generic_Formal_Part_Memos;

      Row_Pos_337       : Token_Index              := No_Token_Index;
      Token_Pos_520     : Token_Index              := No_Token_Index;
      Token_Res_520     : Token_Index              := No_Token_Index;
      Lst_Cpos_42       : Token_Index              := No_Token_Index;
      Tmp_List_42       : Free_Parse_List;
      Defer_Pos_552     : Token_Index              := No_Token_Index;
      Defer_Res_552     : Bare_Ada_Node            := No_Bare_Ada_Node;
      Defer_Pos_553     : Token_Index              := No_Token_Index;
      Defer_Res_553     : Bare_Use_Clause          := No_Bare_Ada_Node;
      Or_Pos_98         : Token_Index              := No_Token_Index;
      Or_Res_98         : Bare_Ada_Node            := No_Bare_Ada_Node;
      List_Pos_42       : Token_Index              := No_Token_Index;
      List_Res_42       : Bare_Ada_Node_List       := No_Bare_Ada_Node;
      Transform_Res_270 : Bare_Generic_Formal_Part := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Generic_Formal_Part_Transform_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_270  := M.Instance;
         return Transform_Res_270;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_270;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_337 := Pos;

--  Start tok_code

      Token_Res_520 := Row_Pos_337;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_520));
      begin
         if T.Kind /= From_Token_Kind (Ada_Generic) then
            Token_Pos_520 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_337 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_337,
                  Expected_Token_Id => Ada_Generic,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_520 := Row_Pos_337 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_520 /= No_Token_Index then

         Row_Pos_337 := Token_Pos_520;

      else
         Row_Pos_337 := No_Token_Index;
         goto Exit_Row_328_0;

      end if;

--  Start list_code

      List_Pos_42 := Row_Pos_337;

      Lst_Cpos_42 := Row_Pos_337;
      Tmp_List_42 := Get_Parse_List (Parser);

      loop

--  Start or_code

         Or_Pos_98 := No_Token_Index;
         Or_Res_98 := No_Bare_Ada_Node;

         Defer_Res_552 := Generic_Formal_Decl_Or_Parse_0 (Parser, Lst_Cpos_42);
         Defer_Pos_552 := Parser.Current_Pos;

         if Defer_Pos_552 /= No_Token_Index then
            Or_Pos_98 := Defer_Pos_552;
            Or_Res_98 := Defer_Res_552;
            goto Exit_Or_99;
         end if;

         Defer_Res_553 := Use_Clause_Or_Parse_0 (Parser, Lst_Cpos_42);
         Defer_Pos_553 := Parser.Current_Pos;

         if Defer_Pos_553 /= No_Token_Index then
            Or_Pos_98 := Defer_Pos_553;
            Or_Res_98 := Defer_Res_553;
            goto Exit_Or_99;
         end if;
         <<Exit_Or_99>>

--  End or_code

         exit when Or_Pos_98 = No_Token_Index;

         List_Pos_42 := Or_Pos_98;
         Lst_Cpos_42 := List_Pos_42;

         Tmp_List_42.Nodes.Append (Or_Res_98);

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_42.Nodes.Length;
      begin
         List_Res_42 := Allocate_Ada_Node_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_337;
            Token_End   :=
              (if Lst_Cpos_42 = Row_Pos_337 then Row_Pos_337
               else Lst_Cpos_42 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_337, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self            => List_Res_42, Kind => Ada_Ada_Node_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_42, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_42.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_42.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_42);

--  End list_code

      if List_Pos_42 /= No_Token_Index then

         Row_Pos_337 := List_Pos_42;

      else
         Row_Pos_337 := No_Token_Index;
         goto Exit_Row_328_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_328_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_337 /= No_Token_Index then

         Transform_Res_270 := Allocate_Generic_Formal_Part (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_270, Kind => Ada_Generic_Formal_Part,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_337 = Pos then No_Token_Index else Row_Pos_337 - 1));

         Initialize_Fields_For_Generic_Formal_Part
           (Self                        => Transform_Res_270,
            Generic_Formal_Part_F_Decls => List_Res_42);

         if List_Res_42 /= null and then Is_Incomplete (List_Res_42) then
            Transform_Res_270.Last_Attempted_Child := 0;
         elsif List_Res_42 /= null and then not Is_Ghost (List_Res_42) then
            Transform_Res_270.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Generic_Formal_Part_Transform_Parse_0_Memo,
         Row_Pos_337 /= No_Token_Index, Transform_Res_270, Pos, Row_Pos_337);

      Parser.Current_Pos := Row_Pos_337;

      return Transform_Res_270;
   end Generic_Formal_Part_Transform_Parse_0;

   function Generic_Decl_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Generic_Decl
   is
      use Bare_Generic_Decl_Memos;

      Row_Pos_328       : Token_Index                   := No_Token_Index;
      Defer_Pos_543     : Token_Index                   := No_Token_Index;
      Defer_Res_543     : Bare_Generic_Formal_Part      := No_Bare_Ada_Node;
      Row_Pos_329       : Token_Index                   := No_Token_Index;
      Defer_Pos_544     : Token_Index                   := No_Token_Index;
      Defer_Res_544     : Bare_Subp_Spec                := No_Bare_Ada_Node;
      Defer_Pos_545     : Token_Index                   := No_Token_Index;
      Defer_Res_545     : Bare_Aspect_Spec              := No_Bare_Ada_Node;
      Transform_Res_263 : Bare_Generic_Subp_Internal    := No_Bare_Ada_Node;
      Token_Pos_514     : Token_Index                   := No_Token_Index;
      Token_Res_514     : Token_Index                   := No_Token_Index;
      Transform_Res_264 : Bare_Generic_Subp_Decl        := No_Bare_Ada_Node;
      Row_Pos_330       : Token_Index                   := No_Token_Index;
      Defer_Pos_546     : Token_Index                   := No_Token_Index;
      Defer_Res_546     : Bare_Generic_Formal_Part      := No_Bare_Ada_Node;
      Row_Pos_331       : Token_Index                   := No_Token_Index;
      Token_Pos_515     : Token_Index                   := No_Token_Index;
      Token_Res_515     : Token_Index                   := No_Token_Index;
      Defer_Pos_547     : Token_Index                   := No_Token_Index;
      Defer_Res_547     : Bare_Defining_Name            := No_Bare_Ada_Node;
      Defer_Pos_548     : Token_Index                   := No_Token_Index;
      Defer_Res_548     : Bare_Aspect_Spec              := No_Bare_Ada_Node;
      Token_Pos_516     : Token_Index                   := No_Token_Index;
      Token_Res_516     : Token_Index                   := No_Token_Index;
      Row_Pos_332       : Token_Index                   := No_Token_Index;
      Defer_Pos_549     : Token_Index                   := No_Token_Index;
      Defer_Res_549     : Bare_Ada_Node_List            := No_Bare_Ada_Node;
      Transform_Res_265 : Bare_Public_Part              := No_Bare_Ada_Node;
      Row_Pos_333       : Token_Index                   := No_Token_Index;
      Token_Pos_517     : Token_Index                   := No_Token_Index;
      Token_Res_517     : Token_Index                   := No_Token_Index;
      Row_Pos_334       : Token_Index                   := No_Token_Index;
      Defer_Pos_550     : Token_Index                   := No_Token_Index;
      Defer_Res_550     : Bare_Ada_Node_List            := No_Bare_Ada_Node;
      Transform_Res_266 : Bare_Private_Part             := No_Bare_Ada_Node;
      Row_Pos_335       : Token_Index                   := No_Token_Index;
      Token_Pos_518     : Token_Index                   := No_Token_Index;
      Token_Res_518     : Token_Index                   := No_Token_Index;
      Row_Pos_336       : Token_Index                   := No_Token_Index;
      Defer_Pos_551     : Token_Index                   := No_Token_Index;
      Defer_Res_551     : Bare_Name                     := No_Bare_Ada_Node;
      Transform_Res_267 : Bare_End_Name                 := No_Bare_Ada_Node;
      Token_Pos_519     : Token_Index                   := No_Token_Index;
      Token_Res_519     : Token_Index                   := No_Token_Index;
      Transform_Res_268 : Bare_Generic_Package_Internal := No_Bare_Ada_Node;
      Transform_Res_269 : Bare_Generic_Package_Decl     := No_Bare_Ada_Node;
      Or_Pos_97         : Token_Index                   := No_Token_Index;
      Or_Res_97         : Bare_Generic_Decl             := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Generic_Decl_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_97          := M.Instance;
         return Or_Res_97;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_97;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_97 := No_Token_Index;
      Or_Res_97 := No_Bare_Ada_Node;

--  Start transform_code

--  Start row_code

      Row_Pos_328 := Pos;

      Defer_Res_543 :=
        Generic_Formal_Part_Transform_Parse_0 (Parser, Row_Pos_328);
      Defer_Pos_543 := Parser.Current_Pos;

      if Defer_Pos_543 /= No_Token_Index then

         Row_Pos_328 := Defer_Pos_543;

      else
         Row_Pos_328 := No_Token_Index;
         goto Exit_Row_327_0;

      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_329 := Row_Pos_328;

      Defer_Res_544 := Subp_Spec_Transform_Parse_2 (Parser, Row_Pos_329);
      Defer_Pos_544 := Parser.Current_Pos;

      if Defer_Pos_544 /= No_Token_Index then

         Row_Pos_329 := Defer_Pos_544;

      else
         Row_Pos_329 := No_Token_Index;
         goto Exit_Row_333_0;

      end if;

      Defer_Res_545 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_329);
      Defer_Pos_545 := Parser.Current_Pos;

      if Defer_Pos_545 /= No_Token_Index then

         Row_Pos_329 := Defer_Pos_545;

      else
         Row_Pos_329 := No_Token_Index;
         goto Exit_Row_333_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_333_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_329 /= No_Token_Index then

         Transform_Res_263 := Allocate_Generic_Subp_Internal (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_263, Kind => Ada_Generic_Subp_Internal,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_328,
            Token_End_Index =>
              (if Row_Pos_329 = Row_Pos_328 then No_Token_Index
               else Row_Pos_329 - 1));

         Initialize_Fields_For_Generic_Subp_Internal
           (Self                              => Transform_Res_263,
            Generic_Subp_Internal_F_Subp_Spec => Defer_Res_544,
            Generic_Subp_Internal_F_Aspects   => Defer_Res_545);

         if Defer_Res_544 /= null and then Is_Incomplete (Defer_Res_544) then
            Transform_Res_263.Last_Attempted_Child := 0;
         elsif Defer_Res_544 /= null and then not Is_Ghost (Defer_Res_544) then
            Transform_Res_263.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_545 /= null and then Is_Incomplete (Defer_Res_545) then
            Transform_Res_263.Last_Attempted_Child := 0;
         elsif Defer_Res_545 /= null and then not Is_Ghost (Defer_Res_545) then
            Transform_Res_263.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_329 /= No_Token_Index then

         Row_Pos_328 := Row_Pos_329;

      else
         Row_Pos_328 := No_Token_Index;
         goto Exit_Row_327_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_514 := Row_Pos_328;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_514));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_514 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_328 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_328,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_514 := Row_Pos_328 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_514 = No_Token_Index then

         Token_Res_514 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_328).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_514 := Row_Pos_328;

      end if;

--  End opt_code

      if Token_Pos_514 /= No_Token_Index then

         Row_Pos_328 := Token_Pos_514;

      else
         Row_Pos_328 := No_Token_Index;
         goto Exit_Row_327_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_327_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_328 /= No_Token_Index then

         Transform_Res_264 := Allocate_Generic_Subp_Decl (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_264, Kind => Ada_Generic_Subp_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_328 = Pos then No_Token_Index else Row_Pos_328 - 1));

         Initialize_Fields_For_Generic_Subp_Decl
           (Self                          => Transform_Res_264,
            Generic_Decl_F_Formal_Part    => Defer_Res_543,
            Generic_Subp_Decl_F_Subp_Decl => Transform_Res_263);

         if Defer_Res_543 /= null and then Is_Incomplete (Defer_Res_543) then
            Transform_Res_264.Last_Attempted_Child := 0;
         elsif Defer_Res_543 /= null and then not Is_Ghost (Defer_Res_543) then
            Transform_Res_264.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_263 /= null
           and then Is_Incomplete (Transform_Res_263)
         then
            Transform_Res_264.Last_Attempted_Child := 0;
         elsif Transform_Res_263 /= null
           and then not Is_Ghost (Transform_Res_263)
         then
            Transform_Res_264.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_328 /= No_Token_Index then
         Or_Pos_97 := Row_Pos_328;
         Or_Res_97 := Transform_Res_264;
         goto Exit_Or_98;
      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_330 := Pos;

      Defer_Res_546 :=
        Generic_Formal_Part_Transform_Parse_0 (Parser, Row_Pos_330);
      Defer_Pos_546 := Parser.Current_Pos;

      if Defer_Pos_546 /= No_Token_Index then

         Row_Pos_330 := Defer_Pos_546;

      else
         Row_Pos_330 := No_Token_Index;
         goto Exit_Row_334_0;

      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_331 := Row_Pos_330;

--  Start tok_code

      Token_Res_515 := Row_Pos_331;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_515));
      begin
         if T.Kind /= From_Token_Kind (Ada_Package) then
            Token_Pos_515 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_331 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_331,
                  Expected_Token_Id => Ada_Package,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_515 := Row_Pos_331 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_515 /= No_Token_Index then

         Row_Pos_331 := Token_Pos_515;

      else
         Row_Pos_331 := No_Token_Index;
         goto Exit_Row_335_0;

      end if;

      Defer_Res_547 := Defining_Name_Transform_Parse_0 (Parser, Row_Pos_331);
      Defer_Pos_547 := Parser.Current_Pos;

      if Defer_Pos_547 /= No_Token_Index then

         Row_Pos_331 := Defer_Pos_547;

      else
         Row_Pos_331 := No_Token_Index;
         goto Exit_Row_335_0;

      end if;

      Defer_Res_548 := Aspect_Spec_Opt_Parse_0 (Parser, Row_Pos_331);
      Defer_Pos_548 := Parser.Current_Pos;

      if Defer_Pos_548 /= No_Token_Index then

         Row_Pos_331 := Defer_Pos_548;

      else
         Row_Pos_331 := No_Token_Index;
         goto Exit_Row_335_0;

      end if;

--  Start tok_code

      Token_Res_516 := Row_Pos_331;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_516));
      begin
         if T.Kind /= From_Token_Kind (Ada_Is) then
            Token_Pos_516 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_331 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_331,
                  Expected_Token_Id => Ada_Is,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_516 := Row_Pos_331 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_516 /= No_Token_Index then

         Row_Pos_331 := Token_Pos_516;

      else
         Row_Pos_331 := No_Token_Index;
         goto Exit_Row_335_0;

      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_332 := Row_Pos_331;

      Parser.Private_Part.Dont_Skip.Append
        (Dontskip_Generic_Decl_0_Extract_Parse_0'Access);

      Defer_Res_549 := Basic_Decls_List_Parse_0 (Parser, Row_Pos_332);
      Defer_Pos_549 := Parser.Current_Pos;

      Parser.Private_Part.Dont_Skip.Delete_Last;

      if Defer_Pos_549 /= No_Token_Index then

         Row_Pos_332 := Defer_Pos_549;

      else
         Row_Pos_332 := No_Token_Index;
         goto Exit_Row_336_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_336_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_332 /= No_Token_Index then

         Transform_Res_265 := Allocate_Public_Part (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_265, Kind => Ada_Public_Part,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_331,
            Token_End_Index =>
              (if Row_Pos_332 = Row_Pos_331 then No_Token_Index
               else Row_Pos_332 - 1));

         Initialize_Fields_For_Public_Part
           (Self                     => Transform_Res_265,
            Declarative_Part_F_Decls => Defer_Res_549);

         if Defer_Res_549 /= null and then Is_Incomplete (Defer_Res_549) then
            Transform_Res_265.Last_Attempted_Child := 0;
         elsif Defer_Res_549 /= null and then not Is_Ghost (Defer_Res_549) then
            Transform_Res_265.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_332 /= No_Token_Index then

         Row_Pos_331 := Row_Pos_332;

      else
         Row_Pos_331 := No_Token_Index;
         goto Exit_Row_335_0;

      end if;

--  Start opt_code

--  Start row_code

      Row_Pos_333 := Row_Pos_331;

--  Start tok_code

      Token_Res_517 := Row_Pos_333;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_517));
      begin
         if T.Kind /= From_Token_Kind (Ada_Private) then
            Token_Pos_517 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_333 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_333,
                  Expected_Token_Id => Ada_Private,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_517 := Row_Pos_333 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_517 /= No_Token_Index then

         Row_Pos_333 := Token_Pos_517;

      else
         Row_Pos_333 := No_Token_Index;
         goto Exit_Row_337_0;

      end if;

--  Start transform_code

--  Start row_code

      Row_Pos_334 := Row_Pos_333;

      Parser.Private_Part.Dont_Skip.Append
        (Dontskip_Generic_Decl_1_Extract_Parse_0'Access);

      Defer_Res_550 := Basic_Decls_List_Parse_0 (Parser, Row_Pos_334);
      Defer_Pos_550 := Parser.Current_Pos;

      Parser.Private_Part.Dont_Skip.Delete_Last;

      if Defer_Pos_550 /= No_Token_Index then

         Row_Pos_334 := Defer_Pos_550;

      else
         Row_Pos_334 := No_Token_Index;
         goto Exit_Row_338_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_338_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_334 /= No_Token_Index then

         Transform_Res_266 := Allocate_Private_Part (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_266, Kind => Ada_Private_Part,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_333,
            Token_End_Index =>
              (if Row_Pos_334 = Row_Pos_333 then No_Token_Index
               else Row_Pos_334 - 1));

         Initialize_Fields_For_Private_Part
           (Self                     => Transform_Res_266,
            Declarative_Part_F_Decls => Defer_Res_550);

         if Defer_Res_550 /= null and then Is_Incomplete (Defer_Res_550) then
            Transform_Res_266.Last_Attempted_Child := 0;
         elsif Defer_Res_550 /= null and then not Is_Ghost (Defer_Res_550) then
            Transform_Res_266.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_334 /= No_Token_Index then

         Row_Pos_333 := Row_Pos_334;

      else
         Row_Pos_333 := No_Token_Index;
         goto Exit_Row_337_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_337_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_333 = No_Token_Index then

         Transform_Res_266 := No_Bare_Ada_Node;

         Row_Pos_333 := Row_Pos_331;

      end if;

--  End opt_code

      if Row_Pos_333 /= No_Token_Index then

         Row_Pos_331 := Row_Pos_333;

      else
         Row_Pos_331 := No_Token_Index;
         goto Exit_Row_335_0;

      end if;

--  Start row_code

      Row_Pos_335 := Row_Pos_331;

--  Start tok_code

      Token_Res_518 := Row_Pos_335;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_518));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_518 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_335 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_335,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_518 := Row_Pos_335 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_518 /= No_Token_Index then

         Row_Pos_335 := Token_Pos_518;

      else
         Row_Pos_335 := No_Token_Index;
         goto Exit_Row_339_0;

      end if;

--  Start opt_code

--  Start transform_code

--  Start row_code

      Row_Pos_336 := Row_Pos_335;

      Defer_Res_551 := Static_Name_Or_Parse_0 (Parser, Row_Pos_336);
      Defer_Pos_551 := Parser.Current_Pos;

      if Defer_Pos_551 /= No_Token_Index then

         Row_Pos_336 := Defer_Pos_551;

      else
         Row_Pos_336 := No_Token_Index;
         goto Exit_Row_340_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_340_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_336 /= No_Token_Index then

         Transform_Res_267 := Allocate_End_Name (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_267, Kind => Ada_End_Name,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_335,
            Token_End_Index =>
              (if Row_Pos_336 = Row_Pos_335 then No_Token_Index
               else Row_Pos_336 - 1));

         Initialize_Fields_For_End_Name
           (Self => Transform_Res_267, End_Name_F_Name => Defer_Res_551);

         if Defer_Res_551 /= null and then Is_Incomplete (Defer_Res_551) then
            Transform_Res_267.Last_Attempted_Child := 0;
         elsif Defer_Res_551 /= null and then not Is_Ghost (Defer_Res_551) then
            Transform_Res_267.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_336 = No_Token_Index then

         Transform_Res_267 := No_Bare_Ada_Node;

         Row_Pos_336 := Row_Pos_335;

      end if;

--  End opt_code

      if Row_Pos_336 /= No_Token_Index then

         Row_Pos_335 := Row_Pos_336;

      else
         Row_Pos_335 := No_Token_Index;
         goto Exit_Row_339_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_339_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_335 /= No_Token_Index then

         Row_Pos_331 := Row_Pos_335;

      else
         Row_Pos_331 := No_Token_Index;
         goto Exit_Row_335_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_519 := Row_Pos_331;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_519));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_519 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_331 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_331,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_519 := Row_Pos_331 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_519 = No_Token_Index then

         Token_Res_519 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_331).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_519 := Row_Pos_331;

      end if;

--  End opt_code

      if Token_Pos_519 /= No_Token_Index then

         Row_Pos_331 := Token_Pos_519;

      else
         Row_Pos_331 := No_Token_Index;
         goto Exit_Row_335_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_335_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_331 /= No_Token_Index then

         Transform_Res_268 :=
           Allocate_Generic_Package_Internal (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_268, Kind => Ada_Generic_Package_Internal,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_330,
            Token_End_Index =>
              (if Row_Pos_331 = Row_Pos_330 then No_Token_Index
               else Row_Pos_331 - 1));

         Initialize_Fields_For_Generic_Package_Internal
           (Self                             => Transform_Res_268,
            Base_Package_Decl_F_Package_Name => Defer_Res_547,
            Base_Package_Decl_F_Aspects      => Defer_Res_548,
            Base_Package_Decl_F_Public_Part  => Transform_Res_265,
            Base_Package_Decl_F_Private_Part => Transform_Res_266,
            Base_Package_Decl_F_End_Name     => Transform_Res_267);

         if Defer_Res_547 /= null and then Is_Incomplete (Defer_Res_547) then
            Transform_Res_268.Last_Attempted_Child := 0;
         elsif Defer_Res_547 /= null and then not Is_Ghost (Defer_Res_547) then
            Transform_Res_268.Last_Attempted_Child := -1;
         end if;
         if Defer_Res_548 /= null and then Is_Incomplete (Defer_Res_548) then
            Transform_Res_268.Last_Attempted_Child := 0;
         elsif Defer_Res_548 /= null and then not Is_Ghost (Defer_Res_548) then
            Transform_Res_268.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_265 /= null
           and then Is_Incomplete (Transform_Res_265)
         then
            Transform_Res_268.Last_Attempted_Child := 0;
         elsif Transform_Res_265 /= null
           and then not Is_Ghost (Transform_Res_265)
         then
            Transform_Res_268.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_266 /= null
           and then Is_Incomplete (Transform_Res_266)
         then
            Transform_Res_268.Last_Attempted_Child := 0;
         elsif Transform_Res_266 /= null
           and then not Is_Ghost (Transform_Res_266)
         then
            Transform_Res_268.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_267 /= null
           and then Is_Incomplete (Transform_Res_267)
         then
            Transform_Res_268.Last_Attempted_Child := 0;
         elsif Transform_Res_267 /= null
           and then not Is_Ghost (Transform_Res_267)
         then
            Transform_Res_268.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_331 /= No_Token_Index then

         Row_Pos_330 := Row_Pos_331;

      else
         Row_Pos_330 := No_Token_Index;
         goto Exit_Row_334_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_334_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_330 /= No_Token_Index then

         Transform_Res_269 := Allocate_Generic_Package_Decl (Parser.Mem_Pool);

         Initialize
           (Self => Transform_Res_269, Kind => Ada_Generic_Package_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_330 = Pos then No_Token_Index else Row_Pos_330 - 1));

         Initialize_Fields_For_Generic_Package_Decl
           (Self                                => Transform_Res_269,
            Generic_Decl_F_Formal_Part          => Defer_Res_546,
            Generic_Package_Decl_F_Package_Decl => Transform_Res_268);

         if Defer_Res_546 /= null and then Is_Incomplete (Defer_Res_546) then
            Transform_Res_269.Last_Attempted_Child := 0;
         elsif Defer_Res_546 /= null and then not Is_Ghost (Defer_Res_546) then
            Transform_Res_269.Last_Attempted_Child := -1;
         end if;
         if Transform_Res_268 /= null
           and then Is_Incomplete (Transform_Res_268)
         then
            Transform_Res_269.Last_Attempted_Child := 0;
         elsif Transform_Res_268 /= null
           and then not Is_Ghost (Transform_Res_268)
         then
            Transform_Res_269.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      if Row_Pos_330 /= No_Token_Index then
         Or_Pos_97 := Row_Pos_330;
         Or_Res_97 := Transform_Res_269;
         goto Exit_Or_98;
      end if;
      <<Exit_Or_98>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Generic_Decl_Or_Parse_0_Memo,
         Or_Pos_97 /= No_Token_Index, Or_Res_97, Pos, Or_Pos_97);

      Parser.Current_Pos := Or_Pos_97;

      return Or_Res_97;
   end Generic_Decl_Or_Parse_0;

   function Basic_Decl_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Defer_Pos_203 : Token_Index                := No_Token_Index;
      Defer_Res_203 : Bare_Null_Subp_Decl        := No_Bare_Ada_Node;
      Defer_Pos_204 : Token_Index                := No_Token_Index;
      Defer_Res_204 : Bare_Abstract_Subp_Decl    := No_Bare_Ada_Node;
      Defer_Pos_205 : Token_Index                := No_Token_Index;
      Defer_Res_205 : Bare_Expr_Function         := No_Bare_Ada_Node;
      Defer_Pos_206 : Token_Index                := No_Token_Index;
      Defer_Res_206 : Bare_Subp_Renaming_Decl    := No_Bare_Ada_Node;
      Defer_Pos_207 : Token_Index                := No_Token_Index;
      Defer_Res_207 : Bare_Body_Stub             := No_Bare_Ada_Node;
      Defer_Pos_208 : Token_Index                := No_Token_Index;
      Defer_Res_208 : Bare_Generic_Instantiation := No_Bare_Ada_Node;
      Defer_Pos_209 : Token_Index                := No_Token_Index;
      Defer_Res_209 : Bare_Body_Node             := No_Bare_Ada_Node;
      Defer_Pos_210 : Token_Index                := No_Token_Index;
      Defer_Res_210 : Bare_Subp_Decl             := No_Bare_Ada_Node;
      Defer_Pos_211 : Token_Index                := No_Token_Index;
      Defer_Res_211 : Bare_Base_Type_Decl        := No_Bare_Ada_Node;
      Defer_Pos_212 : Token_Index                := No_Token_Index;
      Defer_Res_212 : Bare_Task_Type_Decl        := No_Bare_Ada_Node;
      Defer_Pos_213 : Token_Index                := No_Token_Index;
      Defer_Res_213 : Bare_Protected_Type_Decl   := No_Bare_Ada_Node;
      Defer_Pos_214 : Token_Index                := No_Token_Index;
      Defer_Res_214 : Bare_Subtype_Decl          := No_Bare_Ada_Node;
      Defer_Pos_215 : Token_Index                := No_Token_Index;
      Defer_Res_215 : Bare_Basic_Decl            := No_Bare_Ada_Node;
      Defer_Pos_216 : Token_Index                := No_Token_Index;
      Defer_Res_216 : Bare_Package_Decl          := No_Bare_Ada_Node;
      Defer_Pos_217 : Token_Index                := No_Token_Index;
      Defer_Res_217 : Bare_Aspect_Clause         := No_Bare_Ada_Node;
      Defer_Pos_218 : Token_Index                := No_Token_Index;
      Defer_Res_218 : Bare_Use_Clause            := No_Bare_Ada_Node;
      Defer_Pos_219 : Token_Index                := No_Token_Index;
      Defer_Res_219 : Bare_Exception_Decl        := No_Bare_Ada_Node;
      Defer_Pos_220 : Token_Index                := No_Token_Index;
      Defer_Res_220 : Bare_Package_Renaming_Decl := No_Bare_Ada_Node;
      Defer_Pos_221 : Token_Index                := No_Token_Index;
      Defer_Res_221 : Bare_Generic_Renaming_Decl := No_Bare_Ada_Node;
      Defer_Pos_222 : Token_Index                := No_Token_Index;
      Defer_Res_222 : Bare_Generic_Decl          := No_Bare_Ada_Node;
      Defer_Pos_223 : Token_Index                := No_Token_Index;
      Defer_Res_223 : Bare_Pragma_Node           := No_Bare_Ada_Node;
      Or_Pos_58     : Token_Index                := No_Token_Index;
      Or_Res_58     : Bare_Ada_Node              := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Basic_Decl_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_58          := M.Instance;
         return Or_Res_58;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_58;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_58 := No_Token_Index;
      Or_Res_58 := No_Bare_Ada_Node;

      Defer_Res_203 := Null_Subp_Decl_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_203 := Parser.Current_Pos;

      if Defer_Pos_203 /= No_Token_Index then
         Or_Pos_58 := Defer_Pos_203;
         Or_Res_58 := Defer_Res_203;
         goto Exit_Or_58;
      end if;

      Defer_Res_204 := Abstract_Subp_Decl_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_204 := Parser.Current_Pos;

      if Defer_Pos_204 /= No_Token_Index then
         Or_Pos_58 := Defer_Pos_204;
         Or_Res_58 := Defer_Res_204;
         goto Exit_Or_58;
      end if;

      Defer_Res_205 := Expr_Fn_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_205 := Parser.Current_Pos;

      if Defer_Pos_205 /= No_Token_Index then
         Or_Pos_58 := Defer_Pos_205;
         Or_Res_58 := Defer_Res_205;
         goto Exit_Or_58;
      end if;

      Defer_Res_206 := Subp_Renaming_Decl_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_206 := Parser.Current_Pos;

      if Defer_Pos_206 /= No_Token_Index then
         Or_Pos_58 := Defer_Pos_206;
         Or_Res_58 := Defer_Res_206;
         goto Exit_Or_58;
      end if;

      Defer_Res_207 := Body_Stub_Or_Parse_0 (Parser, Pos);
      Defer_Pos_207 := Parser.Current_Pos;

      if Defer_Pos_207 /= No_Token_Index then
         Or_Pos_58 := Defer_Pos_207;
         Or_Res_58 := Defer_Res_207;
         goto Exit_Or_58;
      end if;

      Defer_Res_208 := Generic_Instantiation_Or_Parse_1 (Parser, Pos);
      Defer_Pos_208 := Parser.Current_Pos;

      if Defer_Pos_208 /= No_Token_Index then
         Or_Pos_58 := Defer_Pos_208;
         Or_Res_58 := Defer_Res_208;
         goto Exit_Or_58;
      end if;

      Defer_Res_209 := Body_Or_Parse_0 (Parser, Pos);
      Defer_Pos_209 := Parser.Current_Pos;

      if Defer_Pos_209 /= No_Token_Index then
         Or_Pos_58 := Defer_Pos_209;
         Or_Res_58 := Defer_Res_209;
         goto Exit_Or_58;
      end if;

      Defer_Res_210 := Simple_Subp_Decl_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_210 := Parser.Current_Pos;

      if Defer_Pos_210 /= No_Token_Index then
         Or_Pos_58 := Defer_Pos_210;
         Or_Res_58 := Defer_Res_210;
         goto Exit_Or_58;
      end if;

      Defer_Res_211 := Type_Decl_Or_Parse_1 (Parser, Pos);
      Defer_Pos_211 := Parser.Current_Pos;

      if Defer_Pos_211 /= No_Token_Index then
         Or_Pos_58 := Defer_Pos_211;
         Or_Res_58 := Defer_Res_211;
         goto Exit_Or_58;
      end if;

      Defer_Res_212 := Task_Type_Decl_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_212 := Parser.Current_Pos;

      if Defer_Pos_212 /= No_Token_Index then
         Or_Pos_58 := Defer_Pos_212;
         Or_Res_58 := Defer_Res_212;
         goto Exit_Or_58;
      end if;

      Defer_Res_213 := Protected_Type_Decl_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_213 := Parser.Current_Pos;

      if Defer_Pos_213 /= No_Token_Index then
         Or_Pos_58 := Defer_Pos_213;
         Or_Res_58 := Defer_Res_213;
         goto Exit_Or_58;
      end if;

      Defer_Res_214 := Subtype_Decl_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_214 := Parser.Current_Pos;

      if Defer_Pos_214 /= No_Token_Index then
         Or_Pos_58 := Defer_Pos_214;
         Or_Res_58 := Defer_Res_214;
         goto Exit_Or_58;
      end if;

      Defer_Res_215 := Object_Decl_Or_Parse_0 (Parser, Pos);
      Defer_Pos_215 := Parser.Current_Pos;

      if Defer_Pos_215 /= No_Token_Index then
         Or_Pos_58 := Defer_Pos_215;
         Or_Res_58 := Defer_Res_215;
         goto Exit_Or_58;
      end if;

      Defer_Res_216 := Package_Decl_Transform_Parse_3 (Parser, Pos);
      Defer_Pos_216 := Parser.Current_Pos;

      if Defer_Pos_216 /= No_Token_Index then
         Or_Pos_58 := Defer_Pos_216;
         Or_Res_58 := Defer_Res_216;
         goto Exit_Or_58;
      end if;

      Defer_Res_217 := Aspect_Clause_Or_Parse_1 (Parser, Pos);
      Defer_Pos_217 := Parser.Current_Pos;

      if Defer_Pos_217 /= No_Token_Index then
         Or_Pos_58 := Defer_Pos_217;
         Or_Res_58 := Defer_Res_217;
         goto Exit_Or_58;
      end if;

      Defer_Res_218 := Use_Clause_Or_Parse_0 (Parser, Pos);
      Defer_Pos_218 := Parser.Current_Pos;

      if Defer_Pos_218 /= No_Token_Index then
         Or_Pos_58 := Defer_Pos_218;
         Or_Res_58 := Defer_Res_218;
         goto Exit_Or_58;
      end if;

      Defer_Res_219 := Exception_Decl_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_219 := Parser.Current_Pos;

      if Defer_Pos_219 /= No_Token_Index then
         Or_Pos_58 := Defer_Pos_219;
         Or_Res_58 := Defer_Res_219;
         goto Exit_Or_58;
      end if;

      Defer_Res_220 := Package_Renaming_Decl_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_220 := Parser.Current_Pos;

      if Defer_Pos_220 /= No_Token_Index then
         Or_Pos_58 := Defer_Pos_220;
         Or_Res_58 := Defer_Res_220;
         goto Exit_Or_58;
      end if;

      Defer_Res_221 := Generic_Renaming_Decl_Or_Parse_1 (Parser, Pos);
      Defer_Pos_221 := Parser.Current_Pos;

      if Defer_Pos_221 /= No_Token_Index then
         Or_Pos_58 := Defer_Pos_221;
         Or_Res_58 := Defer_Res_221;
         goto Exit_Or_58;
      end if;

      Defer_Res_222 := Generic_Decl_Or_Parse_0 (Parser, Pos);
      Defer_Pos_222 := Parser.Current_Pos;

      if Defer_Pos_222 /= No_Token_Index then
         Or_Pos_58 := Defer_Pos_222;
         Or_Res_58 := Defer_Res_222;
         goto Exit_Or_58;
      end if;

      Defer_Res_223 := Pragma_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_223 := Parser.Current_Pos;

      if Defer_Pos_223 /= No_Token_Index then
         Or_Pos_58 := Defer_Pos_223;
         Or_Res_58 := Defer_Res_223;
         goto Exit_Or_58;
      end if;
      <<Exit_Or_58>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Basic_Decl_Or_Parse_0_Memo,
         Or_Pos_58 /= No_Token_Index, Or_Res_58, Pos, Or_Pos_58);

      Parser.Current_Pos := Or_Pos_58;

      return Or_Res_58;
   end Basic_Decl_Or_Parse_0;

   function Basic_Decls_List_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node_List
   is
      use Bare_Ada_Node_List_Memos;

      Lst_Cpos_16       : Token_Index        := No_Token_Index;
      Tmp_List_16       : Free_Parse_List;
      Defer_Pos_202     : Token_Index        := No_Token_Index;
      Defer_Res_202     : Bare_Ada_Node      := No_Bare_Ada_Node;
      Row_Pos_144       : Token_Index        := No_Token_Index;
      Transform_Res_124 : Bare_Error_Decl    := No_Bare_Ada_Node;
      Skip_Pos_0        : Token_Index        := No_Token_Index;
      Skip_Dummy_0      : Bare_Ada_Node      := No_Bare_Ada_Node;
      Or_Pos_57         : Token_Index        := No_Token_Index;
      Or_Res_57         : Bare_Ada_Node      := No_Bare_Ada_Node;
      List_Pos_16       : Token_Index        := No_Token_Index;
      List_Res_16       : Bare_Ada_Node_List := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Basic_Decls_List_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         List_Res_16        := M.Instance;
         return List_Res_16;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return List_Res_16;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start list_code

      List_Pos_16 := Pos;

      Lst_Cpos_16 := Pos;
      Tmp_List_16 := Get_Parse_List (Parser);

      loop

--  Start or_code

         Or_Pos_57 := No_Token_Index;
         Or_Res_57 := No_Bare_Ada_Node;

         Defer_Res_202 := Basic_Decl_Or_Parse_0 (Parser, Lst_Cpos_16);
         Defer_Pos_202 := Parser.Current_Pos;

         if Defer_Pos_202 /= No_Token_Index then
            Or_Pos_57 := Defer_Pos_202;
            Or_Res_57 := Defer_Res_202;
            goto Exit_Or_57;
         end if;

         if Get_Token (Parser.TDH.all, Lst_Cpos_16).Kind =
           From_Token_Kind (Ada_Termination)
         then
            Skip_Pos_0 := No_Token_Index;
            goto Exit_Or_101;
         end if;

         for Fn of Parser.Private_Part.Dont_Skip loop
            Skip_Dummy_0 := Fn (Parser, Lst_Cpos_16);

            if Parser.Current_Pos /= No_Token_Index then
               Skip_Pos_0 := No_Token_Index;
               goto Exit_Or_101;
            end if;
         end loop;

         Skip_Pos_0 := Lst_Cpos_16 + 1;

--  Start transform_code

--  Start row_code

         Row_Pos_144 := Lst_Cpos_16;

         pragma Warnings (Off, "referenced");
         <<Exit_Row_341_0>>
         pragma Warnings (On, "referenced");

--  End row_code

         if Row_Pos_144 /= No_Token_Index then

            Transform_Res_124 := Allocate_Error_Decl (Parser.Mem_Pool);

            Initialize
              (Self            => Transform_Res_124, Kind => Ada_Error_Decl,
               Unit            => Parser.Unit,
Token_Start_Index              => Lst_Cpos_16,
               Token_End_Index =>
                 (if Row_Pos_144 = Lst_Cpos_16 then No_Token_Index
                  else Row_Pos_144 - 1));

         end if;

--  End transform_code

         Transform_Res_124.Token_End_Index := Lst_Cpos_16;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Lst_Cpos_16).Sloc_Range,
            To_Text ("Skipped token ") &
            Common.Text
              (Wrap_Token_Reference
                 (Parser.TDH, (Lst_Cpos_16, No_Token_Index))));

         <<Exit_Or_101>>

         if Skip_Pos_0 /= No_Token_Index then
            Or_Pos_57 := Skip_Pos_0;
            Or_Res_57 := Transform_Res_124;
            goto Exit_Or_57;
         end if;
         <<Exit_Or_57>>

--  End or_code

         exit when Or_Pos_57 = No_Token_Index;

         List_Pos_16 := Or_Pos_57;
         Lst_Cpos_16 := List_Pos_16;

         Tmp_List_16.Nodes.Append (Or_Res_57);

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_16.Nodes.Length;
      begin
         List_Res_16 := Allocate_Ada_Node_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Pos;
            Token_End := (if Lst_Cpos_16 = Pos then Pos else Lst_Cpos_16 - 1);

         else
            Token_Start := Token_Index'Max (Pos, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self            => List_Res_16, Kind => Ada_Ada_Node_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_16, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_16.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_16.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_16);

--  End list_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Basic_Decls_List_Parse_0_Memo,
         List_Pos_16 /= No_Token_Index, List_Res_16, Pos, List_Pos_16);

      Parser.Current_Pos := List_Pos_16;

      return List_Res_16;
   end Basic_Decls_List_Parse_0;

   function Decl_Part_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Declarative_Part
   is
      use Bare_Declarative_Part_Memos;

      Row_Pos_143       : Token_Index           := No_Token_Index;
      Defer_Pos_201     : Token_Index           := No_Token_Index;
      Defer_Res_201     : Bare_Ada_Node_List    := No_Bare_Ada_Node;
      Transform_Res_123 : Bare_Declarative_Part := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Decl_Part_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_123  := M.Instance;
         return Transform_Res_123;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_123;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_143 := Pos;

      Defer_Res_201 := Basic_Decls_List_Parse_0 (Parser, Row_Pos_143);
      Defer_Pos_201 := Parser.Current_Pos;

      if Defer_Pos_201 /= No_Token_Index then

         Row_Pos_143 := Defer_Pos_201;

      else
         Row_Pos_143 := No_Token_Index;
         goto Exit_Row_143_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_143_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_143 /= No_Token_Index then

         Transform_Res_123 := Allocate_Declarative_Part (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_123, Kind => Ada_Declarative_Part,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_143 = Pos then No_Token_Index else Row_Pos_143 - 1));

         Initialize_Fields_For_Declarative_Part
           (Self                     => Transform_Res_123,
            Declarative_Part_F_Decls => Defer_Res_201);

         if Defer_Res_201 /= null and then Is_Incomplete (Defer_Res_201) then
            Transform_Res_123.Last_Attempted_Child := 0;
         elsif Defer_Res_201 /= null and then not Is_Ghost (Defer_Res_201) then
            Transform_Res_123.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Decl_Part_Transform_Parse_0_Memo,
         Row_Pos_143 /= No_Token_Index, Transform_Res_123, Pos, Row_Pos_143);

      Parser.Current_Pos := Row_Pos_143;

      return Transform_Res_123;
   end Decl_Part_Transform_Parse_0;

   function Dontskip_Exception_Handler_0_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Row_Pos_342   : Token_Index   := No_Token_Index;
      Null_Res_15   : Bare_Ada_Node := No_Bare_Ada_Node;
      Token_Pos_522 : Token_Index   := No_Token_Index;
      Token_Res_522 : Token_Index   := No_Token_Index;
      Token_Pos_523 : Token_Index   := No_Token_Index;
      Token_Res_523 : Token_Index   := No_Token_Index;
      Token_Pos_524 : Token_Index   := No_Token_Index;
      Token_Res_524 : Token_Index   := No_Token_Index;
      Or_Pos_100    : Token_Index   := No_Token_Index;
      Or_Res_100    : Token_Index   := No_Token_Index;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part
             .Dontskip_Exception_Handler_0_Extract_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Null_Res_15        := M.Instance;
         return Null_Res_15;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Null_Res_15;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start row_code

      Row_Pos_342 := Pos;

      Null_Res_15 := No_Bare_Ada_Node;

      if Row_Pos_342 /= No_Token_Index then

         Row_Pos_342 := Row_Pos_342;

      else
         Row_Pos_342 := No_Token_Index;
         goto Exit_Row_342_0;

      end if;

--  Start or_code

      Or_Pos_100 := No_Token_Index;
      Or_Res_100 := No_Token_Index;

--  Start tok_code

      Token_Res_522 := Row_Pos_342;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_522));
      begin
         if T.Kind /= From_Token_Kind (Ada_When) then
            Token_Pos_522 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_342 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_342,
                  Expected_Token_Id => Ada_When,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_522 := Row_Pos_342 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_522 /= No_Token_Index then
         Or_Pos_100 := Token_Pos_522;
         Or_Res_100 := Token_Res_522;
         goto Exit_Or_102;
      end if;

--  Start tok_code

      Token_Res_523 := Row_Pos_342;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_523));
      begin
         if T.Kind /= From_Token_Kind (Ada_Pragma) then
            Token_Pos_523 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_342 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_342,
                  Expected_Token_Id => Ada_Pragma,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_523 := Row_Pos_342 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_523 /= No_Token_Index then
         Or_Pos_100 := Token_Pos_523;
         Or_Res_100 := Token_Res_523;
         goto Exit_Or_102;
      end if;

--  Start tok_code

      Token_Res_524 := Row_Pos_342;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_524));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_524 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_342 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_342,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_524 := Row_Pos_342 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_524 /= No_Token_Index then
         Or_Pos_100 := Token_Pos_524;
         Or_Res_100 := Token_Res_524;
         goto Exit_Or_102;
      end if;
      <<Exit_Or_102>>

--  End or_code

      if Or_Pos_100 /= No_Token_Index then

         Row_Pos_342 := Or_Pos_100;

      else
         Row_Pos_342 := No_Token_Index;
         goto Exit_Row_342_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_342_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Dontskip_Exception_Handler_0_Extract_Parse_0_Memo,
         Row_Pos_342 /= No_Token_Index, Null_Res_15, Pos, Row_Pos_342);

      Parser.Current_Pos := Row_Pos_342;

      return Null_Res_15;
   end Dontskip_Exception_Handler_0_Extract_Parse_0;

   function With_Clause_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_With_Clause
   is
      use Bare_With_Clause_Memos;

      Row_Pos_344       : Token_Index       := No_Token_Index;
      Token_Pos_525     : Token_Index       := No_Token_Index;
      Token_Res_525     : Token_Index       := No_Token_Index;
      Opt_Res_30        : Bare_Limited_Node := No_Bare_Ada_Node;
      Token_Pos_526     : Token_Index       := No_Token_Index;
      Token_Res_526     : Token_Index       := No_Token_Index;
      Opt_Res_31        : Bare_Private_Node := No_Bare_Ada_Node;
      Token_Pos_527     : Token_Index       := No_Token_Index;
      Token_Res_527     : Token_Index       := No_Token_Index;
      Lst_Cpos_45       : Token_Index       := No_Token_Index;
      Tmp_List_45       : Free_Parse_List;
      Defer_Pos_566     : Token_Index       := No_Token_Index;
      Defer_Res_566     : Bare_Name         := No_Bare_Ada_Node;
      Token_Pos_528     : Token_Index       := No_Token_Index;
      Token_Res_528     : Token_Index       := No_Token_Index;
      List_Pos_45       : Token_Index       := No_Token_Index;
      List_Res_45       : Bare_Name_List    := No_Bare_Ada_Node;
      Token_Pos_529     : Token_Index       := No_Token_Index;
      Token_Res_529     : Token_Index       := No_Token_Index;
      Transform_Res_276 : Bare_With_Clause  := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.With_Clause_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_276  := M.Instance;
         return Transform_Res_276;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_276;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_344 := Pos;

--  Start opt_code

--  Start tok_code

      Token_Res_525 := Row_Pos_344;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_525));
      begin
         if T.Kind /= From_Token_Kind (Ada_Limited) then
            Token_Pos_525 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_344 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_344,
                  Expected_Token_Id => Ada_Limited,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_525 := Row_Pos_344 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_525 = No_Token_Index then

         Opt_Res_30 := Allocate_Limited_Absent (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_30, Kind => Ada_Limited_Absent,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_344,
            Token_End_Index => No_Token_Index);

         Token_Pos_525 := Row_Pos_344;

      else

         Opt_Res_30 := Allocate_Limited_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_30, Kind => Ada_Limited_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_344,
            Token_End_Index => Token_Pos_525 - 1);

      end if;

--  End opt_code

      if Token_Pos_525 /= No_Token_Index then

         Row_Pos_344 := Token_Pos_525;

      else
         Row_Pos_344 := No_Token_Index;
         goto Exit_Row_344_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_526 := Row_Pos_344;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_526));
      begin
         if T.Kind /= From_Token_Kind (Ada_Private) then
            Token_Pos_526 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_344 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_344,
                  Expected_Token_Id => Ada_Private,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_526 := Row_Pos_344 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_526 = No_Token_Index then

         Opt_Res_31 := Allocate_Private_Absent (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_31, Kind => Ada_Private_Absent,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_344,
            Token_End_Index => No_Token_Index);

         Token_Pos_526 := Row_Pos_344;

      else

         Opt_Res_31 := Allocate_Private_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_31, Kind => Ada_Private_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_344,
            Token_End_Index => Token_Pos_526 - 1);

      end if;

--  End opt_code

      if Token_Pos_526 /= No_Token_Index then

         Row_Pos_344 := Token_Pos_526;

      else
         Row_Pos_344 := No_Token_Index;
         goto Exit_Row_344_0;

      end if;

--  Start tok_code

      Token_Res_527 := Row_Pos_344;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_527));
      begin
         if T.Kind /= From_Token_Kind (Ada_With) then
            Token_Pos_527 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_344 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_344,
                  Expected_Token_Id => Ada_With,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_527 := Row_Pos_344 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_527 /= No_Token_Index then

         Row_Pos_344 := Token_Pos_527;

      else
         Row_Pos_344 := No_Token_Index;
         goto Exit_Row_344_0;

      end if;

--  Start list_code

      List_Pos_45 := No_Token_Index;

      Lst_Cpos_45 := Row_Pos_344;
      Tmp_List_45 := Get_Parse_List (Parser);

      loop

         Defer_Res_566 := Static_Name_Or_Parse_0 (Parser, Lst_Cpos_45);
         Defer_Pos_566 := Parser.Current_Pos;

         exit when Defer_Pos_566 = No_Token_Index;

         List_Pos_45 := Defer_Pos_566;
         Lst_Cpos_45 := List_Pos_45;

         Tmp_List_45.Nodes.Append (Defer_Res_566);

--  Start tok_code

         Token_Res_528 := Lst_Cpos_45;

         declare
            T : constant Stored_Token_Data :=
              Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_528));
         begin
            if T.Kind /= From_Token_Kind (Ada_Comma) then
               Token_Pos_528 := No_Token_Index;

               if Parser.Last_Fail.Pos <= Lst_Cpos_45 then
                  Parser.Last_Fail :=
                    (Kind              => Token_Fail, Pos => Lst_Cpos_45,
                     Expected_Token_Id => Ada_Comma,
                     Found_Token_Id    => To_Token_Kind (T.Kind));
               end if;
            else
               Token_Pos_528 := Lst_Cpos_45 + 1;
            end if;
         end;

--  End tok_code

         if Token_Pos_528 /= No_Token_Index then
            Lst_Cpos_45 := Token_Pos_528;
         else
            exit;
         end if;

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_45.Nodes.Length;
      begin
         List_Res_45 := Allocate_Name_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_344;
            Token_End   :=
              (if Lst_Cpos_45 = Row_Pos_344 then Row_Pos_344
               else Lst_Cpos_45 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_344, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self => List_Res_45, Kind => Ada_Name_List, Unit => Parser.Unit,
            Token_Start_Index => Token_Start, Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_45, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_45.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_45.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_45);

--  End list_code

      if List_Pos_45 /= No_Token_Index then

         Row_Pos_344 := List_Pos_45;

      else
         Row_Pos_344 := No_Token_Index;
         goto Exit_Row_344_0;

      end if;

--  Start opt_code

--  Start tok_code

      Token_Res_529 := Row_Pos_344;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_529));
      begin
         if T.Kind /= From_Token_Kind (Ada_Semicolon) then
            Token_Pos_529 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_344 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_344,
                  Expected_Token_Id => Ada_Semicolon,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_529 := Row_Pos_344 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_529 = No_Token_Index then

         Token_Res_529 := No_Token_Index;

         Append
           (Parser.Diagnostics,
            Get_Token (Parser.TDH.all, Row_Pos_344).Sloc_Range,
            To_Text ("Missing ';'"));

         Token_Pos_529 := Row_Pos_344;

      end if;

--  End opt_code

      if Token_Pos_529 /= No_Token_Index then

         Row_Pos_344 := Token_Pos_529;

      else
         Row_Pos_344 := No_Token_Index;
         goto Exit_Row_344_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_344_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_344 /= No_Token_Index then

         Transform_Res_276 := Allocate_With_Clause (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_276, Kind => Ada_With_Clause,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_344 = Pos then No_Token_Index else Row_Pos_344 - 1));

         Initialize_Fields_For_With_Clause
           (Self => Transform_Res_276, With_Clause_F_Has_Limited => Opt_Res_30,
            With_Clause_F_Has_Private => Opt_Res_31,
            With_Clause_F_Packages    => List_Res_45);

         if Opt_Res_30 /= null and then Is_Incomplete (Opt_Res_30) then
            Transform_Res_276.Last_Attempted_Child := 0;
         elsif Opt_Res_30 /= null and then not Is_Ghost (Opt_Res_30) then
            Transform_Res_276.Last_Attempted_Child := -1;
         end if;
         if Opt_Res_31 /= null and then Is_Incomplete (Opt_Res_31) then
            Transform_Res_276.Last_Attempted_Child := 0;
         elsif Opt_Res_31 /= null and then not Is_Ghost (Opt_Res_31) then
            Transform_Res_276.Last_Attempted_Child := -1;
         end if;
         if List_Res_45 /= null and then Is_Incomplete (List_Res_45) then
            Transform_Res_276.Last_Attempted_Child := 0;
         elsif List_Res_45 /= null and then not Is_Ghost (List_Res_45) then
            Transform_Res_276.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.With_Clause_Transform_Parse_0_Memo,
         Row_Pos_344 /= No_Token_Index, Transform_Res_276, Pos, Row_Pos_344);

      Parser.Current_Pos := Row_Pos_344;

      return Transform_Res_276;
   end With_Clause_Transform_Parse_0;

   function Context_Item_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Defer_Pos_563 : Token_Index      := No_Token_Index;
      Defer_Res_563 : Bare_With_Clause := No_Bare_Ada_Node;
      Defer_Pos_564 : Token_Index      := No_Token_Index;
      Defer_Res_564 : Bare_Use_Clause  := No_Bare_Ada_Node;
      Defer_Pos_565 : Token_Index      := No_Token_Index;
      Defer_Res_565 : Bare_Pragma_Node := No_Bare_Ada_Node;
      Or_Pos_102    : Token_Index      := No_Token_Index;
      Or_Res_102    : Bare_Ada_Node    := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Context_Item_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_102         := M.Instance;
         return Or_Res_102;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_102;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_102 := No_Token_Index;
      Or_Res_102 := No_Bare_Ada_Node;

      Defer_Res_563 := With_Clause_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_563 := Parser.Current_Pos;

      if Defer_Pos_563 /= No_Token_Index then
         Or_Pos_102 := Defer_Pos_563;
         Or_Res_102 := Defer_Res_563;
         goto Exit_Or_103;
      end if;

      Defer_Res_564 := Use_Clause_Or_Parse_0 (Parser, Pos);
      Defer_Pos_564 := Parser.Current_Pos;

      if Defer_Pos_564 /= No_Token_Index then
         Or_Pos_102 := Defer_Pos_564;
         Or_Res_102 := Defer_Res_564;
         goto Exit_Or_103;
      end if;

      Defer_Res_565 := Pragma_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_565 := Parser.Current_Pos;

      if Defer_Pos_565 /= No_Token_Index then
         Or_Pos_102 := Defer_Pos_565;
         Or_Res_102 := Defer_Res_565;
         goto Exit_Or_103;
      end if;
      <<Exit_Or_103>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Context_Item_Or_Parse_0_Memo,
         Or_Pos_102 /= No_Token_Index, Or_Res_102, Pos, Or_Pos_102);

      Parser.Current_Pos := Or_Pos_102;

      return Or_Res_102;
   end Context_Item_Or_Parse_0;

   function Subunit_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Subunit
   is
      use Bare_Subunit_Memos;

      Row_Pos_345       : Token_Index         := No_Token_Index;
      Token_Pos_530     : Token_Index         := No_Token_Index;
      Token_Res_530     : Token_Index         := No_Token_Index;
      Token_Pos_531     : Token_Index         := No_Token_Index;
      Token_Res_531     : Token_Index         := No_Token_Index;
      Defer_Pos_567     : Token_Index         := No_Token_Index;
      Defer_Res_567     : Bare_Name           := No_Bare_Ada_Node;
      Token_Pos_532     : Token_Index         := No_Token_Index;
      Token_Res_532     : Token_Index         := No_Token_Index;
      Defer_Pos_568     : Token_Index         := No_Token_Index;
      Defer_Res_568     : Bare_Subp_Body      := No_Bare_Ada_Node;
      Defer_Pos_569     : Token_Index         := No_Token_Index;
      Defer_Res_569     : Bare_Package_Body   := No_Bare_Ada_Node;
      Defer_Pos_570     : Token_Index         := No_Token_Index;
      Defer_Res_570     : Bare_Task_Body      := No_Bare_Ada_Node;
      Defer_Pos_571     : Token_Index         := No_Token_Index;
      Defer_Res_571     : Bare_Protected_Body := No_Bare_Ada_Node;
      Or_Pos_103        : Token_Index         := No_Token_Index;
      Or_Res_103        : Bare_Body_Node      := No_Bare_Ada_Node;
      Transform_Res_277 : Bare_Subunit        := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Subunit_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_277  := M.Instance;
         return Transform_Res_277;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_277;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_345 := Pos;

--  Start tok_code

      Token_Res_530 := Row_Pos_345;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_530));
      begin
         if T.Kind /= From_Token_Kind (Ada_Separate) then
            Token_Pos_530 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_345 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_345,
                  Expected_Token_Id => Ada_Separate,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_530 := Row_Pos_345 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_530 /= No_Token_Index then

         Row_Pos_345 := Token_Pos_530;

      else
         Row_Pos_345 := No_Token_Index;
         goto Exit_Row_345_0;

      end if;

--  Start tok_code

      Token_Res_531 := Row_Pos_345;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_531));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Open) then
            Token_Pos_531 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_345 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_345,
                  Expected_Token_Id => Ada_Par_Open,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_531 := Row_Pos_345 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_531 /= No_Token_Index then

         Row_Pos_345 := Token_Pos_531;

      else
         Row_Pos_345 := No_Token_Index;
         goto Exit_Row_345_0;

      end if;

      Defer_Res_567 := Static_Name_Or_Parse_0 (Parser, Row_Pos_345);
      Defer_Pos_567 := Parser.Current_Pos;

      if Defer_Pos_567 /= No_Token_Index then

         Row_Pos_345 := Defer_Pos_567;

      else
         Row_Pos_345 := No_Token_Index;
         goto Exit_Row_345_0;

      end if;

--  Start tok_code

      Token_Res_532 := Row_Pos_345;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_532));
      begin
         if T.Kind /= From_Token_Kind (Ada_Par_Close) then
            Token_Pos_532 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_345 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_345,
                  Expected_Token_Id => Ada_Par_Close,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_532 := Row_Pos_345 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_532 /= No_Token_Index then

         Row_Pos_345 := Token_Pos_532;

      else
         Row_Pos_345 := No_Token_Index;
         goto Exit_Row_345_0;

      end if;

--  Start or_code

      Or_Pos_103 := No_Token_Index;
      Or_Res_103 := No_Bare_Ada_Node;

      Defer_Res_568 := Subp_Body_Transform_Parse_1 (Parser, Row_Pos_345);
      Defer_Pos_568 := Parser.Current_Pos;

      if Defer_Pos_568 /= No_Token_Index then
         Or_Pos_103 := Defer_Pos_568;
         Or_Res_103 := Defer_Res_568;
         goto Exit_Or_105;
      end if;

      Defer_Res_569 := Package_Body_Transform_Parse_1 (Parser, Row_Pos_345);
      Defer_Pos_569 := Parser.Current_Pos;

      if Defer_Pos_569 /= No_Token_Index then
         Or_Pos_103 := Defer_Pos_569;
         Or_Res_103 := Defer_Res_569;
         goto Exit_Or_105;
      end if;

      Defer_Res_570 := Task_Body_Transform_Parse_1 (Parser, Row_Pos_345);
      Defer_Pos_570 := Parser.Current_Pos;

      if Defer_Pos_570 /= No_Token_Index then
         Or_Pos_103 := Defer_Pos_570;
         Or_Res_103 := Defer_Res_570;
         goto Exit_Or_105;
      end if;

      Defer_Res_571 := Protected_Body_Transform_Parse_1 (Parser, Row_Pos_345);
      Defer_Pos_571 := Parser.Current_Pos;

      if Defer_Pos_571 /= No_Token_Index then
         Or_Pos_103 := Defer_Pos_571;
         Or_Res_103 := Defer_Res_571;
         goto Exit_Or_105;
      end if;
      <<Exit_Or_105>>

--  End or_code

      if Or_Pos_103 /= No_Token_Index then

         Row_Pos_345 := Or_Pos_103;

      else
         Row_Pos_345 := No_Token_Index;
         goto Exit_Row_345_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_345_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_345 /= No_Token_Index then

         Transform_Res_277 := Allocate_Subunit (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_277, Kind => Ada_Subunit,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_345 = Pos then No_Token_Index else Row_Pos_345 - 1));

         Initialize_Fields_For_Subunit
           (Self => Transform_Res_277, Subunit_F_Name => Defer_Res_567,
            Subunit_F_Body => Or_Res_103);

         if Defer_Res_567 /= null and then Is_Incomplete (Defer_Res_567) then
            Transform_Res_277.Last_Attempted_Child := 0;
         elsif Defer_Res_567 /= null and then not Is_Ghost (Defer_Res_567) then
            Transform_Res_277.Last_Attempted_Child := -1;
         end if;
         if Or_Res_103 /= null and then Is_Incomplete (Or_Res_103) then
            Transform_Res_277.Last_Attempted_Child := 0;
         elsif Or_Res_103 /= null and then not Is_Ghost (Or_Res_103) then
            Transform_Res_277.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Subunit_Transform_Parse_0_Memo,
         Row_Pos_345 /= No_Token_Index, Transform_Res_277, Pos, Row_Pos_345);

      Parser.Current_Pos := Row_Pos_345;

      return Transform_Res_277;
   end Subunit_Transform_Parse_0;

   function Library_Unit_Body_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Body_Node
   is
      use Bare_Body_Node_Memos;

      Defer_Pos_582 : Token_Index       := No_Token_Index;
      Defer_Res_582 : Bare_Subp_Body    := No_Bare_Ada_Node;
      Defer_Pos_583 : Token_Index       := No_Token_Index;
      Defer_Res_583 : Bare_Package_Body := No_Bare_Ada_Node;
      Or_Pos_105    : Token_Index       := No_Token_Index;
      Or_Res_105    : Bare_Body_Node    := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Library_Unit_Body_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_105         := M.Instance;
         return Or_Res_105;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_105;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_105 := No_Token_Index;
      Or_Res_105 := No_Bare_Ada_Node;

      Defer_Res_582 := Subp_Body_Transform_Parse_1 (Parser, Pos);
      Defer_Pos_582 := Parser.Current_Pos;

      if Defer_Pos_582 /= No_Token_Index then
         Or_Pos_105 := Defer_Pos_582;
         Or_Res_105 := Defer_Res_582;
         goto Exit_Or_107;
      end if;

      Defer_Res_583 := Package_Body_Transform_Parse_1 (Parser, Pos);
      Defer_Pos_583 := Parser.Current_Pos;

      if Defer_Pos_583 /= No_Token_Index then
         Or_Pos_105 := Defer_Pos_583;
         Or_Res_105 := Defer_Res_583;
         goto Exit_Or_107;
      end if;
      <<Exit_Or_107>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Library_Unit_Body_Or_Parse_0_Memo,
         Or_Pos_105 /= No_Token_Index, Or_Res_105, Pos, Or_Pos_105);

      Parser.Current_Pos := Or_Pos_105;

      return Or_Res_105;
   end Library_Unit_Body_Or_Parse_0;

   function Library_Unit_Renaming_Decl_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Basic_Decl
   is
      use Bare_Basic_Decl_Memos;

      Defer_Pos_584 : Token_Index                := No_Token_Index;
      Defer_Res_584 : Bare_Package_Renaming_Decl := No_Bare_Ada_Node;
      Defer_Pos_585 : Token_Index                := No_Token_Index;
      Defer_Res_585 : Bare_Generic_Renaming_Decl := No_Bare_Ada_Node;
      Or_Pos_106    : Token_Index                := No_Token_Index;
      Or_Res_106    : Bare_Basic_Decl            := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Library_Unit_Renaming_Decl_Or_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_106         := M.Instance;
         return Or_Res_106;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_106;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_106 := No_Token_Index;
      Or_Res_106 := No_Bare_Ada_Node;

      Defer_Res_584 := Package_Renaming_Decl_Transform_Parse_0 (Parser, Pos);
      Defer_Pos_584 := Parser.Current_Pos;

      if Defer_Pos_584 /= No_Token_Index then
         Or_Pos_106 := Defer_Pos_584;
         Or_Res_106 := Defer_Res_584;
         goto Exit_Or_108;
      end if;

      Defer_Res_585 := Generic_Renaming_Decl_Or_Parse_1 (Parser, Pos);
      Defer_Pos_585 := Parser.Current_Pos;

      if Defer_Pos_585 /= No_Token_Index then
         Or_Pos_106 := Defer_Pos_585;
         Or_Res_106 := Defer_Res_585;
         goto Exit_Or_108;
      end if;
      <<Exit_Or_108>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Library_Unit_Renaming_Decl_Or_Parse_0_Memo,
         Or_Pos_106 /= No_Token_Index, Or_Res_106, Pos, Or_Pos_106);

      Parser.Current_Pos := Or_Pos_106;

      return Or_Res_106;
   end Library_Unit_Renaming_Decl_Or_Parse_0;

   function Library_Item_Transform_Parse_1
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Library_Item
   is
      use Bare_Library_Item_Memos;

      Row_Pos_346       : Token_Index                := No_Token_Index;
      Token_Pos_533     : Token_Index                := No_Token_Index;
      Token_Res_533     : Token_Index                := No_Token_Index;
      Opt_Res_32        : Bare_Private_Node          := No_Bare_Ada_Node;
      Defer_Pos_572     : Token_Index                := No_Token_Index;
      Defer_Res_572     : Bare_Null_Subp_Decl        := No_Bare_Ada_Node;
      Defer_Pos_573     : Token_Index                := No_Token_Index;
      Defer_Res_573     : Bare_Abstract_Subp_Decl    := No_Bare_Ada_Node;
      Defer_Pos_574     : Token_Index                := No_Token_Index;
      Defer_Res_574     : Bare_Expr_Function         := No_Bare_Ada_Node;
      Defer_Pos_575     : Token_Index                := No_Token_Index;
      Defer_Res_575     : Bare_Subp_Renaming_Decl    := No_Bare_Ada_Node;
      Defer_Pos_576     : Token_Index                := No_Token_Index;
      Defer_Res_576     : Bare_Generic_Instantiation := No_Bare_Ada_Node;
      Defer_Pos_577     : Token_Index                := No_Token_Index;
      Defer_Res_577     : Bare_Body_Node             := No_Bare_Ada_Node;
      Defer_Pos_578     : Token_Index                := No_Token_Index;
      Defer_Res_578     : Bare_Subp_Decl             := No_Bare_Ada_Node;
      Defer_Pos_579     : Token_Index                := No_Token_Index;
      Defer_Res_579     : Bare_Basic_Decl            := No_Bare_Ada_Node;
      Defer_Pos_580     : Token_Index                := No_Token_Index;
      Defer_Res_580     : Bare_Generic_Decl          := No_Bare_Ada_Node;
      Defer_Pos_581     : Token_Index                := No_Token_Index;
      Defer_Res_581     : Bare_Package_Decl          := No_Bare_Ada_Node;
      Row_Pos_347       : Token_Index                := No_Token_Index;
      Transform_Res_278 : Bare_Error_Decl            := No_Bare_Ada_Node;
      Skip_Pos_2        : Token_Index                := No_Token_Index;
      Skip_Dummy_2      : Bare_Ada_Node              := No_Bare_Ada_Node;
      Or_Pos_104        : Token_Index                := No_Token_Index;
      Or_Res_104        : Bare_Basic_Decl            := No_Bare_Ada_Node;
      Transform_Res_279 : Bare_Library_Item          := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Library_Item_Transform_Parse_1_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_279  := M.Instance;
         return Transform_Res_279;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_279;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_346 := Pos;

--  Start opt_code

--  Start tok_code

      Token_Res_533 := Row_Pos_346;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_533));
      begin
         if T.Kind /= From_Token_Kind (Ada_Private) then
            Token_Pos_533 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_346 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_346,
                  Expected_Token_Id => Ada_Private,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_533 := Row_Pos_346 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_533 = No_Token_Index then

         Opt_Res_32 := Allocate_Private_Absent (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_32, Kind => Ada_Private_Absent,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_346,
            Token_End_Index => No_Token_Index);

         Token_Pos_533 := Row_Pos_346;

      else

         Opt_Res_32 := Allocate_Private_Present (Parser.Mem_Pool);
         Initialize
           (Self            => Opt_Res_32, Kind => Ada_Private_Present,
            Unit            => Parser.Unit, Token_Start_Index => Row_Pos_346,
            Token_End_Index => Token_Pos_533 - 1);

      end if;

--  End opt_code

      if Token_Pos_533 /= No_Token_Index then

         Row_Pos_346 := Token_Pos_533;

      else
         Row_Pos_346 := No_Token_Index;
         goto Exit_Row_346_0;

      end if;

--  Start or_code

      Or_Pos_104 := No_Token_Index;
      Or_Res_104 := No_Bare_Ada_Node;

      Defer_Res_572 := Null_Subp_Decl_Transform_Parse_0 (Parser, Row_Pos_346);
      Defer_Pos_572 := Parser.Current_Pos;

      if Defer_Pos_572 /= No_Token_Index then
         Or_Pos_104 := Defer_Pos_572;
         Or_Res_104 := Defer_Res_572;
         goto Exit_Or_106;
      end if;

      Defer_Res_573 :=
        Abstract_Subp_Decl_Transform_Parse_0 (Parser, Row_Pos_346);
      Defer_Pos_573 := Parser.Current_Pos;

      if Defer_Pos_573 /= No_Token_Index then
         Or_Pos_104 := Defer_Pos_573;
         Or_Res_104 := Defer_Res_573;
         goto Exit_Or_106;
      end if;

      Defer_Res_574 := Expr_Fn_Transform_Parse_0 (Parser, Row_Pos_346);
      Defer_Pos_574 := Parser.Current_Pos;

      if Defer_Pos_574 /= No_Token_Index then
         Or_Pos_104 := Defer_Pos_574;
         Or_Res_104 := Defer_Res_574;
         goto Exit_Or_106;
      end if;

      Defer_Res_575 :=
        Subp_Renaming_Decl_Transform_Parse_0 (Parser, Row_Pos_346);
      Defer_Pos_575 := Parser.Current_Pos;

      if Defer_Pos_575 /= No_Token_Index then
         Or_Pos_104 := Defer_Pos_575;
         Or_Res_104 := Defer_Res_575;
         goto Exit_Or_106;
      end if;

      Defer_Res_576 := Generic_Instantiation_Or_Parse_1 (Parser, Row_Pos_346);
      Defer_Pos_576 := Parser.Current_Pos;

      if Defer_Pos_576 /= No_Token_Index then
         Or_Pos_104 := Defer_Pos_576;
         Or_Res_104 := Defer_Res_576;
         goto Exit_Or_106;
      end if;

      Defer_Res_577 := Library_Unit_Body_Or_Parse_0 (Parser, Row_Pos_346);
      Defer_Pos_577 := Parser.Current_Pos;

      if Defer_Pos_577 /= No_Token_Index then
         Or_Pos_104 := Defer_Pos_577;
         Or_Res_104 := Defer_Res_577;
         goto Exit_Or_106;
      end if;

      Defer_Res_578 :=
        Simple_Subp_Decl_Transform_Parse_0 (Parser, Row_Pos_346);
      Defer_Pos_578 := Parser.Current_Pos;

      if Defer_Pos_578 /= No_Token_Index then
         Or_Pos_104 := Defer_Pos_578;
         Or_Res_104 := Defer_Res_578;
         goto Exit_Or_106;
      end if;

      Defer_Res_579 :=
        Library_Unit_Renaming_Decl_Or_Parse_0 (Parser, Row_Pos_346);
      Defer_Pos_579 := Parser.Current_Pos;

      if Defer_Pos_579 /= No_Token_Index then
         Or_Pos_104 := Defer_Pos_579;
         Or_Res_104 := Defer_Res_579;
         goto Exit_Or_106;
      end if;

      Defer_Res_580 := Generic_Decl_Or_Parse_0 (Parser, Row_Pos_346);
      Defer_Pos_580 := Parser.Current_Pos;

      if Defer_Pos_580 /= No_Token_Index then
         Or_Pos_104 := Defer_Pos_580;
         Or_Res_104 := Defer_Res_580;
         goto Exit_Or_106;
      end if;

      Defer_Res_581 := Package_Decl_Transform_Parse_3 (Parser, Row_Pos_346);
      Defer_Pos_581 := Parser.Current_Pos;

      if Defer_Pos_581 /= No_Token_Index then
         Or_Pos_104 := Defer_Pos_581;
         Or_Res_104 := Defer_Res_581;
         goto Exit_Or_106;
      end if;

      if Get_Token (Parser.TDH.all, Row_Pos_346).Kind =
        From_Token_Kind (Ada_Termination)
      then
         Skip_Pos_2 := No_Token_Index;
         goto Exit_Or_109;
      end if;

      for Fn of Parser.Private_Part.Dont_Skip loop
         Skip_Dummy_2 := Fn (Parser, Row_Pos_346);

         if Parser.Current_Pos /= No_Token_Index then
            Skip_Pos_2 := No_Token_Index;
            goto Exit_Or_109;
         end if;
      end loop;

      Skip_Pos_2 := Row_Pos_346 + 1;

--  Start transform_code

--  Start row_code

      Row_Pos_347 := Row_Pos_346;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_347_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_347 /= No_Token_Index then

         Transform_Res_278 := Allocate_Error_Decl (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_278, Kind => Ada_Error_Decl,
            Unit            => Parser.Unit,
Token_Start_Index           => Row_Pos_346,
            Token_End_Index =>
              (if Row_Pos_347 = Row_Pos_346 then No_Token_Index
               else Row_Pos_347 - 1));

      end if;

--  End transform_code

      Transform_Res_278.Token_End_Index := Row_Pos_346;

      Append
        (Parser.Diagnostics,
         Get_Token (Parser.TDH.all, Row_Pos_346).Sloc_Range,
         To_Text ("Skipped token ") &
         Common.Text
           (Wrap_Token_Reference (Parser.TDH, (Row_Pos_346, No_Token_Index))));

      <<Exit_Or_109>>

      if Skip_Pos_2 /= No_Token_Index then
         Or_Pos_104 := Skip_Pos_2;
         Or_Res_104 := Transform_Res_278;
         goto Exit_Or_106;
      end if;
      <<Exit_Or_106>>

--  End or_code

      if Or_Pos_104 /= No_Token_Index then

         Row_Pos_346 := Or_Pos_104;

      else
         Row_Pos_346 := No_Token_Index;
         goto Exit_Row_346_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_346_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_346 /= No_Token_Index then

         Transform_Res_279 := Allocate_Library_Item (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_279, Kind => Ada_Library_Item,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_346 = Pos then No_Token_Index else Row_Pos_346 - 1));

         Initialize_Fields_For_Library_Item
           (Self                       => Transform_Res_279,
            Library_Item_F_Has_Private => Opt_Res_32,
            Library_Item_F_Item        => Or_Res_104);

         if Opt_Res_32 /= null and then Is_Incomplete (Opt_Res_32) then
            Transform_Res_279.Last_Attempted_Child := 0;
         elsif Opt_Res_32 /= null and then not Is_Ghost (Opt_Res_32) then
            Transform_Res_279.Last_Attempted_Child := -1;
         end if;
         if Or_Res_104 /= null and then Is_Incomplete (Or_Res_104) then
            Transform_Res_279.Last_Attempted_Child := 0;
         elsif Or_Res_104 /= null and then not Is_Ghost (Or_Res_104) then
            Transform_Res_279.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Library_Item_Transform_Parse_1_Memo,
         Row_Pos_346 /= No_Token_Index, Transform_Res_279, Pos, Row_Pos_346);

      Parser.Current_Pos := Row_Pos_346;

      return Transform_Res_279;
   end Library_Item_Transform_Parse_1;

   function Compilation_Unit_Transform_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index)
      return Bare_Compilation_Unit
   is
      use Bare_Compilation_Unit_Memos;

      Row_Pos_343       : Token_Index           := No_Token_Index;
      Lst_Cpos_43       : Token_Index           := No_Token_Index;
      Tmp_List_43       : Free_Parse_List;
      Defer_Pos_559     : Token_Index           := No_Token_Index;
      Defer_Res_559     : Bare_Ada_Node         := No_Bare_Ada_Node;
      List_Pos_43       : Token_Index           := No_Token_Index;
      List_Res_43       : Bare_Ada_Node_List    := No_Bare_Ada_Node;
      Defer_Pos_560     : Token_Index           := No_Token_Index;
      Defer_Res_560     : Bare_Subunit          := No_Bare_Ada_Node;
      Defer_Pos_561     : Token_Index           := No_Token_Index;
      Defer_Res_561     : Bare_Library_Item     := No_Bare_Ada_Node;
      Or_Pos_101        : Token_Index           := No_Token_Index;
      Or_Res_101        : Bare_Ada_Node         := No_Bare_Ada_Node;
      Lst_Cpos_44       : Token_Index           := No_Token_Index;
      Tmp_List_44       : Free_Parse_List;
      Defer_Pos_562     : Token_Index           := No_Token_Index;
      Defer_Res_562     : Bare_Pragma_Node      := No_Bare_Ada_Node;
      List_Pos_44       : Token_Index           := No_Token_Index;
      List_Res_44       : Bare_Pragma_Node_List := No_Bare_Ada_Node;
      Transform_Res_275 : Bare_Compilation_Unit := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Compilation_Unit_Transform_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Transform_Res_275  := M.Instance;
         return Transform_Res_275;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Transform_Res_275;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start transform_code

--  Start row_code

      Row_Pos_343 := Pos;

--  Start list_code

      List_Pos_43 := Row_Pos_343;

      Lst_Cpos_43 := Row_Pos_343;
      Tmp_List_43 := Get_Parse_List (Parser);

      loop

         Defer_Res_559 := Context_Item_Or_Parse_0 (Parser, Lst_Cpos_43);
         Defer_Pos_559 := Parser.Current_Pos;

         exit when Defer_Pos_559 = No_Token_Index;

         List_Pos_43 := Defer_Pos_559;
         Lst_Cpos_43 := List_Pos_43;

         Tmp_List_43.Nodes.Append (Defer_Res_559);

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_43.Nodes.Length;
      begin
         List_Res_43 := Allocate_Ada_Node_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_343;
            Token_End   :=
              (if Lst_Cpos_43 = Row_Pos_343 then Row_Pos_343
               else Lst_Cpos_43 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_343, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self            => List_Res_43, Kind => Ada_Ada_Node_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_43, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_43.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_43.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_43);

--  End list_code

      if List_Pos_43 /= No_Token_Index then

         Row_Pos_343 := List_Pos_43;

      else
         Row_Pos_343 := No_Token_Index;
         goto Exit_Row_343_0;

      end if;

--  Start or_code

      Or_Pos_101 := No_Token_Index;
      Or_Res_101 := No_Bare_Ada_Node;

      Defer_Res_560 := Subunit_Transform_Parse_0 (Parser, Row_Pos_343);
      Defer_Pos_560 := Parser.Current_Pos;

      if Defer_Pos_560 /= No_Token_Index then
         Or_Pos_101 := Defer_Pos_560;
         Or_Res_101 := Defer_Res_560;
         goto Exit_Or_104;
      end if;

      Defer_Res_561 := Library_Item_Transform_Parse_1 (Parser, Row_Pos_343);
      Defer_Pos_561 := Parser.Current_Pos;

      if Defer_Pos_561 /= No_Token_Index then
         Or_Pos_101 := Defer_Pos_561;
         Or_Res_101 := Defer_Res_561;
         goto Exit_Or_104;
      end if;
      <<Exit_Or_104>>

--  End or_code

      if Or_Pos_101 /= No_Token_Index then

         Row_Pos_343 := Or_Pos_101;

      else
         Row_Pos_343 := No_Token_Index;
         goto Exit_Row_343_0;

      end if;

--  Start list_code

      List_Pos_44 := Row_Pos_343;

      Lst_Cpos_44 := Row_Pos_343;
      Tmp_List_44 := Get_Parse_List (Parser);

      loop

         Defer_Res_562 := Pragma_Transform_Parse_0 (Parser, Lst_Cpos_44);
         Defer_Pos_562 := Parser.Current_Pos;

         exit when Defer_Pos_562 = No_Token_Index;

         List_Pos_44 := Defer_Pos_562;
         Lst_Cpos_44 := List_Pos_44;

         Tmp_List_44.Nodes.Append (Defer_Res_562);

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_44.Nodes.Length;
      begin
         List_Res_44 := Allocate_Pragma_Node_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_343;
            Token_End   :=
              (if Lst_Cpos_44 = Row_Pos_343 then Row_Pos_343
               else Lst_Cpos_44 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_343, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self            => List_Res_44, Kind => Ada_Pragma_Node_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_44, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_44.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_44.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_44);

--  End list_code

      if List_Pos_44 /= No_Token_Index then

         Row_Pos_343 := List_Pos_44;

      else
         Row_Pos_343 := No_Token_Index;
         goto Exit_Row_343_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_343_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_343 /= No_Token_Index then

         Transform_Res_275 := Allocate_Compilation_Unit (Parser.Mem_Pool);

         Initialize
           (Self            => Transform_Res_275, Kind => Ada_Compilation_Unit,
            Unit            => Parser.Unit,
Token_Start_Index           => Pos,
            Token_End_Index =>
              (if Row_Pos_343 = Pos then No_Token_Index else Row_Pos_343 - 1));

         Initialize_Fields_For_Compilation_Unit
           (Self                       => Transform_Res_275,
            Compilation_Unit_F_Prelude => List_Res_43,
            Compilation_Unit_F_Body    => Or_Res_101,
            Compilation_Unit_F_Pragmas => List_Res_44);

         if List_Res_43 /= null and then Is_Incomplete (List_Res_43) then
            Transform_Res_275.Last_Attempted_Child := 0;
         elsif List_Res_43 /= null and then not Is_Ghost (List_Res_43) then
            Transform_Res_275.Last_Attempted_Child := -1;
         end if;
         if Or_Res_101 /= null and then Is_Incomplete (Or_Res_101) then
            Transform_Res_275.Last_Attempted_Child := 0;
         elsif Or_Res_101 /= null and then not Is_Ghost (Or_Res_101) then
            Transform_Res_275.Last_Attempted_Child := -1;
         end if;
         if List_Res_44 /= null and then Is_Incomplete (List_Res_44) then
            Transform_Res_275.Last_Attempted_Child := 0;
         elsif List_Res_44 /= null and then not Is_Ghost (List_Res_44) then
            Transform_Res_275.Last_Attempted_Child := -1;
         end if;

      end if;

--  End transform_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Compilation_Unit_Transform_Parse_0_Memo,
         Row_Pos_343 /= No_Token_Index, Transform_Res_275, Pos, Row_Pos_343);

      Parser.Current_Pos := Row_Pos_343;

      return Transform_Res_275;
   end Compilation_Unit_Transform_Parse_0;

   function Dontskip_Case_Alt_0_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Row_Pos_348   : Token_Index   := No_Token_Index;
      Null_Res_16   : Bare_Ada_Node := No_Bare_Ada_Node;
      Token_Pos_534 : Token_Index   := No_Token_Index;
      Token_Res_534 : Token_Index   := No_Token_Index;
      Token_Pos_535 : Token_Index   := No_Token_Index;
      Token_Res_535 : Token_Index   := No_Token_Index;
      Or_Pos_107    : Token_Index   := No_Token_Index;
      Or_Res_107    : Token_Index   := No_Token_Index;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Dontskip_Case_Alt_0_Extract_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Null_Res_16        := M.Instance;
         return Null_Res_16;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Null_Res_16;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start row_code

      Row_Pos_348 := Pos;

      Null_Res_16 := No_Bare_Ada_Node;

      if Row_Pos_348 /= No_Token_Index then

         Row_Pos_348 := Row_Pos_348;

      else
         Row_Pos_348 := No_Token_Index;
         goto Exit_Row_348_0;

      end if;

--  Start or_code

      Or_Pos_107 := No_Token_Index;
      Or_Res_107 := No_Token_Index;

--  Start tok_code

      Token_Res_534 := Row_Pos_348;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_534));
      begin
         if T.Kind /= From_Token_Kind (Ada_When) then
            Token_Pos_534 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_348 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_348,
                  Expected_Token_Id => Ada_When,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_534 := Row_Pos_348 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_534 /= No_Token_Index then
         Or_Pos_107 := Token_Pos_534;
         Or_Res_107 := Token_Res_534;
         goto Exit_Or_110;
      end if;

--  Start tok_code

      Token_Res_535 := Row_Pos_348;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_535));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_535 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_348 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_348,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_535 := Row_Pos_348 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_535 /= No_Token_Index then
         Or_Pos_107 := Token_Pos_535;
         Or_Res_107 := Token_Res_535;
         goto Exit_Or_110;
      end if;
      <<Exit_Or_110>>

--  End or_code

      if Or_Pos_107 /= No_Token_Index then

         Row_Pos_348 := Or_Pos_107;

      else
         Row_Pos_348 := No_Token_Index;
         goto Exit_Row_348_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_348_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Dontskip_Case_Alt_0_Extract_Parse_0_Memo,
         Row_Pos_348 /= No_Token_Index, Null_Res_16, Pos, Row_Pos_348);

      Parser.Current_Pos := Row_Pos_348;

      return Null_Res_16;
   end Dontskip_Case_Alt_0_Extract_Parse_0;

   function Dontskip_Select_Stmt_2_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Row_Pos_349   : Token_Index   := No_Token_Index;
      Null_Res_17   : Bare_Ada_Node := No_Bare_Ada_Node;
      Token_Pos_536 : Token_Index   := No_Token_Index;
      Token_Res_536 : Token_Index   := No_Token_Index;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Dontskip_Select_Stmt_2_Extract_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Null_Res_17        := M.Instance;
         return Null_Res_17;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Null_Res_17;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start row_code

      Row_Pos_349 := Pos;

      Null_Res_17 := No_Bare_Ada_Node;

      if Row_Pos_349 /= No_Token_Index then

         Row_Pos_349 := Row_Pos_349;

      else
         Row_Pos_349 := No_Token_Index;
         goto Exit_Row_349_0;

      end if;

--  Start tok_code

      Token_Res_536 := Row_Pos_349;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_536));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_536 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_349 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_349,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_536 := Row_Pos_349 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_536 /= No_Token_Index then

         Row_Pos_349 := Token_Pos_536;

      else
         Row_Pos_349 := No_Token_Index;
         goto Exit_Row_349_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_349_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Dontskip_Select_Stmt_2_Extract_Parse_0_Memo,
         Row_Pos_349 /= No_Token_Index, Null_Res_17, Pos, Row_Pos_349);

      Parser.Current_Pos := Row_Pos_349;

      return Null_Res_17;
   end Dontskip_Select_Stmt_2_Extract_Parse_0;

   function Dontskip_Select_Stmt_1_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Row_Pos_350   : Token_Index   := No_Token_Index;
      Null_Res_18   : Bare_Ada_Node := No_Bare_Ada_Node;
      Token_Pos_537 : Token_Index   := No_Token_Index;
      Token_Res_537 : Token_Index   := No_Token_Index;
      Token_Pos_538 : Token_Index   := No_Token_Index;
      Token_Res_538 : Token_Index   := No_Token_Index;
      Or_Pos_108    : Token_Index   := No_Token_Index;
      Or_Res_108    : Token_Index   := No_Token_Index;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Dontskip_Select_Stmt_1_Extract_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Null_Res_18        := M.Instance;
         return Null_Res_18;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Null_Res_18;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start row_code

      Row_Pos_350 := Pos;

      Null_Res_18 := No_Bare_Ada_Node;

      if Row_Pos_350 /= No_Token_Index then

         Row_Pos_350 := Row_Pos_350;

      else
         Row_Pos_350 := No_Token_Index;
         goto Exit_Row_350_0;

      end if;

--  Start or_code

      Or_Pos_108 := No_Token_Index;
      Or_Res_108 := No_Token_Index;

--  Start tok_code

      Token_Res_537 := Row_Pos_350;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_537));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_537 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_350 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_350,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_537 := Row_Pos_350 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_537 /= No_Token_Index then
         Or_Pos_108 := Token_Pos_537;
         Or_Res_108 := Token_Res_537;
         goto Exit_Or_111;
      end if;

--  Start tok_code

      Token_Res_538 := Row_Pos_350;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_538));
      begin
         if T.Kind /= From_Token_Kind (Ada_Then) then
            Token_Pos_538 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_350 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_350,
                  Expected_Token_Id => Ada_Then,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_538 := Row_Pos_350 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_538 /= No_Token_Index then
         Or_Pos_108 := Token_Pos_538;
         Or_Res_108 := Token_Res_538;
         goto Exit_Or_111;
      end if;
      <<Exit_Or_111>>

--  End or_code

      if Or_Pos_108 /= No_Token_Index then

         Row_Pos_350 := Or_Pos_108;

      else
         Row_Pos_350 := No_Token_Index;
         goto Exit_Row_350_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_350_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Dontskip_Select_Stmt_1_Extract_Parse_0_Memo,
         Row_Pos_350 /= No_Token_Index, Null_Res_18, Pos, Row_Pos_350);

      Parser.Current_Pos := Row_Pos_350;

      return Null_Res_18;
   end Dontskip_Select_Stmt_1_Extract_Parse_0;

   function Dontskip_Iloop_Stmt_1_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Row_Pos_351   : Token_Index   := No_Token_Index;
      Null_Res_19   : Bare_Ada_Node := No_Bare_Ada_Node;
      Token_Pos_539 : Token_Index   := No_Token_Index;
      Token_Res_539 : Token_Index   := No_Token_Index;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Dontskip_Iloop_Stmt_1_Extract_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Null_Res_19        := M.Instance;
         return Null_Res_19;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Null_Res_19;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start row_code

      Row_Pos_351 := Pos;

      Null_Res_19 := No_Bare_Ada_Node;

      if Row_Pos_351 /= No_Token_Index then

         Row_Pos_351 := Row_Pos_351;

      else
         Row_Pos_351 := No_Token_Index;
         goto Exit_Row_351_0;

      end if;

--  Start tok_code

      Token_Res_539 := Row_Pos_351;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_539));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_539 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_351 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_351,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_539 := Row_Pos_351 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_539 /= No_Token_Index then

         Row_Pos_351 := Token_Pos_539;

      else
         Row_Pos_351 := No_Token_Index;
         goto Exit_Row_351_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_351_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Dontskip_Iloop_Stmt_1_Extract_Parse_0_Memo,
         Row_Pos_351 /= No_Token_Index, Null_Res_19, Pos, Row_Pos_351);

      Parser.Current_Pos := Row_Pos_351;

      return Null_Res_19;
   end Dontskip_Iloop_Stmt_1_Extract_Parse_0;

   function Dontskip_Package_Decl_0_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Row_Pos_352   : Token_Index   := No_Token_Index;
      Null_Res_20   : Bare_Ada_Node := No_Bare_Ada_Node;
      Token_Pos_540 : Token_Index   := No_Token_Index;
      Token_Res_540 : Token_Index   := No_Token_Index;
      Token_Pos_541 : Token_Index   := No_Token_Index;
      Token_Res_541 : Token_Index   := No_Token_Index;
      Or_Pos_109    : Token_Index   := No_Token_Index;
      Or_Res_109    : Token_Index   := No_Token_Index;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Dontskip_Package_Decl_0_Extract_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Null_Res_20        := M.Instance;
         return Null_Res_20;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Null_Res_20;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start row_code

      Row_Pos_352 := Pos;

      Null_Res_20 := No_Bare_Ada_Node;

      if Row_Pos_352 /= No_Token_Index then

         Row_Pos_352 := Row_Pos_352;

      else
         Row_Pos_352 := No_Token_Index;
         goto Exit_Row_352_0;

      end if;

--  Start or_code

      Or_Pos_109 := No_Token_Index;
      Or_Res_109 := No_Token_Index;

--  Start tok_code

      Token_Res_540 := Row_Pos_352;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_540));
      begin
         if T.Kind /= From_Token_Kind (Ada_Private) then
            Token_Pos_540 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_352 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_352,
                  Expected_Token_Id => Ada_Private,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_540 := Row_Pos_352 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_540 /= No_Token_Index then
         Or_Pos_109 := Token_Pos_540;
         Or_Res_109 := Token_Res_540;
         goto Exit_Or_112;
      end if;

--  Start tok_code

      Token_Res_541 := Row_Pos_352;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_541));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_541 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_352 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_352,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_541 := Row_Pos_352 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_541 /= No_Token_Index then
         Or_Pos_109 := Token_Pos_541;
         Or_Res_109 := Token_Res_541;
         goto Exit_Or_112;
      end if;
      <<Exit_Or_112>>

--  End or_code

      if Or_Pos_109 /= No_Token_Index then

         Row_Pos_352 := Or_Pos_109;

      else
         Row_Pos_352 := No_Token_Index;
         goto Exit_Row_352_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_352_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Dontskip_Package_Decl_0_Extract_Parse_0_Memo,
         Row_Pos_352 /= No_Token_Index, Null_Res_20, Pos, Row_Pos_352);

      Parser.Current_Pos := Row_Pos_352;

      return Null_Res_20;
   end Dontskip_Package_Decl_0_Extract_Parse_0;

   function Dontskip_Package_Decl_1_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Row_Pos_353   : Token_Index   := No_Token_Index;
      Null_Res_21   : Bare_Ada_Node := No_Bare_Ada_Node;
      Token_Pos_542 : Token_Index   := No_Token_Index;
      Token_Res_542 : Token_Index   := No_Token_Index;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Dontskip_Package_Decl_1_Extract_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Null_Res_21        := M.Instance;
         return Null_Res_21;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Null_Res_21;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start row_code

      Row_Pos_353 := Pos;

      Null_Res_21 := No_Bare_Ada_Node;

      if Row_Pos_353 /= No_Token_Index then

         Row_Pos_353 := Row_Pos_353;

      else
         Row_Pos_353 := No_Token_Index;
         goto Exit_Row_353_0;

      end if;

--  Start tok_code

      Token_Res_542 := Row_Pos_353;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_542));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_542 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_353 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_353,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_542 := Row_Pos_353 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_542 /= No_Token_Index then

         Row_Pos_353 := Token_Pos_542;

      else
         Row_Pos_353 := No_Token_Index;
         goto Exit_Row_353_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_353_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Dontskip_Package_Decl_1_Extract_Parse_0_Memo,
         Row_Pos_353 /= No_Token_Index, Null_Res_21, Pos, Row_Pos_353);

      Parser.Current_Pos := Row_Pos_353;

      return Null_Res_21;
   end Dontskip_Package_Decl_1_Extract_Parse_0;

   function Compilation_Or_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Row_Pos_354   : Token_Index                := No_Token_Index;
      Lst_Cpos_46   : Token_Index                := No_Token_Index;
      Tmp_List_46   : Free_Parse_List;
      Defer_Pos_586 : Token_Index                := No_Token_Index;
      Defer_Res_586 : Bare_Pragma_Node           := No_Bare_Ada_Node;
      List_Pos_46   : Token_Index                := No_Token_Index;
      List_Res_46   : Bare_Pragma_Node_List      := No_Bare_Ada_Node;
      Token_Pos_543 : Token_Index                := No_Token_Index;
      Token_Res_543 : Token_Index                := No_Token_Index;
      Row_Pos_355   : Token_Index                := No_Token_Index;
      Defer_Pos_587 : Token_Index                := No_Token_Index;
      Defer_Res_587 : Bare_Compilation_Unit      := No_Bare_Ada_Node;
      Token_Pos_544 : Token_Index                := No_Token_Index;
      Token_Res_544 : Token_Index                := No_Token_Index;
      Row_Pos_356   : Token_Index                := No_Token_Index;
      Lst_Cpos_47   : Token_Index                := No_Token_Index;
      Tmp_List_47   : Free_Parse_List;
      Defer_Pos_588 : Token_Index                := No_Token_Index;
      Defer_Res_588 : Bare_Compilation_Unit      := No_Bare_Ada_Node;
      List_Pos_47   : Token_Index                := No_Token_Index;
      List_Res_47   : Bare_Compilation_Unit_List := No_Bare_Ada_Node;
      Token_Pos_545 : Token_Index                := No_Token_Index;
      Token_Res_545 : Token_Index                := No_Token_Index;
      Or_Pos_110    : Token_Index                := No_Token_Index;
      Or_Res_110    : Bare_Ada_Node              := No_Bare_Ada_Node;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Compilation_Or_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Or_Res_110         := M.Instance;
         return Or_Res_110;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Or_Res_110;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start or_code

      Or_Pos_110 := No_Token_Index;
      Or_Res_110 := No_Bare_Ada_Node;

--  Start row_code

      Row_Pos_354 := Pos;

--  Start list_code

      List_Pos_46 := No_Token_Index;

      Lst_Cpos_46 := Row_Pos_354;
      Tmp_List_46 := Get_Parse_List (Parser);

      loop

         Defer_Res_586 := Pragma_Transform_Parse_0 (Parser, Lst_Cpos_46);
         Defer_Pos_586 := Parser.Current_Pos;

         exit when Defer_Pos_586 = No_Token_Index;

         List_Pos_46 := Defer_Pos_586;
         Lst_Cpos_46 := List_Pos_46;

         Tmp_List_46.Nodes.Append (Defer_Res_586);

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_46.Nodes.Length;
      begin
         List_Res_46 := Allocate_Pragma_Node_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_354;
            Token_End   :=
              (if Lst_Cpos_46 = Row_Pos_354 then Row_Pos_354
               else Lst_Cpos_46 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_354, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self            => List_Res_46, Kind => Ada_Pragma_Node_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_46, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_46.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_46.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_46);

--  End list_code

      if List_Pos_46 /= No_Token_Index then

         Row_Pos_354 := List_Pos_46;

      else
         Row_Pos_354 := No_Token_Index;
         goto Exit_Row_354_0;

      end if;

--  Start tok_code

      Token_Res_543 := Row_Pos_354;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_543));
      begin
         if T.Kind /= From_Token_Kind (Ada_Termination) then
            Token_Pos_543 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_354 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_354,
                  Expected_Token_Id => Ada_Termination,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_543 := Row_Pos_354;
         end if;
      end;

--  End tok_code

      if Token_Pos_543 /= No_Token_Index then

         Row_Pos_354 := Token_Pos_543;

      else
         Row_Pos_354 := No_Token_Index;
         goto Exit_Row_354_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_354_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_354 /= No_Token_Index then
         Or_Pos_110 := Row_Pos_354;
         Or_Res_110 := List_Res_46;
         goto Exit_Or_113;
      end if;

--  Start row_code

      Row_Pos_355 := Pos;

      Defer_Res_587 :=
        Compilation_Unit_Transform_Parse_0 (Parser, Row_Pos_355);
      Defer_Pos_587 := Parser.Current_Pos;

      if Defer_Pos_587 /= No_Token_Index then

         Row_Pos_355 := Defer_Pos_587;

      else
         Row_Pos_355 := No_Token_Index;
         goto Exit_Row_355_0;

      end if;

--  Start tok_code

      Token_Res_544 := Row_Pos_355;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_544));
      begin
         if T.Kind /= From_Token_Kind (Ada_Termination) then
            Token_Pos_544 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_355 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_355,
                  Expected_Token_Id => Ada_Termination,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_544 := Row_Pos_355;
         end if;
      end;

--  End tok_code

      if Token_Pos_544 /= No_Token_Index then

         Row_Pos_355 := Token_Pos_544;

      else
         Row_Pos_355 := No_Token_Index;
         goto Exit_Row_355_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_355_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_355 /= No_Token_Index then
         Or_Pos_110 := Row_Pos_355;
         Or_Res_110 := Defer_Res_587;
         goto Exit_Or_113;
      end if;

--  Start row_code

      Row_Pos_356 := Pos;

--  Start list_code

      List_Pos_47 := Row_Pos_356;

      Lst_Cpos_47 := Row_Pos_356;
      Tmp_List_47 := Get_Parse_List (Parser);

      loop

         Defer_Res_588 :=
           Compilation_Unit_Transform_Parse_0 (Parser, Lst_Cpos_47);
         Defer_Pos_588 := Parser.Current_Pos;

         exit when Defer_Pos_588 = No_Token_Index;

         List_Pos_47 := Defer_Pos_588;
         Lst_Cpos_47 := List_Pos_47;

         Tmp_List_47.Nodes.Append (Defer_Res_588);

      end loop;

      declare
         Token_Start, Token_End : Token_Index;
         Count                  : constant Natural := Tmp_List_47.Nodes.Length;
      begin
         List_Res_47 := Allocate_Compilation_Unit_List (Parser.Mem_Pool);

         if Count > 0 then
            Token_Start := Row_Pos_356;
            Token_End   :=
              (if Lst_Cpos_47 = Row_Pos_356 then Row_Pos_356
               else Lst_Cpos_47 - 1);

         else
            Token_Start := Token_Index'Max (Row_Pos_356, 1);
            Token_End   := No_Token_Index;
         end if;

         Initialize
           (Self            => List_Res_47, Kind => Ada_Compilation_Unit_List,
            Unit            => Parser.Unit, Token_Start_Index => Token_Start,
            Token_End_Index => Token_End);
         Initialize_List
           (Self => List_Res_47, Parser => Parser, Count => Count);

         declare
            Vec : Bare_Ada_Node_Vectors.Vector renames Tmp_List_47.Nodes;
            Arr : Alloc_AST_List_Array.Element_Array_Access renames
              List_Res_47.Nodes;
         begin
            Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
            for I in Vec.First_Index .. Vec.Last_Index loop
               Arr (I) := Vec.Get (I);
            end loop;
         end;
      end;

      Release_Parse_List (Parser, Tmp_List_47);

--  End list_code

      if List_Pos_47 /= No_Token_Index then

         Row_Pos_356 := List_Pos_47;

      else
         Row_Pos_356 := No_Token_Index;
         goto Exit_Row_356_0;

      end if;

--  Start tok_code

      Token_Res_545 := Row_Pos_356;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_545));
      begin
         if T.Kind /= From_Token_Kind (Ada_Termination) then
            Token_Pos_545 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_356 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_356,
                  Expected_Token_Id => Ada_Termination,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_545 := Row_Pos_356;
         end if;
      end;

--  End tok_code

      if Token_Pos_545 /= No_Token_Index then

         Row_Pos_356 := Token_Pos_545;

      else
         Row_Pos_356 := No_Token_Index;
         goto Exit_Row_356_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_356_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      if Row_Pos_356 /= No_Token_Index then
         Or_Pos_110 := Row_Pos_356;
         Or_Res_110 := List_Res_47;
         goto Exit_Or_113;
      end if;
      <<Exit_Or_113>>

--  End or_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Compilation_Or_Parse_0_Memo,
         Or_Pos_110 /= No_Token_Index, Or_Res_110, Pos, Or_Pos_110);

      Parser.Current_Pos := Or_Pos_110;

      return Or_Res_110;
   end Compilation_Or_Parse_0;

   function Dontskip_If_Stmt_1_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Row_Pos_357   : Token_Index   := No_Token_Index;
      Null_Res_22   : Bare_Ada_Node := No_Bare_Ada_Node;
      Token_Pos_546 : Token_Index   := No_Token_Index;
      Token_Res_546 : Token_Index   := No_Token_Index;
      Token_Pos_547 : Token_Index   := No_Token_Index;
      Token_Res_547 : Token_Index   := No_Token_Index;
      Token_Pos_548 : Token_Index   := No_Token_Index;
      Token_Res_548 : Token_Index   := No_Token_Index;
      Or_Pos_111    : Token_Index   := No_Token_Index;
      Or_Res_111    : Token_Index   := No_Token_Index;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Dontskip_If_Stmt_1_Extract_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Null_Res_22        := M.Instance;
         return Null_Res_22;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Null_Res_22;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start row_code

      Row_Pos_357 := Pos;

      Null_Res_22 := No_Bare_Ada_Node;

      if Row_Pos_357 /= No_Token_Index then

         Row_Pos_357 := Row_Pos_357;

      else
         Row_Pos_357 := No_Token_Index;
         goto Exit_Row_357_0;

      end if;

--  Start or_code

      Or_Pos_111 := No_Token_Index;
      Or_Res_111 := No_Token_Index;

--  Start tok_code

      Token_Res_546 := Row_Pos_357;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_546));
      begin
         if T.Kind /= From_Token_Kind (Ada_Elsif) then
            Token_Pos_546 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_357 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_357,
                  Expected_Token_Id => Ada_Elsif,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_546 := Row_Pos_357 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_546 /= No_Token_Index then
         Or_Pos_111 := Token_Pos_546;
         Or_Res_111 := Token_Res_546;
         goto Exit_Or_114;
      end if;

--  Start tok_code

      Token_Res_547 := Row_Pos_357;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_547));
      begin
         if T.Kind /= From_Token_Kind (Ada_Else) then
            Token_Pos_547 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_357 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_357,
                  Expected_Token_Id => Ada_Else,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_547 := Row_Pos_357 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_547 /= No_Token_Index then
         Or_Pos_111 := Token_Pos_547;
         Or_Res_111 := Token_Res_547;
         goto Exit_Or_114;
      end if;

--  Start tok_code

      Token_Res_548 := Row_Pos_357;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_548));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_548 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_357 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_357,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_548 := Row_Pos_357 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_548 /= No_Token_Index then
         Or_Pos_111 := Token_Pos_548;
         Or_Res_111 := Token_Res_548;
         goto Exit_Or_114;
      end if;
      <<Exit_Or_114>>

--  End or_code

      if Or_Pos_111 /= No_Token_Index then

         Row_Pos_357 := Or_Pos_111;

      else
         Row_Pos_357 := No_Token_Index;
         goto Exit_Row_357_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_357_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Dontskip_If_Stmt_1_Extract_Parse_0_Memo,
         Row_Pos_357 /= No_Token_Index, Null_Res_22, Pos, Row_Pos_357);

      Parser.Current_Pos := Row_Pos_357;

      return Null_Res_22;
   end Dontskip_If_Stmt_1_Extract_Parse_0;

   function Dontskip_If_Stmt_2_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Row_Pos_358   : Token_Index   := No_Token_Index;
      Null_Res_23   : Bare_Ada_Node := No_Bare_Ada_Node;
      Token_Pos_549 : Token_Index   := No_Token_Index;
      Token_Res_549 : Token_Index   := No_Token_Index;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Dontskip_If_Stmt_2_Extract_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Null_Res_23        := M.Instance;
         return Null_Res_23;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Null_Res_23;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start row_code

      Row_Pos_358 := Pos;

      Null_Res_23 := No_Bare_Ada_Node;

      if Row_Pos_358 /= No_Token_Index then

         Row_Pos_358 := Row_Pos_358;

      else
         Row_Pos_358 := No_Token_Index;
         goto Exit_Row_358_0;

      end if;

--  Start tok_code

      Token_Res_549 := Row_Pos_358;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_549));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_549 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_358 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_358,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_549 := Row_Pos_358 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_549 /= No_Token_Index then

         Row_Pos_358 := Token_Pos_549;

      else
         Row_Pos_358 := No_Token_Index;
         goto Exit_Row_358_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_358_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Dontskip_If_Stmt_2_Extract_Parse_0_Memo,
         Row_Pos_358 /= No_Token_Index, Null_Res_23, Pos, Row_Pos_358);

      Parser.Current_Pos := Row_Pos_358;

      return Null_Res_23;
   end Dontskip_If_Stmt_2_Extract_Parse_0;

   function Dontskip_If_Stmt_0_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Row_Pos_359   : Token_Index   := No_Token_Index;
      Null_Res_24   : Bare_Ada_Node := No_Bare_Ada_Node;
      Token_Pos_550 : Token_Index   := No_Token_Index;
      Token_Res_550 : Token_Index   := No_Token_Index;
      Token_Pos_551 : Token_Index   := No_Token_Index;
      Token_Res_551 : Token_Index   := No_Token_Index;
      Token_Pos_552 : Token_Index   := No_Token_Index;
      Token_Res_552 : Token_Index   := No_Token_Index;
      Or_Pos_112    : Token_Index   := No_Token_Index;
      Or_Res_112    : Token_Index   := No_Token_Index;

      M : Memo_Entry :=
        Get (Parser.Private_Part.Dontskip_If_Stmt_0_Extract_Parse_0_Memo, Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Null_Res_24        := M.Instance;
         return Null_Res_24;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Null_Res_24;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start row_code

      Row_Pos_359 := Pos;

      Null_Res_24 := No_Bare_Ada_Node;

      if Row_Pos_359 /= No_Token_Index then

         Row_Pos_359 := Row_Pos_359;

      else
         Row_Pos_359 := No_Token_Index;
         goto Exit_Row_359_0;

      end if;

--  Start or_code

      Or_Pos_112 := No_Token_Index;
      Or_Res_112 := No_Token_Index;

--  Start tok_code

      Token_Res_550 := Row_Pos_359;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_550));
      begin
         if T.Kind /= From_Token_Kind (Ada_Elsif) then
            Token_Pos_550 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_359 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_359,
                  Expected_Token_Id => Ada_Elsif,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_550 := Row_Pos_359 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_550 /= No_Token_Index then
         Or_Pos_112 := Token_Pos_550;
         Or_Res_112 := Token_Res_550;
         goto Exit_Or_115;
      end if;

--  Start tok_code

      Token_Res_551 := Row_Pos_359;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_551));
      begin
         if T.Kind /= From_Token_Kind (Ada_Else) then
            Token_Pos_551 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_359 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_359,
                  Expected_Token_Id => Ada_Else,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_551 := Row_Pos_359 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_551 /= No_Token_Index then
         Or_Pos_112 := Token_Pos_551;
         Or_Res_112 := Token_Res_551;
         goto Exit_Or_115;
      end if;

--  Start tok_code

      Token_Res_552 := Row_Pos_359;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_552));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_552 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_359 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_359,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_552 := Row_Pos_359 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_552 /= No_Token_Index then
         Or_Pos_112 := Token_Pos_552;
         Or_Res_112 := Token_Res_552;
         goto Exit_Or_115;
      end if;
      <<Exit_Or_115>>

--  End or_code

      if Or_Pos_112 /= No_Token_Index then

         Row_Pos_359 := Or_Pos_112;

      else
         Row_Pos_359 := No_Token_Index;
         goto Exit_Row_359_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_359_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Dontskip_If_Stmt_0_Extract_Parse_0_Memo,
         Row_Pos_359 /= No_Token_Index, Null_Res_24, Pos, Row_Pos_359);

      Parser.Current_Pos := Row_Pos_359;

      return Null_Res_24;
   end Dontskip_If_Stmt_0_Extract_Parse_0;

   function Dontskip_Iloop_Stmt_2_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Row_Pos_360   : Token_Index   := No_Token_Index;
      Null_Res_25   : Bare_Ada_Node := No_Bare_Ada_Node;
      Token_Pos_553 : Token_Index   := No_Token_Index;
      Token_Res_553 : Token_Index   := No_Token_Index;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Dontskip_Iloop_Stmt_2_Extract_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Null_Res_25        := M.Instance;
         return Null_Res_25;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Null_Res_25;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start row_code

      Row_Pos_360 := Pos;

      Null_Res_25 := No_Bare_Ada_Node;

      if Row_Pos_360 /= No_Token_Index then

         Row_Pos_360 := Row_Pos_360;

      else
         Row_Pos_360 := No_Token_Index;
         goto Exit_Row_360_0;

      end if;

--  Start tok_code

      Token_Res_553 := Row_Pos_360;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_553));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_553 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_360 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_360,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_553 := Row_Pos_360 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_553 /= No_Token_Index then

         Row_Pos_360 := Token_Pos_553;

      else
         Row_Pos_360 := No_Token_Index;
         goto Exit_Row_360_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_360_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Dontskip_Iloop_Stmt_2_Extract_Parse_0_Memo,
         Row_Pos_360 /= No_Token_Index, Null_Res_25, Pos, Row_Pos_360);

      Parser.Current_Pos := Row_Pos_360;

      return Null_Res_25;
   end Dontskip_Iloop_Stmt_2_Extract_Parse_0;

   function Dontskip_Generic_Decl_1_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Row_Pos_361   : Token_Index   := No_Token_Index;
      Null_Res_26   : Bare_Ada_Node := No_Bare_Ada_Node;
      Token_Pos_554 : Token_Index   := No_Token_Index;
      Token_Res_554 : Token_Index   := No_Token_Index;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Dontskip_Generic_Decl_1_Extract_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Null_Res_26        := M.Instance;
         return Null_Res_26;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Null_Res_26;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start row_code

      Row_Pos_361 := Pos;

      Null_Res_26 := No_Bare_Ada_Node;

      if Row_Pos_361 /= No_Token_Index then

         Row_Pos_361 := Row_Pos_361;

      else
         Row_Pos_361 := No_Token_Index;
         goto Exit_Row_361_0;

      end if;

--  Start tok_code

      Token_Res_554 := Row_Pos_361;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_554));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_554 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_361 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_361,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_554 := Row_Pos_361 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_554 /= No_Token_Index then

         Row_Pos_361 := Token_Pos_554;

      else
         Row_Pos_361 := No_Token_Index;
         goto Exit_Row_361_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_361_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Dontskip_Generic_Decl_1_Extract_Parse_0_Memo,
         Row_Pos_361 /= No_Token_Index, Null_Res_26, Pos, Row_Pos_361);

      Parser.Current_Pos := Row_Pos_361;

      return Null_Res_26;
   end Dontskip_Generic_Decl_1_Extract_Parse_0;

   function Dontskip_Select_Stmt_0_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Row_Pos_362   : Token_Index   := No_Token_Index;
      Null_Res_27   : Bare_Ada_Node := No_Bare_Ada_Node;
      Token_Pos_555 : Token_Index   := No_Token_Index;
      Token_Res_555 : Token_Index   := No_Token_Index;
      Token_Pos_556 : Token_Index   := No_Token_Index;
      Token_Res_556 : Token_Index   := No_Token_Index;
      Token_Pos_557 : Token_Index   := No_Token_Index;
      Token_Res_557 : Token_Index   := No_Token_Index;
      Token_Pos_558 : Token_Index   := No_Token_Index;
      Token_Res_558 : Token_Index   := No_Token_Index;
      Or_Pos_113    : Token_Index   := No_Token_Index;
      Or_Res_113    : Token_Index   := No_Token_Index;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Dontskip_Select_Stmt_0_Extract_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Null_Res_27        := M.Instance;
         return Null_Res_27;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Null_Res_27;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start row_code

      Row_Pos_362 := Pos;

      Null_Res_27 := No_Bare_Ada_Node;

      if Row_Pos_362 /= No_Token_Index then

         Row_Pos_362 := Row_Pos_362;

      else
         Row_Pos_362 := No_Token_Index;
         goto Exit_Row_362_0;

      end if;

--  Start or_code

      Or_Pos_113 := No_Token_Index;
      Or_Res_113 := No_Token_Index;

--  Start tok_code

      Token_Res_555 := Row_Pos_362;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_555));
      begin
         if T.Kind /= From_Token_Kind (Ada_Else) then
            Token_Pos_555 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_362 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_362,
                  Expected_Token_Id => Ada_Else,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_555 := Row_Pos_362 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_555 /= No_Token_Index then
         Or_Pos_113 := Token_Pos_555;
         Or_Res_113 := Token_Res_555;
         goto Exit_Or_116;
      end if;

--  Start tok_code

      Token_Res_556 := Row_Pos_362;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_556));
      begin
         if T.Kind /= From_Token_Kind (Ada_Then) then
            Token_Pos_556 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_362 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_362,
                  Expected_Token_Id => Ada_Then,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_556 := Row_Pos_362 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_556 /= No_Token_Index then
         Or_Pos_113 := Token_Pos_556;
         Or_Res_113 := Token_Res_556;
         goto Exit_Or_116;
      end if;

--  Start tok_code

      Token_Res_557 := Row_Pos_362;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_557));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_557 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_362 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_362,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_557 := Row_Pos_362 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_557 /= No_Token_Index then
         Or_Pos_113 := Token_Pos_557;
         Or_Res_113 := Token_Res_557;
         goto Exit_Or_116;
      end if;

--  Start tok_code

      Token_Res_558 := Row_Pos_362;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_558));
      begin
         if T.Kind /= From_Token_Kind (Ada_Or) then
            Token_Pos_558 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_362 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_362,
                  Expected_Token_Id => Ada_Or,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_558 := Row_Pos_362 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_558 /= No_Token_Index then
         Or_Pos_113 := Token_Pos_558;
         Or_Res_113 := Token_Res_558;
         goto Exit_Or_116;
      end if;
      <<Exit_Or_116>>

--  End or_code

      if Or_Pos_113 /= No_Token_Index then

         Row_Pos_362 := Or_Pos_113;

      else
         Row_Pos_362 := No_Token_Index;
         goto Exit_Row_362_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_362_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Dontskip_Select_Stmt_0_Extract_Parse_0_Memo,
         Row_Pos_362 /= No_Token_Index, Null_Res_27, Pos, Row_Pos_362);

      Parser.Current_Pos := Row_Pos_362;

      return Null_Res_27;
   end Dontskip_Select_Stmt_0_Extract_Parse_0;

   function Dontskip_Iloop_Stmt_0_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Row_Pos_363   : Token_Index   := No_Token_Index;
      Null_Res_28   : Bare_Ada_Node := No_Bare_Ada_Node;
      Token_Pos_559 : Token_Index   := No_Token_Index;
      Token_Res_559 : Token_Index   := No_Token_Index;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Dontskip_Iloop_Stmt_0_Extract_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Null_Res_28        := M.Instance;
         return Null_Res_28;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Null_Res_28;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start row_code

      Row_Pos_363 := Pos;

      Null_Res_28 := No_Bare_Ada_Node;

      if Row_Pos_363 /= No_Token_Index then

         Row_Pos_363 := Row_Pos_363;

      else
         Row_Pos_363 := No_Token_Index;
         goto Exit_Row_363_0;

      end if;

--  Start tok_code

      Token_Res_559 := Row_Pos_363;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_559));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_559 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_363 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_363,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_559 := Row_Pos_363 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_559 /= No_Token_Index then

         Row_Pos_363 := Token_Pos_559;

      else
         Row_Pos_363 := No_Token_Index;
         goto Exit_Row_363_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_363_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Dontskip_Iloop_Stmt_0_Extract_Parse_0_Memo,
         Row_Pos_363 /= No_Token_Index, Null_Res_28, Pos, Row_Pos_363);

      Parser.Current_Pos := Row_Pos_363;

      return Null_Res_28;
   end Dontskip_Iloop_Stmt_0_Extract_Parse_0;

   function Dontskip_Package_Body_0_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Row_Pos_364   : Token_Index   := No_Token_Index;
      Null_Res_29   : Bare_Ada_Node := No_Bare_Ada_Node;
      Token_Pos_560 : Token_Index   := No_Token_Index;
      Token_Res_560 : Token_Index   := No_Token_Index;
      Token_Pos_561 : Token_Index   := No_Token_Index;
      Token_Res_561 : Token_Index   := No_Token_Index;
      Or_Pos_114    : Token_Index   := No_Token_Index;
      Or_Res_114    : Token_Index   := No_Token_Index;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Dontskip_Package_Body_0_Extract_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Null_Res_29        := M.Instance;
         return Null_Res_29;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Null_Res_29;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start row_code

      Row_Pos_364 := Pos;

      Null_Res_29 := No_Bare_Ada_Node;

      if Row_Pos_364 /= No_Token_Index then

         Row_Pos_364 := Row_Pos_364;

      else
         Row_Pos_364 := No_Token_Index;
         goto Exit_Row_364_0;

      end if;

--  Start or_code

      Or_Pos_114 := No_Token_Index;
      Or_Res_114 := No_Token_Index;

--  Start tok_code

      Token_Res_560 := Row_Pos_364;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_560));
      begin
         if T.Kind /= From_Token_Kind (Ada_Begin) then
            Token_Pos_560 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_364 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_364,
                  Expected_Token_Id => Ada_Begin,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_560 := Row_Pos_364 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_560 /= No_Token_Index then
         Or_Pos_114 := Token_Pos_560;
         Or_Res_114 := Token_Res_560;
         goto Exit_Or_117;
      end if;

--  Start tok_code

      Token_Res_561 := Row_Pos_364;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_561));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_561 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_364 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_364,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_561 := Row_Pos_364 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_561 /= No_Token_Index then
         Or_Pos_114 := Token_Pos_561;
         Or_Res_114 := Token_Res_561;
         goto Exit_Or_117;
      end if;
      <<Exit_Or_117>>

--  End or_code

      if Or_Pos_114 /= No_Token_Index then

         Row_Pos_364 := Or_Pos_114;

      else
         Row_Pos_364 := No_Token_Index;
         goto Exit_Row_364_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_364_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Dontskip_Package_Body_0_Extract_Parse_0_Memo,
         Row_Pos_364 /= No_Token_Index, Null_Res_29, Pos, Row_Pos_364);

      Parser.Current_Pos := Row_Pos_364;

      return Null_Res_29;
   end Dontskip_Package_Body_0_Extract_Parse_0;

   function Dontskip_Protected_Body_0_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Row_Pos_365   : Token_Index   := No_Token_Index;
      Null_Res_30   : Bare_Ada_Node := No_Bare_Ada_Node;
      Token_Pos_562 : Token_Index   := No_Token_Index;
      Token_Res_562 : Token_Index   := No_Token_Index;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Dontskip_Protected_Body_0_Extract_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Null_Res_30        := M.Instance;
         return Null_Res_30;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Null_Res_30;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start row_code

      Row_Pos_365 := Pos;

      Null_Res_30 := No_Bare_Ada_Node;

      if Row_Pos_365 /= No_Token_Index then

         Row_Pos_365 := Row_Pos_365;

      else
         Row_Pos_365 := No_Token_Index;
         goto Exit_Row_365_0;

      end if;

--  Start tok_code

      Token_Res_562 := Row_Pos_365;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_562));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_562 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_365 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_365,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_562 := Row_Pos_365 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_562 /= No_Token_Index then

         Row_Pos_365 := Token_Pos_562;

      else
         Row_Pos_365 := No_Token_Index;
         goto Exit_Row_365_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_365_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Dontskip_Protected_Body_0_Extract_Parse_0_Memo,
         Row_Pos_365 /= No_Token_Index, Null_Res_30, Pos, Row_Pos_365);

      Parser.Current_Pos := Row_Pos_365;

      return Null_Res_30;
   end Dontskip_Protected_Body_0_Extract_Parse_0;

   function Dontskip_Recov_Decl_Part_0_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Row_Pos_366   : Token_Index   := No_Token_Index;
      Null_Res_31   : Bare_Ada_Node := No_Bare_Ada_Node;
      Token_Pos_563 : Token_Index   := No_Token_Index;
      Token_Res_563 : Token_Index   := No_Token_Index;
      Token_Pos_564 : Token_Index   := No_Token_Index;
      Token_Res_564 : Token_Index   := No_Token_Index;
      Token_Pos_565 : Token_Index   := No_Token_Index;
      Token_Res_565 : Token_Index   := No_Token_Index;
      Token_Pos_566 : Token_Index   := No_Token_Index;
      Token_Res_566 : Token_Index   := No_Token_Index;
      Token_Pos_567 : Token_Index   := No_Token_Index;
      Token_Res_567 : Token_Index   := No_Token_Index;
      Token_Pos_568 : Token_Index   := No_Token_Index;
      Token_Res_568 : Token_Index   := No_Token_Index;
      Token_Pos_569 : Token_Index   := No_Token_Index;
      Token_Res_569 : Token_Index   := No_Token_Index;
      Token_Pos_570 : Token_Index   := No_Token_Index;
      Token_Res_570 : Token_Index   := No_Token_Index;
      Token_Pos_571 : Token_Index   := No_Token_Index;
      Token_Res_571 : Token_Index   := No_Token_Index;
      Token_Pos_572 : Token_Index   := No_Token_Index;
      Token_Res_572 : Token_Index   := No_Token_Index;
      Or_Pos_115    : Token_Index   := No_Token_Index;
      Or_Res_115    : Token_Index   := No_Token_Index;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Dontskip_Recov_Decl_Part_0_Extract_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Null_Res_31        := M.Instance;
         return Null_Res_31;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Null_Res_31;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start row_code

      Row_Pos_366 := Pos;

      Null_Res_31 := No_Bare_Ada_Node;

      if Row_Pos_366 /= No_Token_Index then

         Row_Pos_366 := Row_Pos_366;

      else
         Row_Pos_366 := No_Token_Index;
         goto Exit_Row_366_0;

      end if;

--  Start or_code

      Or_Pos_115 := No_Token_Index;
      Or_Res_115 := No_Token_Index;

--  Start tok_code

      Token_Res_563 := Row_Pos_366;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_563));
      begin
         if T.Kind /= From_Token_Kind (Ada_Begin) then
            Token_Pos_563 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_366 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_366,
                  Expected_Token_Id => Ada_Begin,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_563 := Row_Pos_366 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_563 /= No_Token_Index then
         Or_Pos_115 := Token_Pos_563;
         Or_Res_115 := Token_Res_563;
         goto Exit_Or_118;
      end if;

--  Start tok_code

      Token_Res_564 := Row_Pos_366;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_564));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_564 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_366 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_366,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_564 := Row_Pos_366 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_564 /= No_Token_Index then
         Or_Pos_115 := Token_Pos_564;
         Or_Res_115 := Token_Res_564;
         goto Exit_Or_118;
      end if;

--  Start tok_code

      Token_Res_565 := Row_Pos_366;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_565));
      begin
         if T.Kind /= From_Token_Kind (Ada_If) then
            Token_Pos_565 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_366 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_366,
                  Expected_Token_Id => Ada_If,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_565 := Row_Pos_366 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_565 /= No_Token_Index then
         Or_Pos_115 := Token_Pos_565;
         Or_Res_115 := Token_Res_565;
         goto Exit_Or_118;
      end if;

--  Start tok_code

      Token_Res_566 := Row_Pos_366;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_566));
      begin
         if T.Kind /= From_Token_Kind (Ada_For) then
            Token_Pos_566 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_366 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_366,
                  Expected_Token_Id => Ada_For,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_566 := Row_Pos_366 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_566 /= No_Token_Index then
         Or_Pos_115 := Token_Pos_566;
         Or_Res_115 := Token_Res_566;
         goto Exit_Or_118;
      end if;

--  Start tok_code

      Token_Res_567 := Row_Pos_366;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_567));
      begin
         if T.Kind /= From_Token_Kind (Ada_While) then
            Token_Pos_567 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_366 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_366,
                  Expected_Token_Id => Ada_While,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_567 := Row_Pos_366 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_567 /= No_Token_Index then
         Or_Pos_115 := Token_Pos_567;
         Or_Res_115 := Token_Res_567;
         goto Exit_Or_118;
      end if;

--  Start tok_code

      Token_Res_568 := Row_Pos_366;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_568));
      begin
         if T.Kind /= From_Token_Kind (Ada_Loop) then
            Token_Pos_568 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_366 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_366,
                  Expected_Token_Id => Ada_Loop,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_568 := Row_Pos_366 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_568 /= No_Token_Index then
         Or_Pos_115 := Token_Pos_568;
         Or_Res_115 := Token_Res_568;
         goto Exit_Or_118;
      end if;

--  Start tok_code

      Token_Res_569 := Row_Pos_366;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_569));
      begin
         if T.Kind /= From_Token_Kind (Ada_Declare) then
            Token_Pos_569 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_366 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_366,
                  Expected_Token_Id => Ada_Declare,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_569 := Row_Pos_366 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_569 /= No_Token_Index then
         Or_Pos_115 := Token_Pos_569;
         Or_Res_115 := Token_Res_569;
         goto Exit_Or_118;
      end if;

--  Start tok_code

      Token_Res_570 := Row_Pos_366;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_570));
      begin
         if T.Kind /= From_Token_Kind (Ada_Accept) then
            Token_Pos_570 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_366 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_366,
                  Expected_Token_Id => Ada_Accept,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_570 := Row_Pos_366 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_570 /= No_Token_Index then
         Or_Pos_115 := Token_Pos_570;
         Or_Res_115 := Token_Res_570;
         goto Exit_Or_118;
      end if;

--  Start tok_code

      Token_Res_571 := Row_Pos_366;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_571));
      begin
         if T.Kind /= From_Token_Kind (Ada_Select) then
            Token_Pos_571 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_366 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_366,
                  Expected_Token_Id => Ada_Select,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_571 := Row_Pos_366 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_571 /= No_Token_Index then
         Or_Pos_115 := Token_Pos_571;
         Or_Res_115 := Token_Res_571;
         goto Exit_Or_118;
      end if;

--  Start tok_code

      Token_Res_572 := Row_Pos_366;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_572));
      begin
         if T.Kind /= From_Token_Kind (Ada_Case) then
            Token_Pos_572 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_366 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_366,
                  Expected_Token_Id => Ada_Case,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_572 := Row_Pos_366 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_572 /= No_Token_Index then
         Or_Pos_115 := Token_Pos_572;
         Or_Res_115 := Token_Res_572;
         goto Exit_Or_118;
      end if;
      <<Exit_Or_118>>

--  End or_code

      if Or_Pos_115 /= No_Token_Index then

         Row_Pos_366 := Or_Pos_115;

      else
         Row_Pos_366 := No_Token_Index;
         goto Exit_Row_366_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_366_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Dontskip_Recov_Decl_Part_0_Extract_Parse_0_Memo,
         Row_Pos_366 /= No_Token_Index, Null_Res_31, Pos, Row_Pos_366);

      Parser.Current_Pos := Row_Pos_366;

      return Null_Res_31;
   end Dontskip_Recov_Decl_Part_0_Extract_Parse_0;

   function Dontskip_Handled_Stmts_0_Extract_Parse_0
     (Parser : in out Parser_Type; Pos : Token_Index) return Bare_Ada_Node
   is
      use Bare_Ada_Node_Memos;

      Row_Pos_367   : Token_Index   := No_Token_Index;
      Null_Res_32   : Bare_Ada_Node := No_Bare_Ada_Node;
      Token_Pos_573 : Token_Index   := No_Token_Index;
      Token_Res_573 : Token_Index   := No_Token_Index;
      Token_Pos_574 : Token_Index   := No_Token_Index;
      Token_Res_574 : Token_Index   := No_Token_Index;
      Or_Pos_116    : Token_Index   := No_Token_Index;
      Or_Res_116    : Token_Index   := No_Token_Index;

      M : Memo_Entry :=
        Get
          (Parser.Private_Part.Dontskip_Handled_Stmts_0_Extract_Parse_0_Memo,
           Pos);

   begin

      if M.State = Success then
         Parser.Current_Pos := M.Final_Pos;
         Null_Res_32        := M.Instance;
         return Null_Res_32;
      elsif M.State = Failure then
         Parser.Current_Pos := No_Token_Index;
         return Null_Res_32;
      end if;

      ---------------------------
      -- MAIN COMBINATORS CODE --
      ---------------------------

--  Start row_code

      Row_Pos_367 := Pos;

      Null_Res_32 := No_Bare_Ada_Node;

      if Row_Pos_367 /= No_Token_Index then

         Row_Pos_367 := Row_Pos_367;

      else
         Row_Pos_367 := No_Token_Index;
         goto Exit_Row_367_0;

      end if;

--  Start or_code

      Or_Pos_116 := No_Token_Index;
      Or_Res_116 := No_Token_Index;

--  Start tok_code

      Token_Res_573 := Row_Pos_367;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_573));
      begin
         if T.Kind /= From_Token_Kind (Ada_Exception) then
            Token_Pos_573 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_367 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_367,
                  Expected_Token_Id => Ada_Exception,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_573 := Row_Pos_367 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_573 /= No_Token_Index then
         Or_Pos_116 := Token_Pos_573;
         Or_Res_116 := Token_Res_573;
         goto Exit_Or_119;
      end if;

--  Start tok_code

      Token_Res_574 := Row_Pos_367;

      declare
         T : constant Stored_Token_Data :=
           Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res_574));
      begin
         if T.Kind /= From_Token_Kind (Ada_End) then
            Token_Pos_574 := No_Token_Index;

            if Parser.Last_Fail.Pos <= Row_Pos_367 then
               Parser.Last_Fail :=
                 (Kind              => Token_Fail, Pos => Row_Pos_367,
                  Expected_Token_Id => Ada_End,
                  Found_Token_Id    => To_Token_Kind (T.Kind));
            end if;
         else
            Token_Pos_574 := Row_Pos_367 + 1;
         end if;
      end;

--  End tok_code

      if Token_Pos_574 /= No_Token_Index then
         Or_Pos_116 := Token_Pos_574;
         Or_Res_116 := Token_Res_574;
         goto Exit_Or_119;
      end if;
      <<Exit_Or_119>>

--  End or_code

      if Or_Pos_116 /= No_Token_Index then

         Row_Pos_367 := Or_Pos_116;

      else
         Row_Pos_367 := No_Token_Index;
         goto Exit_Row_367_0;

      end if;

      pragma Warnings (Off, "referenced");
      <<Exit_Row_367_0>>
      pragma Warnings (On, "referenced");

--  End row_code

      -------------------------------
      -- END MAIN COMBINATORS CODE --
      -------------------------------

      Set
        (Parser.Private_Part.Dontskip_Handled_Stmts_0_Extract_Parse_0_Memo,
         Row_Pos_367 /= No_Token_Index, Null_Res_32, Pos, Row_Pos_367);

      Parser.Current_Pos := Row_Pos_367;

      return Null_Res_32;
   end Dontskip_Handled_Stmts_0_Extract_Parse_0;

   -----------
   -- Reset --
   -----------

   procedure Reset (Parser : in out Parser_Type) is
      New_Parser : Parser_Type;
      --  We create this new parser instance to leverage creation of default
      --  values, so as to not repeat them.
   begin
      --  We just keep the private part, to not have to reallocate it
      New_Parser.Private_Part := Parser.Private_Part;

      --  And then reset everything else
      Parser := New_Parser;

      --  Reset the memo tables in the private part
      Bare_Abort_Stmt_Memos.Clear
        (Parser.Private_Part.Abort_Stmt_Transform_Parse_0_Memo);
      Bare_Abstract_Subp_Decl_Memos.Clear
        (Parser.Private_Part.Abstract_Subp_Decl_Transform_Parse_0_Memo);
      Bare_Accept_Stmt_Memos.Clear
        (Parser.Private_Part.Accept_Stmt_Or_Parse_0_Memo);
      Bare_Access_Def_Memos.Clear
        (Parser.Private_Part.Access_Def_Or_Parse_0_Memo);
      Bare_Aggregate_Assoc_Memos.Clear
        (Parser.Private_Part.Aggregate_Assoc_Transform_Parse_0_Memo);
      Bare_Base_Aggregate_Memos.Clear
        (Parser.Private_Part.Aggregate_Or_Parse_0_Memo);
      Bare_Allocator_Memos.Clear
        (Parser.Private_Part.Allocator_Transform_Parse_0_Memo);
      Bare_Anonymous_Type_Decl_Memos.Clear
        (Parser.Private_Part.Anonymous_Type_Decl_Transform_Parse_0_Memo);
      Bare_Anonymous_Type_Memos.Clear
        (Parser.Private_Part.Anonymous_Type_Transform_Parse_0_Memo);
      Bare_Array_Type_Def_Memos.Clear
        (Parser.Private_Part.Array_Type_Def_Transform_Parse_2_Memo);
      Bare_Aspect_Assoc_Memos.Clear
        (Parser.Private_Part.Aspect_Assoc_Transform_Parse_0_Memo);
      Bare_Aspect_Clause_Memos.Clear
        (Parser.Private_Part.Aspect_Clause_Or_Parse_1_Memo);
      Bare_Aspect_Spec_Memos.Clear
        (Parser.Private_Part.Aspect_Spec_Opt_Parse_0_Memo);
      Bare_Assign_Stmt_Memos.Clear
        (Parser.Private_Part.Assignment_Stmt_Transform_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Basic_Decl_Or_Parse_0_Memo);
      Bare_Ada_Node_List_Memos.Clear
        (Parser.Private_Part.Basic_Decls_List_Parse_0_Memo);
      Bare_Composite_Stmt_Memos.Clear
        (Parser.Private_Part.Block_Stmt_Or_Parse_0_Memo);
      Bare_Body_Node_Memos.Clear (Parser.Private_Part.Body_Or_Parse_0_Memo);
      Bare_Body_Stub_Memos.Clear
        (Parser.Private_Part.Body_Stub_Or_Parse_0_Memo);
      Bare_Op_Memos.Clear (Parser.Private_Part.Boolean_Op_Or_Parse_0_Memo);
      Bare_Box_Expr_Memos.Clear
        (Parser.Private_Part.Box_Expr_Transform_Parse_0_Memo);
      Bare_Call_Stmt_Memos.Clear
        (Parser.Private_Part.Call_Stmt_Transform_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Call_Suffix_Or_Parse_0_Memo);
      Bare_Case_Stmt_Alternative_Memos.Clear
        (Parser.Private_Part.Case_Alt_Transform_Parse_0_Memo);
      Bare_Case_Expr_Alternative_Memos.Clear
        (Parser.Private_Part.Case_Expr_Alt_Transform_Parse_0_Memo);
      Bare_Case_Expr_Memos.Clear
        (Parser.Private_Part.Case_Expr_Transform_Parse_0_Memo);
      Bare_Case_Stmt_Memos.Clear
        (Parser.Private_Part.Case_Stmt_Transform_Parse_0_Memo);
      Bare_Char_Literal_Memos.Clear
        (Parser.Private_Part.Char_Literal_Transform_Parse_0_Memo);
      Bare_Alternatives_List_Memos.Clear
        (Parser.Private_Part.Choice_List_List_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear (Parser.Private_Part.Choice_Or_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Compilation_Or_Parse_0_Memo);
      Bare_Compilation_Unit_Memos.Clear
        (Parser.Private_Part.Compilation_Unit_Transform_Parse_0_Memo);
      Bare_Component_Clause_Memos.Clear
        (Parser.Private_Part.Component_Clause_Transform_Parse_0_Memo);
      Bare_Component_Decl_Memos.Clear
        (Parser.Private_Part.Component_Decl_Transform_Parse_0_Memo);
      Bare_Component_Def_Memos.Clear
        (Parser.Private_Part.Component_Def_Transform_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Component_Item_Or_Parse_0_Memo);
      Bare_Component_List_Memos.Clear
        (Parser.Private_Part.Component_List_Transform_Parse_0_Memo);
      Bare_Composite_Stmt_Memos.Clear
        (Parser.Private_Part.Compound_Stmt_Or_Parse_0_Memo);
      Bare_Expr_Memos.Clear
        (Parser.Private_Part.Conditional_Expr_Or_Parse_0_Memo);
      Bare_Constrained_Subtype_Indication_Memos.Clear
        (Parser.Private_Part
           .Constrained_Subtype_Indication_Transform_Parse_0_Memo);
      Bare_Constraint_List_Memos.Clear
        (Parser.Private_Part.Constraint_List_List_Parse_0_Memo);
      Bare_Constraint_Memos.Clear
        (Parser.Private_Part.Constraint_Or_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Context_Item_Or_Parse_0_Memo);
      Bare_Contract_Case_Assoc_Memos.Clear
        (Parser.Private_Part.Contract_Case_Assoc_Transform_Parse_0_Memo);
      Bare_Contract_Cases_Memos.Clear
        (Parser.Private_Part.Contract_Cases_Expr_Transform_Parse_0_Memo);
      Bare_Real_Literal_Memos.Clear
        (Parser.Private_Part.Dec_Literal_Transform_Parse_0_Memo);
      Bare_Decimal_Fixed_Point_Def_Memos.Clear
        (Parser.Private_Part.Decimal_Fixed_Point_Def_Transform_Parse_0_Memo);
      Bare_Declarative_Part_Memos.Clear
        (Parser.Private_Part.Decl_Part_Transform_Parse_0_Memo);
      Bare_Defining_Name_List_Memos.Clear
        (Parser.Private_Part.Defining_Id_List_List_Parse_0_Memo);
      Bare_Defining_Name_Memos.Clear
        (Parser.Private_Part.Defining_Id_Transform_Parse_0_Memo);
      Bare_Defining_Name_Memos.Clear
        (Parser.Private_Part.Defining_Name_Transform_Parse_0_Memo);
      Bare_Delay_Stmt_Memos.Clear
        (Parser.Private_Part.Delay_Stmt_Transform_Parse_0_Memo);
      Bare_Delta_Constraint_Memos.Clear
        (Parser.Private_Part.Delta_Constraint_Transform_Parse_0_Memo);
      Bare_Derived_Type_Def_Memos.Clear
        (Parser.Private_Part.Derived_Type_Def_Transform_Parse_0_Memo);
      Bare_Digits_Constraint_Memos.Clear
        (Parser.Private_Part.Digits_Constraint_Transform_Parse_0_Memo);
      Bare_Base_Id_Memos.Clear
        (Parser.Private_Part.Direct_Name_Or_Parse_0_Memo);
      Bare_Name_Memos.Clear
        (Parser.Private_Part.Direct_Name_Or_Target_Name_Or_Parse_0_Memo);
      Bare_Discriminant_Spec_List_Memos.Clear
        (Parser.Private_Part.Discr_Spec_List_List_Parse_0_Memo);
      Bare_Expr_Memos.Clear
        (Parser.Private_Part.Discrete_Range_Or_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Discrete_Subtype_Definition_Or_Parse_0_Memo);
      Bare_Discrete_Subtype_Indication_Memos.Clear
        (Parser.Private_Part
           .Discrete_Subtype_Indication_Transform_Parse_0_Memo);
      Bare_Discriminant_Assoc_Memos.Clear
        (Parser.Private_Part.Discriminant_Assoc_Transform_Parse_0_Memo);
      Bare_Discriminant_Constraint_Memos.Clear
        (Parser.Private_Part.Discriminant_Constraint_Transform_Parse_0_Memo);
      Bare_Discriminant_Part_Memos.Clear
        (Parser.Private_Part.Discriminant_Part_Or_Parse_0_Memo);
      Bare_Discriminant_Spec_Memos.Clear
        (Parser.Private_Part.Discriminant_Spec_Transform_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Dontskip_Case_Alt_0_Extract_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part
           .Dontskip_Exception_Handler_0_Extract_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Dontskip_Generic_Decl_0_Extract_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Dontskip_Generic_Decl_1_Extract_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Dontskip_Handled_Stmts_0_Extract_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Dontskip_If_Stmt_0_Extract_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Dontskip_If_Stmt_1_Extract_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Dontskip_If_Stmt_2_Extract_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Dontskip_Iloop_Stmt_0_Extract_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Dontskip_Iloop_Stmt_1_Extract_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Dontskip_Iloop_Stmt_2_Extract_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Dontskip_Package_Body_0_Extract_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Dontskip_Package_Decl_0_Extract_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Dontskip_Package_Decl_1_Extract_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Dontskip_Protected_Body_0_Extract_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Dontskip_Recov_Decl_Part_0_Extract_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Dontskip_Select_Stmt_0_Extract_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Dontskip_Select_Stmt_1_Extract_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Dontskip_Select_Stmt_2_Extract_Parse_0_Memo);
      Bare_Entry_Body_Memos.Clear
        (Parser.Private_Part.Entry_Body_Transform_Parse_3_Memo);
      Bare_Entry_Decl_Memos.Clear
        (Parser.Private_Part.Entry_Decl_Transform_Parse_1_Memo);
      Bare_Enum_Literal_Decl_Memos.Clear
        (Parser.Private_Part.Enum_Literal_Decl_Transform_Parse_1_Memo);
      Bare_Enum_Type_Def_Memos.Clear
        (Parser.Private_Part.Enum_Type_Def_Transform_Parse_0_Memo);
      Bare_Exception_Decl_Memos.Clear
        (Parser.Private_Part.Exception_Decl_Transform_Parse_0_Memo);
      Bare_Exception_Handler_Memos.Clear
        (Parser.Private_Part.Exception_Handler_Transform_Parse_0_Memo);
      Bare_Exit_Stmt_Memos.Clear
        (Parser.Private_Part.Exit_Stmt_Transform_Parse_0_Memo);
      Bare_Expr_Function_Memos.Clear
        (Parser.Private_Part.Expr_Fn_Transform_Parse_0_Memo);
      Bare_Expr_Memos.Clear (Parser.Private_Part.Expr_Or_Parse_0_Memo);
      Bare_Extended_Return_Stmt_Object_Decl_Memos.Clear
        (Parser.Private_Part.Ext_Ret_Stmt_Object_Decl_Transform_Parse_0_Memo);
      Bare_Extended_Return_Stmt_Memos.Clear
        (Parser.Private_Part.Ext_Return_Stmt_Transform_Parse_0_Memo);
      Bare_Expr_Memos.Clear (Parser.Private_Part.Factor_Or_Parse_1_Memo);
      Bare_Floating_Point_Def_Memos.Clear
        (Parser.Private_Part.Floating_Point_Def_Transform_Parse_0_Memo);
      Bare_For_Loop_Spec_Memos.Clear
        (Parser.Private_Part.For_Loop_Param_Spec_Transform_Parse_3_Memo);
      Bare_Formal_Discrete_Type_Def_Memos.Clear
        (Parser.Private_Part.Formal_Discrete_Type_Def_Transform_Parse_0_Memo);
      Bare_Formal_Subp_Decl_Memos.Clear
        (Parser.Private_Part.Formal_Subp_Decl_Or_Parse_2_Memo);
      Bare_Generic_Decl_Memos.Clear
        (Parser.Private_Part.Generic_Decl_Or_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Generic_Formal_Decl_Or_Parse_0_Memo);
      Bare_Generic_Formal_Part_Memos.Clear
        (Parser.Private_Part.Generic_Formal_Part_Transform_Parse_0_Memo);
      Bare_Generic_Instantiation_Memos.Clear
        (Parser.Private_Part.Generic_Instantiation_Or_Parse_1_Memo);
      Bare_Generic_Renaming_Decl_Memos.Clear
        (Parser.Private_Part.Generic_Renaming_Decl_Or_Parse_1_Memo);
      Bare_Goto_Stmt_Memos.Clear
        (Parser.Private_Part.Goto_Stmt_Transform_Parse_0_Memo);
      Bare_Handled_Stmts_Memos.Clear
        (Parser.Private_Part.Handled_Stmts_Transform_Parse_0_Memo);
      Bare_Block_Stmt_Memos.Clear
        (Parser.Private_Part.Iblock_Stmt_Or_Parse_0_Memo);
      Bare_Identifier_Memos.Clear
        (Parser.Private_Part.Identifier_Transform_Parse_0_Memo);
      Bare_If_Expr_Memos.Clear
        (Parser.Private_Part.If_Expr_Transform_Parse_1_Memo);
      Bare_If_Stmt_Memos.Clear
        (Parser.Private_Part.If_Stmt_Transform_Parse_1_Memo);
      Bare_Base_Loop_Stmt_Memos.Clear
        (Parser.Private_Part.Iloop_Stmt_Or_Parse_0_Memo);
      Bare_Index_Constraint_Memos.Clear
        (Parser.Private_Part.Index_Constraint_Transform_Parse_0_Memo);
      Bare_Int_Literal_Memos.Clear
        (Parser.Private_Part.Int_Literal_Transform_Parse_0_Memo);
      Bare_Interface_Type_Def_Memos.Clear
        (Parser.Private_Part.Interface_Type_Def_Transform_Parse_4_Memo);
      Bare_Label_Memos.Clear
        (Parser.Private_Part.Label_Transform_Parse_1_Memo);
      Bare_Library_Item_Memos.Clear
        (Parser.Private_Part.Library_Item_Transform_Parse_1_Memo);
      Bare_Body_Node_Memos.Clear
        (Parser.Private_Part.Library_Unit_Body_Or_Parse_0_Memo);
      Bare_Basic_Decl_Memos.Clear
        (Parser.Private_Part.Library_Unit_Renaming_Decl_Or_Parse_0_Memo);
      Bare_Composite_Stmt_Memos.Clear
        (Parser.Private_Part.Loop_Stmt_Or_Parse_0_Memo);
      Bare_Expr_Alternatives_List_Memos.Clear
        (Parser.Private_Part.Membership_Choice_List_List_Parse_0_Memo);
      Bare_Expr_Memos.Clear
        (Parser.Private_Part.Membership_Choice_Or_Parse_0_Memo);
      Bare_Mod_Int_Type_Def_Memos.Clear
        (Parser.Private_Part.Mod_Int_Type_Def_Transform_Parse_0_Memo);
      Bare_Mode_Memos.Clear (Parser.Private_Part.Mode_Or_Parse_0_Memo);
      Bare_Multi_Dim_Array_Assoc_Memos.Clear
        (Parser.Private_Part.Multidim_Array_Assoc_Transform_Parse_0_Memo);
      Bare_Name_Memos.Clear (Parser.Private_Part.Name_Or_Parse_1_Memo);
      Bare_Null_Literal_Memos.Clear
        (Parser.Private_Part.Null_Literal_Transform_Parse_0_Memo);
      Bare_Null_Stmt_Memos.Clear
        (Parser.Private_Part.Null_Stmt_Transform_Parse_0_Memo);
      Bare_Null_Subp_Decl_Memos.Clear
        (Parser.Private_Part.Null_Subp_Decl_Transform_Parse_0_Memo);
      Bare_Num_Literal_Memos.Clear
        (Parser.Private_Part.Num_Literal_Or_Parse_0_Memo);
      Bare_Number_Decl_Memos.Clear
        (Parser.Private_Part.Number_Decl_Transform_Parse_0_Memo);
      Bare_Basic_Decl_Memos.Clear
        (Parser.Private_Part.Object_Decl_Or_Parse_0_Memo);
      Bare_Ordinary_Fixed_Point_Def_Memos.Clear
        (Parser.Private_Part.Ordinary_Fixed_Point_Def_Transform_Parse_0_Memo);
      Bare_Others_Designator_Memos.Clear
        (Parser.Private_Part.Others_Designator_Transform_Parse_0_Memo);
      Bare_Overriding_Node_Memos.Clear
        (Parser.Private_Part.Overriding_Indicator_Or_Parse_0_Memo);
      Bare_Package_Body_Stub_Memos.Clear
        (Parser.Private_Part.Package_Body_Stub_Transform_Parse_0_Memo);
      Bare_Package_Body_Memos.Clear
        (Parser.Private_Part.Package_Body_Transform_Parse_1_Memo);
      Bare_Package_Decl_Memos.Clear
        (Parser.Private_Part.Package_Decl_Transform_Parse_3_Memo);
      Bare_Package_Renaming_Decl_Memos.Clear
        (Parser.Private_Part.Package_Renaming_Decl_Transform_Parse_0_Memo);
      Bare_Param_Assoc_Memos.Clear
        (Parser.Private_Part.Param_Assoc_Transform_Parse_0_Memo);
      Bare_Param_Spec_Memos.Clear
        (Parser.Private_Part.Param_Spec_Transform_Parse_0_Memo);
      Bare_Params_Memos.Clear
        (Parser.Private_Part.Param_Specs_Transform_Parse_0_Memo);
      Bare_Paren_Expr_Memos.Clear
        (Parser.Private_Part.Paren_Expr_Transform_Parse_0_Memo);
      Bare_Parent_List_Memos.Clear
        (Parser.Private_Part.Parent_List_List_Parse_0_Memo);
      Bare_Pragma_Argument_Assoc_Memos.Clear
        (Parser.Private_Part.Pragma_Argument_Transform_Parse_0_Memo);
      Bare_Pragma_Node_Memos.Clear
        (Parser.Private_Part.Pragma_Transform_Parse_0_Memo);
      Bare_Expr_Memos.Clear (Parser.Private_Part.Primary_Or_Parse_0_Memo);
      Bare_Protected_Body_Stub_Memos.Clear
        (Parser.Private_Part.Protected_Body_Stub_Transform_Parse_0_Memo);
      Bare_Protected_Body_Memos.Clear
        (Parser.Private_Part.Protected_Body_Transform_Parse_1_Memo);
      Bare_Single_Protected_Decl_Memos.Clear
        (Parser.Private_Part.Protected_Decl_Transform_Parse_0_Memo);
      Bare_Protected_Def_Memos.Clear
        (Parser.Private_Part.Protected_Def_Transform_Parse_3_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Protected_El_Or_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Protected_Op_Or_Parse_0_Memo);
      Bare_Protected_Type_Decl_Memos.Clear
        (Parser.Private_Part.Protected_Type_Decl_Transform_Parse_0_Memo);
      Bare_Name_Memos.Clear
        (Parser.Private_Part.Qual_Name_Internal_Or_Parse_0_Memo);
      Bare_Qual_Expr_Memos.Clear
        (Parser.Private_Part.Qualified_Name_Transform_Parse_0_Memo);
      Bare_Quantified_Expr_Memos.Clear
        (Parser.Private_Part.Quantified_Expr_Transform_Parse_2_Memo);
      Bare_Raise_Expr_Memos.Clear
        (Parser.Private_Part.Raise_Expr_Or_Parse_0_Memo);
      Bare_Raise_Stmt_Memos.Clear
        (Parser.Private_Part.Raise_Stmt_Or_Parse_0_Memo);
      Bare_Range_Constraint_Memos.Clear
        (Parser.Private_Part.Range_Constraint_Transform_Parse_1_Memo);
      Bare_Range_Spec_Memos.Clear
        (Parser.Private_Part.Range_Spec_Transform_Parse_0_Memo);
      Bare_Real_Type_Def_Memos.Clear
        (Parser.Private_Part.Real_Type_Def_Or_Parse_0_Memo);
      Bare_Base_Record_Def_Memos.Clear
        (Parser.Private_Part.Record_Def_Or_Parse_0_Memo);
      Bare_Record_Type_Def_Memos.Clear
        (Parser.Private_Part.Record_Type_Def_Transform_Parse_0_Memo);
      Bare_Declarative_Part_Memos.Clear
        (Parser.Private_Part.Recov_Decl_Part_Dont_Skip_Parse_0_Memo);
      Bare_Op_Memos.Clear (Parser.Private_Part.Rel_Op_Or_Parse_0_Memo);
      Bare_Expr_Memos.Clear (Parser.Private_Part.Relation_Or_Parse_1_Memo);
      Bare_Renaming_Clause_Memos.Clear
        (Parser.Private_Part.Renaming_Clause_Transform_Parse_0_Memo);
      Bare_Requeue_Stmt_Memos.Clear
        (Parser.Private_Part.Requeue_Stmt_Transform_Parse_0_Memo);
      Bare_Return_Stmt_Memos.Clear
        (Parser.Private_Part.Return_Stmt_Transform_Parse_0_Memo);
      Bare_Select_Stmt_Memos.Clear
        (Parser.Private_Part.Select_Stmt_Transform_Parse_1_Memo);
      Bare_Expr_Memos.Clear (Parser.Private_Part.Sexpr_Or_Box_Or_Parse_0_Memo);
      Bare_Signed_Int_Type_Def_Memos.Clear
        (Parser.Private_Part.Signed_Int_Type_Def_Transform_Parse_0_Memo);
      Bare_Expr_Memos.Clear (Parser.Private_Part.Simple_Expr_Or_Parse_1_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Simple_Stmt_Or_Parse_0_Memo);
      Bare_Subp_Decl_Memos.Clear
        (Parser.Private_Part.Simple_Subp_Decl_Transform_Parse_0_Memo);
      Bare_Single_Task_Decl_Memos.Clear
        (Parser.Private_Part.Single_Task_Decl_Transform_Parse_1_Memo);
      Bare_Name_Memos.Clear (Parser.Private_Part.Static_Name_Or_Parse_0_Memo);
      Bare_Ada_Node_Memos.Clear (Parser.Private_Part.Stmt_Or_Parse_0_Memo);
      Bare_Stmt_List_Memos.Clear (Parser.Private_Part.Stmts_List_Parse_0_Memo);
      Bare_String_Literal_Memos.Clear
        (Parser.Private_Part.String_Literal_Transform_Parse_0_Memo);
      Bare_Object_Decl_Memos.Clear
        (Parser.Private_Part.Sub_Object_Decl_Transform_Parse_0_Memo);
      Bare_Subp_Body_Stub_Memos.Clear
        (Parser.Private_Part.Subp_Body_Stub_Transform_Parse_0_Memo);
      Bare_Subp_Body_Memos.Clear
        (Parser.Private_Part.Subp_Body_Transform_Parse_1_Memo);
      Bare_Basic_Decl_Memos.Clear
        (Parser.Private_Part.Subp_Decl_Or_Parse_0_Memo);
      Bare_Subp_Renaming_Decl_Memos.Clear
        (Parser.Private_Part.Subp_Renaming_Decl_Transform_Parse_0_Memo);
      Bare_Subp_Spec_Memos.Clear
        (Parser.Private_Part.Subp_Spec_Transform_Parse_2_Memo);
      Bare_Subtype_Decl_Memos.Clear
        (Parser.Private_Part.Subtype_Decl_Transform_Parse_0_Memo);
      Bare_Subtype_Indication_Memos.Clear
        (Parser.Private_Part.Subtype_Indication_Transform_Parse_0_Memo);
      Bare_Name_Memos.Clear (Parser.Private_Part.Subtype_Name_Or_Parse_0_Memo);
      Bare_Subunit_Memos.Clear
        (Parser.Private_Part.Subunit_Transform_Parse_0_Memo);
      Bare_Target_Name_Memos.Clear
        (Parser.Private_Part.Target_Name_Transform_Parse_0_Memo);
      Bare_Task_Body_Stub_Memos.Clear
        (Parser.Private_Part.Task_Body_Stub_Transform_Parse_0_Memo);
      Bare_Task_Body_Memos.Clear
        (Parser.Private_Part.Task_Body_Transform_Parse_1_Memo);
      Bare_Task_Def_Memos.Clear
        (Parser.Private_Part.Task_Def_Transform_Parse_3_Memo);
      Bare_Ada_Node_Memos.Clear
        (Parser.Private_Part.Task_Item_Or_Parse_0_Memo);
      Bare_Task_Type_Decl_Memos.Clear
        (Parser.Private_Part.Task_Type_Decl_Transform_Parse_0_Memo);
      Bare_Expr_Memos.Clear (Parser.Private_Part.Term_Or_Parse_1_Memo);
      Bare_Terminate_Alternative_Memos.Clear
        (Parser.Private_Part.Terminate_Alternative_Transform_Parse_0_Memo);
      Bare_Base_Type_Decl_Memos.Clear
        (Parser.Private_Part.Type_Decl_Or_Parse_1_Memo);
      Bare_Type_Def_Memos.Clear (Parser.Private_Part.Type_Def_Or_Parse_0_Memo);
      Bare_Type_Expr_Memos.Clear
        (Parser.Private_Part.Type_Expr_Or_Parse_0_Memo);
      Bare_Unconstrained_Array_Index_Memos.Clear
        (Parser.Private_Part.Unconstrained_Index_Transform_Parse_0_Memo);
      Bare_Expr_Memos.Clear (Parser.Private_Part.Unop_Term_Or_Parse_1_Memo);
      Bare_Base_Aggregate_Memos.Clear
        (Parser.Private_Part.Update_Attr_Aggregate_Or_Parse_0_Memo);
      Bare_Assoc_List_Memos.Clear
        (Parser.Private_Part.Update_Attr_Content_List_Parse_0_Memo);
      Bare_Use_Clause_Memos.Clear
        (Parser.Private_Part.Use_Clause_Or_Parse_0_Memo);
      Bare_Use_Package_Clause_Memos.Clear
        (Parser.Private_Part.Use_Package_Clause_Transform_Parse_0_Memo);
      Bare_Use_Type_Clause_Memos.Clear
        (Parser.Private_Part.Use_Type_Clause_Transform_Parse_0_Memo);
      Bare_Variant_Part_Memos.Clear
        (Parser.Private_Part.Variant_Part_Transform_Parse_0_Memo);
      Bare_Variant_Memos.Clear
        (Parser.Private_Part.Variant_Transform_Parse_0_Memo);
      Bare_With_Clause_Memos.Clear
        (Parser.Private_Part.With_Clause_Transform_Parse_0_Memo);
   end Reset;

   -------------
   -- Destroy --
   -------------

   procedure Destroy (Parser : in out Parser_Type) is
      procedure Free is new Ada.Unchecked_Deallocation
        (Parser_Private_Part_Type, Parser_Private_Part);
      procedure Free is new Ada.Unchecked_Deallocation
        (Free_Parse_List_Record, Free_Parse_List);

      Cur : Free_Parse_List renames Parser.Private_Part.Parse_Lists;
   begin
      while Cur /= null loop
         declare
            Next : constant Free_Parse_List := Cur.Next;
         begin
            Cur.Nodes.Destroy;
            Free (Cur);
            Cur := Next;
         end;
      end loop;
      Free (Parser.Private_Part);
   end Destroy;

   ----------------
   -- Initialize --
   ----------------

   procedure Initialize (Parser : in out Parser_Type) is
   begin
      Parser.Private_Part := new Parser_Private_Part_Type'(others => <>);
   end Initialize;

   --------------------
   -- Get_Parse_List --
   --------------------

   function Get_Parse_List (Parser : Parser_Type) return Free_Parse_List is
      Lists  : Free_Parse_List renames Parser.Private_Part.Parse_Lists;
      Result : Free_Parse_List;
   begin
      if Lists = null then
         Result := new Free_Parse_List_Record;

      else
         Result := Lists;
         Lists  := Lists.Next;
      end if;

      return Result;
   end Get_Parse_List;

   ------------------------
   -- Release_Parse_List --
   ------------------------

   procedure Release_Parse_List
     (Parser : Parser_Type; List : in out Free_Parse_List)
   is
      Lists : Free_Parse_List renames Parser.Private_Part.Parse_Lists;
   begin
      List.Nodes.Clear;
      List.Next := Lists;
      Lists     := List;
      List      := null;
   end Release_Parse_List;

end Libadalang.Parsers;
